<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>JS高级程序设计读书笔记(7)——代理与反射 | Yolo</title>
  <meta name="description" content="ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。 在 ES6 之前，ECMAScript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高级程序设计读书笔记(7)——代理与反射">
<meta property="og:url" content="http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。 在 ES6 之前，ECMAScript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-07T19:54:39.000Z">
<meta property="article:modified_time" content="2023-11-27T15:34:23.883Z">
<meta property="article:author" content="pvnk1u">
<meta property="article:tag" content="web">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/index.html">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center theme-white" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/pvnk1u" target="_blank">
          <img class="img-circle img-rotate" src="/images/dog.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Yolo</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/pvnk1u" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/css/">css</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/html/">html</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/html/css/">css</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/javascript/">javascript</a><span class="category-list-count">14</span></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/html/">html</a>
              </p>
              <p class="item-title">
                <a href="/2023/11/21/UdemyHtmlCss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81/" class="title">UdemyHtmlCss学习笔记——代码</a>
              </p>
              <p class="item-date">
                <time datetime="2023-11-21T07:32:39.000Z" itemprop="datePublished">2023-11-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/07/01/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BD%91%E6%A0%BC/" class="title">精通CSS读书笔记(6)——内容布局</a>
              </p>
              <p class="item-date">
                <time datetime="2023-07-01T07:28:39.000Z" itemprop="datePublished">2023-07-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/05/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80/" class="title">精通CSS读书笔记(6)——内容布局</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-05T07:28:39.000Z" itemprop="datePublished">2023-06-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/04/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E6%BC%82%E4%BA%AE%E7%9A%84%E7%9B%92%E5%AD%90/" class="title">精通CSS读书笔记(5)——漂亮的盒子</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-04T01:28:39.000Z" itemprop="datePublished">2023-06-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/03/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88/" class="title">精通CSS读书笔记(4)——网页排版</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-03T01:28:39.000Z" itemprop="datePublished">2023-06-03</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">代理基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">创建空代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">定义捕获器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%99%A8%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%8D%E5%B0%84API"><span class="toc-number">1.3.</span> <span class="toc-text">捕获器参数和反射API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">捕获器不变式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%92%A4%E9%94%80%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">可撤销代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%8F%8D%E5%B0%84API"><span class="toc-number">1.6.</span> <span class="toc-text">实用反射API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">代理另一个代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.8.</span> <span class="toc-text">代理的问题与不足</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">代理捕获器与反射方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get"><span class="toc-number">2.1.</span> <span class="toc-text">get()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">2.2.</span> <span class="toc-text">set()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#has"><span class="toc-number">2.3.</span> <span class="toc-text">has()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defineProperty"><span class="toc-number">2.4.</span> <span class="toc-text">defineProperty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getOwnPropertyDescriptor"><span class="toc-number">2.5.</span> <span class="toc-text">getOwnPropertyDescriptor()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deleteProperty"><span class="toc-number">2.6.</span> <span class="toc-text">deleteProperty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ownKeys"><span class="toc-number">2.7.</span> <span class="toc-text">ownKeys()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getPrototypeOf"><span class="toc-number">2.8.</span> <span class="toc-text">getPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setPrototypeOf"><span class="toc-number">2.9.</span> <span class="toc-text">setPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isExtensible"><span class="toc-number">2.10.</span> <span class="toc-text">isExtensible()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#preventExtensions"><span class="toc-number">2.11.</span> <span class="toc-text">preventExtensions()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply"><span class="toc-number">2.12.</span> <span class="toc-text">apply()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#construct"><span class="toc-number">2.13.</span> <span class="toc-text">construct()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="toc-number">3.1.</span> <span class="toc-text">跟踪属性访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">隐藏属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="toc-number">3.3.</span> <span class="toc-text">属性验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81"><span class="toc-number">3.4.</span> <span class="toc-text">函数与构造函数参数验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">数据绑定与可观察对象</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-JS高级程序设计读书笔记(7)——代理与反射" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      JS高级程序设计读书笔记(7)——代理与反射
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" class="article-date">
	  <time datetime="2023-03-07T19:54:39.000Z" itemprop="datePublished">2023-03-08</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/web/">web</a>►<a class="article-category-link" href="/categories/web/javascript/">javascript</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/javascript/" rel="tag">javascript</a>, <a class="article-tag-link-link" href="/tags/web/" rel="tag">web</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 7k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 29(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p><code>ECMAScript 6</code> 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</p>
<p>在 <code>ES6</code> 之前，<code>ECMAScript</code> 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的 <code>ECMAScript </code>代码，因为代理的行为实际上是无可替代的。<strong>为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。</strong></p>
<h1 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h1><p>代理是目标对象的抽象。它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。</p>
<h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p>
<p>代理是使用 <code>Proxy</code> 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 <code>TypeError</code>。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// id 属性会访问同一个值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为两个对象访问的是同一个值</span></span><br><span class="line">target.<span class="property">id</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方</span></span><br><span class="line"><span class="comment">// 都会应用到目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy.prototype 是 undefined</span></span><br><span class="line"><span class="comment">// 因此不能使用 instanceof 操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（<code>trap</code>）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<p>捕获器（<code>trap</code>）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。</p>
<p>例如，可以定义一个 <code>get()</code>捕获器，在 <code>ECMAScript</code> 操作以某种形式调用 <code>get()</code>时触发。下面的例子定义了一个 <code>get()</code>捕获器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>这样，当通过代理对象执行 <code>get()</code>操作时，就会触发定义的 <code>get()</code>捕获器。当然，<code>get()</code>不是<code>ECMAScript</code> 对象可以调用的方法。这个操作在 <code>JavaScript</code> 代码中可以通过多种形式触发并被 <code>get()</code>捕获器拦截到。<code>proxy[property]</code>、<code>proxy.property</code> 或 <code>Object.create(proxy)[property]</code>等操作都会触发基本的 <code>get()</code>操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 <code>get()</code>捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">	<span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// handler override</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// handler override</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(target)[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// handler override</span></span><br></pre></td></tr></table></figure>



<h2 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，<code>get()</code>捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(trapTarget === target);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(property);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(receiver === proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有了这些参数，就可以重建被捕获方法的原始行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> trapTarget[property];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 <code>get()</code>那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 <code>Reflect</code> 对象上（封装了原始行为）的同名方法来轻松重建。</p>
<p>处理程序对象中所有可以捕获的方法都有对应的反射（<code>Reflect</code>）<code>API</code> 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 <code>API</code> 也可以像下面这样定义出空代理对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>甚至还可以写得更简洁一些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">	<span class="attr">get</span>: <span class="title class_">Reflect</span>.<span class="property">get</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 <code>API</code> 的空代理，那么甚至不需要定义处理程序对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, <span class="title class_">Reflect</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>反射 <code>API</code> 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> decoration = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (property === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">            decoration = <span class="string">&#x27;!!!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar!!!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>); <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>



<h2 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h2><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 <code>ECMAScript</code> 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（<code>trap invariant</code>）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p>
<p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 <code>TypeError</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>



<h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。<strong>对于使用 <code>new Proxy()</code>创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</strong></p>
<p><code>Proxy</code> 也暴露了 <code>revocable()</code>方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（<code>revoke()</code>）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 <code>TypeError</code>。</p>
<p>撤销函数和代理对象是在实例化时同时生成的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>



<h2 id="实用反射API"><a href="#实用反射API" class="headerlink" title="实用反射API"></a>实用反射API</h2><p>某些情况下应该优先使用反射 <code>API</code>，这是有一些理由的。</p>
<ol>
<li><p>反射<code>API</code>与对象<code>API</code></p>
<p>在使用反射 <code>API</code> 时，要记住：</p>
<ol>
<li>反射 <code>API</code> 并不限于捕获处理程序；</li>
<li>大多数反射 <code>API</code> 方法在 <code>Object</code> 类型上有对应的方法。</li>
</ol>
<p>通常，<code>Object</code> 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p>
</li>
<li><p>状态标记</p>
<p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 <code>API</code> 方法更有用。例如，可以使用反射<code>API</code> 对下面的代码进行重构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义新属性时如果发生问题，<code>Reflect.defineProperty()</code>会返回 <code>false</code>，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下反射方法都会提供状态标记：</p>
<ul>
<li>Reflect.defineProperty()</li>
<li>Reflect.preventExtensions()</li>
<li>Reflect.setPropertyOf()</li>
<li>Reflect.set()</li>
<li>Relect.deleteProperty()</li>
</ul>
</li>
<li><p>用一等函数替代操作符</p>
<p>以下反射方法提供只有通过操作符才能完成的操作</p>
<ul>
<li>Reflect.get()：可以替代对象属性访问操作符</li>
<li>Reflect.set()：可以替代&#x3D;赋值操作符</li>
<li>Reflect.has()：可以替代in操作符或with()</li>
<li>Reflect.deleteProperty()：可以替代delete操作符</li>
<li>Reflect.construct()：可以替代new操作符</li>
</ul>
</li>
<li><p>安全地应用函数</p>
<p>在通过<code>apply</code>方法调用函数时，被调用的函数可能也定义了自己的<code>apply</code>属性(虽然可能性极小)。为绕过这个问题，可以使用定义在<code>Function</code>原型上的<code>apply</code>方法，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(myFunc, thisVal, argumentList);</span><br></pre></td></tr></table></figure>

<p>这种可怕的代码完全可以使用 <code>Reflect.apply</code> 来避免：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(myFunc, thisVal, argumentsList);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h2><p>代理可以拦截反射<code>API</code>的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first proxy&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second proxy&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>



<h2 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h2><p>代理是在 <code>ECMAScript</code> 现有基础之上构建起来的一套新 <code>API</code>，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 <code>ECMAScript</code>机制很好地协同。</p>
<ol>
<li><p>代理中的this</p>
<p>代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="title function_">thisValEqualsProxy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span> === proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">thisValEqualsProxy</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">thisValEqualsProxy</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 <code>proxy.outerMethod()</code>，而这个方法进而又会调用另一个方法，如 <code>this.innerMethod()</code>，实际上都会调用 <code>proxy.innerMethod()</code>。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    	wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    	wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">id</span>() &#123;</span><br><span class="line">    	<span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">id</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInstanceProxy.<span class="property">id</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>User</code> 实例一开始使用目标对象作为 <code>WeakMap</code> 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 <code>User</code> 实例改为代理 <code>User</code> 类本身。之后再创建代理的实例就会以代理实例作为 <code>WeakMap</code> 的键了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserClassProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="title class_">UserClassProxy</span>(<span class="number">456</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyUser.<span class="property">id</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理与内部槽位</p>
<p>代理与内置引用类型（比如 <code>Array</code>）的实例通常可以很好地协同，但有些 <code>ECMAScript</code> 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p>
<p>一个典型的例子就是 <code>Date</code> 类型。根据 <code>ECMAScript</code> 规范，<code>Date</code> 类型方法的执行依赖 <code>this</code> 值上的内部槽位<code>[[NumberDate]]</code>。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 <code>get()</code>和 <code>set()</code>操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 <code>TypeError</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: &#x27;this&#x27; is not a Date object</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h1><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 <code>API</code> 方法、参数、关联 <code>ECMAScript</code>操作和不变式。</p>
<p>正如前面示例所展示的，有几种不同的 JavaScript 操作会调用同一个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</p>
<p>只要在代理上调用，所有捕获器都会拦截它们对应的反射 <code>API</code> 操作。</p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get()</code>捕获器会在获取属性值的操作中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.get()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">// get()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p>返回值无限制</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>proxy.property</li>
<li>proxy[property]</li>
<li>Object.create(proxy)[property]</li>
<li>Reflect.get(proxy,property,receiver)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>property：引用的目标对象上的字符串键属性</li>
<li>receiver：代理对象或继承代理对象的对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target.property</code> 不可写且不可配置，则处理程序返回的值必须与 <code>target.property</code> 匹配。如果 <code>target.property</code> 不可配置且<code>[[Get]]</code>特性为 <code>undefined</code>，处理程序的返回值也必须是 <code>undefined</code>。</p>
</li>
</ol>
<h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.set()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// set()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p>返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 <code>TypeError</code>。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>proxy.property &#x3D; value</li>
<li>proxy[property] &#x3D; value</li>
<li>Object.create(proxy)[property] &#x3D; value</li>
<li>Reflect.set(proxy,property,value,receiver)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>property：引用的目标对象上的字符串键属性</li>
<li>value：要赋给属性的值</li>
<li>receiver：接收最初赋值的对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target.property</code> 不可写且不可配置，则不能修改目标属性的值。</p>
<p>如果 <code>target.property</code> 不可配置且<code>[[Set]]</code>特性为 <code>undefined</code>，则不能修改目标属性的值。在严格模式下，处理程序中返回 false 会抛出 <code>TypeError</code>。</p>
</li>
</ol>
<h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p><code>has()</code>捕获器会在 <code>in</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.has()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">// has()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>has()</code>必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>property in proxy</li>
<li>property in Object.create(proxy)</li>
<li>with(proxy) {(property);}</li>
<li>Reflect.has(proxy,property)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>property：引用的目标对象上的字符串键属性</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target.property</code> 存在且不可配置，则处理程序必须返回 true。<br>如果 <code>target.property</code> 存在且目标对象不可扩展，则处理程序必须返回 true。</p>
</li>
</ol>
<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h2><p><code>defineProperty()</code>捕获器会在 <code>Object.defineProperty()</code>中被调用。对应的反射 <code>API </code>方法为<code>Reflect.defineProperty()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(<span class="params">target, property, descriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proxy, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// defineProperty()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>defineProperty()</code>必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.defineProperty(proxy, property, descriptor)</li>
<li>Reflect.defineProperty(proxy, property, descriptor)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>property：引用的目标对象上的字符串键属性</li>
<li>descriptor：包含可选的enumerable、configurable、writable、value、get和set定义的对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果目标对象不可扩展，则无法定义属性。<br>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。<br>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</p>
</li>
</ol>
<h2 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h2><p><code>getOwnPropertyDescriptor()</code>捕获器会在 <code>Object.getOwnPropertyDescriptor()</code>中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.getOwnPropertyDescriptor()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">	<span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getOwnPropertyDescriptor()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>getOwnPropertyDescriptor()</code>必须返回对象，或者在属性不存在时返回 <code>undefined</code>。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.getOwnPropertyDescriptor(proxy,property)</li>
<li>Reflect.getOwnPropertyDescriptor(proxy,property)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>property：引用的目标对象上的字符串键属性</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果自有的 <code>target.property</code> 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。<br>如果自有的 <code>target.property</code> 存在且可配置，则处理程序必须返回表示该属性可配置的对象。<br>如果自有的 <code>target.property</code> 存在且 <code>target</code> 不可扩展，则处理程序必须返回一个表示该属性存在的对象。<br>如果 <code>target.property</code> 不存在且 <code>target</code> 不可扩展，则处理程序必须返回 <code>undefined</code> 表示该属性不存在。<br>如果 <code>target.property</code> 不存在，则处理程序不能返回表示该属性可配置的对象。</p>
<h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h2><p><code>deleteProperty()</code>捕获器会在 <code>delete</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.deleteProperty()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;deleteProperty()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>deleteProperty()</code>必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>delete proxy.property</li>
<li>delete proxy[property]</li>
<li>Reflect.deleteProperty(proxy, property)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>property：引用的目标对象上的字符串键属性</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果自有的 <code>target.property</code> 存在且不可配置，则处理程序不能删除这个属性。</p>
</li>
</ol>
</li>
</ol>
<h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h2><p><code>ownKeys()</code>捕获器会在 <code>Object.keys()</code>及类似方法中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.ownKeys()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ownKeys()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy);</span><br><span class="line"><span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p>ownKeys()必须返回包含字符串或符号的可枚举对象。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.getOwnPropertyNames(proxy)</li>
<li>Object.getOwnPropertySymbols(proxy)</li>
<li>Object.keys(proxy)</li>
<li>Reflect.ownKeys(proxy)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
</ul>
</li>
<li><p>捕获器不定式</p>
<p>返回的可枚举对象必须包含 <code>target</code> 的所有不可配置的自有属性。<br>如果 <code>target</code> 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</p>
</li>
</ol>
<h2 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h2><p><code>getPrototypeOf()</code>捕获器会在 <code>Object.getPrototypeOf()</code>中被调用。对应的反射 <code>API</code> 方法为<code>Reflect.getPrototypeOf()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getPrototypeOf()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy);</span><br><span class="line"><span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>getPrototypeOf()</code>必须返回对象或 <code>null</code>。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.getPrototypeOf(proxy)</li>
<li>Reflect.getPrototypeOf(proxy)</li>
<li><code>proxy.__proxy__</code></li>
<li>Object.prototype.isPrototypeOf(proxy)</li>
<li>proxy instanceof Object</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target</code> 不可扩展，则 <code>Object.getPrototypeOf(proxy)</code>唯一有效的返回值就是 <code>Object.getPrototypeOf(target)</code>的返回值。</p>
</li>
</ol>
<h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h2><p><code>setPrototypeOf()</code>捕获器会在 <code>Object.setPrototypeOf()</code>中被调用。对应的反射 <code>API</code> 方法为<code>Reflect.setPrototypeOf()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">setPrototypeOf</span>(<span class="params">target, prototype</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setPrototypeOf()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, <span class="title class_">Object</span>);</span><br><span class="line"><span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>setPrototypeOf()</code>必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.setPrototypeOf(proxy)</li>
<li>Reflect.setPrototypeOf(proxy)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标参数</li>
<li>prototype：target的替代原型，如果是顶级原型则为null</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target</code> 不可扩展，则唯一有效的 <code>prototype</code> 参数就是 <code>Object.getPrototypeOf(target)</code>的返回值。</p>
</li>
</ol>
<h2 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h2><p><code>isExtensible()</code>捕获器会在 <code>Object.isExtensible()</code>中被调用。对应的反射 <code>API</code> 方法为<code>Reflect.isExtensible()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isExtensible()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy);</span><br><span class="line"><span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>isExtensible()</code>必须返回布尔值，表示 <code>target</code> 是否可扩展。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.isExtenible(proxy)</li>
<li>Reflect.isEntensible(proxy)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 target 可扩展，则处理程序必须返回 true。<br>如果 target 不可扩展，则处理程序必须返回 false。</p>
</li>
</ol>
<h2 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h2><p><code>preventExtensions()</code>捕获器会在 <code>Object.preventExtensions()</code>中被调用。对应的反射 <code>API</code>方法为 <code>Reflect.preventExtensions()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;preventExtensions()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy);</span><br><span class="line"><span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>preventExtensions()</code>必须返回布尔值，表示 <code>target</code> 是否已经不可扩展。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>Object.preventExtensions(proxy)</li>
<li>Reflect.preventExtensions(proxy)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果Object.isExtensible(proxy)是false，则处理程序必须返回true。</p>
</li>
</ol>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p><code>apply()</code>捕获器会在调用函数时中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.apply()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p>返回值无限制</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>proxy(…argumentsList)</li>
<li>Function.prototype.apply(thisArg, argumentsList)</li>
<li>Function.prototype.call(thisArg, …argumentsList)</li>
<li>Reflect.apply(target, thisArgument, argumentsList)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标对象</li>
<li>thisArg：调用函数时的this参数</li>
<li>argumentsList：调用函数时的参数列表</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>target必须是一个函数对象</p>
</li>
</ol>
<h2 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h2><p><code>construct()</code>捕获器会在 <code>new</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.construct()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;construct()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy;</span><br><span class="line"><span class="comment">// construct()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值</p>
<p><code>construct()</code>必须返回一个对象。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li>new Proxy(…argumentsList)</li>
<li>Reflect.construct(target,argumentsList,newTarget)</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li>target：目标构造函数</li>
<li>argumentsList：传给目标构造函数的参数列表</li>
<li>newTarget：最初被调用的构造函数</li>
</ul>
</li>
<li><p>捕获器不定式</p>
<p>target必须可以用作构造函数</p>
</li>
</ol>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h2 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h2><p>通过捕获 <code>get</code>、<code>set</code> 和 <code>has</code> 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></table></figure>



<h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p><strong>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举</strong>。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">bar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><p>因为所有赋值操作都会触发 <code>set()</code>捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<h2 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, &#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&#x27;Non-number argument provided&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="string">&#x27;7&#x27;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br></pre></td></tr></table></figure>

<p>类似地，可以要求实例化时必须给构造函数传参：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;User cannot be instantiated without id&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></table></figure>



<h2 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p>
<p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        userList.<span class="title function_">push</span>(newUser);</span><br><span class="line">        <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&#x27;Jacob&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&#x27;Jingleheimerschmidt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userList); <span class="comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span></span><br></pre></td></tr></table></figure>

<p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    	<span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        	<span class="title function_">emit</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">&#x27;Jacob&#x27;</span>);</span><br><span class="line"><span class="comment">// Jacob</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" title="JS高级程序设计读书笔记(7)——代理与反射" target="_blank" rel="external">http://pvnk1u.github.io/2023/03/08/JS高级程序设计读书笔记(7)——代理与反射/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/pvnk1u" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/dog.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/pvnk1u" target="_blank"><span class="text-dark">Yolo</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>Everything happens for the best</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/" title="JS高级程序设计读书笔记(8)——函数"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/02/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="JS高级程序设计读书笔记(6)——对象、类与面向对象编程"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/pvnk1u" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2024 pvnk1u
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
    <script defer>
    var disqus_config = function () {
        
            this.page.url = 'http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/';
        
        this.page.identifier = 'JS高级程序设计读书笔记(7)——代理与反射';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + '' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>








</body>
</html>