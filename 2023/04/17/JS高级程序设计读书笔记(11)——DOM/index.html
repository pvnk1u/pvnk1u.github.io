<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>JS高级程序设计读书笔记(11)——DOM | Yolo</title>
  <meta name="description" content="文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示 由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早 期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页 的方式。 DOM Level 1 在 1998 年成为 W3C 推荐标准，提">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高级程序设计读书笔记(11)——DOM">
<meta property="og:url" content="http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示 由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早 期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页 的方式。 DOM Level 1 在 1998 年成为 W3C 推荐标准，提">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pvnk1u.github.io/images/DOMLevel.PNG">
<meta property="article:published_time" content="2023-04-16T21:26:39.000Z">
<meta property="article:modified_time" content="2023-11-27T15:34:23.878Z">
<meta property="article:author" content="pvnk1u">
<meta property="article:tag" content="web">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pvnk1u.github.io/images/DOMLevel.PNG">
  <!-- Canonical links -->
  <link rel="canonical" href="http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/index.html">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center theme-white" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/pvnk1u" target="_blank">
          <img class="img-circle img-rotate" src="/images/dog.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Yolo</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/pvnk1u" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/css/">css</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/html/">html</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/html/css/">css</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/javascript/">javascript</a><span class="category-list-count">14</span></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/html/">html</a>
              </p>
              <p class="item-title">
                <a href="/2023/11/21/UdemyHtmlCss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1/" class="title">UdemyHtmlCss学习笔记——代码</a>
              </p>
              <p class="item-date">
                <time datetime="2023-11-21T07:32:39.000Z" itemprop="datePublished">2023-11-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/07/01/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BD%91%E6%A0%BC/" class="title">精通CSS读书笔记(6)——内容布局</a>
              </p>
              <p class="item-date">
                <time datetime="2023-07-01T07:28:39.000Z" itemprop="datePublished">2023-07-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/05/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80/" class="title">精通CSS读书笔记(6)——内容布局</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-05T07:28:39.000Z" itemprop="datePublished">2023-06-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/04/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E6%BC%82%E4%BA%AE%E7%9A%84%E7%9B%92%E5%AD%90/" class="title">精通CSS读书笔记(5)——漂亮的盒子</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-04T01:28:39.000Z" itemprop="datePublished">2023-06-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/web/">web</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/web/css/">css</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/03/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88/" class="title">精通CSS读书笔记(4)——网页排版</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-03T01:28:39.000Z" itemprop="datePublished">2023-06-03</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">节点层级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Node类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Document%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">Document类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Element%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Element类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">Text节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comment%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Comment类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">DOM编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.</span> <span class="toc-text">动态脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">动态样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%A8%E6%A0%BC"><span class="toc-number">2.3.</span> <span class="toc-text">操作表格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8NodeList"><span class="toc-number">2.4.</span> <span class="toc-text">使用NodeList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MutationObserver%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">MutationObserver接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MutationObserverInit-%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%8C%83%E5%9B%B4"><span class="toc-number">3.2.</span> <span class="toc-text">MutationObserverInit 与观察范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%8E%E8%AE%B0%E5%BD%95%E9%98%9F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">异步回调与记录队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E3%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.4.</span> <span class="toc-text">性能、内存与垃圾回收</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-JS高级程序设计读书笔记(11)——DOM" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      JS高级程序设计读书笔记(11)——DOM
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/" class="article-date">
	  <time datetime="2023-04-16T21:26:39.000Z" itemprop="datePublished">2023-04-17</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/web/">web</a>►<a class="article-category-link" href="/categories/web/javascript/">javascript</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/javascript/" rel="tag">javascript</a>, <a class="article-tag-link-link" href="/tags/web/" rel="tag">web</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 20.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 81(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>文档对象模型（<code>DOM</code>，<code>Document Object Model</code>）是 <code>HTML</code> 和 <code>XML</code> 文档的编程接口。<code>DOM</code> 表示 由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早 期的动态 <code>HTML</code>（<code>DHTML</code>，<code>Dynamic HTML</code>），<code>DOM</code> 现在是真正跨平台、语言无关的表示和操作网页 的方式。</p>
<p><code>DOM Level</code> 1 在 1998 年成为 <code>W3C</code> 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 <code>DOM</code>，主要因为它与浏览器中的 <code>HTML</code> 网页相关，并且在 <code>JavaScript</code> 中提供了 <code>DOM API</code>。</p>
<h1 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h1><p>任何 <code>HTML</code> 或 <code>XML</code> 文档都可以用 <code>DOM</code> 表示为一个由节点构成的层级结构。节点分很多类型，每 种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 <code>HTML</code> 为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果表示为层级结构，则如下图所示。</p>
<p><img src="https://pvnk1u.github.io/images/DOMLevel.PNG" alt="1679552057208"></p>
<p>其中，<code>document</code> 节点表示每个文档的根节点。在这里，根节点的唯一子节点是元素，称之为文档元素（<code>documentElement</code>）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 <code>HTML</code> 页面中，文档元素始终是元素。在 <code>XML</code> 文档中， 则没有这样预定义的元素，任何元素都可能成为文档元素。</p>
<p><code>HTML</code> 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 <code>HTML</code> 元素，属性 节点表示属性，文档类型节点表示文档类型，注释节点表示注释。<code>DOM</code> 中总共有 12 种节点类型，这些 类型都继承一种基本类型。</p>
<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p><code>DOM Level</code> 1 描述了名为 <code>Node</code> 的接口，这个接口是所有 <code>DOM</code> 节点类型都必须实现的。<code>Node</code> 接口 在 <code>JavaScript</code>中被实现为 <code>Node</code> 类型，在除 <code>IE</code>之外的所有浏览器中都可以直接访问这个类型。在<code>JavaScript</code> 中，所有节点类型都继承 <code>Node</code> 类型，因此所有类型都共享相同的基本属性和方法。</p>
<p>每个节点都有 <code>nodeType</code> 属性，表示该节点的类型。节点类型由定义在 <code>Node</code> 类型上的 12 个数值 常量表示：</p>
<ol>
<li>Node.ELEMENT_NODE（1）</li>
<li>Node.ATTRIBUTE_NODE（2）</li>
<li>Node.TEXT_NODE（3）</li>
<li>Node.CDATA_SECTION_NODE（4）</li>
<li>Node.ENTITY_REFERENCE_NODE（5） </li>
<li>Node.ENTITY_NODE（6）</li>
<li>Node.PROCESSING_INSTRUCTION_NODE（7）</li>
<li>Node.COMMENT_NODE（8）</li>
<li>Node.DOCUMENT_NODE（9）</li>
<li>Node.DOCUMENT_TYPE_NODE（10）</li>
<li>Node.DOCUMENT_FRAGMENT_NODE（11）</li>
<li>Node.NOTATION_NODE（12）</li>
</ol>
<p>节点类型可通过与这些常量比较来确定，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>)&#123;</span><br><span class="line"> 	<span class="title function_">alert</span>(<span class="string">&quot;Node is an element.&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这个例子比较了 <code>someNode.nodeType</code> 与 <code>Node.ELEMENT_NODE</code> 常量。如果两者相等，则意味着 <code>someNode</code> 是一个元素节点。</p>
<p><strong>浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。</strong>本章后面会讨论每种节点受支持的程度及其用法。</p>
<ol>
<li><p><code>nodeName</code>与<code>nodeValue</code></p>
<p><code>nodeName</code> 与 <code>nodeValue</code> 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用 这两个属性前，最好先检测节点类型，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>)&#123;</span><br><span class="line">	 value = someNode.<span class="property">nodeName</span>; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这个例子中，先检查了节点是不是元素。如果是，则将其 <code>nodeName</code> 的值赋给一个变量。对元素 而言，<code>nodeName</code> 始终等于元素的标签名，而 <code>nodeValue</code> 则始终为 <code>null</code>。</p>
</li>
<li><p>节点关系</p>
<p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。 在 <code>HTML</code> 中，<code>&lt;body&gt;</code>元素是<code>&lt;html&gt;</code>元素的子元素，而<code>&lt;html&gt;</code>元素则是<code>&lt;body&gt;</code>元素的父元素。 <code>&lt;head&gt;</code>元素是<code>&lt;body&gt;</code>元素的同胞元素，因为它们有共同的父元素<code>&lt;html&gt;</code>。</p>
<p>每个节点都有一个 <code>childNodes</code> 属性，其中包含一个 <code>NodeList</code> 的实例。<code>NodeList</code> 是一个类数组 对象，用于存储可以按位置存取的有序节点。注意，**<code>NodeList</code> 并不是 <code>Array</code> 的实例，但可以使用中括 号访问它的值，而且它也有 <code>length</code> 属性。<code>NodeList</code> 对象独特的地方在于，它其实是一个对 <code>DOM</code> 结 构的查询，因此 <code>DOM</code> 结构的变化会自动地在 <code>NodeList</code> 中反映出来。我们通常说 <code>NodeList</code> 是实时的 活动对象，而不是第一次访问时所获得内容的快照。**</p>
<p>下面的例子展示了如何使用中括号或使用 <code>item()</code>方法访问 <code>NodeList</code> 中的元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChild = someNode.<span class="property">childNodes</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> secondChild = someNode.<span class="property">childNodes</span>.<span class="title function_">item</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> count = someNode.<span class="property">childNodes</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>无论是使用中括号还是 <code>item()</code>方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个 类数组对象。注意，**<code>length</code> 属性表示那一时刻 <code>NodeList</code> 中节点的数量。使用 <code>Array.prototype.slice()</code>可以像前面介绍 <code>arguments</code> 时一样把 <code>NodeList</code> 对象转换为数组。**比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(someNode.<span class="property">childNodes</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当然，使用 <code>ES6</code> 的 <code>Array.from()</code>静态方法，可以替换这种笨拙的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes = <span class="title class_">Array</span>.<span class="title function_">from</span>(someNode.<span class="property">childNodes</span>);</span><br></pre></td></tr></table></figure>

<p>每个节点都有一个 <code>parentNode</code> 属性，指向其 <code>DOM</code> 树中的父元素。<code>childNodes</code> 中的所有节点都有同一个父元素，因此它们的 <code>parentNode</code> 属性都指向同一个节点。此外，<code>childNodes</code> 列表中的每个 节点都是同一列表中其他节点的同胞节点。而使用 <code>previousSibling</code> 和 <code>nextSibling</code> 可以在这个列表的节点间导航。这个列表中第一个节点的 <code>previousSibling</code> 属性是 <code>null</code>，最后一个节点的 <code>nextSibling</code> 属性也是 <code>null</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nextSibling</span> === <span class="literal">null</span>)&#123;</span><br><span class="line"> 	<span class="title function_">alert</span>(<span class="string">&quot;Last node in the parent&#x27;s childNodes list.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.<span class="property">previousSibling</span> === <span class="literal">null</span>)&#123;</span><br><span class="line"> 	<span class="title function_">alert</span>(<span class="string">&quot;First node in the parent&#x27;s childNodes list.&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>注意，如果 <code>childNodes</code> 中只有一个节点，则它的 <code>previousSibling</code> 和 <code>nextSibling</code> 属性都是 <code>null</code>。</p>
<p>父节点和它的第一个及最后一个子节点也有专门属性：<code>firstChild</code> 和 <code>lastChild</code> 分别指向 <code>childNodes</code> 中的第一个和最后一个子节点。<code>someNode.firstChild</code> 的值始终等于 <code>someNode. childNodes[0]</code>，而 <code>someNode.lastChild</code> 的值始终等于 <code>someNode.childNodes[someNode. childNodes.length-1]</code>。如果只有一个子节点，则 <code>firstChild</code> 和 <code>lastChild</code> 指向同一个节点。如 果没有子节点，则 <code>firstChild</code> 和 <code>lastChild</code> 都是 <code>null</code>。上述这些节点之间的关系为在文档树的节 点之间导航提供了方便。</p>
<p>有了这些关系，<code>childNodes</code> 属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是 <code>childNodes</code> 的最大亮点。还有一个便利的方法是 <code>hasChildNodes()</code>，这个方法如果返回 <code>true</code> 则说明节点有一个或多个子节点。相比查询 <code>childNodes </code>的 <code>length</code> 属性，这个方法无疑更方便。</p>
<p><strong>最后还有一个所有节点都共享的关系。<code>ownerDocument</code> 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。</strong></p>
</li>
<li><p>操纵节点</p>
<p>因为所有关系指针都是只读的，所以 <code>DOM</code> 又提供了一些操纵节点的方法。最常用的方法是 <code>appendChild()</code>，用于在 <code>childNodes</code> 列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。<code>appendChild()</code>方法返回新添加的节点，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(newNode);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(someNode.<span class="property">lastChild</span> == newNode); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>如果把文档中已经存在的节点传给 <code>appendChild()</code>，则这个节点会从之前的位置被转移到新位置。 即使 <code>DOM</code> 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此， 如果调用 <code>appendChild()</code>传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点</strong>， 如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">firstChild</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果想把节点放到 <code>childNodes</code> 中的特定位置而不是末尾，则可以使用 <code>insertBefore()</code>方法。 这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是 <code>null</code>，则 <code>insertBefore()</code>与 <code>appendChild()</code>效果相同，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, <span class="literal">null</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为新的第一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">firstChild</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">lastChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">childNodes</span>[someNode.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>appendChild()</code> 和 <code>insertBefore()</code> 在插入节点时不会删除任何已有节点。相对地， <code>replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档 树中完全移除，要插入的节点会取而代之。下面看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">lastChild</span>); </span><br></pre></td></tr></table></figure>

<p>使用 <code>replaceChild()</code>插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
<p>要移除节点而不是替换节点，可以使用 <code>removeChild()</code>方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerFirstChild = someNode.<span class="title function_">removeChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerLastChild = someNode.<span class="title function_">removeChild</span>(someNode.<span class="property">lastChild</span>); </span><br></pre></td></tr></table></figure>

<p>与 <code>replaceChild()</code>方法一样，通过 <code>removeChild()</code>被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
<p>上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使 用前面介绍的 <code>parentNode</code> 属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用 这些方法，则会导致抛出错误。</p>
</li>
<li><p>其他方法</p>
<p>所有节点类型还共享了两个方法。第一个是 <code>cloneNode()</code>，会返回与调用它的节点一模一样的节点。<code>cloneNode()</code>方法接收一个布尔值参数，表示是否深复制。在传入 true 参数时，会进行深复制， 即复制节点及其整个子 <code>DOM</code> 树。如果传入 false，则只会复制调用该方法的节点。复制返回的节点属 于文档所有，但尚未指定父节点，所以可称为孤儿节点（<code>orphan</code>）。可以通过 <code>appendChild()</code>、 <code>insertBefore()</code>或 <code>replaceChild()</code>方法把孤儿节点添加到文档中。以下面的 <code>HTML</code> 片段为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>myList</code>保存着对这个元素的引用，则下列代码展示了使用<code>cloneNode()</code>方法的两种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deepList = myList.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">alert</span>(deepList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 3（IE9 之前的版本）或 7（其他浏览器）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shallowList = myList.<span class="title function_">cloneNode</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="title function_">alert</span>(shallowList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>deepList</code> 保存着 <code>myList</code> 的副本。这意味着 <code>deepList</code>有 3 个列表项，每个列表项又各自包含文本。变量 <code>shallowList</code> 则保存着 <code>myList </code>的浅副本，因此没有子节点。 <code>deepList.childNodes.length</code> 的值会因 <code>IE8</code> 及更低版本和其他浏览器对空格的处理方式而不同。<code>IE9</code> 之前的版本不会为空格创建节点。</p>
<p>本节要介绍的最后一个方法是 <code>normalize()</code>。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或 <code>DOM</code> 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用 <code>normalize()</code>方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。 这个方法将在本章后面进一步讨论。</p>
</li>
</ol>
<h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p><code>Document</code> 类型是 <code>JavaScript</code> 中表示文档节点的类型。在浏览器中，文档对象 <code>document</code> 是 <code>HTMLDocument</code> 的实例（<code>HTMLDocument</code>继承 <code>Document</code>），表示整个 <code>HTML</code> 页面。<code>document</code> 是 <code>window</code> 对象的属性，因此是一个全局对象。<code>Document</code>类型的节点有以下特征：</p>
<ol>
<li><code>nodeType</code>等于9</li>
<li><code>nodeName</code>值为”#document”</li>
<li><code>nodeValue</code>值为<code>null</code></li>
<li><code>parentNode</code>值为<code>null</code></li>
<li><code>ownerDocument</code>值为<code>null</code></li>
<li>子节点可以是<code>DocumentType</code>(最多一个)、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code>或<code>Comment</code>类型。</li>
</ol>
<p><code>Document</code>类型可以表示<code>HTML</code>页面或其他<code>XML</code>文档，但最常用的还是通过<code>HTMLDocument</code>的实例取得<code>document</code>对象。<code>document</code>对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p>
<ol>
<li><p>文档子节点</p>
<p>虽然 <code>DOM</code> 规范规定 <code>Document</code> 节点的子节点可以是 <code>DocumentType</code>、<code>Element</code>、<code>ProcessingInstruction</code> 或 <code>Comment</code>，但也提供了两个访问子节点的快捷方式。第一个是 <code>documentElement</code> 属 性，始终指向 <code>HTML</code> 页面中的元素。虽然 <code>document.childNodes</code> 中始终有元素，但使用 <code>documentElement</code> 属性可以更快更直接地访问该元素。假如有以下简单的页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>浏览器解析完这个页面之后，文档只有一个子节点，即元素。这个元素既可以通过 <code>documentElement</code> 属性获取，也可以通过 <code>childNodes</code> 列表访问，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">childNodes</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">firstChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个例子表明 <code>documentElement</code>、<code>firstChild</code> 和 <code>childNodes[0]</code>都指向同一个值，即元素。</p>
<p>作为 <code>HTMLDocument</code> 的实例，<code>document</code> 对象还有一个 <code>body</code> 属性，直接指向元素。因为 这个元素是开发者使用最多的元素，所以 <code>JavaScript</code> 代码中经常可以看到 <code>document.body</code>，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">// 取得对&lt;body&gt;的引用</span></span><br></pre></td></tr></table></figure>

<p>所有主流浏览器都支持 <code>document.documentElement</code> 和 <code>document.body</code>。</p>
<p><code>Document</code> 类型另一种可能的子节点是 <code>DocumentType</code>。标签是文档中独立的部分， 其信息可以通过 <code>doctype</code> 属性（在浏览器中是 <code>document.doctype</code>）来访问，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>; <span class="comment">// 取得对&lt;!doctype&gt;的引用</span></span><br></pre></td></tr></table></figure>

<p>另外，严格来讲出现在元素外面的注释也是文档的子节点，它们的类型是 <code>Comment</code>。不过， 由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下 <code>HTML</code> 页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一条注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二条注释 --&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这个页面看起来有 3 个子节点：注释、元素、注释。逻辑上讲，<code>document.childNodes</code> 应该包含 3 项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待元素外部的 注释，比如忽略一个或两个注释。</p>
<p>一般来说，<code>appendChild()</code>、<code>removeChild()</code>和 <code>replaceChild()</code>方法不会用在 <code>document</code> 对象 上。这是因为文档类型（如果存在）是只读的，而且只能有一个 <code>Element</code> 类型的子节点（即<code>&lt;html&gt;</code>， 已经存在了）。</p>
</li>
<li><p>文档信息</p>
<p><code>document</code> 作为 <code>HTMLDocument</code> 的实例，还有一些标准 <code>Document</code> 对象上所没有的属性。这些属性 提供浏览器所加载网页的信息。其中第一个属性是 <code>title</code>，包含<code>&lt;title&gt;</code>元素中的文本，通常显示在浏 览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题 栏上。不过，修改 title 属性并不会改变<code>&lt;title&gt;</code>元素。下面是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文档标题</span></span><br><span class="line"><span class="keyword">let</span> originalTitle = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文档标题</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;New page title&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>接下来要介绍的 3 个属性是 <code>URL</code>、<code>domain</code> 和 <code>referrer</code>。其中，<code>URL</code> 包含当前页面的完整 <code>URL</code>（地址栏中的 <code>URL</code>），<code>domain</code> 包含页面的域名，而 <code>referrer</code> 包含链接到当前页面的那个页面的 <code>URL</code>。如 果当前页面没有来源，则 <code>referrer</code> 属性包含空字符串。所有这些信息都可以在请求的 <code>HTTP</code> 头部信息 中获取，只是在 <code>JavaScript</code> 中通过这几个属性暴露出来而已，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得完整的 URL</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="variable language_">document</span>.<span class="property">URL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得域名</span></span><br><span class="line"><span class="keyword">let</span> domain = <span class="variable language_">document</span>.<span class="property">domain</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得来源</span></span><br><span class="line"><span class="keyword">let</span> referrer = <span class="variable language_">document</span>.<span class="property">referrer</span>;</span><br></pre></td></tr></table></figure>

<p><code>URL</code> 跟域名是相关的。比如，如果 <code>document.URL</code> 是 <code>http://www.wrox.com/WileyCDA/</code>，则 <code>document.domain</code> 就是 <code>www.wrox.com</code>。</p>
<p>在这些属性中，只有 <code>domain</code> 属性是可以设置的。出于安全考虑，给 <code>domain</code> 属性设置的值是有限制的。如果 <code>URL</code>包含子域名如 <code>p2p.wrox.com</code>，则可以将 <code>domain</code> 设置为”wrox.com”（<code>URL</code>包含“www” 时也一样，比如 <code>www.wrox.com</code>）。不能给这个属性设置 <code>URL</code> 中不包含的值，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 成功</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;nczonline.net&quot;</span>; <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>

<p>当页面中包含来自某个不同子域的窗格（<code>&lt;frame&gt;</code>）或内嵌窗格（<code>&lt;iframe&gt;</code>)时，设置<code>document.domain</code>是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过<code>JavaScript</code>通信。此时，在每个页面上把 <code>document.domain</code> 设置为相同的值，这些页面就可以访问对方的 <code>JavaScript</code> 对象了。比如，一个加载自 <code>www.wrox.com</code> 的页面中包含一个内嵌窗格，其中的页面加载自 <code>p2p.wrox.com</code>。这两个页面的 <code>document.domain</code> 包含不同的字符串，内部和外部页面相互之间不能 访问对方的 <code>JavaScript</code>对象。如果每个页面都把 <code>document.domain</code> 设置为 <code>wrox.com</code>，那这两个页面之间就可以通信了。</p>
<p>浏览器对 <code>domain</code> 属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把 <code>document.domain</code> 设置为”wrox.com”之后，就不能再将其设置回”p2p.wrox.com”，后者会导致错误，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 放松，成功</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;p2p.wrox.com&quot;</span>; <span class="comment">// 收紧，错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定位元素</p>
<p>使用 <code>DOM</code> 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。 <code>document</code> 对象上暴露了一些方法，可以实现这些操作。<code>getElementById()</code>和 <code>getElementsByTagName()</code>就是 <code>Document</code> 类型提供的两个方法。</p>
<p><code>getElementById()</code>方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果 没找到则返回 <code>null</code>。参数 ID 必须跟元素在页面中的 id 属性值完全匹配，包括大小写。比如页面中有以下元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Some text<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>可以使用如下代码取得这个元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); <span class="comment">// 取得对这个&lt;div&gt;元素的引用</span></span><br></pre></td></tr></table></figure>

<p>但参数大小写不匹配会返回 null：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mydiv&quot;</span>); <span class="comment">// null </span></span><br></pre></td></tr></table></figure>

<p>如果页面中存在多个具有相同 ID 的元素，则 <code>getElementById()</code>返回在文档中出现的第一个元素。</p>
<p><code>getElementsByTagName()</code>是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 <code>NodeList</code>。在 <code>HTML</code> 文档中，这个方法返回一个 <code>HTMLCollection</code> 对象。考虑到二者都是“实时”列表，<code>HTMLCollection</code> 与 <code>NodeList</code> 是很相似的。 例如，下面的代码会取得页面中所有的<code>&lt;img&gt;</code>元素并返回包含它们的 <code>HTMLCollection</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> images = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里把返回的 <code>HTMLCollection</code> 对象保存在了变量 <code>images</code> 中。与 <code>NodeList</code> 对象一样，也可以 使用中括号或 <code>item()</code>方法从 <code>HTMLCollection</code> 取得特定的元素。而取得元素的数量同样可以通过 <code>length</code> 属性得知，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(images.<span class="property">length</span>); <span class="comment">// 图片数量</span></span><br><span class="line"><span class="title function_">alert</span>(images[<span class="number">0</span>].<span class="property">src</span>); <span class="comment">// 第一张图片的 src 属性</span></span><br><span class="line"><span class="title function_">alert</span>(images.<span class="title function_">item</span>(<span class="number">0</span>).<span class="property">src</span>); <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>

<p><code>HTMLCollection</code> 对象还有一个额外的方法 <code>namedItem()</code>，可通过标签的 <code>name</code> 属性取得某一项 的引用。例如，假设页面中包含如下的<code>&lt;img&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.gif&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myImage&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>那么也可以像这样从 <code>images</code> 中取得对这个<code>&lt;img&gt;</code>元素的引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = images.<span class="title function_">namedItem</span>(<span class="string">&quot;myImage&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>这样，<code>HTMLCollection</code> 就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了 便利。对于 <code>name</code> 属性的元素，还可以直接使用中括号来获取，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = images[<span class="string">&quot;myImage&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>对 <code>HTMLCollection</code> 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台， 数值索引会调用 <code>item()</code>，字符串索引会调用 <code>namedItem()</code>。</p>
<p>要取得文档中的所有元素，可以给 <code>getElementsByTagName()</code>传入<code>*</code>。在 <code>JavaScript</code> 和 <code>CSS</code> 中，<code>*</code> 一般被认为是匹配一切的字符。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allElements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码可以返回包含页面中所有元素的 <code>HTMLCollection</code> 对象，顺序就是它们在页面中出现的 顺序。因此第一项是<code>&lt;html&gt;</code>元素，第二项是<code>&lt;head&gt;</code>元素，以此类推。</p>
<p><code>HTMLDocument</code> 类型上定义的获取元素的第三个方法是 <code>getElementsByName()</code>。顾名思义，这个 方法会返回具有给定 <code>name</code> 属性的所有元素。<code>getElementsByName()</code>方法最常用于单选按钮，因为同 一字段的单选按钮必须具有相同的 <code>name</code> 属性才能确保把正确的值发送给服务器，比如下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorRed&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorRed&quot;</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorGreen&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorGreen&quot;</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorBlue&quot;</span>&gt;</span> </span><br><span class="line">             <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorBlue&quot;</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里所有的单选按钮都有名为”color”的 <code>name</code> 属性，但它们的 <code>ID</code> 都不一样。这是因为 <code>ID</code> 是为了 匹配对应的元素，而 <code>name</code> 相同是为了保证只将三个中的一个值发送给服务器。然后就可以像 下面这样取得所有单选按钮：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radios = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;color&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>与 <code>getElementsByTagName()</code>一样，<code>getElementsByName()</code>方法也返回 <code>HTMLCollection</code>。不 过在这种情况下，<code>namedItem()</code>方法只会取得第一项（因为所有项的 <code>name</code> 属性都一样）。</p>
</li>
<li><p>特殊集合</p>
<p><code>document</code> 对象上还暴露了几个特殊集合，这些集合也都是 <code>HTMLCollection</code> 的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。</p>
<ul>
<li><code>document.anchors</code>包含文档中所有带 <code>name</code> 属性的<code>&lt;a&gt;</code>元素。</li>
<li><code>document.applets</code> 包含文档中所有元素（因为元素已经不建议使用，所 以这个集合已经废弃）。</li>
<li><code>document.forms</code> 包含文档中所有元素（与 <code>document.getElementsByTagName (&quot;form&quot;) </code>返回的结果相同）。</li>
<li><code>document.images</code> 包含文档中所有<code>&lt;img&gt;</code>元素（与 <code>document.getElementsByTagName (&quot;img&quot;)</code> 返回的结果相同)。</li>
<li><code>document.links</code> 包含文档中所有带 <code>href</code> 属性的<code>&lt;a&gt;</code>元素。</li>
</ul>
<p>这些特殊集合始终存在于 <code>HTMLDocument</code> 对象上，而且与所有 <code>HTMLCollection</code> 对象一样，其内容也会实时更新以符合当前文档的内容。</p>
</li>
<li><p>DOM兼容性检测</p>
<p>由于 <code>DOM</code> 有多个 <code>Level</code>和多个部分，因此确定浏览器实现了 <code>DOM</code> 的哪些部分是很必要的。 <code>document.implementation</code> 属性是一个对象，其中提供了与浏览器 <code>DOM</code> 实现相关的信息和能力。 <code>DOM Level</code> 1 在 <code>document.implementation</code> 上只定义了一个方法，即 <code>hasFeature()</code>。这个方法接收两个参数：特性名称和 <code>DOM</code> 版本。如果浏览器支持指定的特性和版本，则 <code>hasFeature()</code>方法返回 true，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasXmlDom = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;XML&quot;</span>, <span class="string">&quot;1.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于实现不一致，因此 <code>hasFeature()</code>的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回 true。</p>
</li>
<li><p>文档写入</p>
<p><code>document</code> 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：<code>write()</code>、 <code>writeln()</code>、<code>open()</code>和 <code>close()</code>。其中，<code>write()</code>和 <code>writeln()</code>方法都接收一个字符串参数，可以将这个字符串写入网页中。<code>write()</code>简单地写入文本，而 <code>writeln()</code>还会在字符串末尾追加一个换行符 （\n）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>The current date and time is:</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> 	<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;strong&gt;&quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>() + <span class="string">&quot;&lt;/strong&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这个例子会在页面加载过程中输出当前日期和时间。日期放在了<code>&lt;strong&gt;</code>元素中，如同它们之前 就包含在 <code>HTML</code> 页面中一样。这意味着会创建一个 <code>DOM</code> 元素，以后也可以访问。通过<code> write()</code>和 <code>writeln()</code>输出的任何 <code>HTML</code> 都会以这种方式来处理。</p>
<p><code>write()</code>和 <code>writeln()</code>方法经常用于动态包含外部资源，如 <code>JavaScript</code> 文件。在包含 <code>JavaScript</code> 文 件时，记住不能像下面的例子中这样直接包含字符串””，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        document.write(&quot;<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>&quot;<span class="attr">text</span>/<span class="attr">javascript</span>\&quot; <span class="attr">src</span>=<span class="string">\</span>&quot;<span class="attr">file.js</span>\&quot;&gt;</span>&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">         &quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;);</span><br><span class="line">     <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>虽然这样写看起来没错，但输出之后的”<code>&lt;/script&gt;</code>“会匹配最外层的<code>&lt;script&gt;</code>标签，导致页面中 显示出”);。为避免出现这个问题，需要对前面的例子稍加修改：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">         document.write(&quot;<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>&quot;<span class="attr">text</span>/<span class="attr">javascript</span>\&quot; <span class="attr">src</span>=<span class="string">\</span>&quot;<span class="attr">file.js</span>\&quot;&gt;</span>&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">         &quot;&lt;\/script&gt;&quot;);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">     </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的字符串”<code>&lt;\/script&gt;</code>“不会再匹配最外层的<code>&lt;script&gt;</code>标签，因此不会在页面中输出额外内容。</p>
<p>前面的例子展示了在页面渲染期间通过 <code>document.write()</code>向文档中输出内容。如果是在页面加 载完之后再调用 <code>document.write()</code>，则输出的内容会重写整个页面，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some content that you won&#x27;t get to see because it will be</span><br><span class="line"> overwritten.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">     	<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     &#125;;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这个例子使用了 <code>window.onload</code> 事件处理程序，将调用 <code>document.write()</code>的函数推迟到页面 加载完毕后执行。执行之后，字符串”Hello world!”会重写整个页面内容。</p>
<p><code>open()</code>和 <code>close()</code>方法分别用于打开和关闭网页输出流。在调用 <code>write()</code>和 <code>writeln()</code>时，这两 个方法都不是必需的。</p>
</li>
</ol>
<h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>除了<code>Document</code> 类型，<code>Element</code> 类型就是<code>Web</code>开发中最常用的类型了。<code>Element</code> 表示<code>XML</code>或<code>HTML</code> 元素，对外暴露出访问元素标签名、子节点和属性的能力。<code>Element</code> 类型的节点具有以下特征：</p>
<ol>
<li><code>nodeType</code>等于1</li>
<li><code>nodeName</code>值为元素的标签名</li>
<li><code>nodeValue</code>值为<code>null</code></li>
<li><code>parentNode</code>值为<code>Document</code>或<code>Element</code>对象</li>
<li>子节点可以是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDTASection</code>、<code>EntityReference</code>类型。</li>
</ol>
<p>可以通过 <code>nodeName </code>或 <code>tagName</code> 属性来获取元素的标签名。这两个属性返回同样的值（添加后一 个属性明显是为了不让人误会）。比如有下面的元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以像这样取得这个元素的标签名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span>); <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span> == div.<span class="property">nodeName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>例子中的元素标签名为 <code>div</code>，<code>ID</code> 为”myDiv”。注意，<code>div.tagName</code> 实际上返回的是”DIV”而不是 “div”。在 <code>HTML</code> 中，元素标签名始终以全大写表示；在 <code>XML</code>（包括 <code>XHTML</code>）中，标签名始终与源 代码中的大小写一致。如果不确定脚本是在 <code>HTML</code> 文档还是 <code>XML</code> 文档中运行，最好将标签名转换为小写形式，以便于比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">tagName</span> == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 不要这样做，可能出错！</span></span><br><span class="line"> <span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 推荐，适用于所有文档</span></span><br><span class="line"> <span class="comment">// 做点什么</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<ol>
<li><p>HTML元素</p>
<p>所有 <code>HTML</code> 元素都通过 <code>HTMLElement</code> 类型表示，包括其直接实例和间接实例。另外，<code>HTMLElement</code> 直接继承 <code>Element</code> 并增加了一些属性。每个属性都对应下列属性之一，它们是所有 <code>HTML</code> 元素上都有 的标准属性：</p>
<ul>
<li><code>id</code>，元素在文档中的唯一标识符</li>
<li><code>title</code>，包含元素的额外信息，通常以提示条形式展示</li>
<li><code>lang</code>，元素内容的语言代码（很少用）</li>
<li><code>dir</code>，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右向左，同样很少用）</li>
<li><code>className</code>，相当于class属性，用于指定元素的 <code>CSS</code> 类（因为 <code>class</code> 是 <code>ECMAScript</code> 关键字， 所以不能直接用这个名字）。</li>
</ul>
<p>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 <code>HTML</code> 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个元素中的所有属性都可以使用下列 <code>JavaScript</code> 代码读取：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">id</span>); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">className</span>); <span class="comment">// &quot;bd&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">title</span>); <span class="comment">// &quot;Body text&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">lang</span>); <span class="comment">// &quot;en&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">dir</span>); <span class="comment">// &quot;ltr&quot; </span></span><br></pre></td></tr></table></figure>

<p>而且，可以使用下列代码修改元素的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;someOtherId&quot;</span>;</span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;ft&quot;</span>;</span><br><span class="line">div.<span class="property">title</span> = <span class="string">&quot;Some other text&quot;</span>;</span><br><span class="line">div.<span class="property">lang</span> = <span class="string">&quot;fr&quot;</span>;</span><br><span class="line">div.<span class="property">dir</span> =<span class="string">&quot;rtl&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>并非所有这些属性的修改都会对页面产生影响。比如，把 <code>id</code> 或 <code>lang</code> 改成其他值对用户是不可见 的（假设没有基于这两个属性应用 <code>CSS</code> 样式），而修改 <code>title </code>属性则只会在鼠标移到这个元素上时才会 反映出来。修改 <code>dir</code> 会导致页面文本立即向左或向右对齐。修改 <code>className</code> 会立即反映应用到新类名 的 <code>CSS</code> 样式（如果定义了不同的样式）。</p>
<p>如前所述，所有 <code>HTML</code> 元素都是 <code>HTMLElement</code> 或其子类型的实例。下表列出了所有 <code>HTML</code> 元素 及其对应的类型（斜体表示已经废弃的元素）。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>类型</th>
<th>元素</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>HTMLAnchorElement</td>
<td>COL</td>
<td>HTMLTableColElement</td>
</tr>
<tr>
<td>ABBR</td>
<td>HTMLElement</td>
<td>COLGROUP</td>
<td>HTMLTableColElement</td>
</tr>
<tr>
<td>ACRONYM</td>
<td>HTMLElement</td>
<td>DD</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>ADDRESS</td>
<td>HTMLElement</td>
<td>DEL</td>
<td>HTMLModElement</td>
</tr>
<tr>
<td><em>APPLET</em></td>
<td><em>HTMLAppletElement</em></td>
<td>DFN</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>AREA</td>
<td>HTMLAreaElement</td>
<td><em>DIR</em></td>
<td><em>HTMLDirectoryElement</em></td>
</tr>
<tr>
<td>B</td>
<td>HTMLElement</td>
<td>DIV</td>
<td>HTMLDivElement</td>
</tr>
<tr>
<td>BASE</td>
<td>HTMLBaseElement</td>
<td>DL</td>
<td>HTMLDListElement</td>
</tr>
<tr>
<td><em>BASEFONT</em></td>
<td><em>HTMLBaseFontElement</em></td>
<td>DT</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>BDO</td>
<td>HTMLElement</td>
<td>EM</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>BIG</td>
<td>HTMLElement</td>
<td>FIELDSET</td>
<td>HTMLFieldSetElement</td>
</tr>
<tr>
<td>BLOCKQUOTE</td>
<td>HTMLQuoteElement</td>
<td><em>FONT</em></td>
<td><em>HTMLFontElement</em></td>
</tr>
<tr>
<td>BODY</td>
<td>HTMLBodyElement</td>
<td>FORM</td>
<td>HTMLFormElement</td>
</tr>
<tr>
<td>BR</td>
<td>HTMLBRElement</td>
<td>FRAME</td>
<td>HTMLFrameElement</td>
</tr>
<tr>
<td>BUTTON</td>
<td>HTMLButtonElement</td>
<td>FRAMESET</td>
<td>HTMLFrameSetElement</td>
</tr>
<tr>
<td>CAPTION</td>
<td>HTMLTableCaptionElement</td>
<td>H1</td>
<td>HTMLHeadingElement</td>
</tr>
<tr>
<td><em>CENTER</em></td>
<td><em>HTMLElement</em></td>
<td>H2</td>
<td>HTMLHeadingElement</td>
</tr>
<tr>
<td>CITE</td>
<td>HTMLElement</td>
<td>H3</td>
<td>HTMLHeadingElement</td>
</tr>
<tr>
<td>CODE</td>
<td>HTMLElement</td>
<td>H4</td>
<td>HTMLHeadingElement</td>
</tr>
<tr>
<td>H5</td>
<td>HTMLHeadingElement</td>
<td>PRE</td>
<td>HTMLPreElement</td>
</tr>
<tr>
<td>H6</td>
<td>HTMLHeadingElement</td>
<td>Q</td>
<td>HTMLQuoteElement</td>
</tr>
<tr>
<td>HEAD</td>
<td>HTMLHeadElement</td>
<td><em>S</em></td>
<td>HTMLElement</td>
</tr>
<tr>
<td>HR</td>
<td>HTMLHRElement</td>
<td>SAMP</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>HTML</td>
<td>HTMLHtmlElement</td>
<td>SCRIPT</td>
<td>HTMLScriptElement</td>
</tr>
<tr>
<td>I</td>
<td>HTMLElement</td>
<td>SELECT</td>
<td>HTMLSelectElement</td>
</tr>
<tr>
<td>IFRAME</td>
<td>HTMLIFrameElement</td>
<td>SMALL</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>IMG</td>
<td>HTMLImageElement</td>
<td>SPAN</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>INPUT</td>
<td>HTMLInputElement</td>
<td><em>STRIKE</em></td>
<td><em>HTMLElement</em></td>
</tr>
<tr>
<td>INS</td>
<td>HTMLModElement</td>
<td>STRONG</td>
<td>HTMLElement</td>
</tr>
<tr>
<td><em>ISINDEX</em></td>
<td><em>HTMLIsIndexElement</em></td>
<td>STYLE</td>
<td>HTMLStyleElement</td>
</tr>
<tr>
<td>KBD</td>
<td>HTMLElement</td>
<td>SUB</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>LABEL</td>
<td>HTMLLabelElement</td>
<td>SUP</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>LEGEND</td>
<td>HTMLLegendElement</td>
<td>TABLE</td>
<td>HTMLTableElement</td>
</tr>
<tr>
<td>LI</td>
<td>HTMLLIElement</td>
<td>TBODY</td>
<td>HTMLTableSectionElement</td>
</tr>
<tr>
<td>LINK</td>
<td>HTMLLinkElement</td>
<td>TD</td>
<td>HTMLTableCellElement</td>
</tr>
<tr>
<td>MAP</td>
<td>HTMLMapElement</td>
<td>TEXTAREA</td>
<td>HTMLTextAreaElement</td>
</tr>
<tr>
<td><em>MENU</em></td>
<td><em>HTMLMenuElement</em></td>
<td>TFOOT</td>
<td>HTMLTableSectionElement</td>
</tr>
<tr>
<td>META</td>
<td>HTMLMetaElement</td>
<td>TH</td>
<td>HTMLTableCellElement</td>
</tr>
<tr>
<td>NOFRAMES</td>
<td>HTMLElement</td>
<td>THEAD</td>
<td>HTMLTableSectionElement</td>
</tr>
<tr>
<td>NOSCRIPT</td>
<td>HTMLElement</td>
<td>TITLE</td>
<td>HTMLTitleElement</td>
</tr>
<tr>
<td>OBJECT</td>
<td>HTMLObjectElement</td>
<td>TR</td>
<td>HTMLTableRowElement</td>
</tr>
<tr>
<td>OL</td>
<td>HTMLOListElement</td>
<td>TT</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>OPTGROUP</td>
<td>HTMLOptGroupElement</td>
<td><em>U</em></td>
<td><em>HTMLElement</em></td>
</tr>
<tr>
<td>OPTION</td>
<td>HTMLOptionElement</td>
<td>UL</td>
<td>HTMLUListElement</td>
</tr>
<tr>
<td>P</td>
<td>HTMLParagraphElement</td>
<td>VAR</td>
<td>HTMLElement</td>
</tr>
<tr>
<td>PARAM</td>
<td>HTMLParamElement</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这里列出的每种类型都有关联的属性和方法。接下来的内容会涉及其中的很多类型。</p>
</li>
<li><p>取得属性</p>
<p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 <code>DOM</code> 方法 主要有 3 个：<code>getAttribute()</code>、<code>setAttribute()</code>和 <code>removeAttribute()</code>。这些方法主要用于操纵属性，包括在 <code>HTMLElement</code> 类型上定义的属性。下面看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;class&quot;</span>)); <span class="comment">// &quot;bd&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>)); <span class="comment">// &quot;Body text&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;lang&quot;</span>)); <span class="comment">// &quot;en&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;dir&quot;</span>)); <span class="comment">// &quot;ltr&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意传给 <code>getAttribute()</code>的属性名与它们实际的属性名是一样的，因此这里要传”class”而非”className”（<code>className</code> 是作为对象属性时才那么拼写的）。如果给定的属性不存在，则 <code>getAttribute()</code> 返回 <code>null</code>。</p>
<p><code>getAttribute()</code>方法也能取得不是 <code>HTML</code> 语言正式属性的自定义属性的值。比如下面的元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">my_special_attribute</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这个元素有一个自定义属性 <code>my_special_attribute</code>，值为”hello!”。可以像其他属性一样使用 <code>getAttribute()</code>取得这个属性的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = div.<span class="title function_">getAttribute</span>(<span class="string">&quot;my_special_attribute&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>注意，属性名不区分大小写，因此”ID”和”id”被认为是同一个属性。另外，根据 <code>HTML5</code> 规范的 要求，自定义属性名应该前缀 <code>data-</code>以方便验证。</p>
<p>元素的所有属性也可以通过相应 <code>DOM</code> 元素对象的属性来取得。当然，这包括 <code>HTMLElement</code> 上定义的直接映射对应属性的 5 个属性，还有所有公认（非自定义）的属性也会被添加为 <code>DOM</code> 对象的属性。 比如下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span> <span class="attr">my_special_attribute</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>id</code> 和 <code>align</code> 在 <code>HTML</code> 中是元素公认的属性，所以 <code>DOM</code> 对象上也会有这两个属性。但 <code>my_special_attribute</code> 是<strong>自定义属性，因此不会成为 <code>DOM</code> 对象的属性。</strong></p>
<p>通过 <code>DOM</code> 对象访问的属性中有两个返回的值跟使用 <code>getAttribute()</code>取得的值不一样。首先是 <code>style</code> 属性，这个属性用于为元素设定 <code>CSS</code> 样式。在使用 <code>getAttribute()</code>访问 <code>style</code> 属性时，返回的 是 <code>CSS </code>字符串。而在通过 <code>DOM</code> 对象的属性访问时，<code>style</code> 属性返回的是一个（<code>CSSStyleDeclaration</code>） 对象。<code>DOM</code> 对象的 <code>style</code> 属性用于以编程方式读写元素样式，因此不会直接映射为元素中 <code>style</code> 属性的字符串值。</p>
<p>第二个属性其实是一类，即事件处理程序（或者事件属性），比如 <code>onclick</code>。在元素上使用事件属 性时（比如 <code>onclick</code>），属性的值是一段 <code>JavaScript</code> 代码。如果使用 <code>getAttribute()</code>访问事件属性， 则返回的是字符串形式的源代码。而通过 <code>DOM</code> 对象的属性访问事件属性时返回的则是一个 <code>JavaScript</code> 函数（未指定该属性则返回 <code>null</code>）。这是因为 <code>onclick</code> 及其他事件属性是可以接受函数作为值的。</p>
<p>考虑到以上差异，开发者在进行<code>DOM</code>编程时通常会放弃使用<code>getAttribute()</code>而只使用对象属性。 <code>getAttribute()</code>主要用于取得自定义属性的值。</p>
</li>
<li><p>设置属性</p>
<p>与 <code>getAttribute()</code>配套的方法是 <code>setAttribute()</code>，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则 <code>setAttribute()</code>会以指定的值替换原来的值；如果属性不存在， 则 <code>setAttribute()</code>会以指定的值创建该属性。下面看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;someOtherId&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;ft&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Some other text&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;lang&quot;</span>,<span class="string">&quot;fr&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;dir&quot;</span>, <span class="string">&quot;rtl&quot;</span>); </span><br></pre></td></tr></table></figure>

<p><code>setAttribute()</code>适用于 <code>HTML</code> 属性，也适用于自定义属性。另外，使用 <code>setAttribute()</code>方法 设置的属性名会规范为小写形式，因此”ID”会变成”id”。</p>
<p>因为元素属性也是 <code>DOM</code> 对象属性，所以直接给 <code>DOM</code> 对象的属性赋值也可以设置元素属性的值， 如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;someOtherId&quot;</span>;</span><br><span class="line">div.<span class="property">align</span> = <span class="string">&quot;left&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>注意，在 <code>DOM</code> 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">mycolor</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;mycolor&quot;</span>)); <span class="comment">// null（IE 除外）</span></span><br></pre></td></tr></table></figure>

<p>这个例子添加了一个自定义属性 <code>mycolor</code> 并将其值设置为”red”。在多数浏览器中，这个属性不 会自动变成元素属性。因此调用 <code>getAttribute()</code>取得 <code>mycolor</code> 的值会返回 <code>null</code>。</p>
<p>最后一个方法 <code>removeAttribute()</code>用于从元素中删除属性。这样不单单是清除属性的值，而是会 把整个属性完全从元素中去掉，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">removeAttribute</span>(<span class="string">&quot;class&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法用得并不多，但在序列化 <code>DOM</code> 元素时可以通过它控制要包含的属性。</p>
</li>
<li><p>attributes属性</p>
<p><code>Element</code> 类型是唯一使用 <code>attributes</code> 属性的 <code>DOM</code> 节点类型。<code>attributes</code> 属性包含一个 <code>NamedNodeMap</code> 实例，是一个类似 <code>NodeList</code> 的“实时”集合。元素的每个属性都表示为一个 <code>Attr</code> 节 点，并保存在这个 <code>NamedNodeMap</code> 对象中。<code>NamedNodeMap</code> 对象包含下列方法：</p>
<ul>
<li><code>getNamedItem(name)</code>，返回 <code>nodeName</code> 属性等于 <code>name</code> 的节点；</li>
<li><code>removeNamedItem(name)</code>，删除 <code>nodeName</code> 属性等于 <code>name</code> 的节点；</li>
<li><code>setNamedItem(node)</code>，向列表中添加 <code>node</code> 节点，以其 <code>nodeName</code> 为索引；</li>
<li><code>item(pos)</code>，返回索引位置 <code>pos</code> 处的节点。</li>
</ul>
<p><code>attributes</code>属性中的每个节点的 <code>nodeName</code> 是对应属性的名字，<code>nodeValue</code> 是属性的值。比如， 要取得元素 id 属性的值，可以使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = element.<span class="property">attributes</span>.<span class="title function_">getNamedItem</span>(<span class="string">&quot;id&quot;</span>).<span class="property">nodeValue</span>;</span><br></pre></td></tr></table></figure>

<p>下面是使用中括号访问属性的简写形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = element.<span class="property">attributes</span>[<span class="string">&quot;id&quot;</span>].<span class="property">nodeValue</span>;</span><br></pre></td></tr></table></figure>

<p>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 <code>nodeValue</code> 设置为新值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">attributes</span>[<span class="string">&quot;id&quot;</span>].<span class="property">nodeValue</span> = <span class="string">&quot;someOtherId&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>removeNamedItem()</code>方法与元素上的 <code>removeAttribute()</code>方法类似，也是删除指定名字的属性。 下面的例子展示了这两个方法唯一的不同之处，就是<code>removeNamedItem()</code>返回表示被删除属性的<code>Attr</code> 节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldAttr = element.<span class="property">attributes</span>.<span class="title function_">removeNamedItem</span>(<span class="string">&quot;id&quot;</span>); </span><br></pre></td></tr></table></figure>

<p><code>setNamedItem()</code>方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">attributes</span>.<span class="title function_">setNamedItem</span>(newAttr); </span><br></pre></td></tr></table></figure>

<p>一般来说，因为使用起来更简便，通常开发者更喜欢使用 <code>getAttribute()</code>、<code>removeAttribute()</code> 和 <code>setAttribute()</code>方法，而不是刚刚介绍的 <code>NamedNodeMap</code> 对象的方法。</p>
<p><code>attributes</code> 属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 <code>DOM</code> 结构 序列化为 <code>XML</code> 或 <code>HTML</code> 字符串。比如，以下代码能够迭代一个元素上的所有属性并以 <code>attribute1= &quot;value1&quot; attribute2=&quot;value2&quot;</code>的形式生成格式化字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outputAttributes</span>(<span class="params">element</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> pairs = [];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = element.<span class="property">attributes</span>.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">     <span class="keyword">const</span> attribute = element.<span class="property">attributes</span>[i];</span><br><span class="line">     pairs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;attribute.nodeName&#125;</span>=&quot;<span class="subst">$&#123;attribute.nodeValue&#125;</span>&quot;`</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> pairs.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这个函数使用数组存储每个名&#x2F;值对，迭代完所有属性后，再将这些名&#x2F;值对用空格拼接在一起。（这 个技术常用于序列化为长字符串。）这个函数中的 <code>for</code> 循环使用 <code>attributes.length</code> 属性迭代每个属 性，将每个属性的名字和值输出为字符串。不同浏览器返回的 <code>attributes</code> 中的属性顺序也可能不一样。 <code>HTML</code> 或 <code>XML</code> 代码中属性出现的顺序不一定与 <code>attributes</code> 中的顺序一致。</p>
</li>
<li><p>创建元素</p>
<p>可以使用 <code>document.createElement()</code>方法创建新元素。这个方法接收一个参数，即要创建元素 的标签名。在 <code>HTML</code> 文档中，标签名是不区分大小写的，而 <code>XML</code> 文档（包括 <code>XHTML</code>）是区分大小写 的。要创建元素，可以使用下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>使用 <code>createElement()</code>方法创建新元素的同时也会将其 <code>ownerDocument</code> 属性设置为 <code>document</code>。 此时，可以再为其添加属性、添加更多子元素。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;myNewDiv&quot;</span>;</span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;box&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用 <code>appendChild()</code>、<code>insertBefore()</code>或<code> replaceChild()</code>。 比如，以下代码会把刚才创建的元素添加到文档的元素中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br></pre></td></tr></table></figure>

<p>元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。</p>
</li>
<li><p>元素后代</p>
<p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<code>childNodes</code> 属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在 识别这些节点时的表现有明显不同。比如下面的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>在解析以上代码时，<code>&lt;ul&gt;</code>元素会包含 7 个子元素，其中 3 个是<code>&lt;li&gt;</code>元素，还有 4 个 Text 节点（表示<code>&lt;li&gt;</code>元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有浏览器解析上面的代码后，<code>&lt;ul&gt;</code>元素都会包含 3 个子节点。考虑到这种情况，通常在执行某个 操作之后需要先检测一下节点的 <code>nodeType</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = element.<span class="property">childNodes</span>.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">     <span class="keyword">if</span> (element.<span class="property">childNodes</span>[i].<span class="property">nodeType</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行某个操作</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以上代码会遍历某个元素的子节点，并且只在 <code>nodeType</code> 等于 1（即 <code>Element</code> 节点）时执行某个操作。</p>
<p>要取得某个元素的子节点和其他后代节点，可以使用元素的 <code>getElementsByTagName()</code>方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面<code>&lt;ul&gt;</code>的例子，可以像下面这样取得其所有的<code>&lt;li&gt;</code>元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myList&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> items = ul.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里例子中的<code>&lt;ul&gt;</code>元素只有一级子节点，如果它包含更多层级，则所有层级中的<code>&lt;li&gt;</code>元素都会返回。</p>
</li>
</ol>
<h2 id="Text节点"><a href="#Text节点" class="headerlink" title="Text节点"></a>Text节点</h2><p><code>Text</code> 节点由 <code>Text</code> 类型表示，包含按字面解释的纯文本，也可能包含转义后的 <code>HTML</code> 字符，但不含 <code>HTML</code> 代码。<code>Text</code> 类型的节点具有以下特征：</p>
<ul>
<li><code>nodeType</code> 等于 3；</li>
<li><code>nodeName</code> 值为”#text”；</li>
<li><code>nodeValue </code>值为节点中包含的文本；</li>
<li><code>parentNode</code> 值为 <code>Element</code> 对象；</li>
<li>不支持子节点。</li>
</ul>
<p><code>Text</code> 节点中包含的文本可以通过 <code>nodeValue</code> 属性访问，也可以通过 <code>data</code> 属性访问，这两个属性包含相同的值。修改 <code>nodeValue</code> 或 <code>data</code> 的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：</p>
<ul>
<li><code>appendData(text)</code>，向节点末尾添加文本 <code>text</code>；</li>
<li><code>deleteData(offset, count)</code>，从位置 <code>offset</code> 开始删除 <code>count</code> 个字符；</li>
<li><code>insertData(offset, text)</code>，在位置 <code>offset</code> 插入 <code>text</code>；</li>
<li><code>replaceData(offset, count, text)</code>，用 <code>text</code> 替换从位置 <code>offset</code> 到 <code>offset + count</code> 的 文本；</li>
<li><code>splitText(offset)</code>，在位置 <code>offset</code> 将当前文本节点拆分为两个文本节点；</li>
<li><code>substringData(offset, count)</code>，提取从位置 <code>offset</code> 到 <code>offset + count</code> 的文本。</li>
</ul>
<p>除了这些方法，还可以通过 <code>length</code> 属性获取文本节点中包含的字符数量。这个值等于 <code>nodeValue. length</code> 和 <code>data.length</code>。</p>
<p>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有内容，因此没有文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有空格，因此有一个文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有内容，因此有一个文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例中的第一个<code>&lt;div</code>&gt;元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个<code>&lt;div</code>&gt;元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的 <code>nodeValue</code> 就是一个空格。第三个<code>&lt;div</code>&gt;元素也有一个文本节点的子节点，其<code>nodeValue</code> 的值为”Hello World!”。下列代码可以用来访问这个文本节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = div.<span class="property">firstChild</span>; <span class="comment">// 或 div.childNodes[0]</span></span><br></pre></td></tr></table></figure>

<p>取得文本节点的引用后，可以像这样来修改它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> = <span class="string">&quot;Some other message&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是 <code>HTML</code> 或 <code>XML</code> 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot;</span></span><br><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> = <span class="string">&quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这实际上是在将 <code>HTML</code> 字符串插入 <code>DOM</code> 文档前进行编码的有效方式。</p>
<ol>
<li><p>创建文本节点</p>
<p><code>document.createTextNode()</code>可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。 跟设置已有文本节点的值一样，这些要插入的文本也会应用 <code>HTML</code> 或 <code>XML</code> 编码，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>创建新文本节点后，其 <code>ownerDocument</code> 属性会被设置为 <code>document</code>。但在把这个节点添加到文档 树之前，我们不会在浏览器中看到它。以下代码创建了一个元素并给它添加了一段文本消息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br></pre></td></tr></table></figure>

<p>这个例子首先创建了一个<code>&lt;div&gt;</code>元素并给它添加了值为”message”的 <code>class</code> 属性，然后又创建了 一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</p>
<p>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element); </span><br></pre></td></tr></table></figure>

<p><strong>在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。</strong></p>
</li>
<li><p>规范化文本节点</p>
<p><code>DOM</code> 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，<code> DOM</code> 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法 叫 <code>normalize()</code>，是在 <code>Node</code> 类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用 <code>normalize()</code>时，所有同胞文本节点会被合并为一个文本节点，这个 文本节点的 <code>nodeValue</code> 就等于之前所有同胞节点 <code>nodeValue</code> 拼接在一起得到的字符串。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">element.<span class="title function_">normalize</span>();</span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello world!Yippee!&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 <code>DOM</code> 脚本生成的文档树中。</strong></p>
</li>
<li><p>拆分文本节点</p>
<p><code>Text</code> 类型定义了一个与 <code>normalize()</code>相反的方法——<code>splitText()</code>。这个方法可以在指定的偏移位置拆分 <code>nodeValue</code>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到 偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点 相同的 <code>parentNode</code>。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newNode = element.<span class="property">firstChild</span>.<span class="title function_">splitText</span>(<span class="number">5</span>);</span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(newNode.<span class="property">nodeValue</span>); <span class="comment">// &quot; world!&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，包含”Hello world!”的文本节点被从位置 5 拆分成两个文本节点。位置 5 对应 “Hello”和”world!”之间的空格，因此原始文本节点包含字符串”Hello”，而新文本节点包含文本” world!”（包含空格）。</p>
<p><strong>拆分文本节点最常用于从文本节点中提取数据的 <code>DOM</code> 解析技术。</strong></p>
</li>
</ol>
<h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p><code>DOM</code> 中的注释通过<code>Comment</code>类型表示。<code>Comment</code>类型的节点具有以下特征：</p>
<ul>
<li><code>nodeType</code>等于8</li>
<li><code>nodeName</code>值为”#comment”；</li>
<li><code>nodeValue</code> 值为注释的内容；</li>
<li><code>parentNode</code> 值为 <code>Document</code> 或 <code>Element</code> 对象；</li>
<li>不支持子节点。</li>
</ul>
<p><code>Comment</code> 类型与 <code>Text</code> 类型继承同一个基类（<code>CharacterData</code>），因此拥有除 <code>splitText()</code>之外 <code>Text</code> 节点所有的字符串操作方法。与 <code>Text</code> 类型相似，注释的实际内容可以通过 <code>nodeValue</code> 或 <code>data</code> 属性获得。</p>
<p>注释节点可以作为父节点的子节点来访问。比如下面的 <code>HTML</code> 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="comment">&lt;!-- A comment --&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的注释是<code>&lt;div&gt;</code>元素的子节点，这意味着可以像下面这样访问它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> comment = div.<span class="property">firstChild</span>;</span><br><span class="line"><span class="title function_">alert</span>(comment.<span class="property">data</span>); <span class="comment">// &quot;A comment&quot;</span></span><br></pre></td></tr></table></figure>





<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><p>很多时候，操作 <code>DOM</code> 是很直观的。通过 <code>HTML</code> 代码能实现的，也一样能通过 <code>JavaScript</code> 实现。但 有时候，<code>DOM</code> 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 <code>DOM</code> 的某些方面会复杂一些。</p>
<h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><p><code>&lt;script&gt;</code>元素用于向网页中插入 <code>JavaScript</code> 代码，可以是 <code>src</code> 属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 <code>DOM</code> 包含的脚本。与对应的 <code>HTML</code> 元素一样，有两种方式通过<code>&lt;script&gt;</code>动态为网页添加脚本：引入外部文件和直接插入源代码。</p>
<p>动态加载外部文件很容易实现，比如下面的<code>&lt;script&gt;</code>元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;foo.js&quot;</span>&gt;&lt;/script&gt; </span><br></pre></td></tr></table></figure>

<p>可以像这样通过 <code>DOM</code> 编程创建这个节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;foo.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>DOM</code> 代码实际上完全照搬了它要表示的 <code>HTML</code> 代码。注意，在上面最后一行把<code>&lt;script&gt;</code>元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到<code>&lt;head&gt;</code>元素，同样可以实 现动态脚本加载。这个过程可以抽象为一个函数，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">url</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">     script.<span class="property">src</span> = url;</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就可以像下面这样加载外部 <code>JavaScript</code> 文件了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadScript</span>(<span class="string">&quot;client.js&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>加载之后，这个脚本就可以对页面执行操作了。这里有个问题：怎么能知道脚本什么时候加载完？ 这个问题并没有标准答案，具体情况取决于使用的浏览器。</p>
<p>另一个动态插入 <code>JavaScript</code> 的方式是嵌入源代码，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"> 	<span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>); </span></span><br><span class="line"><span class="language-javascript"> &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>DOM</code>，可以实现以下逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>));</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script); </span><br></pre></td></tr></table></figure>

<p>以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在 全局作用域中把源代码传给 <code>eval()</code>方法。</p>
<p>注意，通过 <code>innerHTML</code> 属性创建的<code>&lt;script&gt;</code>元素永远不会执行。浏览器会尽责地创建<code>script</code>元素，以及其中的脚本文本，但解析器会给这个<code>&lt;script&gt;</code>元素打上永不执行的标签。只要是使用 <code>innerHTML</code> 创建的<code>&lt;script&gt;</code>元素，以后也没有办法强制其执行。</p>
<h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p><code>CSS</code> 样式在 <code>HTML</code>页面中可以通过两个元素加载。元素用于包含 <code>CSS</code> 外部文件，而<code>&lt;style&gt;</code>元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。</p>
<p>来看下面这个典型的<code>&lt;link&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个元素很容易使用 <code>DOM</code> 编程创建出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">link.<span class="property">href</span> = <span class="string">&quot;styles.css&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(link); </span><br></pre></td></tr></table></figure>

<p>以上代码在所有主流浏览器中都能正常运行。注意应该把<code>&lt;link&gt;</code>元素添加到<code>&lt;head&gt;</code>元素而不是<code>&lt;body&gt;</code>元素，这样才能保证所有浏览器都能正常运行。这个过程可以抽象为以下通用函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadStyles</span>(<span class="params">url</span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line"> link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line"> link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line"> link.<span class="property">href</span> = url;</span><br><span class="line"> <span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"> head.<span class="title function_">appendChild</span>(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以这样调用这个 <code>loadStyles()</code>函数了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadStyles</span>(<span class="string">&quot;styles.css&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 <code>JavaScript</code> 代码并没有先后 顺序。一般来说，也没有必要知道样式什么时候加载完成。</p>
<p>另一种定义样式的方式是使用<code>&lt;script&gt;</code>元素包含嵌入的 <code>CSS</code> 规则，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">     	<span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>逻辑上，下列 <code>DOM</code> 代码会有同样的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">style.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">style.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(style); </span><br></pre></td></tr></table></figure>



<h2 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h2><p>表格是 <code>HTML</code> 中最复杂的结构之一。通过 <code>DOM</code> 编程创建<code>&lt;table&gt;</code>元素，通常要涉及大量标签，包 括表行、表元、表题，等等。因此，通过 <code>DOM</code> 编程创建和修改表格时可能要写很多代码。假设要通过 <code>DOM</code> 来创建以下 <code>HTML </code>表格：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面就是以 <code>DOM</code> 编程方式重建这个表格的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>;</span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>);</span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"><span class="keyword">let</span> row1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row1);</span><br><span class="line"><span class="keyword">let</span> cell1_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell1_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell1_1);</span><br><span class="line"><span class="keyword">let</span> cell2_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell2_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell2_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line"><span class="keyword">let</span> row2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row2);</span><br><span class="line"><span class="keyword">let</span> cell1_2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell1_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>));</span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell1_2);</span><br><span class="line"><span class="keyword">let</span> cell2_2= <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell2_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>));</span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell2_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure>

<p>以上代码相当烦琐，也不好理解。为了方便创建表格，<code>HTML</code> <code>DOM</code> 给<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tr&gt;</code>元素添加了一些属性和方法。</p>
<p><code>&lt;table&gt;</code>&gt;元素添加了以下属性和方法：</p>
<ul>
<li><code>caption</code>，指向&#96;&#96;<caption>&#96;元素的指针（如果存在）</li>
<li><code>tBodies</code>，包含<code>&lt;tbody&gt;</code>元素的 <code>HTMLCollection</code>；</li>
<li><code>tFoot</code>，指向<code>&lt;tfoot&gt;</code>元素（如果存在）</li>
<li><code>tHead</code>，指向<code>&lt;thead&gt;</code>元素（如果存在）</li>
<li><code>rows</code>，包含表示所有行的 <code>HTMLCollection</code>；</li>
<li><code>createTHead()</code>，创建<code>&lt;thead&gt;</code>元素，放到表格中，返回引用；</li>
<li><code>createTFoot()</code>，创建<code>&lt;tfoot&gt;</code>元素，放到表格中，返回引用；</li>
<li><code>createCaption()</code>，创建<code>&lt;caption&gt;</code>元素，放到表格中，返回引用；</li>
<li><code>deleteTHead()</code>，删除<code>&lt;thead&gt;</code>元素；</li>
<li><code>deleteTFoot()</code>，删除<code>&lt;tfoot&gt;</code>元素；</li>
<li><code>deleteCaption()</code>，删除<code>&lt;caption&gt;</code>元素；</li>
<li><code>deleteRow(pos)</code>，删除给定位置的行；</li>
<li><code>insertRow(pos)</code>，在行集合中给定位置插入一行。</li>
</ul>
<p><code>&lt;tbody&gt;</code>元素添加了以下属性和方法：</p>
<ul>
<li><code>rows</code>，包含<code>&lt;tbody&gt;</code>元素中所有行的 <code>HTMLCollection</code>；</li>
<li><code>deleteRow(pos)</code>，删除给定位置的行；</li>
<li><code>insertRow(pos)</code>，在行集合中给定位置插入一行，返回该行的引用。</li>
</ul>
<p><code>&lt;tr&gt;</code>元素添加了以下属性和方法：</p>
<ul>
<li><code>cells</code>，包含<code>&lt;tr&gt;</code>元素所有表元的 <code>HTMLCollection</code>；</li>
<li><code>deleteCell(pos)</code>，删除给定位置的表元；</li>
<li><code>insertCell(pos)</code>，在表元集合给定位置插入一个表元，返回该表元的引用。</li>
</ul>
<p>这些属性和方法极大地减少了创建表格所需的代码量。例如，使用这些方法重写前面的代码之后是 这样的（加粗代码表示更新的部分）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>;</span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>);</span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line">tbody.<span class="title function_">insertRow</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="title function_">insertCell</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">0</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>));</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="title function_">insertCell</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.<span class="title function_">insertRow</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="title function_">insertCell</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="property">cells</span>[<span class="number">0</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>));</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="title function_">insertCell</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure>

<p>这里创建<code>&lt;table&gt;</code>和<code>&lt;tbody&gt;</code>元素的代码没有变。变化的是创建两行的部分，这次使用了 <code>HTML DOM</code> 表格的属性和方法。创建第一行时，在<code>&lt;tbody&gt;</code>元素上调用了 <code>insertRow()</code>方法。传入参数 0， 表示把这一行放在什么位置。然后，使用 <code>tbody.rows[0]</code>来引用这一行，因为这一行刚刚创建并被添 加到了<code>&lt;tbody&gt;</code>的位置 0。</p>
<p>创建表元的方式也与之类似。在<code>&lt;tr&gt;</code>元素上调用 <code>insertCell()</code>方法，传入参数 0，表示把这个表元放在什么位置上。然后，使用 <code>tbody.rows[0].cells[0]</code>来引用这个表元，因为这个表元刚刚创建 并被添加到了<code>&lt;tr&gt;</code>的位置 0。</p>
<p>虽然以上两种代码在技术上都是正确的，但使用这些属性和方法创建表格让代码变得更有逻辑性， 也更容易理解。</p>
<h2 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h2><p>理解 <code>NodeList</code> 对象和相关的 <code>NamedNodeMap</code>、<code>HTMLCollection</code>，是理解 <code>DOM</code> 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，<code>NodeList</code> 就是基于 <code>DOM</code> 文档的实时查询。例如，下面的代码会导致无穷循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i)&#123;</span><br><span class="line">     <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>使用 <code>ES6</code> 迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导 致无穷循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>))&#123;</span><br><span class="line"> <span class="keyword">let</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDiv);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>任何时候要迭代 <code>NodeList</code>，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这 个变量进行比较，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = divs.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line"> <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这个例子中，又初始化了一个保存集合长度的变量 <code>len</code>。因为 <code>len</code> 保存着循环开始时集合的长度， 而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。本章还会使用这种技术来演示迭代 <code>NodeList</code> 对象的首选方式。</p>
<p>另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = divs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"> <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，最好限制操作 <code>NodeList</code> 的次数。因为每次查询都会搜索整个文档，所以最好把查询到 的 <code>NodeList</code> 缓存起来。</p>
<h1 id="MutationObserver接口"><a href="#MutationObserver接口" class="headerlink" title="MutationObserver接口"></a>MutationObserver接口</h1><p>不久前添加到 <code>DOM</code> 规范中的 <code>MutationObserver</code> 接口，可以在 <code>DOM</code> 被修改时异步执行回调。使 用 <code>MutationObserver</code> 可以观察整个文档、<code>DOM</code> 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>MutationObserver</code> 的实例要通过调用 <code>MutationObserver</code> 构造函数并传入一个回调函数来创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM was mutated!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li><p>observe()方法</p>
<p>新创建的 <code>MutationObserver</code> 实例不会关联 <code>DOM</code> 的任何部分。要把这个 <code>observer</code> 与 <code>DOM</code> 关 联起来，需要使用 <code>observe()</code>方法。这个方法接收两个必需的参数：要观察其变化的 <code>DOM</code> 节点，以及 一个 <code>MutationObserverInit</code> 对象。</p>
<p><code>MutationObserverInit</code> 对象用于控制观察哪些方面的变化，是一个键&#x2F;值对形式配置选项的字典。 例如，下面的代码会创建一个观察者（<code>observer</code>）并配置它观察元素上的属性变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br></pre></td></tr></table></figure>

<p>执行以上代码后，<code>&lt;body&gt;</code>元素上任何属性发生变化都会被这个 <code>MutationObserver</code> 实例发现，然 后就会异步执行注册的回调函数。元素后代的修改或其他非属性修改都不会触发回调进入任务 队列。可以通过以下代码来验证：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Changed body class&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Changed body class</span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure>

<p>注意，回调中的<code>console.log()</code>是后执行的。这表明回调并非与实际的 <code>DOM</code> 变化同步执行。</p>
</li>
<li><p>回调与<code>MutationRecord</code></p>
<p>每个回调都会收到一个 <code>MutationRecord</code> 实例的数组。<code>MutationRecord </code>实例包含的信息包括发 生了什么变化，以及 <code>DOM</code> 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 <code>MutationRecord</code> 实例的数组。</p>
<p>下面展示了反映一个属性变化的 <code>MutationRecord</code> 实例的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"> 	</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 	&#123;</span></span><br><span class="line"><span class="comment">// 		addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// 		attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// 		attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// 		nextSibling: null,</span></span><br><span class="line"><span class="comment">// 		oldValue: null,</span></span><br><span class="line"><span class="comment">// 		previousSibling: null</span></span><br><span class="line"><span class="comment">// 		removedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// 		target: body</span></span><br><span class="line"><span class="comment">// 		type: &quot;attributes&quot;</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure>

<p>下面是一次涉及命名空间的类似变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttributeNS</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 	&#123;</span></span><br><span class="line"><span class="comment">// 		addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// 		attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// 		attributeNamespace: &quot;baz&quot;,</span></span><br><span class="line"><span class="comment">// 		nextSibling: null,</span></span><br><span class="line"><span class="comment">// 		oldValue: null,</span></span><br><span class="line"><span class="comment">// 		previousSibling: null</span></span><br><span class="line"><span class="comment">// 		removedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// 		target: body</span></span><br><span class="line"><span class="comment">// 		type: &quot;attributes&quot;</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure>

<p>连续修改会生成多个 <code>MutationRecord</code> 实例，下次回调执行时就会收到包含所有这些实例的数组， 顺序为变化事件发生的顺序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>下表列出了 <code>MutationRecord</code> 实例的属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>被修改影响的目标节点</td>
</tr>
<tr>
<td>type</td>
<td>字符串，表示变化的类型：”attributes”、”characterData”或”childList”</td>
</tr>
<tr>
<td>oldValue</td>
<td>如果在 MutationObserverInit 对象中启用（attributeOldValue 或 characterData OldValue 为 true），”attributes”或”characterData”的变化事件会设置这个属性为被替代的值 “childList”类型的变化始终将这个属性设置为 null</td>
</tr>
<tr>
<td>attributeName</td>
<td>对于”attributes”类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null</td>
</tr>
<tr>
<td>attributeNamespace</td>
<td>对于使用了命名空间的”attributes”类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null</td>
</tr>
<tr>
<td>addedNodes</td>
<td>对于”childList”类型的变化，返回包含变化中添加节点的 NodeList 默认为空 NodeList</td>
</tr>
<tr>
<td>removedNodes</td>
<td>对于”childList”类型的变化，返回包含变化中删除节点的 NodeList 默认为空 NodeList</td>
</tr>
<tr>
<td>previousSibling</td>
<td>对于”childList”类型的变化，返回变化节点的前一个同胞 Node 默认为 null</td>
</tr>
<tr>
<td>nextSibling</td>
<td>对于”childList”类型的变化，返回变化节点的后一个同胞 Node 默认为 null</td>
</tr>
</tbody></table>
<p>传给回调函数的第二个参数是观察变化的 <code>MutationObserver</code> 的实例，演示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords, mutationObserver</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords,</span><br><span class="line">mutationObserver));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="comment">// [MutationRecord], MutationObserver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>disconnect()</code>方法</p>
<p>默认情况下，只要被观察的元素不被垃圾回收，<code>MutationObserver</code> 的回调就会响应 <code>DOM</code> 变化事 件，从而被执行。要提前终止执行回调，可以调用 <code>disconnect()</code>方法。下面的例子演示了同步调用 <code>disconnect()</code>之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（没有日志输出）</span></span><br></pre></td></tr></table></figure>

<p>要想让已经加入任务队列的回调执行，可以使用 <code>setTimeout()</code>让已经入列的回调执行完毕再调用 <code>disconnect()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     observer.<span class="title function_">disconnect</span>();</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复用 <code>MutationObserver</code></p>
<p>多次调用 <code>observe()</code>方法，可以复用一个 <code>MutationObserver</code> 对象观察多个不同的目标节点。此 时，<code>MutationRecord</code> 的 <code>target</code> 属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">x.<span class="property">target</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line"> 	childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;span&gt;]</span></span><br></pre></td></tr></table></figure>

<p><code>disconnect()</code>方法是一个“一刀切”的方案，调用它会停止观察所有目标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">x.<span class="property">target</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">	 childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （没有日志输出）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重用 <code>MutationObserver</code></p>
<p>调用 <code>disconnect()</code>并不会结束 <code>MutationObserver</code> 的生命。还可以重新使用这个观察者，再将 它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与元素的关联：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes</span></span><br><span class="line"><span class="string">changed&#x27;</span>));</span><br><span class="line">                                                      </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     observer.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这行代码不会触发变化事件</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// Reattach</span></span><br><span class="line">     observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MutationObserverInit-与观察范围"><a href="#MutationObserverInit-与观察范围" class="headerlink" title="MutationObserverInit 与观察范围"></a><code>MutationObserverInit</code> 与观察范围</h2><p><code>MutationObserverInit</code> 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p>
<p>下表列出了 <code>MutationObserverInit</code> 对象的属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>subtree</td>
<td>布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是 <code>false</code>，则只观察目标节点的变化；如果是 <code>true</code>，则观察目标节点及其整个子树 默认为 <code>false</code></td>
</tr>
<tr>
<td>attributes</td>
<td>布尔值，表示是否观察目标节点的属性变化 默认为 false</td>
</tr>
<tr>
<td><code>attributeFilter</code></td>
<td>字符串数组，表示要观察哪些属性的变化 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为观察所有属性</td>
</tr>
<tr>
<td><code>attributeOldValue</code></td>
<td>布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的属性值 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为 false</td>
</tr>
<tr>
<td><code>characterData</code></td>
<td>布尔值，表示修改字符数据是否触发变化事件 默认为 false</td>
</tr>
<tr>
<td><code>characterDataOldValue</code></td>
<td>布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的字符数据 把这个值设置为 true 也会将 <code>characterData</code> 的值转换为 true 默认为 false</td>
</tr>
<tr>
<td><code>childList</code></td>
<td>布尔值，表示修改目标节点的子节点是否触发变化事件 默认为 <code>false</code></td>
</tr>
</tbody></table>
<p>在调用 <code>observe()</code>时，<code>MutationObserverInit</code> 对象中的 <code>attribute</code>、<code>characterData</code> 和 <code>childList</code> 属性必须至少有一项为 true（无论是直接设置这几个属性，还是通过设置 <code>attributeOldValue</code> 等属性间接导致它们的值转换为 <code>true</code>）。否则会抛出错误，因为没有任何变化事件可能触发回调。</p>
<ol>
<li><p>观察属性</p>
<p><code>MutationObserver</code> 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 <code>MutationObserverInit</code> 对象中将 <code>attributes</code> 属性设置为 true，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>把 <code>attributes</code> 设置为 true 的默认行为是观察所有属性，但不会在 <code>MutationRecord</code> 对象中记 录原来的属性值。如果想观察某个或某几个属性，可以使用 <code>attributeFilter</code> 属性来设置白名单，即 一个属性名字符串数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeFilter</span>: [<span class="string">&#x27;foo&#x27;</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加白名单属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加被排除的属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有 foo 属性的变化被记录了</span></span><br><span class="line"><span class="comment">// [MutationRecord] </span></span><br></pre></td></tr></table></figure>

<p>如果想在变化记录中保存属性原来的值，可以将 <code>attributeOldValue</code> 属性设置为 true：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>)));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeOldValue</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [null, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>观察字符数据</p>
<p><code>MutationObserver</code> 可以观察文本节点（如 <code>Text</code>、<code>Comment</code>或 <code>ProcessingInstruction</code> 节点） 中字符的添加、删除和修改。要为字符数据注册回调，需要在 <code>MutationObserverInit</code>对象中将 <code>characterData</code> 属性设置为 true，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要观察的文本节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值为相同的字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值为新字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过节点设置函数赋值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>将 <code>characterData</code> 属性设置为 true 的默认行为不会在 <code>MutationRecord</code> 对象中记录原来的字符 数据。如果想在变化记录中保存原来的字符数据，可以将 <code>characterDataOldValue</code> 属性设置为 true：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>)));</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterDataOldValue</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>观察子节点</p>
<p><code>MutationObserver</code> 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 <code>MutationObserverInit</code> 对象中将 <code>childList</code> 属性设置为 true。</p>
<p>下面的例子演示了添加子节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 	&#123;</span></span><br><span class="line"><span class="comment">// 		addedNodes: NodeList[div],</span></span><br><span class="line"><span class="comment">// 		attributeName: null,</span></span><br><span class="line"><span class="comment">// 		attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// 		oldValue: null,</span></span><br><span class="line"><span class="comment">// 		nextSibling: null,</span></span><br><span class="line"><span class="comment">// 		previousSibling: null,</span></span><br><span class="line"><span class="comment">// 		removedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// 		target: body,</span></span><br><span class="line"><span class="comment">// 		type: &quot;childList&quot;,</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>下面的例子演示了移除子节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> 	<span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"> 	</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 	&#123;</span></span><br><span class="line"><span class="comment">// 		addedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// 		attributeName: null,</span></span><br><span class="line"><span class="comment">// 		attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// 		oldValue: null,</span></span><br><span class="line"><span class="comment">// 		nextSibling: null,</span></span><br><span class="line"><span class="comment">// 		previousSibling: null,</span></span><br><span class="line"><span class="comment">// 		removedNodes: NodeList[div],</span></span><br><span class="line"><span class="comment">// 		target: body,</span></span><br><span class="line"><span class="comment">// 		type: &quot;childList&quot;,</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure>

<p>对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移 除和再添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个初始子节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换子节点顺序</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">lastChild</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生了两次变化：第一次是节点被移除，第二次是节点被添加</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 	&#123;</span></span><br><span class="line"><span class="comment">// 		addedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// 		attributeName: null,</span></span><br><span class="line"><span class="comment">// 		attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// 		oldValue: null,</span></span><br><span class="line"><span class="comment">// 		nextSibling: null,</span></span><br><span class="line"><span class="comment">// 		previousSibling: div,</span></span><br><span class="line"><span class="comment">// 		removedNodes: NodeList[span],</span></span><br><span class="line"><span class="comment">// 		target: body,</span></span><br><span class="line"><span class="comment">// 		type: childList,</span></span><br><span class="line"><span class="comment">// 	&#125;,</span></span><br><span class="line"><span class="comment">// 	&#123;</span></span><br><span class="line"><span class="comment">// 		addedNodes: NodeList[span],</span></span><br><span class="line"><span class="comment">// 		attributeName: null,</span></span><br><span class="line"><span class="comment">// 		attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// 		oldValue: null,</span></span><br><span class="line"><span class="comment">// 		nextSibling: div,</span></span><br><span class="line"><span class="comment">// 		previousSibling: null,</span></span><br><span class="line"><span class="comment">// 		removedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// 		target: body,</span></span><br><span class="line"><span class="comment">// 		type: &quot;childList&quot;,</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>观察子树</p>
<p>默认情况下，<code>MutationObserver</code> 将观察的范围限定为一个元素及其子节点的变化。可以把观察 的范围扩展到这个元素的子树（所有后代节点），这需要在 <code>MutationObserverInit</code> 对象中将 <code>subtree</code> 属性设置为 true。</p>
<p>下面的代码展示了观察元素及其后代节点属性的变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"><span class="comment">// 创建一个后代</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察&lt;body&gt;元素及其子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// 修改&lt;body&gt;元素的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// 记录了子树变化的事件</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 		&#123;</span></span><br><span class="line"><span class="comment">// 			addedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// 			attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// 			attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// 			oldValue: null,</span></span><br><span class="line"><span class="comment">// 			nextSibling: null,</span></span><br><span class="line"><span class="comment">// 			previousSibling: null,</span></span><br><span class="line"><span class="comment">// 			removedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// 			target: div,</span></span><br><span class="line"><span class="comment">// 			type: &quot;attributes&quot;,</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure>

<p>有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</p>
<p>下面的代码演示了这种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subtreeRoot = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line"> 	subtreeLeaf = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建包含两层的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(subtreeRoot);</span><br><span class="line">subtreeRoot.<span class="title function_">appendChild</span>(subtreeLeaf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(subtreeRoot, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把节点转移到其他子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(subtreeLeaf, subtreeRoot);</span><br><span class="line"></span><br><span class="line">subtreeLeaf.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移出的节点仍然触发变化事件</span></span><br><span class="line"><span class="comment">// [MutationRecord]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="异步回调与记录队列"><a href="#异步回调与记录队列" class="headerlink" title="异步回调与记录队列"></a>异步回调与记录队列</h2><p><code>MutationObserver</code> 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在 大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 <code>MutationRecord</code> 实例中，然后添加到记录队列。这个队列对每个 <code>MutationObserver</code> 实例都是唯一的，是所有 DOM 变化事件的有序列表。</p>
<ol>
<li><p>记录队列</p>
<p>每次 <code>MutationRecord</code> 被添加到 <code>MutationObserver</code> 的记录队列时，仅当之前没有已排期的微任 务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 <code>MutationObserver</code> 时传入） 作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。 不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一 个 <code>MutationRecord</code> 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一 个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 <code>MutationRecord</code> 就用不着了， 因此记录队列会被清空，其内容会被丢弃。</p>
</li>
<li><p>takeRecords()方法</p>
<p>调用 <code>MutationObserver</code> 实例的 <code>takeRecords()</code>方法可以清空记录队列，取出并返回其中的所 有 <code>MutationRecord</code> 实例。看这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">	 <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br><span class="line"><span class="comment">// [] </span></span><br></pre></td></tr></table></figure>

<p>这在希望断开与观察目标的联系，但又希望处理由于调用 <code>disconnect()</code>而被抛弃的记录队列中的 <code>MutationRecord</code> 实例时比较有用。</p>
</li>
</ol>
<h2 id="性能、内存与垃圾回收"><a href="#性能、内存与垃圾回收" class="headerlink" title="性能、内存与垃圾回收"></a>性能、内存与垃圾回收</h2><p>DOM Level 2 规范中描述的 <code>MutationEvent</code> 定义了一组会在各种 <code>DOM</code> 变化时触发的事件。由于 浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。 <code>MutationObserver</code> 接口就是为替代这些事件而设计的更实用、性能更好的方案。</p>
<p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 <code>MutationObserver</code> 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p>
<p>无论如何，使用 <code>MutationObserver</code> 仍然不是没有代价的。因此理解什么时候避免出现这种情况就很重要了。</p>
<ol>
<li><p><code>MutationObserver</code> 的引用</p>
<p><code>MutationObserver</code> 实例与目标节点之间的引用关系是非对称的。<code>MutationObserver</code> 拥有对要 观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p>
<p>然而，目标节点却拥有对 <code>MutationObserver</code> 的强引用。如果目标节点从 <code>DOM</code> 中被移除，随后 被垃圾回收，则关联的 <code>MutationObserver</code> 也会被垃圾回收。</p>
</li>
<li><p><code>MutationRecord</code> 的引用</p>
</li>
</ol>
<p>   记录队列中的每个 <code>MutationRecord</code> 实例至少包含对已有 <code>DOM</code> 节点的一个引用。如果变化是 <code>childList</code> 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理 每个 <code>MutationRecord</code>，然后让它们超出作用域并被垃圾回收。</p>
<p>   有时候可能需要保存某个观察者的完整变化记录。保存这些 <code>MutationRecord</code> 实例，也就会保存 它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 <code>MutationRecord</code> 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 <code>MutationRecord</code>。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/" title="JS高级程序设计读书笔记(11)——DOM" target="_blank" rel="external">http://pvnk1u.github.io/2023/04/17/JS高级程序设计读书笔记(11)——DOM/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/pvnk1u" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/dog.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/pvnk1u" target="_blank"><span class="text-dark">Yolo</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>Everything happens for the best</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/05/11/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(12)%E2%80%94%E2%80%94DOM%E6%89%A9%E5%B1%95/" title="JS高级程序设计读书笔记(12)——DOM扩展"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/04/16/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(10)%E2%80%94%E2%80%94BOM/" title="JS高级程序设计读书笔记(10)——BOM"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/pvnk1u" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2024 pvnk1u
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
    <script defer>
    var disqus_config = function () {
        
            this.page.url = 'http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/';
        
        this.page.identifier = 'JS高级程序设计读书笔记(11)——DOM';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + '' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>








</body>
</html>