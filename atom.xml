<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YOLO</title>
  
  
  <link href="http://pvnk1u.github.io/atom.xml" rel="self"/>
  
  <link href="http://pvnk1u.github.io/"/>
  <updated>2024-01-18T16:01:09.230Z</updated>
  <id>http://pvnk1u.github.io/</id>
  
  <author>
    <name>pvnk1u</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UdemyHtmlCss学习笔记——代码</title>
    <link href="http://pvnk1u.github.io/2023/11/21/UdemyHtmlCss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://pvnk1u.github.io/2023/11/21/UdemyHtmlCss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-11-21T07:32:39.000Z</published>
    <updated>2024-01-18T16:01:09.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h1><ol><li>使用<code>strong</code>元素取代<code>b</code>元素进行加粗显示</li><li>使用<code>em</code>元素取代<code>i</code>元素进行斜体显示</li></ol><h2 id="语义化元素"><a href="#语义化元素" class="headerlink" title="语义化元素"></a>语义化元素</h2><ul><li><strong>header</strong></li><li><strong>nav</strong></li><li><strong>section</strong></li><li><strong>article</strong></li><li><strong>aside</strong></li><li><strong>figcaption</strong></li><li><strong>figure</strong></li><li><strong>footer</strong></li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="默认样式"><a href="#默认样式" class="headerlink" title="默认样式"></a>默认样式</h2><p>很多HTML元素本身都带有默认样式，默认样式定义在<code>用户代理样式表(user agent stylesheet)</code>中。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><code>font-family</code>为<code>sans-serif</code>代表无衬线字体，<code>serif</code>代表有衬线字体，有无沉陷的区别体现在文字的边角上是否有相应多出来的边缘线。无衬线字体更加简洁现代。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ol><li><p>后代选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Id、Class选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#name</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通用选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通用选择器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际上，通用选择器是非常有用的，因为很多HTML元素都具有默认样式，如margin、padding等属性都有默认值。此时，为了方便对页面元素进行排版，便可以使用通用选择器直接指定所有元素的margin、padding值为0，这样后续开发时，HTML元素便不会受到默认样式的影响，因为通用选择器的优先级很低，可以很容易地被其他选择器设置的样式覆盖。</strong></p></li></ol><h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>在<code>CSS</code>中可以通过<code>height</code>和<code>width</code>设置元素的高度和宽度。</p><p>对图像设置尺寸时，需要注意宽高度需要和原图片的宽高度保持一致，否则图片将会失真，可以在对宽高度中的其中一个进行了设置后，对另外一个属性使用<code>auto</code>属性自动适应。另外，如果使用百分比(如50%)设置元素宽度时，意味着元素的宽度将会是元素所在父元素的一半宽度，这对于<code>响应式</code>非常有用。</p><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>每种颜色都可以通过<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>三种颜色的组合来呈现，这就是RGB颜色表示法。这三种基础颜色的取值范围可以从0~255不等，也就是说可以通过这三种基础颜色的组合呈现出一千六百多万种颜色。</p><p>当<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>三种颜色中的的某一个值分别为最大值，而另外两个值为0时，则呈现出纯粹的对应颜色。</p><p><img src="https://cdn.britannica.com/89/234589-050-0E6E9D4B/color-wheel-additive.jpg?w=400&h=300&c=crop" alt="RGB"></p><h3 id="CSS颜色表示法"><a href="#CSS颜色表示法" class="headerlink" title="CSS颜色表示法"></a>CSS颜色表示法</h3><p>在CSS中有两种颜色表示法：</p><ol><li><p>RGB&#x2F;RGBA表示法</p><p>通过使用<code>RGB</code>函数指定颜色，例如<code>rgb(0,255,255)</code>。</p><p>当需要指定颜色透明度的时候可以使用<code>RGBA</code>,<code>A</code>代表<code>Alpha</code>，例如<code>rgba(0,255,255,0.3)</code>，第四位值取值范围为0~1，取值越小则越透明，越大则越明显。</p></li><li><p>十六进制表示法</p><p>十六进制表示法不使用RGB的0<del>255的表示法，而是使用0</del>FF的表示法，FF和255一样。例如<code>#00ffff</code>，当十六进制表示法中的某两位相同时，可以使用速记法表示，例如<code>#00ffff</code>可以表示为<code>#0ff</code>。</p></li></ol><p>实践中大多使用十六进制表示法，如果需要透明度，则使用<code>RGBA</code>表示法。</p><h3 id="灰色"><a href="#灰色" class="headerlink" title="灰色"></a>灰色</h3><p>在<code>RGB</code>表示法中，当光谱中的三个颜色相同时，将会得到灰色。当三个光谱值为最大值255时，得到白色，当三个值为最小值0时，得到黑色。也就是说正好有256种灰色值可以选择。</p><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><ol><li><p>first-child</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">当一个li元素所在父元素下的第一个子元素是li元素时，这个第一个子元素(li元素)将被选中。</span></span><br><span class="line"><span class="comment">如果一个li元素所在父元素下的第一个子元素不是li元素时，则这个li元素所在父元素下的子li元素都将不会被选中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>last-child</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">当一个li元素所在父元素下的最后一个子元素是li元素时，这个第一个子元素(li元素)将被选中。</span></span><br><span class="line"><span class="comment">如果一个li元素所在父元素下的第一个子元素不是li元素时，则这个li元素所在父元素下的子li元素都将不会被选中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nth-child()</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当一个li元素所在父元素下的第偶数个元素是li元素时，这个元素将会被选中，如果第偶数个元素不是li元素则不会被选中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(even)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多用法参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child">MDN nth-child()</a></p></li><li><p>链接伪类</p><ul><li><p><code>a:link</code></p><p>选中所有具有<code>href</code>属性的<code>a</code>元素，如果没有<code>href</code>属性代表不是真正的链接，所以不算是<code>link</code>，<code>a:link&#123;&#125;</code>中的<code>css</code>规则如果与<code>a&#123;&#125;</code>中设置的规则相同时，生效的将是<code>a:link&#123;&#125;</code>中设置的规则。</p></li><li><p><code>a:visited</code></p><p>设置访问过的链接的样式，大多数现实情况下与<code>a:link&#123;&#125;</code>中的样式相同。</p></li><li><p><code>a:hover</code></p><p>设置鼠标在<code>a</code>链接上悬停时的样式，</p></li><li><p><code>a:active</code></p><p>设置实际点击<code>a</code>链接时的链接的样式</p></li></ul><p>需要特别注意的是，在实际使用时，总是应该按照这个顺序定义链接在不同情况下的样式，即<code>L V H A</code>。</p><p>在浏览器的开发者工具中，可以手动选中链接伪类以进行链接样式调试。</p></li></ol><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="CSS选择器优先级"><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h3><p>当一个元素被多个选择器共同指定样式规则时，其中的所有样式都将被应用，但是可能会存在一个元素对应的多个选择器中存在相同CSS属性的情况，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;author-text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span></span><br><span class="line">Some Text</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author</span>&#123;</span><br><span class="line"><span class="attribute">font-style</span>: italic;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#author-text</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>: sans-serif;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">22px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，都对指定的<code>p</code>元素设置了<code>font-size</code>属性，这种情况下会根据CSS选择器的优先级来确定哪个选择器中的样式得到应用，优先级顺序如下（从高到低）：</p><ol><li><p>!important</p><p>使用<code>!important</code>声明的样式具有最高优先级，但是通常不应该使用，只应该在必要时作为最后的手段用来解决CSS中的冲突。</p></li><li><p>内联样式（不应该使用）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span> style=&quot;<span class="attribute">font-size</span>:<span class="number">18px</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">Some Text</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ID选择器(#)</p><p>如果有多个ID选择器对同一个元素设置了样式，则最后被定义的选择器生效</p></li><li><p>Class&#x2F;伪类选择器</p><p>同样的，当有多个class选择器时，最后被定义的选择器生效</p></li><li><p>元素选择器</p><p>同样的，当有多个元素选择器时，最后被定义的选择器生效</p></li><li><p>通用选择器（优先级最低）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通用选择器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>VS Code</code>中当鼠标悬浮在CSS选择器上时，<code>VS Code</code>会自动计算并显示出对应选择器的生效优先级权重<code>Selector Specificity</code>，其存在三个值，例如(1,0,0)，值越大的选择器，其定义的样式生效的优先级越高。</p><p>在实际开发中，应尽量避免某个元素的相同属性被定义在其多个选择器中，这样会使选择器及其中定义的样式变得非常混乱难以理解。</p><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。</p><ol><li>并不是所有的属性都可以继承, 只有以color&#x2F;font-&#x2F;text-&#x2F;line-&#x2F;letter-&#x2F;list-开头的文本属性才可以继承。</li><li>在CSS的继承中不仅仅是直接子元素可以继承, 只要是后代都可以继承</li><li>继承性中的特殊性<ul><li>a标签的文字颜色和下划线是不能继承的</li><li>h标签的文字大小是不能继承的</li></ul></li><li>元素继承来的样式是优先级最低的。</li></ol><p>可以通过通用选择器来为所有元素设置统一的不会被继承的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><h3 id="盒子模型组成"><a href="#盒子模型组成" class="headerlink" title="盒子模型组成"></a>盒子模型组成</h3><p>盒子模型是CSS最基本的模型，盒子模型定义了元素如何显示在网页上以及元素的大小。每个页面元素都可以看作是一个矩形框，每个框都可以有内容（content）、内部的填充（padding）、内部的边框（border）、外部的边界（margin）等部分。</p><ol><li><p>内容（content）</p><p>这是页面元素的实际内容，它可以是文本&#x2F;图像&#x2F;表格&#x2F;视频等各种内容，CSS属性中的高度<code>height</code>、宽度<code>width</code>属性所指的宽高度就是指的内容区的宽高度。</p></li><li><p>边框（border）</p><p>在元素内容之外的区域内，可以指定元素的边框（包括宽度、样式、杨色等样式），需要注意的是，边框依然属性元素内的区域。</p></li><li><p>填充（padding）</p><p>在元素内容向外、边框向内的区域，是元素的填充，填充围绕着元素内容。和边框（border）一样，padding也依然是在元素内部。 填充（padding）本质上是可以在元素内部创建的独立于元素内容之外的空白空间。</p></li><li><p>外边距（margin）</p><p>在边框（border）之外的区域就是外边距 （margin），和填充（padding）不同的是，外边距（margin）已经不是在元素内部了，外边距描述的是多个元素之间的空间。</p></li></ol><p>对于页面元素的这四个部分来说，其中前三个部分内容（content）、边框（border）、填充（padding）加起来的区域是元素的可见部分（也可称为填充区域）。需要特别注意的是，虽然元素的实际内容（文字、图像、视频等）只会显示在内容（content）区域中，但是如果元素设置了<code>background</code>、<code>background-color</code>等背景属性时，这些背景属性所应用的范围并不是内容（content）区域，而是整个元素的可见部分（填充区域）。</p><p>对于边框（border）、填充（padding）、外边距（margin）可以有多种方式指定上下左右四个方向的值，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指定元素的上下左右的填充都是20个像素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指定元素的上下填充都是20个像素、左右的填充是40个像素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指定元素的</span></span><br><span class="line"><span class="comment">    上填充为25px</span></span><br><span class="line"><span class="comment">    右填充为50px</span></span><br><span class="line"><span class="comment">    下填充为75px</span></span><br><span class="line"><span class="comment">    左填充为100px</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">25px</span> <span class="number">50px</span> <span class="number">75px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指定元素的</span></span><br><span class="line"><span class="comment">    上填充为25px</span></span><br><span class="line"><span class="comment">    左右填充为50px</span></span><br><span class="line"><span class="comment">    下填充为75px</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line"> <span class="attribute">padding</span>:<span class="number">25px</span> <span class="number">50px</span> <span class="number">75px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于margin属性，特别需要注意的一点是：如果两个相邻元素均设置了彼此对向方向上的margin属性值，则这两个相邻元素的外边距值不是其分别设置的外边距值之和，而是两个外边距值中的最大值。这种现象被称为边缘坍陷。</strong></p><h3 id="盒子模型计算"><a href="#盒子模型计算" class="headerlink" title="盒子模型计算"></a>盒子模型计算</h3><p>默认盒子模型下，元素在页面上实际显示时所占用的宽度和高度计算方式由内容区域（content）、填充（padding）、边框（border）三部分得出，元素内容（content）的高度和宽度可以通过height和width属性指定，如果不指定的话，浏览器将根据实际内容自动计算得出，但是这个内容区域的高度和宽度并不是元素最终在页面上显示时的高度和宽度，真正的宽高度计算方式如下：</p><ol><li><p>真正的元素宽度</p><p>左边框(left border) + 左填充（left padding） + 元素内容区域宽度（width） + 右填充（right padding） + 右边框（right border）</p></li><li><p>真正的元素高度</p><p>顶部边框(top border) + 顶部填充（top padding） + 元素内容区域高度（height） + 下填充（bottom padding） + 底部边框（bottom border）</p></li></ol><h3 id="盒子模型类型"><a href="#盒子模型类型" class="headerlink" title="盒子模型类型"></a>盒子模型类型</h3><p>默认的盒子模型为<code>box-sizing: content-box;</code>，但是在这种默认的盒子模型下，<code>height</code>、<code>width</code>属性的应用范围是内容本身，此时元素盒子的实际高度和实际宽度的计算是比较复杂的，因为需要将内容本身的宽高度再加上填充长度再加上边框宽度才是盒子模型最后的宽度，所以可以将<code>box-sizing</code>属性的值修改为<code>border-box</code>。在<code>border-box</code>下，<code>height</code>、<code>width</code>属性应用的范围是包含<code>border</code>、<code>padding</code>、<code>内容</code>在内的全部范围。此时，就不需要再手动计算元素盒子的实际宽度和高度了，直接使用<code>width</code>、<code>height</code>即可。<strong>需要注意的是，在<code>box-sizing:border-box</code>下，再指定元素的<code>padding</code>、<code>border</code>值时，这部分的值将会从实际内容区域中扣减掉（即实际内容区域将会减小）。</strong></p><p>可以使用全局选择器指定所有元素的盒子模型都是<code>border-box</code>，同时指定所有元素的默认填充<code>padding</code>、边距<code>margin</code>的值都是0，方便开发调试。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span> ;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h2><p>HTML元素根据默认布局方式的不同，分为块级元素、内联元素（也叫行内元素）、内联块元素三种。</p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>常用的标签如：div、p、ul、li、h1~h6、dl、dt、dd等等都是块元素，它在布局中的行为：</p><ol><li>支持全部的样式</li><li>如果没有设置宽度，默认的宽度为父级宽度100%</li><li>默认情况下，块级元素总是单独占据一行、即使设置了宽度</li></ol><p>通过<code>display:block</code>可以将其他类型的元素转换为块级元素。</p><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p>内联元素也叫行内元素，常见的内联元素有<code>strong</code>、<code>em</code>、<code>a</code>、<code>img</code>、<code>button</code>元素等。它在布局中的行为：</p><ol><li>支持部分样式</li><li>宽高由实际内容决定</li><li>不同的内联元素并在同一行里，不会换行</li><li>使用CSS代码强制换行，盒子之间会产生间距</li><li>子元素是内联元素时，父元素可以用<code>text-align</code>属性设置子元素水平对齐方式。</li></ol><p>通过<code>display:inline</code>可以把其他类型的元素转换为内联元素。</p><p><strong>需要特别注意的是，对于内联元素，宽度和高度是没有效果的，填充(padding)和外边距(margin)也只会在水平方向上起作用。</strong></p><h3 id="内联块元素"><a href="#内联块元素" class="headerlink" title="内联块元素"></a>内联块元素</h3><p><strong>内联块元素，也叫行内块元素，是新增的元素类型，现有元素没有归于此类别的</strong>，<code>img</code>和<code>input</code>元素的行为类似这种元素，但是也归类于内联元素，可以用display属性将块元素或者内联元素转化成这种元素。它们在布局中表现的行为：</p><ol><li>支持全部样式</li><li>如果没有设置宽高，宽高由内容决定</li><li>只占用需要的空间，会和其他内联块元素和内联元素并在一行</li><li>代码换行，盒子会产生间距</li><li>子元素是内联块元素，父元素可以用<code>text-align</code>属性设置子元素水平对齐方式。</li></ol><p>总结一下就是，内联块元素在外部表现得像内联元素（所以它们会并在同一行内显示），但是在内部表现得像是块级元素（所以可以设置宽度和高度）。</p><p>可以使用<code>display:inline-block</code>来将其他类型的元素转换为内联块元素。实际开发时，可以灵活地将内联元素转换为内联块元素来应用相应的样式。</p><h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><p>CSS中有几种几种不同的定位模式，可以通过<code>position</code>属性进行设置，该属性的可选值：</p><ol><li><p>static</p><p>元素的默认定位模式，没有定位，元素出现在正常的文档流中</p></li><li><p>relative</p><p>该关键字下，元素默认先被放置在未添加定位时的默认位置，再使用<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>属性相对于默认位置调整定位（此时，相对定位元素会相对原默认位置出现偏移，原默认位置会变为空白）。</p><p>如果想要让一个父元素的某个子元素（可以不是直接子元素）相对于父元素进行绝对定位，则父元素需要是<code>relative</code>相对定位的。</p></li><li><p>fixed</p><p>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code>、<code>perspective</code>、<code>filter</code> 或 <code>backdrop-filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p></li><li><p>absolute</p><p>可以将任何元素绝对定位于页面上的任何位置，<strong>这种绝对定位模式会使对应的元素脱离原有文档流</strong>，并使其完全失去对周围其他元素的任何影响（甚至会与其他元素重叠）。而且这种定位将是相对于一个相对定位的父容器而言的；<strong>也就是说，如果想要对某个元素设置绝对定位，则这个元素的某一个父级元素（不需要必须是父元素）需要是相对（relative）定位的。</strong>绝对元素定位的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行定位，最终定位位置是相对于其第一个<code>relative</code>的父级元素（不需要必须是父元素）而言的。<strong>如果绝对定位元素的父元素是<code>body</code>且<code>body</code>未设置<code>relative</code>相对定位的话，则绝对定位元素的位置是相对于视口<code>viewport</code>而言的，也就是相对于浏览器当前窗口范围内进行绝对定位。</strong></p><p>未通过left、top、right、bottom属性设置绝对定位元素的位置时，默认情况下，绝对定位元素的位置将出现在其第一个父级元素的左上角（即top和left都是0）。</p></li><li><p>sticky</p><p>元素根据正常文档流进行定位，但是在页面滚动时，该元素不会跟随页面一起滚动（显示&#x2F;消失），而是始终位于其默认相对于视口<code>viewport</code>的位置。相当于是相对定位和固定定位的结合，既有相对定位的保留自己原来位置的特点又有固定定位相对于可视窗口定位的特点。</p></li></ol><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素本质上是HTML中不存在的，但是仍然可以在CSS中选择并设置样式的元素。</p><p>伪元素在CSS中以两个冒号(::)表示。</p><p>常用伪元素</p><ol><li><p>first-letter</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::first-letter</span>&#123;</span><br><span class="line"><span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选中<code>h1</code>元素的第一个字符</p></li><li><p>first-line</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择p元素中的第一行内容。</p></li><li><ul><li></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> + <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相邻兄弟选择器。选中紧跟<code>h3</code>标题后的兄弟<code>p</code>元素的第一行。</p></li><li><p>after&#x2F;before</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置伪元素内容,即使伪元素没有实际内容，仍然需要定义content属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;TOP&quot;</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#ffe70e</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>after&#x2F;before伪元素可用于设置指定元素的最后一个&#x2F;第一个子元素。</strong>after&#x2F;before伪元素对于不想创建真实HTML元素但是又想设置样式的装饰元素的场景(比如页面上的一个标识符)非常有帮助。</p><p><strong>需要特别注意的是，<code>after/before</code>创建的伪元素默认元素类型是内联元素。</strong></p></li></ol><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Float浮动布局"><a href="#Float浮动布局" class="headerlink" title="Float浮动布局"></a>Float浮动布局</h3><p>这是使用<code>float</code>属性实现布局的老方式，目前已经基本上不会在新项目中使用。</p><p>例如：**<code>float: left; </code>将页面元素设置为向左浮动后，元素将会像绝对定位一样脱离正常文档流。**浮动元素周围的元素都将会在它周围漂浮(这一点在周围的文本元素特别多时表现得更加明显)。 假如先后有两个块级元素 A、B，如果把 A 设置为 float: left 但是不设置 B 元素为浮动，此时 B 元素将会在 A  元素的右侧紧贴着 A 元素漂浮显示，但是此时 B 元素的左填充、左边距并不是相较于 A 元素的最右侧计算的，其依然是相较于 A  元素的最左侧计算，因为此时只有 A 元素脱离了文档流，B 元素并没有，所以虽然视觉效果上看起来 B 元素是在 A 元素右侧紧贴着 A 元素的，其计算时依然是参照文档流中的位置进行计算。但是如果把 A、B 元素均设置为浮动，此时 B 元素仍然紧贴着 A  元素的右侧，但是其计算左填充、左外边距的时候就变成根据 A 元素的右侧进行计算了，因为此时 A、B 元素都已脱离文档流，再次处于同一区域中。 设置了浮动的元素依然可以设置 margin 值来调整浮动元素与页面上其他仍处在文档流中的元素的外边距。</p><p>还有一条有关浮动需要注意的是当一个块级元素没有设置高度 height  值（高度自动扩展）时，如果这个块级元素内部的元素都变成了浮动元素，即其内部的元素都脱离了文档流，则这个父块级元素的高度将会失去高度，这就是”折叠元素”（元素的高度已经被折叠了），因为其内部已经没有实际上可以显示在文档流中的元素了，所以其高度变成了 0。避免这种副作用最好的方式就是使用 clear 来设置不想被浮动元素影响的元素（清除其围绕浮动元素漂浮的效果），可以使用 .container::after{content: ‘’;display:  block;clear:both}来实现，这样就不需要手动在容器最后添加一个 HTML  元素来清除浮动了。元素被清除浮动之后，其将不会再围绕着浮动元素漂浮，而是依然在其原本的位置中。使用这个特性可以灵活的用来实现多个块级元素的并排、并列布局。<strong>如果想让浮动元素相邻的元素不要跟随在浮动元素周围漂浮显示的话，也可以对相应的元素使用<code>clear</code>属性清除浮动。</strong></p><p>当在一行中有两个浮动元素，一个向左浮动，一个向右浮动且这两个元素的宽度之和不等于其父元素的宽度之和时，这两个元素中间会自动露出相应的空白区域，这一点可以非常方便的用于页面布局美化。</p><p><strong>浮动和绝对定位的都会使元素脱离文档流，不同之处在于浮动元素会影响其周围的其他元素，使其他元素漂浮在它周围，而绝对定位与其周围的元素之间不会有任何影响。</strong></p><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><p><code>Flexbox</code> 是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间。</p><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的创建工具只有 <code>float</code> 和  <code>position</code>。这两个工具大部分情况下都很好使，但是在某些方面它们具有一定的局限性，让人难以完成任务。以下简单的布局需求是难以或不可能用这样的工具（<code>float</code> 和 <code>position</code>）方便且灵活的实现的：</p><ol><li>在父内容里面垂直居中一个块内容。</li><li>使容器的所有子项占用等量的可用宽度&#x2F;高度，而不管有多少宽度&#x2F;高度可用。</li><li>使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。</li></ol><p><code>Flexbox</code> 使得这些布局任务变得更加容易。</p><p>要使用 flexbox，首先要创建弹性容器，可以通过在容器上添加 <code>display: flex</code>实现。这样弹性容器的所有直接子元素都将变为弹性元素。这些弹性元素的布局方向称为主轴。另外一个轴称为辅轴。主轴和辅轴可以通过设置属性调换。</p><p>对于弹性容器，有以下几个需要记住的属性：</p><ol><li><p>gap 可以在不使用 margin 外边距的情况下在各元素之间创建间隔。</p></li><li><p>justify-content 沿主轴对齐项目（默认情况下水平对齐）的方式 可选值有：flex-start | flex-end | center | space-between | space-around | space-evenly </p><p><strong>space-between 可以实现均分排满主轴的效果，经常拿来实现分别在最左侧和最右侧展示两个元素的效果。</strong></p></li><li><p>align-items 沿辅轴对齐项目（默认情况下垂直对齐）的方式 stretch | flex-start | flex-end | center | baseline</p></li><li><p>flex-direction 定义哪个是主轴 row | row-reverse | column | column-reverse</p></li><li><p>flex-wrap 设置在项目太大的时候是否可以换行 nowrap | wrap | wrap-reverse</p></li><li><p>align-content 在元素有多行时适用 stretch | flex-start | flex-end | center | space-between | space-around</p></li></ol><p>对于弹性容器内部的容器元素，也有几个需要记住的属性：</p><ol><li><p>align-self 重新设置单个弹性容器元素的对齐属性（而不是适用弹性容器设置的的默认对齐方式） 可选值有: auto | stretch | flex-start | flex-end | center | baseline</p></li><li><p>flex-grow </p><p>flex-grow的默认值为0。这个属性可以允许弹性元素自动扩大以占据多余的空白空间，如果对一个弹性容器内的所有弹性元素均设置一个相同的 flex-grow 非零 值，则所有弹性元素将均分剩余空白空间，如果只对其中的指定某几项弹性元素设置，则将由这几项分别具有响应的空间，具体分得的空间将由每一项的  flex-grow 值占总值的比例计算得出。</p></li><li><p>flex-shrink 设置当空间不够时弹性元素的伸缩方式，默认值为 1（即允许伸缩），如果将其设置为 0，则将不允许收缩（如果此时设置了 flex-basis  的值，则将以 flex-basis 的值作为统一大小，但是此时因为不允许收缩，所以可能会出现元素显示范围超出容器的情况）。</p></li><li><p>flex-basis</p><p>flex-basis的默认值为auto， 作用与 width  相同，用于设置一个弹性元素的基本宽度，但是并不代表设置了这个值后，所有元素的大小都是这个值，弹性容器允许弹性元素根据其需要的空间自动调整大小（即 flex-shrink 默认为 1），因此，flex-basis 更像是一个基准值。在弹性容器中，应该使用 flex-basis 替代  width 设置元素宽度。</p></li><li><p>flex: 0 1 auto 简写法，共有三个值，分别表示 flex-grow，-shrink、basis</p></li><li><p>order 不需要改变弹性元素在代码中的顺序即可定义真正显示时的先后顺序，弹性元素的默认order为0，默认按照升序排列。</p></li></ol><p>可以使用<code>flex: flex-grow flex-shrink flex-basis</code>的速记表示法一次性表示<code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>三个属性。</p><p><strong>对于需要明确指定宽度的弹性元素，需要通过<code>flex-basis</code>指定最佳宽度，对于其他的没有那么需要明确指定宽度的弹性元素，可以将其<code>flex-grow</code>设置为1（根据其他弹性元素的宽度自动调节自身宽度），这样就只需要在个别的弹性元素上指定宽度及指定弹性容器的<code>gap</code>间隙值即可实现弹性元素宽度自动计算的效果。省去了手动计算元素宽度并逐个指定的步骤。</strong></p><p>使用 flexbox 的一个很明显的好处在于，对弹性容器素中的多个弹性元素，只需要设置好其中的部分元素，并且设置好其他元素的 flex 值后（比如 flex: 1 代表这个弹性元素将尽可能地占据剩余的空间），浏览器会自动计算出所有元素应该占据地空间。</p><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p><code>Grid</code>可以实现构建完整的二维布局，这使得它非常适合实现页面整体布局。<code>CSS Grid</code> 使用方式： 通过设置容器 <code>display: grid</code> 来实现 <code>grid</code>。</p><p>对于 <code>CSS Grid</code> 容器有如下重要属性：</p><ol><li><p>容器内部的多个元素将按照指定的列数来挨个排列，比如总共有 8 个元素，通过 <code>grid-template-columns: 200px  200px 100px 100px;</code>设置了 <code>grid</code> 具有四列元素，且前两列的宽度是 200 像素，后两列的宽度是 100 像素。那么这 8  个元素将通过第一行 4 个，第二行 4 个的排列方式展现在页面上。</p></li><li><p><strong>除了可以通过在 <code>CSS Grid</code> 容器上 <code>grid-template-columns</code> 设置列的宽度，也可以通过  <code>grid-template-rows</code>  以同样的方式设置行的高度。如果设置的高度过高，那么实际高度没有达到这个高度的元素将会以其实际高度展示而不是被拉长。</strong></p></li><li><p>可以通过 <code>gap</code> 属性设置 <code>grid</code> 容器中的间距，<code>gap</code> 属性设置的间距不仅适用于列之间，也适用于行之间，如果想单独设置列间距和行间距，可以通过 <code>column-gap</code> 和 <code>row-gap</code>来分别设置。</p></li><li><p>与 <code>flexbox</code> 相似，<code>CSS Grid</code>容器 也具有 <code>justify-items</code> 和 <code>align-items</code> 属性，分别代表行排列方式和列排列方式。<code> justify-items: stretch</code> | <code>start</code> | <code>center</code> | <code>end</code> <code>align-items: stretch</code> | <code>start</code> | <code>center</code> | <code>end</code> 这两个属性和在 <code>flexbox</code> 中的用法及作用一致，是用来指定实际内容在其对应的单元格内的排列方式的</p></li><li><p>在 <code>CSS Grid</code> 容器 上还有两个属性是 <code>justify-content</code> 和 <code>align-content</code>。 <code>justify-content: stretch</code> | <code>start</code> | <code>center</code> | <code>end</code> <code>align-content: stretch</code> | <code>start</code> | <code>center</code> | <code>end</code> 。</p><p><strong>需要与 <code>justify-items</code> 和 <code>align-items</code> 注意区分的是，这两个内容对齐属性指定的是网格的行、列两个轨道在其父 Grid 容器中的排列方式（因为网格容器的大小肯定大于等于网格的大小）。</strong></p></li></ol><p>对于这两组属性的区分，只需要记住 <code>justify-items</code> 和 <code>align-items</code>指定的是实际内容在其所在的 <code>grid</code> 内的单元格中的排列方式，而 <code>justify-content</code> 和 <code>align-content</code> 指定的则是 <code>grid</code> 中的单元格在  <code>grid</code> 容器中的排列方式。</p><p>对于 <code>CSS Grid</code> 容器中的网格项目，有如下属性：</p><ol><li><p>网格列、网格行 <code>grid-column</code>:  &#x2F;  | span  <code>grid-row</code>:  &#x2F;  | span  </p><p>网格列和网格行对于放置网格项目进入特定的单元格（而不是按照默认的顺序放入对应的单元格）非常重要。</p><p><strong>例如<code>grid-column: 2 / 3</code>就是将指定的单元格放入第2列，同理，<code>grid-row: 2 / 3</code>就是将指定的单元格放入第2行，像这种只占据一行&#x2F;列的（第二个值只比第一个值大1的）可以只写第一个值，例如<code>grid-column: 2</code>。当然，这个属性也可以指定网格跨越多列&#x2F;多行显示，例如<code>grid-column: 2 / 4</code>就是设置网格占据第二列~第三列的两列位置显示。为了不用进行计算，也可以使用<code>grid-column: 2 / span 2</code>设置跨越两列显示，不需要再进行计算。也可以设置<code>grid-column: 1 / -1</code>直接使元素占据整行。（因为grid分割线里最右边和最下方的值都是-1）</strong></p></li><li><p><code>justify-self: stretch</code> | <code>start</code> | <code>center</code> | <code>end</code> <code>align-self: stretch</code> | <code>start</code> | <code>center</code> | <code>end</code> 用于覆盖对齐项，当其所在的 <code>grid</code> 容器被指定了 <code>justify-items</code> 和 <code>align-items</code>  属性，但是又想让特殊项使用个性化项目对齐样式替代 <code>grid</code> 容器的元素对齐样式时，就可以使用 <code>justify-self</code> 和 <code>align-self</code> 来代替父 <code>grid</code> 容器中的 <code>justify-items</code> 和 <code>align-items</code> 设置的样式。</p></li></ol><p><strong>在 <code>CSS grid</code> 中，可以在 <code>grid-template-columns</code> 和  <code>grid-template-rows</code> 中使用 fr(比如 1fr) 单位替代 px 单位指定大小。这样可以使对应的列或行填满 <code>CSS Grid</code>  容器中在指定方向上的所有剩余空间。如果对所有网格都使用了 fr 单位来指定大小，则这些网格将根据 fr 单位的大小按照 fr  单位的比例瓜分占满容器在这个方向上的空间。如果各网格的值都相同（1fr），则将均分容器在这个方向上的空间。</strong></p><p><strong>如果在 <code>grid-template-colums</code> 和 <code>grid-template-rows</code>  中的某一列或某一行上使用了 <code>auto</code>，则这一列（行）将只占据其实际需要占据的空间，除去这个 <code>auto</code> 大小元素之后的空间再被其他的设置了相应  px 像素或者 fr 单位的列（行）瓜分。</strong></p><p><strong>如果想快速均匀设置四列元素的 <code>grid</code> 布局，只需要简写为 <code>grid-template-columns: repeat(4,1fr)</code>，而不用写上四遍 1fr。</strong></p><p><strong>如果没有手动设置容器的高度，则每一行网格的实际高度由这一行中高度最高的一个网格的高度确定。如果通过 <code>grid-template-rows</code> 设置了每一行的高度相同，则所有行的高度都由其中高度最高的一个网格确定。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;H5&quot;&gt;&lt;a href=&quot;#H5&quot; class=&quot;headerlink&quot; title=&quot;H5&quot;&gt;&lt;/a&gt;H5&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;strong&lt;/code&gt;元素取代&lt;code&gt;b&lt;/code&gt;元素进行加粗显示&lt;/li&gt;
&lt;li&gt;使用&lt;code</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="html" scheme="http://pvnk1u.github.io/categories/web/html/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/html/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="html" scheme="http://pvnk1u.github.io/tags/html/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(6)——内容布局</title>
    <link href="http://pvnk1u.github.io/2023/07/01/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BD%91%E6%A0%BC/"/>
    <id>http://pvnk1u.github.io/2023/07/01/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BD%91%E6%A0%BC/</id>
    <published>2023-07-01T07:28:39.000Z</published>
    <updated>2023-11-27T15:34:23.888Z</updated>
    
    <content type="html"><![CDATA[<p>本章介绍布局的系统性方法。上一章探讨的是个别页面组件的布局方式。了解页面布局最好先从个别组件开始。但与此同时，会发现总体结构中有重复出现的模式。本章主要讨论如何以可重用的方式实现这些结构，也就是能够盛放内容的容器。</p><p>创建容器的时候，一般都需要一个包含预置尺寸和比例的网格系统。首先会介绍相对传统的创建网格系统的方法，然后演进到使用Flexbox。后半章还会涉及到面向未来的CSS Grid Layout规范。</p><p>在把设计方案转换成模板时，很多时候想都不想，就开始写HTML和写CSS。这样写着写着，很快就会发现没有了任何回旋余地。如果能在事前稍微作一番规划，将来很可能就避免了大量的无用功。规划阶段的关键就在于从设计方案中找出重复的模式，并识别出一些本质的东西。</p><h1 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h1><p>说到一个网站的整体布局，经常会想到网格系统。网格系统是设计师在切分布局时作为参照的一组行和列。行和列之间的空白叫作空距。网格系统是页面布局常用的参考系。</p><h2 id="布局辅助类"><a href="#布局辅助类" class="headerlink" title="布局辅助类"></a>布局辅助类</h2><p>类名用于为布局添加样式。对于简单的网站，几个类名就够用了。比如，用于控制两栏博客布局的类名大概这样就可以了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-content</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.secondary-content</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>随着网站的复杂度提高，会发现一些规律：由于某些部分从属于特定的内容层级，类名无法清晰地传达其意图。这时候类名重用就成了一个问题。为了让样式可以重用，很多人尝试“可视化”的命名方式，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.column</span>&#123; <span class="comment">/* 一般列的样式 */</span>&#125;</span><br><span class="line"><span class="selector-class">.column-half</span>&#123;<span class="comment">/* 占行宽的一半 */</span>&#125;</span><br><span class="line"><span class="selector-class">.row</span>&#123;<span class="comment">/*一般行的样式 */</span>&#125;</span><br></pre></td></tr></table></figure><p>这几个类名严格来说是表现性的，也就是在HTML中要加入表现性信息。另外，这样命名一目了然，方便重用，可以一次到位地解决布局问题。</p><p>另一种做法是把具有共用样式的选择符集中到一起：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.thing</span>,</span><br><span class="line"><span class="selector-class">.other-thing</span>,</span><br><span class="line"><span class="selector-class">.third-thing</span>,</span><br><span class="line"><span class="selector-class">.fourth-thing</span>&#123;</span><br><span class="line"><span class="comment">/* 共用的样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处是不必为了应用这些样式而专门搞一个类名，只需要在这一个地方添加或删除即可。但如此一来，选择符可能会越来越多，变得难以维护。这也会给代码组织带来问题。而且像这样根据共用样式而非可重用组件来分割样式，还会让修改网站中特定部分的样式变得非常麻烦，因为不得不在很多样式块之间跳来跳去。</p><p>命名规范是高质量代码的重要组成部分，把表现与标记混在一起也是权衡的结果。本章将走一条中间路线，一方面会使用一些辅助类，另一方面会尽可能少地与表现绑定起来。这是创建布局系统的简便方式，可以快速实现原型，同时还能保持样式的一致性。</p><h2 id="固定、流动还是弹性"><a href="#固定、流动还是弹性" class="headerlink" title="固定、流动还是弹性"></a>固定、流动还是弹性</h2><p>“固定布局”、“流动布局”、“弹性布局”的说法指的是在某种布局下如何约束元素的尺寸。</p><ol><li><p>固定布局</p><p>指页面具有特定的宽度，比如960像素。固定布局已经流行很长时间了，因为这样设计师和开发者会轻松很多。但是，有人会质疑到底什么尺寸是最好的：现在用户屏幕的主流宽度是1024像素，还是1280像素呢？</p></li><li><p>弹性布局</p><p>指布局元素的尺寸使用em单位。这样，即使用户缩放文本大小，布局的比例也不会变。再与最小和最大宽度结合使用，还能使页面更好地适应屏幕大小。虽然弹性布局有点过时了，但其利用最大宽度限制em单位的思想是创建流动布局的关键。</p></li><li><p>流动布局</p><p>也称为“流式布局”，指页面元素会按比例缩放，但元素与元素之间的比率（有时候连元素之间的距离也）保持不变。这其实是Web的默认模式，即块级元素没有预置的宽度，其尺寸会随可用空间大小而变化。</p></li></ol><p>建议尽量不要使用固定布局，最好使用流式布局，使其适应不同的设备。这种让设计能响应环境的设计方法叫作响应表WEB设计。</p><h1 id="创建灵活的页面布局"><a href="#创建灵活的页面布局" class="headerlink" title="创建灵活的页面布局"></a>创建灵活的页面布局</h1><p>本节会介绍几种实用的布局方法，可以用来创建可靠、灵活、可重用的页面布局。</p><p>接下来会创建一个如下图所示的页面布局，这个布局会随屏幕大小而展示不同的列数，同时水平的分节也会变化。</p><p><img src="https://pvnk1u.github.io/images/page-layout.PNG" alt="page-layout"></p><p>把这个页面的布局简化成线框图，可以得到如下图所示的样子：</p><p><img src="https://pvnk1u.github.io/images/page-layout-simple.PNG" alt="page-layout-simple"></p><p>这个线框图没有表现出布局整体是居中的，有一个最大宽度限制。接下来就从这个限制宽度包装元素开始。</p><h2 id="包装元素"><a href="#包装元素" class="headerlink" title="包装元素"></a>包装元素</h2><p>包装元素是页面布局中常用的一个盛放内容的元素，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Some temporary style attributes added, just to see the effects of the wrapper. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #ccc; min-height: 300px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;margin: 0&quot;</span>&gt;</span>My page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面为这个包装元素添加一些样式。这些样式通过自动外边距，将包装元素设置为在页面上居中，同时使用了最大宽度。对于流动布局而言，适应百分比来设置一个稍微小于100%的宽度是很常见的。最大宽度则相对于文本大小来设置，单位是em。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">76em</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>body元素默认是有外边距的，为避免不必要的困扰，这里需要去掉它。简单地去掉body的外边距：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示的结果就是布局的起点了。以上寥寥几行CSS样式反映了如下几个布局选择。</p><ol><li>主包装元素正常情况下应该是视口宽度的95%。</li><li>通过简写的margin: 0 auto，我们去掉了它的上下外边距，然后将水平剩余空间平均分配给左、右外边距（每一侧是2.5%），这样就让它在页面上居中了。</li><li>但是，这个包装元素最宽不会超过76em。按照每em默认为16像素计算，相当于1216像素。不过，如果用户通过浏览器缩放文本大小，包装元素的宽度也会同比例缩放。76em不是谁规定的，只是觉得它比较适合当前的布局。</li></ol><p><img src="https://pvnk1u.github.io/images/basic-layout.PNG" alt="basic-layout"></p><p>这里屏蔽了一些不可控因素，比如屏幕大小及用户的字体设置，因为不希望布局的宽度值固定。</p><p>但一个居中的布局两侧应该留出一些空白区域，这跟屏幕大小无关。我们希望布局的宽度有一个上限，以防止文本行的长度超出可读范围。假如用户的浏览器有不同的默认文本大小，那么布局的最大宽度应该也能自动缩放。</p><p>由于设计不同，选择的度量方式也可能不同，但原理都是一样的：首先大体上确定内容包装元素的限制条件，但又不能把它们的值写死。要让布局能随机应变。</p><p>“随机应变”是软件设计的各种领域中经常能听到的一句话。在整体布局时不使用特定的像素值，就可以实现这一点。而这些样式一旦写完，就可以应用给任何包装元素，只要给它们添加相应的类即可。</p><p>换句话说，现在只要应用wrapper类就行了。以下代码中有3个地方应用这个类。首先是页头部分，然后是导航条。这两个元素本身是与浏览器视口一样宽的，但通过在它们内部包含一个包装元素，就可以实现内容在布局层面上居中。这两个块之后的main元素也是包装元素，用于盛放特定于页面的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;masthead&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Important News<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">role</span>=<span class="string">&quot;navigation&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navlist&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Local<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Sports<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是主体内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关CSS代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* here&#x27;s our wrapper */</span></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">76em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* masthead styling */</span></span><br><span class="line"><span class="selector-class">.masthead</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#8E3339</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.masthead</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: -.<span class="number">1em</span> .<span class="number">1em</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* navbar styling */</span></span><br><span class="line"><span class="selector-class">.navbar</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5E2126</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">1.375em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir Next&#x27;</span>, Avenir, Corbel, <span class="string">&#x27;Franklin Gothic&#x27;</span>, <span class="string">&#x27;Century Gothic&#x27;</span>, CenturyGothic, AppleGothic, sans-serif;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#752A2F</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#8E3339</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.75em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://pvnk1u.github.io/images/grid-demo.PNG" alt="grid-demo"></p><h2 id="创建行容器和列"><a href="#创建行容器和列" class="headerlink" title="创建行容器和列"></a>创建行容器和列</h2><p>创建好了头部菜单之后，再来实现“内容“部分在水平方向上的分组。效果如下图所示：</p><p><img src="https://pvnk1u.github.io/images/layout-demo-section.PNG" alt="layout-demo-section"></p><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Finished column layout sketch<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/grid-base.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the HTML5 shiv, to help older browsers understand styling</span></span><br><span class="line"><span class="comment"> on newer HTML5 elements: --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* our grid styles: */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-quartet</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-trio</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">33.3333%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    -moz-<span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#666</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-featured</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;masthead&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Important News<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">role</span>=<span class="string">&quot;navigation&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navlist&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Local<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Sports<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Sub-section 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-featured&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Sub-section 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-trio&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用的grid-base.css中的样式表代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.375</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Georgia, Times New Roman, Times, serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Avenir Next, Avenir, Franklin Gothic, Trebuchet MS, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#8E3339</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* here&#x27;s our wrapper */</span></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">76em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* masthead styling */</span></span><br><span class="line"><span class="selector-class">.masthead</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#8E3339</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.masthead</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: -.<span class="number">1em</span> .<span class="number">1em</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* navbar styling */</span></span><br><span class="line"><span class="selector-class">.navbar</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5E2126</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">1.375em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir Next&#x27;</span>, Avenir, Corbel, <span class="string">&#x27;Franklin Gothic&#x27;</span>, <span class="string">&#x27;Century Gothic&#x27;</span>, CenturyGothic, AppleGothic, sans-serif;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#752A2F</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#8E3339</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.75em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析这份代码，在这段代码中，首先创建了行容器（class名为row）及行容器中的多列内容。首先定义HTML元素及类名（行为row，列为col），然后实现了内容在水平方向上的分组。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">display: block;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用伪类和clear:both实现.row行元素分别各占一行的效果。</p><p>实现了行元素之后，再来实现创建列的效果。上一章的几种水平布局方法中，浮动是最常用的，也是浏览器支持最好的技术。因此，这里用浮动创建列。对于从左向右书写的语言，默认的向左浮动应该是最佳选择。</p><p>考虑到将来可能会在不影响列宽度的前提下，直接给列容器添加边框和内边距，还应该把box-sizing属性设置为border-box。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的min-height是为列指定了最低高度。outline则是指定了列的轮廓线（因为不影响元素尺寸，所以轮廓线适用于元素可视化布局和调试布局）。</p><p>接下来需要给列设置列宽。很多CSS库都使用直接表示宽度的类来指定列宽，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-1of4</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-1of2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式非常适合面向台式电脑或笔记本电脑的快速原型。根据前面定义的规则，很容易在HTML中定义一个3列的、最左列占一半宽度的布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col-1of2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col-1of4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col-1of4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式的缺点是过分强调某种布局。如果将来需要根据屏幕大小动态调整布局，这种命名方式就不太合适了。</p><p>如果想通过可重用的类名来控制尺寸，就必须让HTML标记与CSS表现有一个结合点。可以给这个结合点换个名字，不使用特定的宽度或者比率，让它更为普适。用音乐来比喻的话，可以创建一条规则，让行容器在正常情况下包含4个宽度相等的部分（quartet，四重奏）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row-quartet</span> &gt; * &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用通用选择符，直接针对行容器的子元素，同时可以降低这条通用规则的特殊性。因为通用选择符的特殊性为0，所以后面可以用一个特殊的类名来覆盖这个宽度。此时通过以下标记就可以创建一个包含4个等宽列的行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，.row-quartet中的列如果想改变宽度，就可以应用覆盖宽度的一个类名，但这个类名并不与布局相关。于是前面的3列布局就可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col my-special-column&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.my-special-column</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了四重奏，当然还应该有三重奏：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row-quartet</span> &gt; *&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.row-trio</span> &gt; *&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">33.3333%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的效果图中，两个子分类都有一个标题区，占整个布局区（包含标题区和内容区两块）的五分之一，右侧的内容区占剩下的五分之四。而在第一个子分类中，还有一个更大的文章列，占内容区的50%。相关代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.subcategory-featured</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subcategory-content</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subcategory-header</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Sub-section 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-featured&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Sub-section 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-trio&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Story<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此便实现了图中的效果。在这些定义好的网格类基础上，很容易组合和扩展出更复杂的布局模式。下面在每个容器中添加一些示例内容，以充实细节。</p><p>以下是带图片文章的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Float grid with dummy content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/grid-base.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the HTML5 shiv, to help older browsers understand styling</span></span><br><span class="line"><span class="comment"> on newer HTML5 elements: --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* grid styling */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    -moz-<span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-quartet</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-trio</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">33.33333%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* content styling */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">1.5em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#8e3339</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-featured</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: .<span class="number">6875em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;masthead&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Important News<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">role</span>=<span class="string">&quot;navigation&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navlist&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Local<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Sports<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-featured&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Cras suscipit nec leo id.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Autem repudiandae aliquid tempora quos reprehenderit architecto, sequi repellat.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Curabitur mattis purus nec velit.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam mattis eros id posuere.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Proin leo felis, semper nec<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam vitae risus tortor. Sed!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dolor sit amet<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-trio&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Ut sit amet mi massa<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Nunc mollis sit amet nunc<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Duis sed ante enim. Cras<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Animi, explicabo, ipsum<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图如下所示：</p><p><img src="https://pvnk1u.github.io/images/float-grid-pic-content-demo.PNG" alt="float-grid-pic-content-demo"></p><p>在列容器（类名为col的元素）中，使用了带story类名的article元素。这个额外的元素将布局与内容隔离开来，避免因加重包装元素的负担而导致其过载。</p><p>这里需要注意的是以下有关.story的CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.story</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">6875em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.story</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定了.story元素的padding内边距的值及背景颜色，使内容区更加美观，随后设置.story的子img图片元素的宽度为100%。这里需要注意的是，例子中用的是同样一张图片，但是因为img的父元素.story的宽度不同，所以展示出的图片大小也不同，第一张图片的story的宽度是其他story元素的2倍，所以图片大小也是其他图片的两倍。</p><h2 id="流式空距"><a href="#流式空距" class="headerlink" title="流式空距"></a>流式空距</h2><p>现在需要给列间添加一些空白了，这样布局才不会看起来紧绷绷的。</p><p>在流动布局中，空距可以是百分比，也可以是相对于字体大小的固定宽度。不管采用哪种方式，列元素两边的宽度都应该相等。换句话说，每一边的空距宽度都应该是空距宽度的一半。</p><p>不管怎么样，都应该知道如何计算百分比外边距的实际值，这样才能保证空距与列宽相协调。在前面的例子中，文本大小为16像素，行高为1.375em，即22像素。假设我们希望在一般的屏幕尺寸中，空距等于文本的行高，从而将排版与布局联系起来。先从布局的最宽点开始，即76em或1216像素。</p><p>因为外边距相对包含块来计算，所以计算空距与总宽度的比例与计算相对文本大小是一样的：预期的宽度除以总宽度。22除以1216等于0.018092105。也就是说，一个空距大约是总宽度的1.8%。最后，这个百分比再除以2，就是每一列的每侧的外边距，即0.9%。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0.9%</span> <span class="number">1.375em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也添加了一个下外边距，让两个内容行之间的距离等于行高。注意这里的垂直空间用em设置，而不是百分比。这是因为行高和屏幕尺寸无关，既然以行高为依据，就应该沿用计算行高的参照物（即文本大小）。</p><p>此时看一下布局，会发现它乱了（如下图）。这是给列设置了外边距所导致的。就算设置了box-sizing: border-box，对外边距也是无能为力。此时所有列的总宽度超过了100%。因此，接下来需要重新定义列宽。</p><p><img src="https://pvnk1u.github.io/images/wrong-gutter.PNG" alt="wrong-gutter"></p><p>因为给每一列加了1.8%的空距，所以只要从原先的列宽中减去它就可以了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row-trio</span> &gt; *&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">31.53333%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row-quartet</span> &gt; *&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">23.2%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subcategory-featured</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">48.2%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subcategory-header</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">18.2%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subcategory-content</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">78.2%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减去之后的效果就变得正常了，而且稍微拖窄一点浏览器窗口可以发现空距也会随之缩小。</p><ol><li><p>抵消最外侧的空距</p><p>现在，我们有了一个网格系统，可以表示行、流动的列和流式空距。接下来要做的是处理细节，尽量避免视觉效果冲突。</p><p>首先，用于创建空距的外边距导致了外层容器左边和右边额外的缩进，这不是我们想要的。在内部行中嵌套的列也出现了同样的问题（如下图所示）。我们应该去掉第一项的左外边距和最后一项的右外边距。但这样会导致列宽和空距的计算复杂化。</p><p><img src="https://pvnk1u.github.io/images/gutter-problem.PNG" alt="gutter-problem"></p><p><strong>对于没有特定宽度的非浮动块级元素，会在左、右负外边距都设置的情况下扩展其宽度。</strong>由于我们使用了一个独立的元素作为行来分隔内容（而不是让列元素也充当行再去嵌套列），此时正好可以利用这一点来应用我们的技巧，那就是给每一行的左、右两侧都应用一个等于空距一半宽度的负外边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> -.<span class="number">9%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置空距的替代方案</p><p>要想进一步简化列宽的计算，可以利用box-sizing属性，并使用内边距来设置空距。</p><p>如果想继续使用流式空距，那么只要把外边距改成内边距即可。这样就可以重新以整个宽度的适当百分比来表示列宽，而不必考虑空距了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> .<span class="number">9%</span> <span class="number">1.375em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row-trio</span> &gt; *&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">33.3333%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subcategory-featured</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样一来就可以使用排版的基准来设置空距了。换句话说，可以使用em来设置空距，而不用基于网格宽度的百分比。在下面的例子中，空距大小与行高相同，在列之间创建了相同的垂直与水平间距，而这与网格的宽度无关。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> .<span class="number">6875em</span> .<span class="number">1375em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Float grid with elastic gutters<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/grid-base.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the HTML5 shiv, to help older browsers understand styling</span></span><br><span class="line"><span class="comment"> on newer HTML5 elements: --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* grid styling */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> -.<span class="number">6875em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-quartet</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-trio</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">33.3333%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    -moz-<span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span> .<span class="number">6875em</span> <span class="number">1.375em</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* content styling */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">1.5em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#8e3339</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-featured</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: .<span class="number">6875em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> + <span class="selector-class">.story</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">1.375em</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;masthead&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Important News<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">role</span>=<span class="string">&quot;navigation&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navlist&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Local<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Sports<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-featured&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Cras suscipit nec leo id.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Autem repudiandae aliquid tempora quos reprehenderit architecto, sequi repellat.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Curabitur mattis purus nec velit.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam mattis eros id posuere.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Proin leo felis, semper nec<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam vitae risus tortor. Sed!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dolor sit amet<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-trio&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Ut sit amet mi massa<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Nunc mollis sit amet nunc<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Duis sed ante enim. Cras<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Animi, explicabo, ipsum<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下图所示，通过设置相对于文本大小的“弹性”空距，空距就跟内容宽度无关了。</p><p><img src="https://pvnk1u.github.io/images/padding-gutter.PNG" alt="padding-gutter"></p></li></ol><h2 id="增强列：包装与等高"><a href="#增强列：包装与等高" class="headerlink" title="增强列：包装与等高"></a>增强列：包装与等高</h2><p>前面创建布局主要使用了浮动。除了浮动以外，还有很多其他布局方案可以实现同样布局的例子。掌握这些方法以后，可创造出更灵活的布局。</p><ol><li><p>用行内块包装行和列</p><p>有时会有如下图这样的两行或更多行标题的HTML区域，使用浮动块来包装这些行可能会有问题。比如，某个新闻的标题很长，导致该列非常高，就会出现非常难看的“锯齿”效果。</p><p><img src="https://pvnk1u.github.io/images/multiline-problem.PNG" alt="multiline-problem"></p><p>为此，可以创建一个通用的类名，预期的应用场景就是包装多行。对添加了这个类名的容器，应用基于文本大小技术的inline-block。此时，由于font-size是0，在设置行容器的负外边距时要使用rem单位。考虑到向后兼容，这里还添加了像素单位的后备规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row-wrapping</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> -<span class="number">11px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> -.<span class="number">6875rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row-wrapping</span> &gt; * &#123;</span><br><span class="line"><span class="attribute">float</span>: none;</span><br><span class="line"><span class="attribute">vertical-align</span>: top;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这两条规则，就可以添加任意多个新闻预览，这些新闻预览会在填满一行四列后自动折行。在验证结果之前，先用Flexbox再打磨一下细节。</p></li><li><p>使用Flexbox实现等高的列</p><p>之前介绍过，Flexbox可以用来创建等高的列。在创建一整套布局时，我们希望有些规则只在浏览器支持Flexbox时应用。</p><p>为检测浏览器是否支持Flexbox，要在页面上方引入一小段脚本。这里使用Modernizr，这个库会根据浏览器支持的特性，给HTML元素添加相应的类。访问<a href="https://modernizr.com/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%8A%E9%9D%A2%E5%AE%9A%E5%88%B6%E9%9C%80%E8%A6%81%E7%9A%84%E6%A3%80%E6%B5%8B%E8%84%9A%E6%9C%AC%E3%80%82%E6%9C%AC%E4%BE%8B%E6%89%80%E9%9C%80%E7%9A%84%E5%AE%9A%E5%88%B6%E8%84%9A%E6%9C%AC%E5%8F%AA%E5%8C%85%E5%90%AB%E6%A3%80%E6%B5%8BFlexbox%E7%89%B9%E6%80%A7%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E4%BF%9D%E6%8C%81%E5%85%B6%E6%9C%80%E5%B0%8F%E5%8C%96%E3%80%82">https://modernizr.com/，可以在上面定制需要的检测脚本。本例所需的定制脚本只包含检测Flexbox特性的代码，以保持其最小化。</a></p><p>创建完检测脚本，把它复制到一个JavaScript文件里，然后引入即可，但次序一定要先于引入CSS文件的元素。然后就可以基于带前缀的类名来编写样式了。只有支持Flexbox的浏览器才会解析它们。flexbox类表示浏览器支持Flexbox，而flexwrap表示可伸缩项会折成多行或多列。</p><p>在完整的代码证还能看到使用了flexboxweener类，这个类表示浏览器支持IE10中的Flexbox。</p><p>首先，把标准行转换成Flexbox行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-class">.row</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就已经创建了等高的列，这也是可伸缩项会拉伸以填充父元素的默认行为。</p><p>因为针对每一列的内容都使用了包装元素，所以需要对这些列应用更多的Flexbox属性，使其中的内容能均匀地填充这些列。这里每一列都会变身为一个列状的可伸缩容器，其子元素按照规则会均匀填充可分配的剩余空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-class">.col</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-class">.col</span> &gt; *&#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写的flexbox: 1代表flex-grow: 1、flex-shrink: 1、flex-basis: 0。</p><p>最后，再对包装行进行增强，让它们也能利用Flexbox的等高机制。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flexwrap</span> <span class="selector-class">.row-wrapping</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Using flexbox to create equal-height columns<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/grid-base.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Modernizr script to detect flexbox support, </span></span><br><span class="line"><span class="comment">     which also includes HTML5 shiv,</span></span><br><span class="line"><span class="comment">     to help older browsers understand styling</span></span><br><span class="line"><span class="comment">     on newer HTML5 elements: --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/modernizr.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* grid styling */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> -.<span class="number">6875em</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexbox</span> <span class="selector-class">.row</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexboxtweener</span> <span class="selector-class">.row</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: -webkit-flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: -ms-flexbox;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-quartet</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-trio</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">33.3333%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-wrapping</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> -<span class="number">11px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> -.<span class="number">6875rem</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexwrap</span> <span class="selector-class">.row-wrapping</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: -webkit-flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: -ms-flexbox;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    -webkit-<span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">        -ms-<span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.row-wrapping</span> &gt; <span class="selector-class">.col</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: none;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">vertical-align</span>: top;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    -moz-<span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span> .<span class="number">6875em</span> <span class="number">1.375em</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexbox</span> <span class="selector-class">.col</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexboxtweener</span> <span class="selector-class">.col</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: -webkit-flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: -ms-flexbox;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    -webkit-<span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">        -ms-<span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexbox</span> <span class="selector-class">.col</span> &gt; *,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.flexboxtweener</span> <span class="selector-class">.col</span> &gt; * &#123;</span></span><br><span class="line"><span class="language-css">    -webkit-<span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    -ms-<span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.col</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="comment">/* content styling */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">1.5em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#8e3339</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-featured</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.subcategory-header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: .<span class="number">6875em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> + <span class="selector-class">.story</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">1.375em</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.story</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;masthead&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Important News<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">role</span>=<span class="string">&quot;navigation&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navlist&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Local<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Sports<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-featured&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Cras suscipit nec leo id.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Autem repudiandae aliquid tempora quos reprehenderit architecto, sequi repellat.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Curabitur mattis purus nec velit.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;row row-quartet row-wrapping&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam! Dolor sit amet consectetur<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam mattis eros id posuere.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Proin leo felis, semper nec<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam vitae risus tortor. Sed!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Perferendis, ipsam!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam mattis eros id posuere.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Proin leo felis, semper nec<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Aliquam vitae risus tortor. Sed!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;subcategory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dolor sit amet<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col subcategory-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row row-trio&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Ut sit amet mi massa<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Nunc mollis sit amet nunc<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Duis sed ante enim. Cras<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://placehold.it/600x300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Dummy image&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Animi, explicabo, ipsum<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本章介绍布局的系统性方法。上一章探讨的是个别页面组件的布局方式。了解页面布局最好先从个别组件开始。但与此同时，会发现总体结构中有重复出现的模式。本章主要讨论如何以可重用的方式实现这些结构，也就是能够盛放内容的容器。&lt;/p&gt;
&lt;p&gt;创建容器的时候，一般都需要一个包含预置尺寸和</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(6)——内容布局</title>
    <link href="http://pvnk1u.github.io/2023/06/05/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80/"/>
    <id>http://pvnk1u.github.io/2023/06/05/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80/</id>
    <published>2023-06-05T07:28:39.000Z</published>
    <updated>2023-11-27T15:34:23.887Z</updated>
    
    <content type="html"><![CDATA[<p>网页是由不同内容块构成的：标题、段落、链接、列表、图片、视频等等。这些元素可以按照主题组织起来，比如一个标题，几段文本，外加一张图片就是一篇新闻报道。通过控制每个组件内部元素的位置、大小、顺序，就可以更好地传达它们的功能与含义。</p><p>所有内容块会进一步组织成整个页面的布局。下一章将会讲到如何系统化地布局页面。本章仍然聚焦于个别的内容块，从而深入理解如何对每个内容块进行布局。</p><p>之前大致讲过使用定位和浮动来实现布局，这两种手段各有千秋。此外，也可以使用表格显示模式和行内块来实现布局，当然也各有各的优缺点。CSS新增的Flexible Box Layout Module（或Flexbox）为内容块提供了一大批顺序、方向、对齐及尺寸相关的属性。Flex是非常强大的布局功能，本章会详细介绍。</p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>定位并不适合于总体布局，因为它会把元素拉出页面的正常流。反过来看，这也正是定位在CSS中之所以重要的原因，接下来将简单探讨一下定位在哪些情况下最合适。</p><p>以下是对定位内容的简单总结：</p><ol><li>元素的初始定位方式是静态定位（static），意思是块级元素垂直堆叠。</li><li>可以把元素设置为相对定位（relative），然后可以相对于其原始位置控制该元素的偏移量，同时又不影响其周围的元素。<strong>与此同时，这也为该元素的后代元素创造了定位上下文。</strong>这一点也是相对定位真正的用处。以前，在一些古老的布局技巧中，经常要偏移元素，当然现在已经很少这样了。</li><li>绝对定位（absolute）支持精确定位元素，相对于其最近的定位上下文：或者是其非静态定位的祖先元素，或者是HTML元素。绝对定位的元素会脱离页面流，然后再相对于其定位上下文进行定位。默认情况下，它们会被浏览器定位于之前静态定位时所处的位置但不会影响周围的元素。然后，可以相对于定位上下文来改变它们的位置。</li><li>固定定位（fixed）与绝对定位基本类似，只不过<strong>定位上下文被自动设置为浏览器视口。</strong></li></ol><h2 id="绝对定位的应用场景"><a href="#绝对定位的应用场景" class="headerlink" title="绝对定位的应用场景"></a>绝对定位的应用场景</h2><p>绝对定位非常适合创建弹出层、提示和对话框这类覆盖于其他内容之上的组件。它们的位置可以通过top、right、bottom和left属性控制。关于绝对定位，了结以下知识可以写出更高效的代码。</p><ol><li><p>利用初始位置</p><p>比如有一篇介绍太空飞船的文章，想在文章上添加一些行内的评注。这些评注最好以气泡图的样式显示在文章外部的空白区域，如下图所示。</p><p><img src="https://pvnk1u.github.io/images/Spaceship.PNG" alt="Spaceship"></p><p>每个评注组件都是一个aside组件，实际位置在它们指向的段落后面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This isa fake article[...]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span>I`ve never done this. Is that really true?<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You may think[...]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了让评注显示在段落之后，需要使其绝对定位。而我们不必为了在垂直方向上准确的定位它们而给出确切的上偏移量。</p><p><strong>绝对定位的元素默认会待在自己静态定位时的地方</strong>，因此第一步是让评注显示在其初始位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加这段CSS代码之后，aside元素将会变成绝对定位，即脱离页面流。这样一来，原本会跟在p元素文本段落之后看起来像是单独段落的aside内的内容将会出现在再往后的第二段p元素的上方，导致显示重叠。</p><p>接下来需要把评注向左和向上偏移，把它定位到之前段落的旁边。这听起来像是要使用相对定位，但元素不能同时既是绝对定位又是相对定位。如果此时使用方向性偏移属性（top、right、left和bottom），那就既要用到定位上下文，又要设置确定的偏移量。好在不用这么麻烦，在这里完全可以通过负外边距来移动元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">7em</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: -<span class="number">9.5em</span>;</span><br><span class="line"><span class="attribute">margin-top</span>: -<span class="number">2.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CSS中，负外边距是完全有效的，它们有如下有趣的行为。</p><ul><li>左边或上边的负外边距会把元素向左或向上拉，盖住其旁边的元素。</li><li>右边或下边的负外边距会把相邻元素向左或向上拉，盖住设置了负外边距的元素。</li><li>在浮动的元素上，与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动的元素。而与浮动方向相同的负外边距会在该方向上把浮动的元素向外拉。</li><li>给未声明宽度的非浮动元素应用负外边距时，左、右负外边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。</li></ul><p>对评注气泡组件而言，使用左和上负外边距把元素拉到位的做法，与使用相对定位很相似。</p></li><li><p>创建三角形</p><p>在评注气泡组件中，指向前面段落的小三角形又相对于评注气泡进行了绝对定位。它是通过伪元素创建的，使用了一种很古老的基于边框的技巧。</p><p>相关代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: .<span class="number">5em</span> solid <span class="number">#dcf0ff</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border-right-color</span>: transparent;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">top</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个0像素的块，其边框是0.5em，而且边框也只显示左、上边框。结果浏览器就只渲染出一个三角形。不用图片一样可以创造出三角形来！然后再把三角形定位到评估气泡的右上角位置。这里通过将border-bottom-color和border-right-color的值设置为transparent透明进而实现右半下角透明的效果（进而只剩下左上半角的图形）。</p></li><li><p>利用偏移实现自动大小</p><p>从另一个角度看，有必要知道：<strong>在绝对定位的情况下，如果声明了多个或所有偏移值，那么结果会怎么样。如果没有显式声明元素大小，那么绝对定位元素的大小由自身包含内容的多少来决定。如果相对于定位上下文的各个边声明偏移值，那么元素会被拉伸以满足设定的规则。</strong></p><p>比如，如果希望让某元素总是与其外部元素保持一定距离，但又不给任何元素设定大小。如下图所示，一张图片上有一个包含文本的元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;photo-header&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/big_spaceship.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;An artist`s mockup of the &quot;</span><span class="attr">Dragon</span>&quot; <span class="attr">spaceship</span>&quot;&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;photo-header-plate&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SpaceX unveil the Crew Dragon<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Photo from SpaceX on <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.flickr.com/photos/spacexphotos/16787988882/&quot;</span> &gt;</span></span><br><span class="line">Flickr<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/SpaceX.PNG" alt="SpaceX"></p></li></ol><p><strong>假设不想给这个包含标题的盒子设定明确的宽度，那么可以只指定其右、下、左边的偏移，让它自己去计算上空距离</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.photo-header</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.photo-header-plate</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">4em</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">4em</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">4em</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>);</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无论图片多大，标题区始终都会位于距离底边及左、右两边4em的地方，而且会在标题折行的情况下自动调整高度，从而适应不同的屏幕大小。</strong></p><h2 id="定位与z-index：堆叠内容的陷阱"><a href="#定位与z-index：堆叠内容的陷阱" class="headerlink" title="定位与z-index：堆叠内容的陷阱"></a>定位与z-index：堆叠内容的陷阱</h2><p>要用好定位，还有一个重点技术必须掌握，那就是z-index，也就是堆叠元素的次序。基本原理：<strong>静态定位（static）以外的元素会根据它们在代码树中的深度依次叠放，就像打扑克牌一样，后发的牌会压在先发的牌上面。它们的次序可以通过z-index来调整。</strong></p><p>设置了z-index的元素，只要值是正值，就会出现在没有设置z-index的元素上方。尚未设置z-inde的元素在z-index值为负的元素上方。</p><p>除了z-index，还有其他影响元素堆叠次序的因素。这里也有一个概念，叫堆叠上下文。就像一盒扑克牌，每张牌本身也是一个上下文（牌盒），而牌只能相对于当前的牌盒排定次序。有一个根堆叠上下文，所有z-index不是auto的定位元素都会在这个上下文中排序。随着其他上下文的建立，就会出现堆叠层级。</p><p>堆叠上下文是由特定属性和值创建的。比如，任何设定了position: absolute及值不是auto的z-index属性的元素，都会创建一个自己后代元素的堆叠上下文。</p><p>在一个堆叠上下文内部，无论z-index值多大或多小，都不会影响其他堆叠上下文，毕竟不能相对于别的堆叠上下文重新排序。</p><p>如下图所示：</p><p><img src="https://pvnk1u.github.io/images/OpacityAndZIndex.PNG" alt="OpacityAndZIndex"></p><p><strong>容器A、B、C和D都是绝对定位的，其中C是B的子元素。容器C和D设置了z-index，但由于容器B的opacity值小于1，所以它又创建了一个新的独立的堆叠上下文。于是，就算C的z-index的值再大，它也不会跑到D的上方。</strong></p><p><strong>设置小于1的opacity值也可以创建新的堆叠上下文。opacity小于1的元素需要独立渲染（包括它的所有后代元素），然后再放到页面上。这样就可以保证在把它们放到页面上时，原有的元素不会与半透明的元素发生交错。后面会有这个例子及其他类似的例子，比如transform和filter属性，也会触发创建新的堆叠上下文。</strong></p><h1 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h1><p>通常，页面会随内容增加沿垂直方向扩展。后来添加的任何块容器（div、article、h1-h6等等）都会垂直堆放起来，因为<strong>块级元素的宽度是自动计算的</strong>。<strong>因此，在需要给内容块设置明确宽度，并让它们水平排列时，就需要特殊处理。</strong></p><p>使用浮动来实现小型“媒体组件”布局是一种基础的组件模式，即组件一边是图片（或其他媒体），另一边是文本，“左边是这个，右边是那个，二者相互关联“。很多网站都在使用这种模式。如下图所示：</p><p><img src="https://pvnk1u.github.io/images/MediaComponent.PNG" alt="MediaComponent"></p><p><strong>除此之外，还有很多通用模式的组件，可见于各类网站。其中很多都涉及水平布局。为此，CSS引入了Flexbox来专门解决水平布局问题（以及其他问题）</strong>，但在得到浏览器完全支持之前，可能还要借助浮动、inline-block显示，或者表格显示模式，才能完美实现水平布局。</p><h2 id="使用浮动"><a href="#使用浮动" class="headerlink" title="使用浮动"></a>使用浮动</h2><p>在太空飞船的例子中，有一个使用浮动的例子。figure浮动到了右侧，让行盒子对其四周环绕。同时通过margin-right的负外边距把图片向外推出去一点，以便与文本保持一些间距。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">figure</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">1em</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">max-width</span>: <span class="number">17em</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-right</span>: -<span class="number">8em</span>; <span class="comment">/* 向右推出 */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You may think[...]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/spaceship.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The Dragon spaceship in orbit around Earth.&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>The &quot;Dragon&quot; spaceship,created by SpaceX.Image from <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.flickr.com/photos/spacexphotos/16787988882/&quot;</span>&gt;</span>Flickr.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">figuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>There`s various[...]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/SpaceshipFloat.PNG" alt="SpaceshipFloat"></p><p>下面的代码中，删除了这个负外边距，并把插图宽度设置为文章宽度的一半，而且还增加了第二幅插图。此时，两幅插图并肩而立。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Two floated images side by side<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: Georgia, Times New Roman, serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">2em</span> <span class="number">8em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">max-width</span>: <span class="number">35em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: Avenir, Franklin Gothic, sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">figure</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">1em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">max-width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">figure</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: .<span class="number">5em</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">figcaption</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-style</span>: italic;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: .<span class="number">875em</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A fake article about spaceships<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a fake article about spaceships. Remember when you did presentations in middle school, and you told the class about what your assignment was about, then read aloud from the paper you had written, including the title?</span><br><span class="line">    ”My assignment is about spaceships. Spaceships. Spaceships are very large, and fly in space...”.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>You may think that spaceships are fake, like this article, but they’re not. There are actual spaceships,</span><br><span class="line">  flying in space right now, probably. For example, there’s the International Space Station, which is </span><br><span class="line">  a spaceship of sorts. Well, actually it’s a space station, which is even cooler!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/spaceship.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The Dragon spaceship in orbit around Earth.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>The ”Dragon” spaceship, created by SpaceX. Image from <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.flickr.com/photos/spacexphotos/16787988882/&quot;</span>&gt;</span>Flickr.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/spaceship2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The Dragon spaceship landing on Mars.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>Artist mockup of Mars landing. Image from <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.flickr.com/photos/spacexphotos/21424800115&quot;</span>&gt;</span>Flickr.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>There’s various government organizations and companies that are building spaceships. One of them is</span><br><span class="line">  SpaceX. An image of one of their spaceships appears on this very page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I can&#x27;t be bothered to write any more about spaceships so the rest of the text will just be</span><br><span class="line">    nonsense. This isn’t a school assignment after all.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sequi saepe harum, excepturi dolorum voluptatem hic amet nemo. Incidunt tenetur dignissimos laborum molestiae reiciendis ipsum quas temporibus nisi dolor, ea libero!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A assumenda, et eius odit, rerum delectus placeat dolores eveniet quis. Iure neque deserunt mollitia impedit illo corporis odio quod, velit ducimus!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://pvnk1u.github.io/images/TwoSpaceshipImage.PNG" alt="TwoSpaceshipImage"></p><p>可以看到从第一个figure元素开始排在最右边，后面的第二个figure元素依次向左排列。</p><p><strong>这种布局方式是很多CSS布局会用到的一种基本技术，即让浮动的元素构成一行中的列。但正如之前讨论过的，浮动也会有一些问题。浮动的元素并不在页面流中，因此需要一个元素来包含浮动元素。为此，可以给容器内部的一个（伪）元素应用clear，也可以通过规则让容器成为一个新的块级格式化上下文（BFC，blocking formating context）。必要时，浮动也可以包含多行，但如果上面的行有浮动元素，也可能会被卡住。</strong></p><p>浮动也可以对有限的水平内容进行独立于源码次序的排序。比如，通过分别向左或向右浮动两个元素，可以调整两幅插图的次序。将上面代码示例中的float的值由right改为left即可实现两幅图片位置调换的效果。</p><p>因为浏览器对浮动的支持极为普遍，所以浮动也成为了各种水平布局中的常用技术。除了浮动，实际上还有其他技术可以用来创建水平布局，虽然这些技术各有利弊。</p><h2 id="行内块布局"><a href="#行内块布局" class="headerlink" title="行内块布局"></a>行内块布局</h2><p>文本行自身就是水平布局时，至少在从左往右和从右往左书写的语言中是如此。使用行内元素（如span、time或a）时，它们会与文本沿相同方向水平对齐。也可以把行内块加入到文本流中，创造出水平对齐的元素，从视觉上看又是一个块。</p><p>比如，为太空飞船的文章末尾添加一些元数据，包括作者姓名、照片和电子邮件地址。为了添加样式，还使用了两个额外的span元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;author-meta&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;author-image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/author.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Arthur C. Lark&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author-info&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author-name&quot;</span>&gt;</span>Written by Arthur C. Lark<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;author-email&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mailto:arthur.c.lark@example.com&lt;/a&gt;&quot;</span>&gt;</span>arthur.c.lark@example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，.author-meta段落的底部会与图片底部及文本基线对齐。段落中的所有空白字符，包括图片和作者信息之间的换行符都被渲染为空格。这些空格的宽度取决于字体及其大小。</p><p><img src="https://pvnk1u.github.io/images/author-case-1.PNG" alt="author-case-1"></p><p>接下来，把图片和作者信息转换为行内块：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-image</span>,</span><br><span class="line"><span class="selector-class">.author-info</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染之后，其实并没有什么可见的差别。差别只在于现在图片和作者信息都是块了。比如，可以把作者信息中包含的姓名和电子邮件地址分别列为两行，只要把它们修改为块级元素即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-name</span>,</span><br><span class="line"><span class="selector-class">.author-email</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 现在已经比较接近想要的水平布局了：左边是浮动的图片，右边是一个文本块。但还有一点，此时作者信息块最后一行的基线与图片底部是对齐的。下图展示了此时的状况：</p><p><img src="https://pvnk1u.github.io/images/author-case-2.PNG" alt="author-case-2"></p><p>现在可以通过vertical-align属性相对于图片来对齐作者信息。下图展示了在对齐关键字设置为top时，作者信息块的顶部与图片顶部对齐的效果：</p><p><img src="https://pvnk1u.github.io/images/author-case-3.PNG" alt="author-case-3"></p><ol><li><p>行内块的垂直居中</p><p>假设想要的设计是让作者信息块相对于图片垂直居中。可能会这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-info</span>&#123;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，结果可能并非是垂直居中，如下图所示：</p><p><img src="https://pvnk1u.github.io/images/author-case-4.PNG" alt="author-case-4"></p><p>这是因为，<strong>关键字middle在应用给行内块时，其含义是“将这个行内块的垂直中心点与这行文本x高度的中心点对齐”。这个例子中没有行内文本，（行内最高的）图片就成为行盒子高度以及基线位置的元素。而此时x高度的中心点就在图片底部（基线）靠上一点。要想将作者信息与图片一起垂直居中，需要让这两个元素都参照同一个“中心点”：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-image</span>,</span><br><span class="line"><span class="selector-class">.author-info</span>&#123;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为图片此时也是行内块，所以它就与作者信息在同一个垂直点上居中对齐了</strong>，从而得到了想要的布局，如下图所示：</p><p><img src="https://pvnk1u.github.io/images/author-case-5.PNG" alt="author-case-5"></p><p>如何确定行盒子的基线，以及这些规则如何影响行内及行内块元素是比较复杂的。<strong>对于利用行内块创建水平布局而言，如果需要垂直对齐，有以下两个要点：</strong></p><ul><li><strong>要让行内块沿上方对齐（很像浮动），设置：vertical-align: top;</strong></li><li><strong>要让两个元素的内容垂直对齐，先把它们都转化成行内块，再对它们应用vertical-align: middle。</strong></li></ul></li><li><p>在容器元素中垂直居中</p><p>前面的两个要点的第二个告诉我们：可以在任意高度的容器内垂直居中内容。其实也不完全对。唯一的前提是把容器的高度设置为确切的高度。</p><p>比如，假设想把作者元数据块设置为10em高，然后在其中居中放置作者图片和信息。首先，给.author-meta块应用这个高度。为清晰起见，也添加了一个边框。如下图：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-meta</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">10em</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/author-case-6.PNG" alt="author-case-6"></p><p>但作者信息和图片并没有相对于容器块垂直居中对齐，而是仍然沿原来那条假想的文本行对齐。<strong>为了实现与容器垂直对齐，还需要增加一个行内块元素，让它占据100%的容器高度。这个元素会让middle关键字认为容器的垂直中点是对齐点。为此，可以借助伪元素。如下图所示，在引入了这个“幽灵元素”后，假想的基线就以它为准了。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-meta</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">display: inline-block;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/middle-of-box.PNG" alt="middle-of-box"></p><p>如图所示，利用高度为100%的伪元素，让middle关键字代表容器的垂直中心点。此时，就好像整个.author-meta容器中只有一行文本，且高度与容器高度相同。因为这个伪元素是一个行内块，且其垂直对齐方式设置为middle，所以其他行内块也就与容器的中心垂直对齐了。接下来要做的就是水平居中内容。因为行内块像文本一样对齐，所以这里使用text-align。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-meta</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">10em</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.author-info</span>&#123;</span><br><span class="line"><span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就是.author-meta既水平居中又垂直居中，如下图所示：</p><p><img src="https://pvnk1u.github.io/images/author-case-7.PNG" alt="author-case-7"></p><p>确切地讲，这里的水平居中并不准确。这是因为行盒子内的任何空白符都会被渲染为一个空格。伪元素就会创建这么一个空格，导致内容向右偏移几个像素。通过给伪元素应用负外边距，可以抵消空格的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.author-info</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">margin-right</span>: -.<span class="number">25em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>追究细节：与空白战斗到底</p><p>对于每个块都占据确切宽度的水平布局而言，空白是个突出的问题。下面以另一个常见的组件为例，介绍在使用行内块的情况下如何解决这个问题，尽量不使用具体数值。</p><p>创建一个导航条，包含4个链接项，每一项都占据宽度的四分之一。标记如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/spaceships&quot;</span>&gt;</span>Spaceships<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/planets&quot;</span>&gt;</span>Planets<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/stars&quot;</span>&gt;</span>Stars<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下CSS标记为导航条添加了基本的颜色及字体样式，并通过轮廓线突出了链接项的边界。这里将每一项设置为占据25%的宽度，4项正好占据全部宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir Next&#x27;</span>, Avenir, Corbel, <span class="string">&#x27;Franklin Gothic&#x27;</span>, <span class="string">&#x27;Century Gothic&#x27;</span>, CenturyGothic, AppleGothic, sans-serif;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#486a8e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  -moz-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">       <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#12459e</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.75em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用box-sizing: border-box确保每一项的边框及内边距都包含在各自25%的宽度以内。导航条本身的背景颜色是蓝灰色，链接项的颜色是深蓝色，链接文本颜色是白色。</p><p><img src="https://pvnk1u.github.io/images/multilinenav.PNG" alt="multilinenav"></p><p><strong>HTML源代码中的换行符被渲染成了空白符，再加上每一项25%的宽度，就导致了折行。</strong>要消灭这些空白符，可以尝试把所有li标签都排到一行，但这种要求显示不友好。</p><p>解决问题的方法也很简单粗暴，就是把包含元素ul的font-size设置为0（从而让每个空格的宽度为0），然后在每一项上重新设置大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就如期解决了空白问题，每一项都相互靠拢，只占据了一行。但这个技术也有缺点。首先与可以继承的font-size有关。假设在导航条上设置的是16像素的font-size，那么就不能再使用em单位或比例，让每一项继承一个可伸缩的大小了。它会变成与0相乘。不过，可以使用rem单位，相对于根字体大小来保持可伸缩性。</p></li></ol><h2 id="使用表格显示属性实现布局"><a href="#使用表格显示属性实现布局" class="headerlink" title="使用表格显示属性实现布局"></a>使用表格显示属性实现布局</h2><p>表格中的行恰好具有导航条例子中我们想要的特质：一组单元格恰好占满一行，而且永远不会折行。这也正是HTML表格在WEB发展早期成为页面布局垄断技术的缘由。可以通过CSS来借用表格的显示模式，不必求诸HTML表格标记。</p><p>如果将前面导航条的例子改为对ul元素使用的一种表格显示模式，并将其中的每一项设置为表格单元，那么也会得到与使用行内块一样的效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line"><span class="attribute">table-layout</span>: fixed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line"><span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以得到相同的布局效果。</p><p><strong>注意这里将ul元素的宽度设置为100，是为了保证导航条能扩展到与父元素同宽。与常规块不同，不设置宽度的表格会“收缩适应”内容宽度，除非包含内容的单元把它撑开，让它的宽度足以填充父容器。</strong></p><p>表格行中每一列的宽度有两种算法。默认情况下，浏览器会使用“自动”算法。这是一种没有明确规定，但某种程度上又是事实标准的算法，基本上就是根据自身单元格内容所需的宽度来决定整个表格的宽度。</p><p>另一种算法是“固定”表格布局，即使用table-layout: fixed。这种算法下的列宽由表格第一行的列决定。第一行中声明的列宽具有决定性，后续行如果遇到内容较多的情况，只能折行或者溢出。</p><p>在利用表格显示模式来创建布局时，必须清楚这样也会引入表格的问题。比如，渲染为表格单元的元素无法应用外边距，给表格单元应用定位时的行为也无法预料。</p><p><strong>表格单元格中的垂直对齐</strong></p><p>使用表格显示模式时，表格单元格中的垂直对齐效果无须借助任何额外的技术。只要给显示为table-cell的元素应用vertical-align: middle，就可以令其中的内容在单元格中垂直居中。</p><h1 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h1><p>Flexbox，也就是Flexible Box Layout模块，是CSS提供的用于布局的一套新属性。这套属性包含针对容器（弹性容器，flex container）和针对其直接子元素（弹性项，flex item）的两类属性。Flexbox可以控制弹性项的如下方面：</p><ol><li>大小</li><li>流动方向，水平还是垂直，正向还是反向</li><li>两个轴向上的对齐与分布</li><li>顺序，与源代码中的顺序无关</li></ol><p>Flexbox就是为了解决行内块、浮动和表格格式对应的棘手问题而生的。</p><h2 id="浏览器支持与语法"><a href="#浏览器支持与语法" class="headerlink" title="浏览器支持与语法"></a>浏览器支持与语法</h2><p>Flexbox已经得到主流浏览器较新版本的广泛支持。对于某些需要兼容的旧版本浏览器，只要调整一下语法或提供商前缀，基本上也没问题。</p><h2 id="理解Flex方向：主轴与辅轴"><a href="#理解Flex方向：主轴与辅轴" class="headerlink" title="理解Flex方向：主轴与辅轴"></a>理解Flex方向：主轴与辅轴</h2><p>Flexbox可以针对页面中某一区域，控制其中元素的顺序、大小、分布及对齐。这个区域内的盒子可以沿两个方向排列：默认水平排列（成一行），也可以垂直排列（成一列），这个排列方式称为主轴。</p><p>与主轴垂直的方向称为辅轴，区域内的盒子可以沿辅轴发生位移或伸缩，如下图所示。通常，Flexbox布局中最重要的尺寸就是主轴方向的尺寸：水平布局时的宽度或垂直布局时的高度。主轴方向的这个尺寸为主尺寸。</p><p><img src="https://pvnk1u.github.io/images/flexboxmainandcross.PNG" alt="flexboxmainandcross"></p><p>回头再看看之前的导航条（包含链接的无序列表和容器），它很容易转换成Flex容器。假设其他样式（颜色、字体、链接、边框）都一样，那么只要一行CSS代码即可。至于列表项，无须声明任何属性，而且也不必给每一项指明宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Navbar using flexbox, no width<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">nav</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.navbar</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -webkit-flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -ms-flexbox;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -webkit-box;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -moz-box;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir Next&#x27;</span>, Avenir, Corbel, <span class="string">&#x27;Franklin Gothic&#x27;</span>, <span class="string">&#x27;Century Gothic&#x27;</span>, CenturyGothic, AppleGothic, sans-serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#486a8e</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.navbar</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-transform</span>: uppercase;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      -moz-<span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#12459e</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.navbar</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">line-height</span>: <span class="number">1.75em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">1em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/spaceships&quot;</span>&gt;</span>Spaceships<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/planets&quot;</span>&gt;</span>Planets<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/stars&quot;</span>&gt;</span>Stars<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexboxnav.PNG" alt="flexboxnav"></p><p>从上图中可以看到，链接项是水平排列的，而且根据各自的内容进行了收缩适应。结果就好像是块级文档流被旋转了90度一样。所有链接项集中在左侧，是从左到右书写的语言环境下的默认行为。如果把flex-direction改成row-inverse，那么所有链接就会集中到右侧，而且变成从右向左排列。</p><p><strong>如果不指定大小，Flex容器内的项目会自动收缩。也就是说，一行中的各项会收缩到各自的最小宽度，或者一列中的各项会收缩到各自的最小高度，以恰好可以容纳自身内容为限。</strong></p><h2 id="对齐与空间"><a href="#对齐与空间" class="headerlink" title="对齐与空间"></a>对齐与空间</h2><p>Flexbox对子项的排列有多种方式。沿主轴的排列叫排布，沿辅轴的排列叫对齐。</p><p>用于指定排布格式的属性叫justify-content，其默认值是flex-start，表示按照当前文本方向排布（也就是向左对齐）。如果改成flex-end，所有项就都会挤到右侧（变成向右对齐），但顺序不变。下面的四个图分别展示了flex-end以及另外三个关键字center、space-between和space-around的效果。</p><p><img src="https://pvnk1u.github.io/images/justify-content.PNG" alt="justify-content"></p><p>Flexbox不允许通过以上这些关键字指定个别项的排布方式。然而，对Flexbox的子项指定值为auto的外边距在这里却有不同的含义。因此，可以利用这一点。<strong>具体来说，如果指定某项一侧的外边距值为auto，而且在容器里那一侧还有空间，那么该外边距就会扩展占据可用空间。</strong>利用这一点，可以创造让一项位于一侧，其他项位于另一侧的布局。下图展示了第一项在左侧，其他项在右侧的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexbox-auto.PNG" alt="flexbox-auto"></p><p>本质上来说，像这样使用自动外边距抵消了其他项的排布效果，因为之后就没有多余空间可分了。尽管如此，对其他项仍然可以应用外边距。</p><ol><li><p>辅轴对齐</p><p>前面通过Flexbox轻松解决了水平布局的问题。实际上，Flexbox还支持对另一轴向的控制。如果增加Flex容器自身或其中一项的高度，会发现控制另一轴向属性的默认值会产生下图这种有趣的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexbox-min-height.PNG" alt="flexbox-min-height"></p><p>如图所示，默认情况下，Flex子项会沿辅轴方向填满Flex容器。好像这些子项被拉高了。实际上，控制辅轴对齐的属性align-items，其默认值是stretch（拉伸）。也就是说，子项默认拉伸，以填满可用空间。其他的关键字还有flex-start、center和flex-end，效果分别如下图所示。这3个关键字都会把子项收缩成原有大小，然后再沿辅轴进行上、中、下对齐。</p><p><img src="https://pvnk1u.github.io/images/align-items.PNG" alt="align-items"></p><p>最后，<strong>还可以使用baseline关键字，将子项中文本的基线与容器基线对齐，效果与行内块的默认行为类似。如果子项大小不一，而又希望它们在辅轴上虽然位置不同，但本身对齐，那么就可以采用这种方法。</strong></p><p>在下图中，添加了一个类名表示当前活动的项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;navbar-active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/spaceships&quot;</span>&gt;</span>Spaceships<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;planets&quot;</span>&gt;</span>Planets<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/stars&quot;</span>&gt;</span>Stars<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flex-active-item.PNG" alt="flex-active-item"></p><p>这个活动项的font-size稍大一点，而且z-index值为1.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-class">.navbar-active</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，容器的基线由较大活动项的基线决定，其他项都自动与之对齐。</p></li><li><p>对齐个别项</p><p>除了同时对齐所有项，还可以在辅轴上指定个别项的对齐方式。比如，可以让“HOME”项对齐到左上角，让其他项对齐到右下角。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">align-items</span>; <span class="attribute">flex</span>-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line"><span class="attribute">align-self</span>: flex-start;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/align-some-item.PNG" alt="align-some-item"></p></li><li><p>Flexbox中的垂直对齐</p><p>终于，Flex使得可以轻松解决垂直对齐问题了。在容器里面只有一个元素时，只要将容器设置为flex，再将需要居中的元素的外边距设置为auto就行了。这是因为Flexbox中各项的自动外边距会扩展“填充”相应方向的空间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-item&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Not so lost in space<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This item sits right in the middle of its container...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无论容器或其中元素有多大，仅需以下代码，即可实现水平垂直居中.flex-item。在这个例子中，让容器与视口一样高（在html、body和.flex-container元素上都设置了height: 100%），就是为了让效果更明显。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-container</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-item</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Flex容器中有多个元素，就像前面作者元素数据的例子一样，那么可以使用对齐属性把它们聚拢到水平和垂直中心上。为此，把排布和对齐都设置为center（当然，这也适用于单个元素的情况，只不过margin: auto的代码更少）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vertical centering using flexbox<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: Georgia, Times New Roman, serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">2em</span> <span class="number">8em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">max-width</span>: <span class="number">35em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.author-meta</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -webkit-box;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -webkit-flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -moz-box;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: -ms-flexbox;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex; <span class="comment">/* [1] */</span></span></span><br><span class="line"><span class="language-css">      -webkit-box-align: center;</span></span><br><span class="line"><span class="language-css">      -webkit-<span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">         -moz-box-align: center;</span></span><br><span class="line"><span class="language-css">          -ms-<span class="attribute">flex</span>-align: center;</span></span><br><span class="line"><span class="language-css">              <span class="attribute">align-items</span>: center; <span class="comment">/* [2] */</span></span></span><br><span class="line"><span class="language-css">      -webkit-box-pack: center;</span></span><br><span class="line"><span class="language-css">      -webkit-<span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">         -moz-box-pack: center;</span></span><br><span class="line"><span class="language-css">          -ms-<span class="attribute">flex</span>-pack: center;</span></span><br><span class="line"><span class="language-css">              <span class="attribute">justify-content</span>: center; <span class="comment">/* [3] */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.author-info</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-left</span>: <span class="number">0.5em</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.author-name</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.author-email</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;author-meta&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;author-image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/author.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Arthur C. Lark&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author-info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author-name&quot;</span>&gt;</span>Written by Arthur C. Lark<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;author-email&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mailto:arthur.c.lark@example.com&quot;</span>&gt;</span>arthur.c.lark@example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexbox-multi-center.PNG" alt="flexbox-multi-center"></p><p>在这里，使用flex-direction将author-meta内的元素排列为垂直显示，就像一列一样。所以排在行内元素img之后的文本元素author-info中的两个行内元素便被垂直排布了。</p></li></ol><h2 id="可伸缩的尺寸"><a href="#可伸缩的尺寸" class="headerlink" title="可伸缩的尺寸"></a>可伸缩的尺寸</h2><p>Flexbox支持对元素大小的灵活控制。这一点是实现精确内容布局的关键。</p><ol><li><p>相关属性</p><p>Flex的意思是“可伸缩”，这体现在以下3个容器中：flex-basis、flex-grow和flex-shrink。这3个属性应用给每个可伸缩项，而不是容器。</p><ul><li><p>flex-basis</p><p>控制项目在主轴方向上、经过修正之前的“首选”大小（width或height）。可以是长度值（如18em）、百分比（相对于容器的主轴而言），也可以是关键字auto（默认值）。</p><p>关键字auto的意思好像是把width或height设置为自动，但实际上并不是那么回事。这里auto值的意思是这个项目可以从对应的属性（width或height）那里获得主尺寸——如果设置了相应属性的话。如果没有设置主尺寸，那么该项目就根据其内容确定大小，有点类似浮动元素或行内块。</p><p>也可以设置content值，意思也是根据项目内容确定大小，但是会忽略通过width或height设置的主轴尺寸（与auto不同了）。注意，content关键字是后来才加入Flexbox的，支持程度可能不一致。</p></li><li><p>flex-grow</p><p>一个弹性系数。在通过flex-basis为每一项设置了首选大小之后，如果还有剩余空间，该系数表示该怎么处理。其值是一个数值，表示剩余空间的一个比值。这个比值的默认值是0，表示从flex-basis取得尺寸后就不再扩展。</p></li><li><p>flex-shrink</p><p>也是一个弹性系数，与flex-grow类似，但作用相反。换句话说，如果空间不够，该项如何收缩？增加了flex-shrink这个因素之后，计算过程更加复杂了。默认值是1，表示如果空间不够，所有项都会以自己的首选尺寸为基准等比例收缩。</p></li></ul><p>要理解flex-basis与flex-grow以及flex-shrink的关系并不容易。Flexbox使用了相当复杂的算法来计算各伸缩项的大小。但是，如果将计算过程简化为以下两个步骤，那么理解起来就容易多了。</p><ul><li>检查flex-basis，确定假想的主尺寸。</li><li>确定实际的主尺寸。如果按照假想的主尺寸把各项排布好之后，容器内还有剩余空间，那么它们可以伸展。伸展多少由flex-grow系数决定。相应地，如果容器装不下那么多项，则根据flex-shrink系数决定各项如何收缩。</li></ul><p>举一个例子来更好地理解这些属性。在这个例子中，假设容器宽度是1000像素。标记中，这个容器包含两个子元素。其中一个包含一个短单词（用“Short”表示），另一个包含一个长单词（用“Looooooong”表示）。因此，前者要占据200像素宽度，后者要占据400像素宽度。此时项目还没有放到容器中。</p><p><img src="https://pvnk1u.github.io/images/flex-property-example.PNG" alt="flex-property-example"></p><p>如果这两项的flex-basis值都是默认的auto，而且都没有设置width属性，那么当它们放到容器中时，它们会各自依据自身内容确定宽度（如下图），因此一共会占据600像素。这是flex-basis默认值的结果，与前面导航条中的例子一致。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">flex-basis</span>: auto; <span class="comment">/* 默认值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flex-property-example1.PNG" alt="flex-property-example1"></p><p>因为有剩余空间可分配，所以可以考虑flex-grow了。默认情况下，flex-grow的值为0，对各项的大小没有影响。假设此时把flex-flow的值设置为1会怎么样呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">flex-basis</span>: auto;</span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的0和现在的1都代表什么？它们并不表示特定的大小，而表示具体的”几份“。</p><p><strong>这个例子里有两项，结果是两项会伸展相同的距离。它们的1份表示各自分得剩余空间的一半，也就是200像素。</strong>换句话说第一项最终的宽度是400像素，第二项最终的宽度是600像素。加在一起，正好是容器的宽度，如下图所示。</p><p><img src="https://pvnk1u.github.io/images/flex-property-example2.PNG" alt="flex-property-example2"></p><p>假如给它们分别设置不同的flex-grow，类似这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会导致第一项分得剩余空间的四分之三，第二项分得四分之一。结果就是，两项各占500像素的宽度！</p><p><img src="https://pvnk1u.github.io/images/flex-property-example3.PNG" alt="flex-property-example3"></p><p>此例中的两项最终恰好平分秋色。如果希望各项能够按比例占据整个空间而不考虑各自内容，那么还有更合适的Flexbox技术，后面会介绍。</p></li><li><p>纯粹按伸缩系数计算大小</p><p>在上一节用到的“简化版Flexbox布局算法”的第一个步骤中，是根据内容宽度来确定项目宽度的，因为flex-basis的值是默认的auto，而且也没有给项目设定明确的宽度。假如第一步中flex-basis的值是0，那在这一步就不会给项目分配空间了。这种情况下，容器内部的全部空间都会留到第二步再分配，就是根据伸缩系数切分，然后将最终尺寸指定给具体的项目。</p><p>在下图中，两个项目的flex-basis值为0，flex-grow的值为1。这意味着容器的全部空间要分为两部分，从而每个项目恰好占据可分配空间的一半。这个效果很接近使用百分比计算的布局，但好在无论有多少项目，Flexbox都会自动伸缩以适应整个宽度。</p><p><img src="https://pvnk1u.github.io/images/flex-algo.PNG" alt="flex-algo"></p><p>接下来要使用flex这个简写属性一次性设置flex-grow、flex-shrink和flex-basis属性，顺序就是这样，值以空格分隔：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，最后一个flex-basis值加了百分号。这是因为简写法中的flex-basis必须带单位，因此这里要么加百分号，要么就写成0px。</p><p>如果想让第一个项目占据的空间是其他项目的2倍，就把其flex-grow值设置为2：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上规则应用给包含4项的导航条标记后，第一项占据2&#x2F;5（40%）的宽度，后三项各占1&#x2F;5（20%）的宽度，如下图所示:</p><p><img src="https://pvnk1u.github.io/images/flex-navbar-five.PNG" alt="flex-navbar-five"></p></li><li><p>收缩项目</p><p>当项目宽度总和超过容器宽度时，Flexbox会按照flex-shrink属性来决定如何收缩它们。此时的收缩机制比flex-grow稍微麻烦一些。麻烦的根源在于，不能因为某个大项目总体宽度超出，就把小项目压缩得不可见了。让项目占据更多空间（比如前面的flex-grow）比较容易理解，不过是按比例分配而已。但收缩的时候，情况就不一样了。</p><p>再以之前1000像素宽的导航条为例，假设这一次两个子项目都通过flex-basis预先设置了宽度。两项宽度的总和超出了容器宽度300像素，如下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flex-shrink1.PNG" alt="flex-shrink1"></p><p>加在一起的首选宽度（1300像素）超出了容器宽度300像素。而且两个项目的flex-shrink值都是1。看起来似乎此时两个项目会分别收缩150像素，以便适应容器宽度。然而事实并非如此。它们会根据自己flex-shrink系数和flex-basis的值来按比例收缩。具体来说，每个项目先用自己的flex-shrink乘以自己的flex-basis，然后再用乘积除以每一项的flex-shrink与flex-basis的乘积之和，最后再拿得到的比例系数去乘以超出的宽度（负空间），从而得到该项目要收缩的空间数量。</p><p>将以上几个步骤简化一下表达：首选尺寸大的项目比首选尺寸小的项目收缩的更多（相对于flex-shrink系数而言）。因此就算这里两个项目的flex-shrink系数都是1，它们收缩的量也是不一样的。以下是求第一个项目要收缩的量的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((800* 1) / ((800 * 1) + (500 * 1 )) ) * 300 = 184.6</span><br></pre></td></tr></table></figure><p>第一项要收缩184.6像素。用同一个公式计算第二项的收缩量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((500 * 1) / ((800 * 1) + (500 * 1))) * 300 = 115.4</span><br></pre></td></tr></table></figure><p>第二项要收缩115.4像素。两者相加，正好是为适应容器宽度而必须减少的300像素：</p><p><img src="https://pvnk1u.github.io/images/flex-shrink.PNG" alt="flex-shrink"></p></li></ol><h2 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h2><p>前面导航条和作者元数据的例子只涉及一行内容。与行内块和浮动类似，Flexbox也支持让内容排布到多行（列），但具有更强的可控性。</p><p>这次设计一组标签，表示星球的种类。这些标签是包含链接的一个无序列表，跟导航条例子中类似。但这里的列表项目要多出好几倍，因此不可能让它们都挤在一行中。这里会给标签设置统一的背景颜色，并使用前面评注气泡中用到的伪元素技术，给它们应用实际标签的外观。</p><p><img src="https://pvnk1u.github.io/images/flex-li-item-list.PNG" alt="flex-li-item-list"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Binary_planet&quot;</span>&gt;</span>Binary planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Carbon_planet&quot;</span>&gt;</span>Carbon planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Coreless_planet&quot;</span>&gt;</span>Coreless planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Desert_planet&quot;</span>&gt;</span>Desert planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Dwarf_planet&quot;</span>&gt;</span>Dwarf planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Earth_analog&quot;</span>&gt;</span>Earth analog<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Exoplanet&quot;</span>&gt;</span>Exoplanet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Gas_giant&quot;</span>&gt;</span>Gas giant<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Helium_planet&quot;</span>&gt;</span>Helium planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Ice_giant&quot;</span>&gt;</span>Ice giant<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Lava_planet&quot;</span>&gt;</span>Lava planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Mesoplanet&quot;</span>&gt;</span>Mesoplanet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Ocean_planet&quot;</span>&gt;</span>Ocean planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Pulsar_planet&quot;</span>&gt;</span>Pulsar planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Rogue_planet&quot;</span>&gt;</span>Rogue planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Terrestrial_planet&quot;</span>&gt;</span>Terrestrial planet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Sub-brown_dwarf&quot;</span>&gt;</span>Sub-brown dwarf<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式有点多：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir Next&#x27;</span>, Avenir, Corbel, <span class="string">&#x27;Franklin Gothic&#x27;</span>, <span class="string">&#x27;Century Gothic&#x27;</span>, CenturyGothic, AppleGothic, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tags</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#c9e1f4</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tags</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tags</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">25em</span> .<span class="number">5em</span> .<span class="number">25em</span> .<span class="number">25em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#c9e1f4</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> .<span class="number">25em</span> .<span class="number">25em</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#28448f</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right-width</span>: .<span class="number">5em</span>;</span><br><span class="line">  <span class="attribute">border-right-color</span>: <span class="number">#c9e1f4</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用上面的样式后，标签都成了行内块，可以随时折行。接下来该Flexbox上场了。首先，把列表元素转换为Flex容器，再通过flex-wrap属性的wrap值告诉它允许子元素折行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tags</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    -webkit-<span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    -ms-<span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#c9e1f4</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果跟刚才差不多。但现在可以用Flexbox来控制方向、大小和行的对齐了。</p><ol><li><p>折行与方向</p><p>首先，可以反转行中标签的排布方向（跟导航条例子中一样）。把flex-direction的值改为row-reverse，所有标签一下子就变成了从右上角起从右向左排布，每一行都变成了右对齐，如下图所示：</p><p><img src="https://pvnk1u.github.io/images/flex-li-item-list.-reverse.PNG" alt="flex-li-item-list.-reverse"></p><p>也可以通过flex-wrap反转垂直排布的方向，让第一行从底部开头，然后向上折行！</p></li><li><p>多行布局中可伸缩的大小</p><p>Flexbox对多行布局的另一个好处是，可以利用可伸缩的大小均匀填充每一行（如下图所示）。flex-grow的计算是以行为单位的，因此项目的可扩展空间以行的宽度为限。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tag</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flex-box-same-width-line.PNG" alt="flex-box-same-width-line"></p><p>此时最后一个标签另起一行后变得非常长。然而，多行Flexbox布局中没有办法控制特定的某一行。换句话说，无法告诉这些项目，让它们到了最后一行就不再扩展了。</p><p>要解决当前这个问题，可以给所有标签设置max-width，限制可伸缩的范围（如下图所示）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tags</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">margin</span>: .<span class="number">5em</span>;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">14em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexbox-max-width.PNG" alt="flexbox-max-width"></p><p>总体来说，可以填充多余空间是Flexbox的核心优势。通过综合使用flex-grow及min-width和max-width，就能实现非常智能的多行flexbox布局。无论屏幕多大，或者容器里项目有多少，所有项目都会有合理的大小。</p></li><li><p>对齐所有行</p><p>在前面介绍辅轴对齐属性（align-items和align-self）时，我们知道flexbox允许我们相对于一行的flex-start、center、baseline和flex-end这几个点来对齐项目。而在多行布局中，则可以相对于容器来对齐行或列。</p><p>如果在标签容器列表中设置了min-height: 300px，就可以知道相对于容器对齐行或列的align-content属性的效果了。默认情况下，这个属性的值是stretch，意思是每一行都会拉伸以填充自己应占的容器高度。如果通过浏览器右键菜单中“检查“来看一看标签，会发现每一个li元素都拉伸为容器高度的三分之一，如下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tags</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="comment">/* align-content: stretch; 在这里是默认值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexbox-stretch.PNG" alt="flexbox-stretch"></p><p>align-content对容器中多行的作用，与justify-content对主轴内容排布的作用非常相似。换句话说，通过align-content还可以把多行排布到flex-start（容器顶部）、flex-end（容器底部）、center（容器中部），还可以通过space-between或space-arount让多行分隔开。</p></li></ol><h2 id="列布局与个别排序"><a href="#列布局与个别排序" class="headerlink" title="列布局与个别排序"></a>列布局与个别排序</h2><p>使用Flexbox的order属性，可以完全摆脱项目在源代码中顺序的约束。只要告诉浏览器这个项目排第几就可以了。默认情况下，每个项目的order值都为0，意味着按照它们在源代码中的顺序出现。</p><p>通过Flexbox可以任意摆放项目顺序。在接下来的例子中，来创建一个小小的“文章导读”组件，其中包含飞船文章的节选，有标题、图片，还有一个阅读全文的链接。这个组件会以一列的形式出现。</p><p>首先从标记开始，组件内容的次序按照它们的重要性来排定：</p><ol><li>以文章标题为内容的标题</li><li>导读正文</li><li>与文本主题相关的插图</li><li>指向文章的链接</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>The Dragon and other spaceships<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>There are actual spaceships,</span><br><span class="line">    flying in space right now, probably. For example, there’s the International Space Station, which is </span><br><span class="line">    a spaceship of sorts. Well, actually it’s a space station, which is even cooler!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/medium_spaceship.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The Dragon spaceship in orbit around Earth.&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-more&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/spaceships&quot;</span>&gt;</span>Read the whole Spaceship article<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成后的文章导读组件如下图所示。这里为组件添加了一些基本样式，主要是外边距、颜色和字体。</p><p><img src="https://pvnk1u.github.io/images/flexbox-article1.PNG" alt="flexbox-article1"></p><p>从设计上说，把图片放在最前面可以抓住读者的眼球。但在HTML中，把图片放在第一位不一定合适。这是因为对屏幕阅读器而言，最好是一上来就拿到文章标题，然后播报给读者。</p><p>为了能让图片排在最前头，需要把.article-teaser容器转换为一个Flexbox列：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article-teaser</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，给图片一个比默认值0小的order值，让它第一个出现（如下图）：</p><p><img src="https://pvnk1u.github.io/images/flexbox-article2.PNG" alt="flexbox-article2"></p><h2 id="嵌套的Flexbox布局"><a href="#嵌套的Flexbox布局" class="headerlink" title="嵌套的Flexbox布局"></a>嵌套的Flexbox布局</h2><p>最后一个例子会展示可嵌套的Flexbox布局，以及一种非常实用的技术。</p><p>重用上面的文章导读组件的例子，但这次有两个组件，并排在一起。为此，给它们加一个包装元素，将Flexbox方向设置为row。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-group&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>The Dragon and other spaceships<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>There are actual spaceships,</span><br><span class="line">      flying in space right now, probably. For example, there’s the International Space Station, which is </span><br><span class="line">      a spaceship of sorts. Well, actually it’s a space station, which is even cooler!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- image from SpaceX on Flick: https://flic.kr/p/rzuQdb --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/medium_spaceship.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The Dragon spaceship in orbit around Earth.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-more&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/spaceships&quot;</span>&gt;</span>Read the whole Spaceship article<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Mission to mars<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-text&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a pretty cool article about spaceships flying to Mars.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- image from SpaceX on Flick: https://flic.kr/p/xGdh8d --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/medium_mars.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;A spaceship about to land on Mars.&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;article-teaser-more&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/spaceships&quot;</span>&gt;</span>Read the whole Mars article<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将包装元素设置为一个Flexbox行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article-teaser-group</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://pvnk1u.github.io/images/flexbox-group.PNG" alt="flexbox-group"></p><p>之前也看到过等高的Flexbox可伸缩项。但在可伸缩项本身又是Flexbox容器时，比如本例的情况，还得再祭出一个“终极大法”。因为两个组件虽然一样高，但它们的内容却不是。第二个组件明显短一截，“阅读详情”按钮一个高一个低，视觉上明显不平衡。Flexbox可以解决这个问题。</p><p>还记得把外边距设为auto就能让可伸缩项吃掉所有剩余空间吗？所以这里只要在“阅读详情”元素上设置margin-top: auto，就可以把它推到列的底部，让两个组件的元素在视觉上对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article-teaser-more</span>&#123;</span><br><span class="line"><span class="attribute">margin-top</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/flexbox-margin-auto.PNG" alt="flexbox-margin-auto"></p><p>如果使用之前的老技术，比如浮动、行内块和定位，那么实现这种动态内容布局肯定会相当麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网页是由不同内容块构成的：标题、段落、链接、列表、图片、视频等等。这些元素可以按照主题组织起来，比如一个标题，几段文本，外加一张图片就是一篇新闻报道。通过控制每个组件内部元素的位置、大小、顺序，就可以更好地传达它们的功能与含义。&lt;/p&gt;
&lt;p&gt;所有内容块会进一步组织成整个页</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(5)——漂亮的盒子</title>
    <link href="http://pvnk1u.github.io/2023/06/04/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E6%BC%82%E4%BA%AE%E7%9A%84%E7%9B%92%E5%AD%90/"/>
    <id>http://pvnk1u.github.io/2023/06/04/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E6%BC%82%E4%BA%AE%E7%9A%84%E7%9B%92%E5%AD%90/</id>
    <published>2023-06-04T01:28:39.000Z</published>
    <updated>2023-11-27T15:34:23.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h1><p>先从一个非常简单的例子开始：为整个页面添加背景颜色。以下代码会把页面背景设置成草绿色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#bada55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接使用更短的background属性:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#bada55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>颜色与不透明度</strong></p><p>在这个例子里，使用了十六进制表示法指定了颜色。所谓十六进制表示法，就是一个#后面加上6位十六进制数字构成的字符串。</p><p>3组数字分别表示颜色中的红、绿、蓝（RGB）通道的值。每种颜色通道的值有256种可能。如果3组数字中每组的2位数字相同，可以简写成3位数字，比如#aabbcc可以简写成#abc。</p><p>RGB值可以用另一种方式表示，即rgb()函数式表示法。RGB的每个值可以是一个十进制数值，取值范围是0-255；也可以是一个百分比值，取值范围是0-100%。用rgb()表示法表示前面例子中的背景颜色，结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">186</span>,<span class="number">218</span>,<span class="number">85</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要介绍的颜色表示法是RGB的加强版，叫rgba()。其中末尾的a表示alpha，是用于控制透明度的阿尔法通道。如果想设置同样背景颜色的背景，但透明度为50%，可以这样做：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">186</span>,<span class="number">218</span>,<span class="number">85</span>,<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四个参数值表示透明度，取值范围为0-1.0，1.0表示完全不透明，0表示完全透明。</p><h1 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h1><p>添加背景颜色可以让页面色彩更加丰富。但有时候也想使用图片作为元素的背景。CSS为实现这些目标提供了充足的工具。</p><h2 id="简单的背景图片示例"><a href="#简单的背景图片示例" class="headerlink" title="简单的背景图片示例"></a>简单的背景图片示例</h2><p>假设设计的页面要像twitter或facebook等社交网站的用户首页一样，需要显示各式各样的页头。</p><p>我们的页面是一个猫咪社交网站，如下图所示，需要包含一个大幅页头图和带个人信息的头像。</p><p><img src="https://pvnk1u.github.io/images/CatBGImg.PNG" alt="CatBGImg"></p><p>首先设置一个灰蓝色的默认背景颜色，再添加一个背景图片。<strong>添加默认背景颜色很重要，以防图片加载失败</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#8Da9cf</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">img/big-cat.jpg</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件的HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;profile-box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如图所示，图片在整个元素盒子范围内平铺，呈拼贴状：</p><p><img src="https://pvnk1u.github.io/images/CatBGImg1.PNG" alt="CatBGImg1"></p><p>为什么图片会平铺到整个元素盒子？这是由背景图片的另一个相关属性background-repeat的默认值决定的。background-repeat属性的默认值为repeat，意思是背景图片要沿x轴和y轴重复。这个特性对花纹图案的背景图片非常有用，但对照片可能就不合适了。可以明确声明repeat-x和repeat-y来限定图片只沿某个轴的方向重复，但在此要通过no-repeat完全禁止重复：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#8Da9cf</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">img/big-cat.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最新的规范重新定义了这个属性，扩展了语法。支持以空格分隔的针对两个方向的关键词声明语法。换句话说，以下声明等同于使用repeat-x：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">background-repeat</span>: repeat no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="背景图片语法"><a href="#背景图片语法" class="headerlink" title="背景图片语法"></a>背景图片语法</h1><p>回到上面的例子，开始使用JPEG格式的图片来创建个人首页的示例。目前，图片已经平铺到元素的背景上，但仍然需要调整。目前的效果如下所示：</p><p><img src="https://pvnk1u.github.io/images/CatBGImg2.PNG" alt="CatBGImg2"></p><p>可以看到现在背景图片是靠左显示的，右侧有了大量的空白。为了解决这个问题，需要设置背景图片的位置。</p><h2 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h2><p>背景图片的位置由background-position属性控制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bigger image, positioned in middle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.profile-box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#8Da9cf</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">img/big-cat.jpg</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;profile-box&quot;</span> <span class="attr">role</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，图片居中覆盖了整个元素。</p><p>background-position属性既可以使用关键字，也可以使用像素、em或百分比。最简单的情况下，可以只给两个值：一个表示相对于左侧的偏移量，一个表示相对于顶部的偏移量。</p><h2 id="背景裁剪与原点"><a href="#背景裁剪与原点" class="headerlink" title="背景裁剪与原点"></a>背景裁剪与原点</h2><p>默认情况下，背景图片是绘制到元素边框以内的。如果把背景图片定位到边框下方，而边框又被设置为半透明，那么图片边缘就会出现半透明的边框。</p><p>使用background-clip属性可以改变这个行为。这个属性的默认值为background-clip: border-box，将其改为padding-box就可以把图片裁剪到内边距盒子以内。而content-box值则会把图片位于内边距及其之外的部分裁剪掉。下面的例子展示了这三个值的区别：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Background clip example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* this default box is the same as background-clip: border-box; */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.profile-box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">img/cat.jpg</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgba</span>(<span class="number">220</span>, <span class="number">220</span>, <span class="number">160</span>, <span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.padding-box-clipped</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-clip</span>: padding-box;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content-box-clipped</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-clip</span>: content-box;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;profile-box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;profile-box padding-box-clipped&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;profile-box content-box-clipped&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相应的效果如下：</p><p><img src="https://pvnk1u.github.io/images/background-clip.PNG" alt="background-clip"></p><h2 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h2><p>背景会附着在指定元素的后面，如果滚动页面，那么背景也会随着元素移动而移动。可以通过background-attachment属性改变这种行为。如果想让示例中的大背景图在页面滚动时“粘”在页面上，可以使用如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Profile page with fixed background<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    * 1. &quot;Artificial&quot; height applied to body, just to trigger a scrollable are.</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    *    and see the effects.</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">4000px</span>; <span class="comment">/* [1] */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    * 1. Note that the positioning of the background now is in relation to the</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    *    viewport, so we can&#x27;t position it in the vertical middle of the header.</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.profile-box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">img/big-cat.jpg</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">0</span>; <span class="comment">/* [1] */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-attachment</span>: fixed;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.profile-photo</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">min-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">bottom</span>: -<span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">left</span>: <span class="number">5%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.profile-photo</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">max-width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.username</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;profile-box&quot;</span> <span class="attr">role</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;profile-photo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/profile.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Charles the Cat&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;username&quot;</span>&gt;</span>@CharlesTheCat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这种方式，可以实现随着页面滚动，头部的背景图片好像藏到了页面后面，很酷的效果。</p><h2 id="背景大小"><a href="#背景大小" class="headerlink" title="背景大小"></a>背景大小</h2><p>在上一节的例子中，使用了一张大图覆盖了整个元素。这样的话，如果是在小屏幕上，那么图片会被裁切掉。反之，如果屏幕特别大，那么元素边缘可能出现空白。要避免上述情况，不管页面怎么缩放，都让内容保持自己的宽高比，就要使用background-size属性。</p><p>给background-size明确指定一个值，可以重新设置图片大小，也可以让它随元素大小缩放而缩放。</p><p>如果还是那张大图，由于某种原因希望它显示的小一点，那么可以重新给它一个尺寸：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">400px</span> <span class="number">240px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让图片随元素缩放而缩放，则必须使用百分比值。不过要注意，<strong>百分比值并不是相对于图片固有大小，而是相对于容器大小。因此，简单地把图片宽度和高度都设置成百分比值，可能会因容器高度变化而导致图片变形。</strong></p><p>更好的做法是只给一个维度设置百分比值，另一个维度设置关键字值auto。比如，要是想让图片宽度始终保持为100%（即x轴，第一个值），同时保持自己固有的宽高比，可以这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">background</span>-box: <span class="number">100%</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>百分比值赋予了我们控制的灵活度，但也不是任何情况下都适用。有时候，我们会希望背景图片的任何一边都不要被切掉。还有一种情况比如前面简介页面的头部区域，我们希望图片始终都能完全覆盖元素。好在CSS为此也提供了一些关键字值。</p><p>首先，可以把背景大小设置为contain。这个值可以让浏览器尽可能保持图片最大化，同时不改变图片的宽高比。与前面的例子类似，但浏览器会自动决定哪一边使用auto值，哪一边使用100%。代码如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">background-size</span>: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高而窄的元素中，方形背景最多100%宽，因此垂直方向会出现空白；而在较宽的元素中，背景最多100%高，因此水平方向会出现空白。</p><p>然后，第二个关键字是cover，意思是图片会缩放以保证覆盖元素的每一个像素，同时不会变形。这正是我们希望的个人简介页面的效果。使用这个关键字，在一个高而窄的元素中，元素高度会被填满，但图片左右两边会被切掉；而在一个较宽的元素中，元素宽度会被填满，但图片上下两边会被切掉。代码如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="边框和圆角"><a href="#边框和圆角" class="headerlink" title="边框和圆角"></a>边框和圆角</h1><p>现代浏览器对边框都提供了一定的控制，包括插入图片和圆角，让边框不再是简单的矩形。</p><p>先简单回顾下边框属性。</p><ol><li>可以分别为盒子的各边设置边框，也可以一次性为四边设置边框。</li><li>可以使用border-width一次性设置所有边框的宽度，也可以使用border-top-width这样的方位属性设置某条边框的宽度。除非明确指定box-sizing属性，否则边框宽度会影响盒子的尺寸。</li><li>同理，可以使用border-color设置所有边框的颜色，也可以使用border-left-color这样的方式属性设置某条边框的颜色。</li><li>边框的样式可以使用border-style（或border-right-style这样的方位属性）来设置，取值中最常用的是solid、dashed或dotted等关键字。</li><li>最后，可以使用border简写属性来设置所有边框属性。具体来说，可以把所有边设置成相同的宽度、样式、颜色，比如border: 2px solid #000;</li></ol><h2 id="边框半径：圆角"><a href="#边框半径：圆角" class="headerlink" title="边框半径：圆角"></a>边框半径：圆角</h2><p>给border-radius属性一个长度值，就可以一次性设置盒子四个角的半径。下面给简介页面添加一个头像，让包含头像的元素拥有圆角。首先是标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Profile with border radius&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">      font-family: &quot;Helvetica Neue&quot;, Arial, sans-serif;</span><br><span class="line">      background-color: #ddd;</span><br><span class="line">    &#125;</span><br><span class="line">    .profile-box &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      height: 600px;</span><br><span class="line">      background-image: url(img/big-cat.jpg);</span><br><span class="line">      background-size: cover;</span><br><span class="line">      background-position: 50% 30%;</span><br><span class="line">      border-bottom: 1px solid #666;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .profile-photo &#123;</span><br><span class="line">      width: 160px;</span><br><span class="line">      min-height: 200px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: -60px;</span><br><span class="line">      left: 5%;</span><br><span class="line">      padding: .5em;</span><br><span class="line">      -webkit-border-radius: .5em;</span><br><span class="line">              border-radius: .5em;</span><br><span class="line">      background-color: #fff;</span><br><span class="line">      border: 1px solid #777;</span><br><span class="line">  border-radius: 0.5em;</span><br><span class="line">    &#125;</span><br><span class="line">    .profile-photo img &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      max-width: 100%;</span><br><span class="line">      height: auto;</span><br><span class="line">    &#125;</span><br><span class="line">    .username &#123;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">      color: #666;</span><br><span class="line">      margin: .35em 0 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;header class=&quot;profile-box&quot; role=&quot;banner&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;profile-photo&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;img/profile.jpg&quot; alt=&quot;Charles the Cat&quot;&gt;</span><br><span class="line">      &lt;h1 class=&quot;username&quot;&gt;@CharlesTheCat&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这段代码里，首先设置了父header容器的定位为相对定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-box</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="comment">/* 其他代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置了头像元素.profile-photo的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.profile-photo</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">      <span class="attribute">min-height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">bottom</span>: -<span class="number">60px</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">5%</span>;</span><br><span class="line">      <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">      -webkit-<span class="attribute">border-radius</span>: .<span class="number">5em</span>;</span><br><span class="line">              <span class="attribute">border-radius</span>: .<span class="number">5em</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#777</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这里，必须要先设置父header容器的定位为relative相对定位，子元素头像元素profile-photo的定位才会生效。这是因为：在父元素没有设置相对定位或绝对定位的情况下，子元素设置absolute绝对定位时是相对于根元素（即HTML元素）来定位的。当父元素设置了相对或绝对定位，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位。</strong>定位设置完成后，又通过border设置了头像元素边框的宽度及颜色，并通过border-radius设置边框样式为圆角。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景颜色&quot;&gt;&lt;a href=&quot;#背景颜色&quot; class=&quot;headerlink&quot; title=&quot;背景颜色&quot;&gt;&lt;/a&gt;背景颜色&lt;/h1&gt;&lt;p&gt;先从一个非常简单的例子开始：为整个页面添加背景颜色。以下代码会把页面背景设置成草绿色：&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(4)——网页排版</title>
    <link href="http://pvnk1u.github.io/2023/06/03/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88/"/>
    <id>http://pvnk1u.github.io/2023/06/03/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88/</id>
    <published>2023-06-03T01:28:39.000Z</published>
    <updated>2023-11-27T15:34:23.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS的基本排版技术"><a href="#CSS的基本排版技术" class="headerlink" title="CSS的基本排版技术"></a>CSS的基本排版技术</h1><p>拿到一个页面时，几乎所有设计师都会先考虑从基本的版式着手。从body元素开始，逐步细化，从而让整个页面具有基本的可行性、层次性和配色。接下来的例子就以此为目标：实现一个示例页面的基本版式。</p><p>下面的代码展示了一个非常简单的HTML文档，没有添加任何样式。此时的网页内容并没有乱作一团，这是因为浏览器有默认样式表，它为网页应用了一些必要的排版规则。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>A Simple Document About the Moon<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>The Moon<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Moon<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> (in Greek: σελήνη <span class="tag">&lt;<span class="name">i</span>&gt;</span>Selene<span class="tag">&lt;/<span class="name">i</span>&gt;</span>, in Latin: <span class="tag">&lt;<span class="name">i</span>&gt;</span>Luna<span class="tag">&lt;/<span class="name">i</span>&gt;</span>) is Earth’s only natural satellite. It is one of the largest natural satellites in the Solar System, and, among planetary satellites, the largest relative to the size of the planet it orbits (its primary). It is the second-densest satellite among those whose densities are known (after Jupiter&#x27;s satellite Io).<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The Moon is thought to have formed approximately 4.5 billion years ago, not long after Earth. There are several hypotheses for its origin; the most widely accepted explanation is that the Moon formed from the debris left over after a giant impact between Earth and a Mars-sized body called Theia.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Orbit<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The Moon is in synchronous rotation with Earth, always showing the same face with its near side marked by dark volcanic maria that fill between the bright ancient crustal highlands and the prominent impact craters. It is the second-brightest regularly visible celestial object in Earth’s sky after the Sun, as measured by illuminance on Earth’s surface.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Although it can appear a very bright white, its surface is actually dark, with a reflectance just slightly higher than that of worn asphalt. Its prominence in the sky and its regular cycle of phases have, since ancient times, made the Moon an important cultural influence on language, calendars, art, and mythology.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Gravitational pull <span class="symbol">&amp;amp;</span> distance<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The Moon’s gravitational influence produces the ocean tides, body tides, and the slight lengthening of the day. The Moon’s current orbital distance is about thirty times the diameter of Earth, causing it to have an apparent size in the sky almost the same as that of the Sun, with the result that the Moon covers the Sun nearly precisely in total solar eclipse. This matching of apparent visual size will not continue in the far future. The Moon’s linear distance from Earth is currently increasing at a rate of 3.82 ± 0.07 centimetres per year, but this rate is not constant.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Lunar travels<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The Soviet Union’s Luna programme was the first to reach the Moon with unmanned spacecraft in 1959; the United States’ <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;National Aeronautics and Space Administration&quot;</span>&gt;</span>NASA<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> Apollo program achieved the only manned missions to date, beginning with the first manned lunar orbiting mission by Apollo 8 in 1968, and six manned lunar landings between 1969 and 1972, with the first being Apollo 11. These missions returned over 380 <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;kilograms&quot;</span>&gt;</span>kg<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> of lunar rocks, which have been used to develop a geological understanding of the Moon&#x27;s origin, the formation of its internal structure, and its subsequent history. After the Apollo 17 mission in 1972, the Moon has been visited only by unmanned spacecraft.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;source&quot;</span>&gt;</span>Text fetched from <span class="tag">&lt;<span class="name">cite</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://en.wikipedia.org/wiki/Moon&quot;</span>&gt;</span>“Moon” article on Wikipedia<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">cite</span>&gt;</span> on <span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2016-02-23&quot;</span>&gt;</span>the 23<span class="tag">&lt;<span class="name">sup</span>&gt;</span>rd<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> of February<span class="symbol">&amp;nbsp;</span>2016.<span class="tag">&lt;/<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个简单的文档包含几个标题和一些段落（段落文本中有一些行内元素，以便必要时添加样式），它们都包含在一个article元素中。这个没添加样式的网页虽然勉强能看，但效果非常不理想。我们的目标是以相对较少的样式来提升页面的易读性，并且让它变得更美观。</p><p>下面逐条分析要添加的规则，同时介绍相关术语，设置规则的原因，以及所涉及的排版属性背后的原理。</p><h2 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h2><p>默认情况下，浏览器会把绝大多数文本渲染为黑色，白底黑字的对比度极高。足够高的对比度是确保网页阅读无障碍的关键，但也往往会被过度强调。事实上，由于屏幕的高对比度，白底黑字会让大段文本显得过分密集，反而影响可读性。</p><p>对于上面的例子而言，标题仍然保持黑色，但正文要改成深蓝灰色。链接还是蓝色，但需要把“活力值”下调一点。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#3b4348</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#235ea7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h2><p>字体族（font-family）属性的值是一个备选字体的列表，按优先级从左到右排列：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">&#x27;Georgia Pro&#x27;</span>,Georgia,Times,<span class="string">&#x27;Time New Roman&#x27;</span>,serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>: Avenir Next,SegoeUI,arial,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段CSS分别指定了body元素（以及几乎其他所有元素）和标题（h1、h2….）依次使用的字体，如果前面的字体在对应的操作系统中不存在的话，则依次尝试使用后面的字体。</p><h2 id="字体大小与行高"><a href="#字体大小与行高" class="headerlink" title="字体大小与行高"></a>字体大小与行高</h2><p>几乎所有浏览器中font-size的默认大小都是16像素，除非用户修改过偏好设置。这里不修改默认的font-size，而是选择使用em单位调整特定元素的大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.314em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>em单位用于font-size属性时，实际上是一个相应元素继承的font-size缩放因子。比如这里的h3元素，字型大小就是1.314*16&#x3D;21px。虽然可以直接设置21px，但em更灵活一些。多数浏览器都允许用户缩放整个页面，即使像素单位也可以缩放。而使用em之后，如果用户修改偏好中的默认font-size大小，那么相应元素的大小也会调整。</p><h2 id="行间距、对齐和行盒子的构造"><a href="#行间距、对齐和行盒子的构造" class="headerlink" title="行间距、对齐和行盒子的构造"></a>行间距、对齐和行盒子的构造</h2><p>随着给文本施加更多的控制，各种排版概念之间的关系便浮出水面。为了掌握这些概念，有必要深入理解CSS行内格式化模型，同时多理解一些排版术语。下图展示了一行文本的各个部分，这里仅以示例中第一段开头的两个词为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Moon<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>...[etc]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/LineFormattedModel.PNG" alt="LineFormattedModel"></p><p>每行文本都会生成一个行盒子。行盒子还可以进一步拆分成表示行内元素（比如上面例子中的strong元素）的行内盒子，或者连接两个行内元素的匿名行内盒子。</p><p>行内盒子中的内容区显示文本。内容区的高度由font-size的测量尺度，即图中的”Moon”末尾那个1em见方的块，以及这个块与字形本身的关系来决定。</p><p>行高指的是行盒子的总高度。更通俗的叫法是行间距，排版术语叫铅空，就是排字员用来分隔字符行的铅块。但与传统排版不同，CSS中的“铅空”始终都会同时应用到行盒子的上方和下方。</p><p>计算方法如下：行盒子的整体行高减去font-size，得到的值再平分成两份，也就是半铅空。如果line-height是30像素，而font-size是21像素，那么半铅空就是4.5像素。</p><ol><li><p>设置行高</p><p>设置行高时，需要考虑当前字体大小。在这个例子中，对于Georgia这个font-family，给body设置的line-height值为1.5：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>: Georgia,Times,<span class="string">&#x27;Times New Roman&#x27;</span>,serif;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于行与行之间既不能太密，也不能太疏。对于较大的字体，行间距应该稍大一点。文本的长度和font-size也要考虑，短文本一般设置较小的line-height。</p><p>这里给line-height设置了没有单位的值1.5，意思就是当前font-size的1.5倍。body的font-size为16px，那么默认的line-height就是24px；</p></li><li><p>垂直对齐</p><p>除了line-height，行内盒子也会受到vertical-align属性的影响。它的默认值是baseline，即子元素的基线与父元素的基线对齐。在示例文章的末尾，有一个日期，其中的序数后缀“rd”包含在一个span中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2016-02-23&quot;</span>&gt;</span>the 23<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;ordinal&quot;</span>&gt;</span>rd<span class="tag">&lt;/<span class="name">span</span>&gt;</span>of February 2016.<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样可以通过vertical-align将其设置为上标文本，即使用super关键字（字号也小一些）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ordinal</span>&#123;</span><br><span class="line"><span class="attribute">vertical-align</span>: super;</span><br><span class="line"><span class="attribute">font-size</span>: smaller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="文本粗细"><a href="#文本粗细" class="headerlink" title="文本粗细"></a>文本粗细</h2><p>使用font-weight属性可设置标题文本的粗细。有些字体的变体很多，此时，可以不用给出变体的名字，而只使用关键字：normal、bold、bolder和lighter。也可以直接给出数字值，都是100的整数倍：100、200、300、400等等，最大为900。</p><p>默认值normal对应400，bold对应700，这两个粗细值是最常用的。关键字bolder和lighter的工作机制略有不同，它们的作用是在继承值的基础上把文本变粗或变细。</p><p>作为标题的默认值，这里使用了数字值500，而对h1和h2分别使用了超粗和中粗：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span>&#123;</span><br><span class="line"><span class="attribute">font-weight</span>:<span class="number">600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="行长、律动和毛边"><a href="#行长、律动和毛边" class="headerlink" title="行长、律动和毛边"></a>行长、律动和毛边</h1><p>接下来探讨一个对阅读体验有着重大影响的因素：行长。过长或过短的文本会打断人的眼球移动，导致读者无法连续阅读，最后甚至读不下去。</p><p>主体内容的文本行长通常是45-75个字符，平均值为66个字符。排版专家发现这个建议同样适用于今天的网页，特别是大屏幕中的网页。对于小屏幕而言，行长至少也应该有40个字符。</p><p>要控制行长，可以通过设定包含文本的段落、标题等元素的宽度来实现。</p><p>对于页面主体文本而言，Georgia字体的字母相对较宽，因此行长就要考虑使用前述范围的上限。为此，简单地将article元素的宽度设置为36em（平均每个字符0.5em），并令其在页面上居中。如果视口缩小到比这个值更窄，该元素会自动调整宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>&#123;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">36em</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文本缩进与对齐"><a href="#文本缩进与对齐" class="headerlink" title="文本缩进与对齐"></a>文本缩进与对齐</h2><p>默认情况下，文本是左对齐的。文本左对齐有助于眼睛找到下一行，保持阅读节奏。对于连续的段落，或者为相邻段落设置一行的外边距，或者设置首段缩进。在此选择后一种方案，使用相邻组合符设置text-indent属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">text-indent</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相邻兄弟选择器</strong> (<code>+</code>) 介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父elment的子元素，则第二个元素将被选中。</p><p>这段代码将对相邻文本中的第二段文本设置文本缩进。</p><p>同时再居中显示h1元素，以及给它添加一个底部边框，从而让它能跟下面的文本连成一体：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#c8bc9d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>text-align属性可以接受下列任意一个关键字值：left、right、center和justify。</p><h2 id="多栏文本"><a href="#多栏文本" class="headerlink" title="多栏文本"></a>多栏文本</h2><p>把整篇文章宽度都限制在36em可以达到限制行长的目的，但是对于大屏幕而言，却又太浪费空间了，留着大片的空白很可惜。有时候，为了有效利用宽屏，可以把文本分成多栏，并对每栏的宽度加以限制。</p><p>如果把之前设置的max-width增加到70em，那么可以分成3栏。为此，要把columns属性设置为想要的最小宽度。栏间距通过column-gap属性控制：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>&#123;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">70em</span>;</span><br><span class="line"><span class="attribute">columns</span>: <span class="number">20em</span>;</span><br><span class="line">coumn-<span class="attribute">gap</span>:<span class="number">1.5em</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的columns属性是column-count和column-width属性的简写形式。如果只设置column-count属性，浏览器会严格生成指定数量的栏，不管宽度如何。如果同时设置了column-count和column-width，则前者会作为最大栏数，后者会作为最小栏宽。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">columns</span>: <span class="number">20em</span>; <span class="comment">/* 在保证最小宽度20em的前提下，自动设置栏数 */</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">column-width</span>: <span class="number">20em</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"> <span class="attribute">columns</span>:<span class="number">3</span> <span class="comment">/* 3栏，自动设置宽度 */</span></span><br><span class="line"> </span><br><span class="line"> columns-count: <span class="number">3</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"> </span><br><span class="line"> <span class="attribute">columns</span>: <span class="number">3</span> <span class="number">20em</span>; <span class="comment">/* 至少3栏，每栏宽度至少20em */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 以下两条声明的组合相当于以上代码的简写形式 */</span></span><br><span class="line"> <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line"> <span class="attribute">column-width</span>: <span class="number">20em</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS的基本排版技术&quot;&gt;&lt;a href=&quot;#CSS的基本排版技术&quot; class=&quot;headerlink&quot; title=&quot;CSS的基本排版技术&quot;&gt;&lt;/a&gt;CSS的基本排版技术&lt;/h1&gt;&lt;p&gt;拿到一个页面时，几乎所有设计师都会先考虑从基本的版式着手。从body元素开始</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(3)——可见格式化模型</title>
    <link href="http://pvnk1u.github.io/2023/05/30/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/"/>
    <id>http://pvnk1u.github.io/2023/05/30/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-05-30T06:34:39.000Z</published>
    <updated>2023-11-27T15:34:23.886Z</updated>
    
    <content type="html"><![CDATA[<p>浮动、定位和盒模型是学习CSS需要掌握的几个最重要的概念。这几个概念决定了元素在页面上排布和显示的方式，是很多布局技术的基础。搞清楚盒模型的各方面细节，绝对和相对定位的区别，以及浮动及清除的原理之后，使用CSS设计网站会变得更简单、更轻松。</p><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>盒模型是CSS的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作一个矩形盒子，这个盒子包含元素的内容、内边距、边框和外边距。</p><p>内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不致于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。</p><p>有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不会影响盒子的宽度和高度。因此，outline常用于调试复杂布局，或者演示布局效果。</p><p>盒模型如下图所示：</p><p><img src="https://pvnk1u.github.io/images/BoxModel.PNG" alt="BoxModel"></p><p>对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。当然，可以覆盖这些样式，要么在自己的样式表里覆盖，要么直接引用重置样式表。</p><h2 id="盒子大小"><a href="#盒子大小" class="headerlink" title="盒子大小"></a>盒子大小</h2><p>默认情况下，元素盒子的width和height属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加5像素的边框和5像素的内边距，同时又想让元素盒子的宽度为100像素，则应该像下面这样把内容区宽度设置为80像素。如果这个元素盒子周围还有10像素的外边距，那么整个盒子占据空间的宽度就是120像素（如下图所示）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mybox</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/WidthBoxModelDemo.PNG" alt="WidthBoxModelDemo"></p><p>通过修改box-sizing属性可以改变计算盒子大小的方式。box-sizing的默认值为content-box，即前面例子中看到的那样，把宽度值应用给内容区。通过修改box-sizing的值，设置元素的width和height属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。</p><p>如果把box-sizing的值修改为border-box，那么width和height属性的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到width中。这样，如下代码可以实现与上面的图一样的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mybox</span>&#123;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/BoxSizingDemo.PNG" alt="WidthBoxModelDemo"></p><p>在很多情况下这都很有用，因为很多情况下，这种计算盒子大小的方式更加直观。之所以说这种计算方式“直观“，是因为现实中的盒子就是这样测量的。</p><p>如果把CSS中的盒子想象成一个包装箱，那么箱子的四壁就是边框，从视觉上规定了箱子的大小；内边距就是箱子内部的填充层，用于保护箱子里的物品。在箱子宽度既定的情况下，无论是加厚箱壁还是增加填充层厚度，都会挤压最终可用于盛放物品的空间。这样在码放箱子时，不管它们之间空出多大距离（对应CSS中的外边距），都不会影响箱子本身的宽度，以及箱子内部可用的空间。总之，这是一个有实物可以参照的方案。但是浏览器开发人员决定默认采用另一种方式来计算CSS盒模型的宽度，这实际上并不明智。</p><p>好在可以通过设置box-sizing属性来覆盖默认行为，简化CSS布局中的一些常用模式。举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;group&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">article</span> class=&quot;block&quot;&gt;</span><br><span class="line">&lt;/<span class="selector-tag">article</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，如果想让.group中的.block宽度在任何情况下都占其父元素的1&#x2F;3，可以使用以下规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.group</span> <span class="selector-class">.block</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">33.3333%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要不给.block应用内边距，这样写就没问题。但如果给.block添加了内边距，它的宽度就会变成.group元素的1&#x2F;3外加应用给它的内边距。如果这是一个三栏布局，那么此时添加内边距很可能会破坏原有布局。下图展示了添加内边距前后的不同之处：</p><p><img src="https://pvnk1u.github.io/images/PaddingDiff.PNG" alt="PaddingDiff"></p><p>要解决这个问题，可以再增加一个内部元素，然后改为给这个元素添加内边距。或者，可以设置一个不同的box-sizing值，从而修改盒子宽度的计算方式(如下图所示)：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.group</span> <span class="selector-class">.block</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">33.3333%</span>;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/BorderBoxBlock.PNG" alt="BorderBoxBlock"></p><p>此时，无论添加多少内边距和边框，.block的宽度始终保持为其父元素的1&#x2F;3。</p><p>内边距、边框和外边距可以应用于元素的四边，也可以应用于具体某一边。外边距甚至还可以使用负值，使得元素可以在页面中移动。</p><p>内边距和外边距的值可以是CSS规范中规定的任意长度单位（px、em或百分比）。其中，使用百分比长度时，有几个问题需要注意。假设还是前面的那个例子，下面代码中的5%到底是什么意思？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里5%指的是父元素.group宽度的5%。如果.group宽度是100像素，那么这里左外边距的宽度就是5像素。</strong></p><p>如果给一个元素的顶部和底部应用内、外边距，那么使用百分比值应该基于元素的高度来计算，对吧？错，因为元素的高度常常不会被声明，而且会因内容多少而差异很大，所以CSS规定，上、下方位的内、外边距，仍然基于包含块的宽度来计算。这里，包含块就是其父元素，但有时候不一定。具体会在后面详细说明。</p><h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><p>有时候，特别是响应式布局中，给一个元素应用min-width和max-width值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比min-width指定的值更窄，或者扩展到比max-width指定的值更宽。</p><p>与此类似的是min-height和max-height属性。不过在CSS中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即便出于种种原因，需要明确设定默认高度，也最好使用min-height，因为这个属性允许盒子随内容扩展。</p><h1 id="可见格式化模型"><a href="#可见格式化模型" class="headerlink" title="可见格式化模型"></a>可见格式化模型</h1><p>有了对盒模型的理解，下一步就可以探讨可见格式化及定位模型了。</p><p>大家常说p、h1盒article这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子的形式。相对而言，strong、span和time被称为行内元素，因为它们的内容会以行内盒子的形式显示在行内。</p><p>可以使用display属性改变生成的盒子类型。换句话说，可以通过把display属性设置为block，让span变得跟块级元素一样。如果把display属性设置为none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。</p><p>CSS中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有元素盒子都会在常规文档流中生成，即position属性的默认值为static。顾名思义，常规文档流中元素盒子的位置，由元素在HTML中的位置决定。</p><p>块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。</p><p>行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但<strong>行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。</strong></p><p><strong>由一行文本形成的水平盒子叫行盒子（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。</strong>下图展示了一个段落的块级盒子及其包含的两行文本，其中有一个单词位于显示为行内盒子的strong元素中。</p><p><img src="https://pvnk1u.github.io/images/LineBoxInBlockBox.PNG" alt="LineBoxInBlockBox"></p><p>当然，也可以把元素的display属性设置为inline-block。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。</p><p>使用表格相关的标记（table、tr、th等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置display属性让非表格元素采用表格的布局方式。只要正确地应用table、table-row和table-cell等值，就可以实现表格布局，无须在HTML标记中使用表格标签。</p><p>Flexible Box Layout（也称为Flexbox）和Grid Layout等CSS模块，又进一步扩展了display属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。</p><p>在Display Level3模块中，上述外部和内部显示模式的差异正在标准化。在这个模块中，既有显示模式的相关属性和关键字都是可扩展的，从而支持更细粒度的控制。但无论如何，行内盒子和块级盒子仍然是HTML元素默认行为的基础，只是显示当中有了更多选项。</p><h2 id="匿名盒子"><a href="#匿名盒子" class="headerlink" title="匿名盒子"></a>匿名盒子</h2><p>HTML元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在section这个块级元素的开头加入”some text“。此时，”some text“就算没有定义为块级元素，也会被当成块级元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">some text</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> some more text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下，这个盒子被称为匿名块盒子，因为这个盒子并不与任何特定的元素相关。</p><p>类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子。除了使用.first-line伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。关键要知道，在屏幕上看到的一切都会从属于某个盒子。</p><h2 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h2><p>常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，但实践中常常给布局网页带来困惑。<strong>简而言之，垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度。</strong></p><p>如下图所示，当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。</p><p><img src="https://pvnk1u.github.io/images/FoldableMargin.PNG" alt="FoldableMargin"></p><p>在一个元素嵌套着另一个元素的情况下，假设没有内边距或边框来分隔外边框，它们的上、下外边距也会折叠。</p><p><img src="https://pvnk1u.github.io/images/FoldableMarginInBox.PNG" alt="FoldableMarginInBox"></p><p>乍一看，这种情况不太正常，但事实还不止如此：甚至同一个元素的外边距都能折叠。假设有一个空元素，只有外边距而没有边框或内边距。此时，上外边距与下外边距接触，结果也会折叠：</p><p><img src="https://pvnk1u.github.io/images/FoldableMarginInEmpty.PNG" alt="FoldableMarginInEmpty"></p><p>更进一步，如果折叠后的外边距又碰到了其他元素的外边距，还会继续折叠。</p><p><img src="https://pvnk1u.github.io/images/ContinueFoldMargin.PNG" alt="ContinueFoldMargin"></p><p>这就是再多的空段落也只会占用一小块空间的原因：它们的外边距都折叠成一个小外边距了。</p><p>外边距折叠好像很奇怪，实际上却很有用。以一个包含几段文本的页面为例：</p><p><img src="https://pvnk1u.github.io/images/ReasonOfMargenFold.PNG" alt="ReasonOfMargenFold"></p><p>这一段上方的间距等于这一段的上外边距。如果没有外边距折叠，则后续所有段落的间距，都是相邻的上、下外边距之和。结果就是段间距是上页边距的两倍。有了外边距折叠，段间距才会与页边距相等。</p><p>外边距折叠只会发生在文档常规文本流中块级盒子的垂直方向上。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。</p><h2 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h2><p>知道什么决定一个元素的包含块非常重要，前面的例子中，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。</p><p>确定元素的包含块，要看元素是如何定位的。<strong>如果元素的定位方式为静态定位（即不指定position属性的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的display属性值必须能够提供类似块级的上下文，如block、inline-block、table-cell、list-item等。</strong></p><p><strong>默认情况下，width、height、margin和padding的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了absolute或fixed，那么计算依据就会发生变化。</strong>接下来逐个讨论不同的定位模型，以及如何确定与之对应的包含块。</p><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>把一个元素的display属性设置为relative，该元素仍然会呆在原来的地方。但此后，可以通过设置top、right、bottom和left属性，使该元素相对于初始位置平移一段距离。比如设置top属性为20像素，该元素就会相对于其初始位置垂直向下平移20像素。而设置left属性为20像素，则会将该元素向右移动20像素，其左侧会出现空白。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mybox</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/relative.PNG" alt="relative"></p><p>无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致遮挡其他元素。</p><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，彷佛绝对定位的那个元素没有存在过一样。</p><p><img src="https://pvnk1u.github.io/images/AbsolutePosition.PNG" alt="AbsolutePosition"></p><p><strong>绝对定位元素的包含块是距离它最近的定位祖先，也就是display属性设置为static之外任意值的祖先元素。如果没有这么一个定位祖先，那么它就相当于文档的根元素即html元素定位。文档的根元素也叫作起始包含块。</strong></p><p>与相对定位的盒子类似，绝对定位的盒子也可以相对于其包含块向上、下、左、右方向平移。平移绝对定位的元素提供了极大的灵活性，因为可以把元素移动到页面的任意位置。</p><p><strong>绝对定位的盒子是脱离了常规文档流的，因此可能会遮挡页面上的其他元素。为了控制这些盒子层叠的次序，可以设置一个叫z-index的属性。z-index的属性值越大，盒子在层叠中的次序就越靠近用户的眼睛。</strong></p><p>尽管绝对定位对于在页面上任意摆放元素非常有用，但近来已经很少被用来构建整体布局了。绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。web技术的特点决定了不太可能指定元素在页面上的确切位置和大小。绝对定位在整体布局上几乎没人用了。</p><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><p>固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport）。因此，固定定位可以用来创建始终停留在窗口相同位置的浮动元素。很多网站都用这个技术让导航区始终保持可见，有的固定侧栏，有的固定顶栏。这样能确保网站的可用性，因为用户不必再费事寻找了。</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>另一种可见格式化模型是浮动模型。浮动盒子可以向左或向右移动，直到其外边沿接触包含块的外边沿，或接触另一个浮动盒子的外边沿。浮动盒子也会脱离常规文档流，因此常规流中的其他块级盒子的表现，几乎当浮动盒子根本不存在一样。</p><p>如下图所示，向右浮动Box1时，Box1会脱离文档流并向右移动，直至其右边沿接触包含块的右边沿。同时，Box1的宽度也会收缩为适应于其中内容的最小宽度，除非通过width或min-width&#x2F;max-width明确设置其宽度。</p><p><img src="https://pvnk1u.github.io/images/FloatBox.PNG" alt="FloatBox"></p><p>如下图所示，向左浮动Box1时，它脱离文档流并向左浮动，直至其左边接触包含块的左边沿。Box1已经不在文档流中，因此不会再占用空间，这导致它浮于上方，遮住了Box2。如果向左浮动全部3个元素，Box1会向左移动，直到接触其包含块；另外两个盒子也向左移动，直到接触自己前面的浮动盒子。</p><p><img src="https://pvnk1u.github.io/images/MoreFloatBox.PNG" alt="MoreFloatBox"></p><p>如果包含元素太窄，无法容纳所有浮动元素水平排列，则后面的浮动元素会向下浮动（如下图）。如果浮动元素高度不同，则后面的浮动元素在向下移动时可能会“卡”在前面的浮动元素右侧。</p><p><img src="https://pvnk1u.github.io/images/FloatBoxToBottom.PNG" alt="FloatBoxToBottom"></p><p><strong>行盒子与清除</strong></p><p>前面说到，浮动元素会脱离文档流，因此不会再像非浮动元素一样影响其他元素。实际上，严格来讲并非如此。如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就会当浮动元素不存在一样，该怎么布局就怎么布局。但是，这个元素盒子中的文本内容则会记住浮动元素的大小，并在排布时避开它，为其留出相应的空间。从<strong>技术上来讲，就是跟在浮动元素后面的行盒子会缩短，从而为浮动元素留空，造成文本环绕浮动盒子的效果。事实上，浮动就是为了在网页中实现文本环绕图片的效果而引入的一种布局模型。</strong>如下图所示：</p><p><img src="https://pvnk1u.github.io/images/DocAroundFloatBox.PNG" alt="DocAroundFloatBox"></p><p>要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的元素应用clear属性。clear属性的值有left、right、both和none，用于指定盒子的哪一侧不应该紧挨着浮动盒子。很多人认为clear属性只是简单地删除几个用于抵消前面浮动元素的标记，事实却没有这么简单。清除一个元素时，浏览器会在这个元素上方添加足够大的外边距，从而将元素的上边沿垂直向下推移到浮动元素下方(如下图所示)。因此，如果给“已清除的”元素添加外边距，那么除非外边距的值超过浏览器自动添加的值，否则不会看到什么效果。</p><p><img src="https://pvnk1u.github.io/images/ClearFloat.PNG" alt="ClearFloat"></p><p>浮动元素除了会导致后面的行盒子缩短，从而造成文本环绕效果外，不会对周围的元素有任何别的影响，毕竟它已经脱离了文档流。但清除一个元素本质上会为所有前面的浮动元素清理出一块垂直空间。这就为使用浮动布局创造了条件，因为周围的元素可以为浮动的元素腾出地方来。</p><p>下面看看怎么利用浮动实现一个简单的布局。假设想把一张图片浮动到一个标题左边，把一小段文本浮动到标题右边。这种布局一般叫作“媒体对象”。因为左侧放一个媒体（如插图、图片或视频）、右侧放一段说明文字是一种常见的布局模式。另外，如果希望这张图片及右侧的文本被包含在另一个有背景颜色和边框的元素中。那么可以写出如下规则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>FloatDemo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.media-block</span>&#123;</span></span><br><span class="line"><span class="language-css">backgroud-<span class="attribute">color</span>: gray;</span></span><br><span class="line"><span class="language-css"><span class="attribute">border</span>: solid <span class="number">1px</span> black;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.media-fig</span>&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">30%</span>; <span class="comment">/* 给文本留出70%的宽度 */</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.media-body</span>&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">65%</span>; <span class="comment">/* 左边再留出一点空隙来 */</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-block&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;media-fig&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/img/pic.jpg&quot;</span>  <span class="attr">alt</span>=<span class="string">&quot;The pic&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-body&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Title of this<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Brief description of this<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，浮动的元素会被拿出文档流，因此类为.media-block的div不会占用空间：它只包含浮动的内容，因此无法在文档流中为它生成高度。怎样才能让这个元素从视觉上也包住浮动元素？需要在这个元素内部某处应用clear。这样就会像前面看到的一样，在清除的元素上方创造出足够的垂直外边距，从而为包住浮动元素创造出空间（如下图）。然而，由于这个例子中没有用来清除的元素，需要在结束后的div标签前额外加一添加一个空元素，然后清除该元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 后补的CSS */</span><br><span class="line">.clear&#123;</span><br><span class="line">clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-block&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;media-fig&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/img/pic.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The pic&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-body&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Title of this<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Brief description of this<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 额外添加的空div --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/ClearFloatToAround.PNG" alt="ClearFloatToAround"></p><p>这样就实现了想要的布局，但也引入了“多余”的标记。有时候可能会有现成的元素用于清除，但有时候就不得不像这里一样，额外加入与布局没什么关系的标记。其实还有更好的方法。</p><p>要改进这个例子，可以使用:after伪类来模拟额外的清除元素。把下面的规则应用给包含浮动元素的容器div，就会在它内部的末尾生成一个盒子，并在这个盒子上应用清除规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">&lt;title&gt;FloatDemo&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-class">.media-block</span>&#123;</span><br><span class="line">backgroud-<span class="attribute">color</span>: gray;</span><br><span class="line"><span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.media-fig</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">30%</span>; <span class="comment">/* 给文本留出70%的宽度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.media-body</span>&#123;</span><br><span class="line"><span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">65%</span>; <span class="comment">/* 左边再留出一点空隙来 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.media-block</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">clear</span>: both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;media-block&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">img</span> class=&quot;media-fig&quot; <span class="attribute">src</span>=&quot;./BoxModel<span class="selector-class">.PNG</span>&quot;  alt=&quot;The pic&quot; /&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;media-<span class="selector-tag">body</span>&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">h3</span>&gt;Title of this&lt;/<span class="selector-tag">h3</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;Brief description of this&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="格式化上下文"><a href="#格式化上下文" class="headerlink" title="格式化上下文"></a>格式化上下文</h2><p>当元素在页面上水平或垂直排布时，它们之间如何相互影响，CSS有几套不同的规则，其中一套规则叫作格式化上下文。前面已经介绍了行内格式化上下文的一些规则。比如，垂直外边距对于行内盒子没有影响。类似的，有的规则适用于块级盒子的叠放，比如上一节对应的外边距折叠。</p><p>此外，<strong>有些规则规定了页面必须自动包含突出的浮动元素（否则浮动元素中的内容可能会跑到可滚动区域之外），而且所有块级盒子的左边界默认与包含块的左边界对齐（如果文字顺序是从右向左，那么与包含块的右边界对齐）。这组规则就是块级格式化上下文。</strong></p><p>还<strong>有些规则允许元素建立自己内部的块级格式化上下文</strong>，包括：</p><ul><li>display的属性值设置为inline-block或table-cell之类的元素，可以为内容创建类似块级的上下文。</li><li>float属性值不是none的元素。</li><li>绝对定位的元素。</li><li>overflow属性值不是visible的元素。</li></ul><p>前面说过，块边界接触其包含块边界的规则同样适用于前面是浮动元素的内容。浮动元素从页面流中移出后，通过触发其后的元素中行盒子的缩短行为，制造了为自身腾出四周空间的视觉效果。而其后的元素仍然会按照需要，在浮动元素下方拉伸。</p><p><strong>当一个元素具备了触发新块级格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则。此时，这个元素会收缩到适当大小；不仅行盒子如此，所有盒子都如此。</strong>利用这一点，可以通过更简单的规则实现前面的媒体对象组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Media Object, utilizing the formatting context<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.media-block</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: gray;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.media-fig</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-right</span>: <span class="number">5%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.media-body</span>, <span class="selector-class">.media-block</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: auto; <span class="comment">/* 1 */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-block&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;media-fig&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/pic.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The pic&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-body&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Title of this<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Brief description of this<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>给.media-block和.media-body元素都设置了overflow: auto;之后，就为它们创建了新的块级格式化上下文。</strong>这样就实现了目标（如下图）：</p><ol><li><strong>不用设置清除规则，就可以让.media-block包住浮动的照片，因为块级格式化上下文自动包含浮动。</strong></li><li><strong>顺带着，可以放弃给.media-body声明宽度和浮动。这是因为它会自动调整以适应浮动元素旁边的剩余空间，并确保挨着图片的一边是直的。如果没有通过给.media-body设置overflow:auto，则.media-body就没有新的格式化上下文，此时如果.media-body的文本比较多，那么位于浮动.media-fig下方的盒子都会伸长，最终填满图片下方的空间。</strong></li></ol><p>尽量基于简单且可预测的行为来创建布局，这样可以降低代码复杂度，并提高布局稳健性。因此，知道什么时候可以使用这个技术，以避免浮动和清除元素之间的复杂交互，可以说是一件可喜的事。</p><p><img src="https://pvnk1u.github.io/images/FomattedContext.PNG" alt="FomattedContext"></p><p>如上图所示，如果只浮动.media-fig且文本足够多，就会有一些文本环绕到图片下方。而创建一个新的块级格式化上下文会强迫.media-body收缩。</p><h1 id="其他CSS布局模块"><a href="#其他CSS布局模块" class="headerlink" title="其他CSS布局模块"></a>其他CSS布局模块</h1><p>目前为止，已经介绍了CSS可见格式化模型的基础以及大部分公共的内容。这一节简单介绍其他相关内容。</p><p>对于CSS这种视觉表现语言来说，稳健又灵活的布局无论如何都是需要的。虽然道理显而易见，但这种模型的诞生却并不容易。过去曾想方设法地利用这门语言中可用的特性来达成目标，哪怕那些特性并不好用。比如最早曾使用表格布局，但问题是代码臃肿、语义不当。近来又在使用浮动和绝对定位，但这些技术同样也并非为页面布局而设计。无论是表格还是浮动与定位，都有非常严重地局限性。使用它们只是不得已的选择。</p><p>可喜的是，最近出现了一些专门针对创建灵活、稳健页面布局的CSS模块。</p><h2 id="弹性盒布局"><a href="#弹性盒布局" class="headerlink" title="弹性盒布局"></a>弹性盒布局</h2><p>弹性盒布局，常被称为Flexbox，是CSS3新引入的一种布局模型。Flexbox支持对子元素水平或垂直布局，以及设置这些子元素的大小、间距和对齐方式。此外，Flexbox还支持改变元素渲染到页面上的次序，可以跟它们在HTML中的次序不同。作为CSS常规流模型（行内和块）的升级版，无论是调整内容本身还是适应内容大小，Flexbox都做到了既精确又灵活。</p><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><p>网格布局是CSS最早成熟的高层布局工具，目标是取代浮动和定位元素的布局方式。网格布局实现了源代码次序的完全分离，从内容结构和个别模块的表现中抽象出了网格系统。Flexbox关注“微观”，而网格系统关注“宏观”，二者正好互补。</p><h2 id="多栏布局"><a href="#多栏布局" class="headerlink" title="多栏布局"></a>多栏布局</h2><p>多栏布局模块的用意很明确，就是实现内容的多栏布局。比如，要排成像报纸那样的多栏样式。可以先指定栏数，也可以先指定每一栏的宽度，然后让浏览器根据可用宽度自动确定栏数。当然，还可以控制栏间距，并在其中应用类似边框的视觉效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浮动、定位和盒模型是学习CSS需要掌握的几个最重要的概念。这几个概念决定了元素在页面上排布和显示的方式，是很多布局技术的基础。搞清楚盒模型的各方面细节，绝对和相对定位的区别，以及浮动及清除的原理之后，使用CSS设计网站会变得更简单、更轻松。&lt;/p&gt;
&lt;h1 id=&quot;盒模型&quot;</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(2)——添加样式</title>
    <link href="http://pvnk1u.github.io/2023/05/24/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/"/>
    <id>http://pvnk1u.github.io/2023/05/24/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/</id>
    <published>2023-05-24T06:34:39.000Z</published>
    <updated>2023-11-27T15:34:23.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS选择符"><a href="#CSS选择符" class="headerlink" title="CSS选择符"></a>CSS选择符</h1><p>类型与后代选择符是最基本的选择符。类型选择符用于选择特定类型的元素，比如段落或标题元素，只要写出想添加样式的元素名即可。类型选择符有时候也被称为元素选择符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后代选择符用于选择某个或某组元素的后代。后代选择符的写法是在两个选择符之间添加空格。在下面的例子中，只有作为块引用后代的段落元素会被选中，从而缩进，其他段落都不会缩进：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型选择符与后代选择符非常适合全面应用基础样式。要想更精确地选择目标元素，可以使用ID选择符和类选择符。这两个选择符通过对应ID和class属性的值来选择元素。ID选择符由j井号(#)开头，类选择符由句点（.）开头。下面例子中的第一条规则会把介绍性段落中的文字变成粗体，而第二条规则会把日期变成灰色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#intro&#123;</span><br><span class="line">font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.date-posted&#123;</span><br><span class="line">    color: #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;intro&quot;</span>&gt;</span></span><br><span class="line">    Happy Birthday</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;date-posted&quot;</span>&gt;</span></span><br><span class="line">    20/1//2013</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时候，可以将ID和类选择符与类型和后代选择符组合起来使用，而不必为所有元素都添加ID和类选择符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#latest h1&#123;</span><br><span class="line">font-size: 1.8em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#latest .date-posted&#123;</span><br><span class="line">font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">id</span>=<span class="string">&quot;latest&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Happy Birthday<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;date-posted&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2013-01-20&quot;</span>&gt;</span>20/1/2013<span class="tag">&lt;/<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="子选择符与同辈选择符"><a href="#子选择符与同辈选择符" class="headerlink" title="子选择符与同辈选择符"></a>子选择符与同辈选择符</h2><p>除了基本选择符，CSS也提供了高级选择符。第一个高级选择符叫子选择符。与后代选择符会选择一个元素的所有后代不同，子选择符只选择一个元素的直接后代，也就是子元素。在下面的例子中，外部列表中的列表项前面会出现自定义的图标，而嵌套列表中的列表项则不会受影响：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#nav &gt; li&#123;</span><br><span class="line">background: url(folder.png) no-repeat left top;</span><br><span class="line">padding-left: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/services/&quot;</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/services/design/&quot;</span>&gt;</span>Design<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/services/development/&quot;</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/services/consultancy/&quot;</span>&gt;</span>Consultancy<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/contact/&quot;</span>&gt;</span>Contact Us<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时候可能需要为与某个元素相邻的元素添加样式。使用相邻同辈选择符，就可以选择位于某个元素后面，并与该元素拥有共同父元素的元素。使用相邻后辈选择符，可以为第一个段落中的文本应用粗体、灰色，让它们比后面段落中的文本稍微大一点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.4em</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#777</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样选择标题后面的第一个段落是可行的，但更简单、更容易维护的方式，还是为开头这一段增加一个类名，比如intro-text。这样，intro-text类也可以应用于其他并非直接位于h2元素之后的段落。</p><p><code>&gt;</code>和<code>+</code>在这里被称为组合子，因为它们描述了自身两侧的选择符组合的方式。实际上还有一个类似的组合子，那就是一般同辈组合子：~。仍以前面的例子来说明，使用一般同辈组合子可以选择h2元素后面的所有段落。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> ~ <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.4em</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#777</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符"></a>通用选择符</h2><p>通用选择符可以匹配任何元素。与其他语言中的通配符类似，通用选择符也使用星号（*）表示。也就是说，只用一个星号，就可以匹配页面中的所有元素。那么，是否可以使用通用选择符来删除所有元素默认的内外边距呢？比如这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这样写可能带来很多意想不到的后果，特别是会影响button、select等表单元素。如果想重设样式，最近还是像下面这样明确指定元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">li</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，通用选择符不仅限于给文档中的所有元素设置属性。还可以把它与组合子结合使用，选择某个特定的嵌套层次，此时重要的是层次而不是元素类型。看下面这个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.product-section</span> &gt; *&#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个组合选择符会选择带有类名product-section的元素的直接后代，不管它是什么元素，有什么属性。</p><h2 id="属性选择符"><a href="#属性选择符" class="headerlink" title="属性选择符"></a>属性选择符</h2><p>属性选择符是基于元素是否有某个属性或者属性是否有某个值来选择元素。有了这种选择符，可以实现很多更有意思、更深入的选择。</p><p>比如，鼠标指针悬停在某个带有title属性的元素上时，多数浏览器都会显示一个提示条。利用这种行为，可以借助<code>&lt;abbr&gt;</code>元素对某些缩写词给出详尽的解释：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The term<span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;self=contained underwater breathing apparatus&quot;</span>&gt;</span>SCUBA<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> is an...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可是，如果不把鼠标放在这个元素上，谁也不知道它还会显示缩写词的解释。为此，可以使用属性选择符给带有title熟悉的abbr元素添加不同的样式，比如，在缩写词下面加一条点划线。然后把悬停状态的鼠标指针改成问号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">abbr</span><span class="selector-attr">[title]</span>&#123;</span><br><span class="line"><span class="attribute">border</span>-botton: <span class="number">1px</span> dotted <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">abbr</span><span class="selector-attr">[title]</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">cursor</span>: help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以根据是否存在某个属性来选择元素，还可以根据特定的属性值来应用样式。比如，下面这个例子可以用来修正一个问题，即鼠标悬停在提交按钮上时，不同浏览器显示的光标不一致。有了这条规则，所有type属性值为submit的input元素在鼠标指针悬停时，都会显示一个手状光标：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span>&#123;</span><br><span class="line"><span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候更关心的是属性值是否匹配某个模式，而非某个特定值。这时候，通过给属性选择符中的等号前面加上特殊字符，就可以表达出想要匹配的值的形式了。</p><p>要匹配以某些字符开头的属性值，在等号前面加上插入符（^）:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;http:&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>要匹配以某些字符结尾的属性值，在等号前面加上美元符号（$）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ims<span class="selector-attr">[src$=<span class="string">&quot;.jpg&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>要匹配包含某些字符的属性值，在等号前面加上星号（*）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;/about/&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>要匹配以空格分隔的字符串中的属性值（比如rel属性的值），在等号前面加上波浪号（~）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[rel~=next]</span></span><br></pre></td></tr></table></figure><p>还有一个属性选择符，可以选择开头是指定值或指定值后连着一个短划线的情况。要匹配这种情况，在等号后加上竖线（|）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[lang|=en]</span></span><br></pre></td></tr></table></figure><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>有时候想选择的页面区域不是通过元素来表示的，而且也不想为此给页面增加额外的标记。css为这种情况提供了一种特殊选择符，叫做伪元素。</p><p>首先，可以使用::first-letter伪元素来选择一段文本的第一个字符。若要选择一段文本的第一行，可以使用::first-line。</p><p>此外，还有伪元素对应着内容开头和末尾处假想的元素，分别是::before和::after。这两个伪元素非常适合用来插入小图标及版面装饰符号。如果没有它们，要实现同样的视觉效果，就必须在HTML中插入真实的元素。</p><p>伪元素结合使用的例子：</p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Study In Scarlet<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;chapter&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>In the 1878 I took my degree od Doctor of Medicine of the University of London,and proceeded to Netley to go through the course prescribed for surgeons in the army. Having complted my studies there, I was duly attached to the Fifth Northumberland Fusiliers as Assistant Surgeon.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.chapter</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&quot;&quot;&#x27;</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.chapter</span> <span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Georaia, Times, <span class="string">&quot;Times New Roman&quot;</span>,serief;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.chapter</span> <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Georaia, Times, <span class="string">&quot;Times New Roman&quot;</span>,serief;</span><br><span class="line">    <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了::first-letter伪元素实现了段落的首字下沉效果。第一行也通过::first-line伪元素转换为全部大写，并应用了不一样的字体。.chapter开头那个装饰性的大引号则利用了::before伪元素。实现这么多视觉效果，却没有额外增加一个元素，确实方便。</p><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>有时候会想基于文档结构以外的情形来为页面添加样式，比如基于超链接或表单元素的状态。这时候就可以使用伪类选择符。伪类选择符的语法是以一个冒号开头，用于选择元素的特定状态或关系。</p><p>一些最常见的用于超链接的伪类列举如下。在涵盖最常见HTML元素的基础样式表中，应该始终包括它们：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 未访问过的链接为蓝色 */</span> </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问过的链接为绿色 */</span></span><br><span class="line"><span class="selector-tag">a</span>:visted&#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 超链接在鼠标悬停及获取键盘焦点时为红色 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 活动状态时为紫色 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: purple</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上伪类的先后次序很重要。:link和:visited应该排在前面，然后才是与用户交互相关的那些。这样一来，当用户鼠标悬停在链接上，或者链接获得键盘焦点时，:hover和:focus规则会覆盖:link和:hover规则。最后，当鼠标点击或键盘回车选择链接时，应用:active规则。</p><h3 id="目标与反选"><a href="#目标与反选" class="headerlink" title="目标与反选"></a>目标与反选</h3><p>另一个有用的伪类是:target，它匹配的元素有一个ID属性，而且该属性的值出现在当前页面URL末尾的井号（#）后边。如果打开链接http:example.com&#x2F;blog&#x2F;1&#x2F;#comment-3，找到该页面中标记为<code>&lt;article class=&quot;comment&quot; id=&quot;comment-3&quot;&gt;...&lt;/article&gt; </code>的评论，那么可以通过以下规则高亮该条评论：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment</span><span class="selector-pseudo">:target</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#fffec4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，假设想高亮一条评论，而该评论不是因投票否决而被隐藏的。也有一个选择符专门用于排除某些选择符：它就是反选（negation）伪类，或者:not()选择符。如果被标记为“投票否决”(downvoted)的评论都有一个特殊的类名，那么就可以像下面这样来改写规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment</span><span class="selector-pseudo">:target</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.comment-downvoted</span>)&#123;</span><br><span class="line">backgroud-<span class="attribute">color</span>: <span class="number">#fffec4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h2><p>CSS3新增了一大批与文档结构相关的新伪类。其中最常用的是nth-child选择符，可以用来交替地为表格应用样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(odd)&#123;</span><br><span class="line"><span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条规则会从表格的第一行开始，将后面每隔一行的背景变成黄色。nth-child选择符就像一个函数，可以接受很多不同的表达式作为参数。如前例所示，它可以接受odd（奇数）和even（偶数）作为参数。这个参数还可以直接是数值，表示目标元素的序数位置。</p><p>还有一个伪类选择符也支持这种表达式，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-last-child</span>(N)</span><br></pre></td></tr></table></figure><p>:nth-last-child选择符与:nth-child选择符类似，只不过是从最后一个元素倒序计算。</p><h2 id="表单伪类"><a href="#表单伪类" class="headerlink" title="表单伪类"></a>表单伪类</h2><p>HTML5为表单输入框新增了几个属性，表示必填的required就是其中之一。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;field-name&quot;</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;field-name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;field-name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果想高亮这个必填控件，可使用:required伪类来选择带有required属性的表单元素，并给它的边框设置一个不同的颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:required</span>&#123;</span><br><span class="line"><span class="attribute">outline</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，可以像下面这样使用：optional伪类，为没有required属性的控件添加样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:optional</span>&#123;</span><br><span class="line"><span class="attribute">border-color</span>:<span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还有针对有效和无效控件的伪类。为满足某个输入框要求填写类型内容（如电子邮件地址）的需求，HTML5也为type属性新增了不少输入值，比如email：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后可以根据输入框中当前内容的有效性，应用不同的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果输入框中包含有效的电子邮件地址 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;email&quot;</span>]</span><span class="selector-pseudo">:valid</span>&#123;</span><br><span class="line"><span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果输入框中的内容不是有效的电子邮件地址 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;email&quot;</span>]</span><span class="selector-pseudo">:invalid</span>&#123;</span><br><span class="line"><span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有针对type值为number的:inrange、:out-of-range伪类，针对readonly属性的:read-only伪类，以及针对没有readonly属性的:read-write伪类。</p><h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><p>稍微复杂点的样式表中都可能存在两条甚至多条规则同时选择一个元素的情况。CSS通过一种叫作层叠（cascade）的机制来处理这种冲突。从CSS这个名字就可知这种机制有多重要，因为其中的C就是cascade。层叠机制的原理是为规则赋予不同的重要程度。最重要的是作者样式表，即由网页开发者所写的样式。其次是用户样式表，用户可以通过浏览器的设置选项，为网页应用自己的样式。排在最后的是浏览器（或用户代码）的默认样式表，它们一般都会被作者样式表覆盖掉。为了给用户更高的优先权，CSS允许用户使用!import覆盖任何规则，包括网站作者使用!important标注的规则。!important标注要放在属性声明的后面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.5em</span> <span class="meta">!important</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#666</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 允许用户使用!important标注来覆盖规则，主要是出于无障碍交互的需要。比如，允许诵读困难的用户使用高对比度的用户样式表。</p><p>归纳起来，层叠机制的重要性级别从高到低如下所示：</p><ol><li>标注为!important的用户样式</li><li>标注为!important的作者样式</li><li>作者样式</li><li>用户样式</li><li>浏览器（或用户代码）的默认样式</li></ol><p>在此基础上，规则再按选择符的特殊性排序。特殊性高的选择符会覆盖特殊性低的选择符。如果两条规则的特殊性相等，则后定义的优先。</p><h1 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h1><p>为了量化规则的特殊性，每种选择符都对应着一个数值。这样，一条规则的特殊性就表示为其每个选择符的累加值。但这里的累加计算使用的并非正常的十进制加法，而是基于位置累加，以保证10个类选择符（或者40个，甚至更多的类选择符）累加的特殊性不会大于等于1个ID选择符的特殊性。这是为了避免ID这种高特殊性选择符被一堆低特殊性选择符（如类型选择符）的累加值所覆盖。如果某条规则中用到的选择符不足10个，为简单起见，也可以使用十进制来计算其特殊性。</p><p>任何选择符的特殊性都对应于如下4个级别，即a、b、c、d：</p><ol><li>行内样式，a为1</li><li>b等于ID选择符的数目</li><li>c等于类（class）选择符、伪类选择符及属性选择符的数目</li><li>d等于类型（type）选择符和伪元素选择符的数目</li></ol><p>根据以上规则，可以计算出CSS选择符的特殊性。下表是一些选择符以及它们所对应的特殊性规则：</p><table><thead><tr><th>选择符</th><th>特殊性</th><th>十进制特殊性</th></tr></thead><tbody><tr><td>style&#x3D;””</td><td>1,0,0,0</td><td>1000</td></tr><tr><td>#wrapper #content{}</td><td>0,2,0,0</td><td>200</td></tr><tr><td>#content .datePosted{}</td><td>0,1,1,0</td><td>110</td></tr><tr><td>div#content{}</td><td>0,1,0,1</td><td>101</td></tr><tr><td>#content{}</td><td>0,1,0,0</td><td>100</td></tr><tr><td>p.comment .datePosted{}</td><td>0,0,2,1</td><td>21</td></tr><tr><td>p.comment{}</td><td>0,0,1,1</td><td>11</td></tr><tr><td>div p{}</td><td>0,0,0,2</td><td>2</td></tr><tr><td>p{}</td><td>0,0,0,1</td><td>1</td></tr></tbody></table><p>乍一看这种计算特殊性的方式有点不好理解，再多解释一下。本质上而言，如果样式被写在了元素的style属性里，那么这些样式的特殊性就最高。然后，通过ID属性应用的规则，其特殊性高于未通过ID属性应用的规则。同理，通过类选择符应用的规则，其特殊性高于只通过类型选择符应用的规则。最后，如果两条规则拥有相等的特殊性，则优先应用后定义的规则，也就是层叠机制。</p><h2 id="利用层叠次序"><a href="#利用层叠次序" class="headerlink" title="利用层叠次序"></a>利用层叠次序</h2><p>如果两条规则特殊性相等，则优先应用后定义的规则，这一点非常重要。这意味着我们在写样式的时候，必须考虑规则在样式中的位置，以及选择符的次序。</p><p>前面的对链接元素使用伪类的例子，就是一个利用层叠次序的典型。如果每个选择符的特殊性都一样，那么它们的次序就很重要了。要是把a:visited选择符放在a:hover选择符后面，那么在访问过链接之后，悬停样式将不会起作用，因为已经被a:visted样式给覆盖了。</p><h2 id="控制特殊性"><a href="#控制特殊性" class="headerlink" title="控制特殊性"></a>控制特殊性</h2><p>理解特殊性是写好CSS的关键，而控制特殊性则是大型网站开发中最难处理的问题。利用特殊性，可以先为公用元素设置默认样式，然后在更特殊的元素上覆盖这些样式。在下面的例子中，为介绍性内容定义了几种不同的样式。首先将介绍性文本的颜色设为灰色，覆盖body元素上定义的默认黑色。而在主页上，介绍性文本的样式变成了浅灰色背景上的黑色字体，其中的链接是绿色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.intro</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line"><span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#home</span> <span class="selector-class">.intro</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line"><span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#home</span> <span class="selector-class">.intro</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上几条规则包含了太多的特殊性。对于小网站这不是问题，但随着网站越来越大，样式也越来越复杂，这样定义规则会导致样式难以管理。这是因为，要想给主页中的介绍性文本添加样式，规则中必须至少包含一个ID选择符和一个类选择符。</p><p>比如，假设一个组件中包含着类为call-to-action的链接，为了让这个链接看上去更像按钮，可以通过如下规则为它应用背景颜色和内边距：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.call-to-action</span>&#123;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个call-to-action链接放到主页的介绍性内容中，会出现什么效果？会不怎么好看，因为链接上的文本不见了：由于给定链接样式（#home.intro a）的特殊性高于这个组件样式（a.call-to-action）的特殊性，绿色背景上的文本也成了绿色的。</p><p>怎么办？必须想办法提高特殊性，比如给call-to-action组件加上更厉害的选择符：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.call-to-action</span>,</span><br><span class="line"><span class="selector-id">#home</span> <span class="selector-class">.intro</span> <span class="selector-tag">a</span><span class="selector-class">.call-to-action</span>&#123;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而像这样因样式表增大而被迫提高特殊性，会导致选择符之间特殊性的竞争，最终导致代码不必要地复杂化。</p><p>更好的做法是从一开始就简化选择符、降低特殊性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.intro</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line"><span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.intro-highlighted</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line"><span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.intro-highlighted</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.call-to-action</span>&#123;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上重写的代码改进了两个方面。首先，去掉了ID选择符，把所有选择符的特殊性降到最低。其次，去掉了对介绍性文本上下文的引用。不再将介绍性文本限定为必须在主页中，而只在原始介绍性文本基础上再命名一个特殊的版本（即intro-highlighted）。于是在标记中可以这样使用类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;intro&quot;</span>&gt;</span>A general intro<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;intro intro-highlighted&quot;</span>&gt;</span>....<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/promo-page&quot;</span> <span class="attr">class</span>=<span class="string">&quot;call-to-action&quot;</span>&gt;</span>promo page<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种简化的、目标更明确的手段让作者可以对样式进行更细粒度地控制。intro-highlighted链接的样式不会再覆盖到call-to-action链接的颜色。与此同时，无须修改CSS，即可将intro-highlighted重用到其他页面，这又是一个好处。</p><h2 id="特殊性与调试"><a href="#特殊性与调试" class="headerlink" title="特殊性与调试"></a>特殊性与调试</h2><p>特殊性对于调试而言非常重要，因为需要知道哪条规则优先，以及为什么优先。比如，假设有下列规则，两个标题会是什么颜色？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-id">#main</span> <span class="selector-tag">h2</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-id">#main</span> &gt; <span class="selector-tag">h2</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> &gt; <span class="selector-attr">[id=<span class="string">&quot;main&quot;</span>]</span> <span class="selector-class">.new-story</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>) <span class="selector-tag">h2</span><span class="selector-class">.first</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: hotpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> <span class="selector-attr">[id=<span class="string">&quot;content&quot;</span>]</span><span class="selector-pseudo">:first</span>-child &gt; <span class="selector-id">#main</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">3</span>)&#123;</span><br><span class="line"><span class="attribute">color</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">”content“</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Strange Times<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Here you can read bizarre news stories from around the globe.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-story&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>Bog Snorkeling Champion around the globe.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The 2008 Bog ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>答案是两个标题都是灰色。这是因为，第一条规则有两个ID选择符，特殊性最高。后面几个选择符看起来挺复杂，但都只包含一个ID选择符，在特殊性的较量中都会败下阵来。值得注意的是，就算选择符中包含对ID属性的引用，它仍然是属性选择符，特殊性并不高。不过对于只能通过ID属性接入样式的情况，使用属性选择符倒是避免特殊性过高的较好选择。</p><p>测试特殊性问题比较难，但是现代浏览器都内置开发者工具，能非常清楚地显示应用给特殊元素的样式来自哪条规则。通过”检测元素“可以看到与元素匹配的所有CSS选择符以及规则，包括浏览器默认样式。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承和层叠的概念虽然有点类似，但实际上它们有着本质的区别。有些属性，像颜色或字体大小，会被应用它们的元素的后代所继承。比如，把body元素的文本颜色设置为黑色，那么body所有后代元素的文本颜色都会继承这个黑色。字号也一样。</p><p>如果在body中设置了一个字号，就会发现页面中的标题并不会变成同样的字号。实际上，标题大小是浏览器默认样式表中设定的。<strong>任何直接应用给元素的样式都会覆盖继承的样式，因为继承的样式没有任何特殊性。</strong>继承的属性值没有任何特殊性，连0都说不上。这意味着使用特殊性为0的通用选择符设置的样式都可以覆盖继承的样式。为此可能会下面这种遇到”意料之外”的情况，表面上看em会继承h2的红色，但通用选择符给所有元素设置的黑色会覆盖它所继承的红色：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>The emphasized text will be <span class="tag">&lt;<span class="name">em</span>&gt;</span>black<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="为文档应用样式"><a href="#为文档应用样式" class="headerlink" title="为文档应用样式"></a>为文档应用样式</h1><p>写CSS就要知道怎么把它应用到HTML文档。为文档应用样式的方法不止一种，各有利弊。</p><h2 id="link与style元素"><a href="#link与style元素" class="headerlink" title="link与style元素"></a>link与style元素</h2><p>首先，可以把样式放在style元素中，直接放在文档的head部分：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>: Avenir Next,SegoeUI,sans-serief;</span><br><span class="line"><span class="attribute">color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>如果样式不多，又希望立刻应用它们，并且不愿意因为浏览器额外下载文件而耽误时间，可以使用这种方法。不过，为了让样式表能在多个页面中重用，通常最好把它保存到一个外部文件中。如果样式在外部样式表中，那么有两种方式把它们挂接到网页上。最常用的方式是使用link元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/c/base.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>除了link元素，还可以使用@import指令加载外部CSS文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="keyword">@import</span> url(<span class="string">&quot;/c/modules.css&quot;</span>)</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在HTML文档的head部分把@import指令放在style中，也可以在外部样式表中使用它。后一种用法意味着，如果网页加载外部样式表，那么浏览器后续可能还需要下载更多CSS文件。</p><p>向页面中添加样式表的时候，别忘了层叠机制的原理是次序决定优先级：如果为某个元素应用样式时，有两个或更多特殊性相等的规则互相竞争，则后声明的样式胜出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS选择符&quot;&gt;&lt;a href=&quot;#CSS选择符&quot; class=&quot;headerlink&quot; title=&quot;CSS选择符&quot;&gt;&lt;/a&gt;CSS选择符&lt;/h1&gt;&lt;p&gt;类型与后代选择符是最基本的选择符。类型选择符用于选择特定类型的元素，比如段落或标题元素，只要写出想添加样式的</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>精通CSS读书笔记(1)——基础知识</title>
    <link href="http://pvnk1u.github.io/2023/05/22/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://pvnk1u.github.io/2023/05/22/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-05-22T06:32:39.000Z</published>
    <updated>2023-11-27T15:34:23.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组织代码"><a href="#组织代码" class="headerlink" title="组织代码"></a>组织代码</h1><h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><h2 id="应该使用哪个版本"><a href="#应该使用哪个版本" class="headerlink" title="应该使用哪个版本"></a>应该使用哪个版本</h2><p>对于CSS属性，可以访问“can i use”网站（<a href="https://caniuse.com/">caniuse</a>）。这个网站可以搜索属性或属性组，结果配有统计信息，显示支持它们的浏览器百分比，包括桌面浏览器和移动浏览器。另一个非常有想法的项目是<a href="https://webplatform.github.io/">webplatform</a>，是W3C和几家浏览器厂商及行业巨头搞出来的，目标是收集合并它们所有关于CSS、HTML、Javascript API等支持情况的文档。不过，就跟很多大型项目一样，最终要完成那么庞大的Web技术文档的聚合，需要花很长时间。此外，Mozzila的开发者文档，即MDN，也是一个非常好的参考。</p><h2 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强"></a>渐进增强</h2><p>平衡向后兼容性与最新的HTML和CSS特性，涉及一种叫作渐进增强的策略。所谓渐进增强，大意就是“首先为最小公分母准备可用的内容，然后再为支持新特性的浏览器添加更多交互优化”。听起来有点复杂，而实际上HTML和CSS的实现已经部分内置了这一策略。</p><p>对HTML而言，这意味着浏览器在遇到未知元素或属性时并不会报错，而且也不会对页面产生什么影响。比如，可以在页面里使用HTML5定义的新input元素。假设表单中有一个电子邮件的标记如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;field-email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;field-email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要使用新的input元素，应该把type属性改成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;field-email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;field-email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尚未实现这个新字段类型的浏览器碰到它只会想：这是啥意思呀？不明白。然后回退为默认的text类型，结果和上面的第一行代码一样。而实现了这个类型的新浏览器则知道email想让用户在这里填写什么样的数据。假如还在这里使用了内置的表单验证，那么支持它的新浏览器也会帮忙做验证。这样，既渐进增强了页面，也不会对旧版本浏览器产生不好的影响。</p><p>CSS中的渐进增强同样也反映在浏览器如何对待新属性上。任何浏览器无法识别的属性或值都会导致浏览器丢弃相应的声明。因此，只要同时提供合理的后备声明，使用新属性就不会带来不良后果。</p><p>举个例子，很多现代浏览器支持以rgba函数方式表示的颜色值。这种方式可以分别传入红、绿、蓝通道，以及阿尔法（alpha，即透明度）通道的值。可以这样使用它：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.overlay</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条规则定义了类名为overlay的元素背景为黑色，但随后又用rgba声明背景色应稍微透明。如果浏览器不支持rgba，那么相应元素的背景色就是不透明的黑色。如果浏览器支持rgba，那么第二条声明就会覆盖第一条。也就是说，即使并非所有浏览器都支持rgba，我们也可以使用它，只是要先为它声明合适的后备代码。</p><ol><li><p>厂商前缀</p><p>浏览器厂商也基于相同的原理为自家浏览器引入实验性特性。实验性特性的标准名称前面会加上一个特殊字符串，这样它们自己的浏览器就能识别该特性，而其他浏览器则会忽略掉该特性。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myThing</span>&#123;</span><br><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">10px</span>);</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">10px</span>);</span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">10px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了几个不同的前缀，给相应的元素应用了变换。以-webkit-开头的适用于基于Webkit的浏览器，如Safari。Chrome和Opera都基于Blick引擎，而Blink最初也是基于Webkit开发的，所以-webkit-前缀通常也适用于这3个浏览器。-moz-前缀适用于基于Mozilla的浏览器，如Firefox。-ms-前缀则适用于微软的IE。</p><p>最后又加了一条不带前缀的声明，这样那些支持标准属性名称的浏览器就不会漏网了。</p></li><li><p>条件规则与检测脚本</p><p>如果希望根据浏览器是否支持某个CSS特性来提供完全不同的样式，那么可以选择@support块。这个特殊的代码块称为条件规则，它会检测括号中的声明，并且仅在浏览器支持该声明的情况下，才会应用块中的规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@support</span>(display:grid)&#123;</span><br><span class="line"><span class="comment">/* 在支持网格布局的浏览器中要应用的规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="创建结构化、语义化富HTML"><a href="#创建结构化、语义化富HTML" class="headerlink" title="创建结构化、语义化富HTML"></a>创建结构化、语义化富HTML</h1><p>语义化标记是优秀HTML文档的基础。语义就是以系统方式表示的含义。对于根据一个形式符号的集合人工创造出的语言（比如HTML语言，及其元素和属性）来说，语义指的就是通过使用某个符号想要表示的含义。简而言之，语义化标记意味着在正确的地方使用正确的元素，从而得到有意义的文档。</p><p>结构良好的标记也能让页面在搜索引擎中排名更靠前。对于CSS来说更重要的是，有意义的标记本身为添加样式提供了方便。实际上，编写CSS的最新实践都建议先给网站一组“基础”样式。</p><h2 id="ID和class属性"><a href="#ID和class属性" class="headerlink" title="ID和class属性"></a>ID和class属性</h2><p>有意义的元素提供了不错的基础，却没有提供应用视觉效果所必需的全部“接入点”。除了元素本身，还需要一种方式把样式“接入到”文档上，这就是ID和class属性。</p><p>给属性起名字非常重要，起什么名字意味着它是什么，或者应该怎么使用它，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">product-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/product/1&quot;</span>&gt;</span>Product1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/product/2&quot;</span>&gt;</span>Product2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/product/3&quot;</span>&gt;</span>Product3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先利用css属性在文档中创造一个product-list模块。在css里，用类名来定义一类事物。这里的product-list就意味着它可以是任何商品列表。换句话说，为product-list写好样式后，不仅可以用在这里，还可以用在网站的任何地方。</p><p>给元素添加类名时，即使类名明确用于样式，也不要体现出其视觉效果。正确的做法是让类名表示组件的类型。比如这里的类名是product-list，而非泛泛的large-centered-list。</p><p>id和class最主要的区别是ID只能应用到页面中的一个元素。也就是说，不能像product-list那样使用ID把页面中的模块定义为可重用的“模板”。ID应该用来标识特定模块的特定实例，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span> id=&quot;primary-product-list&quot; class=product-list&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href=&quot;/product/<span class="number">1</span>&quot;&gt;Product1&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href=&quot;/product/<span class="number">2</span>&quot;&gt;Product2&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href=&quot;/product/<span class="number">3</span>&quot;&gt;Product3&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ul</span>&gt;</span><br></pre></td></tr></table></figure><p>这是product-list的一个实例，它因为有同样的class属性而获得了相应的样式。但在这里，这个实例也被ID定义为primary-product-list。每个页面通常只能有一个主要商品的列表，因此这个ID值还是比较恰当的。利用这个ID，可以为这个模块实例添加额外的样式，可以增加一些JavaScript交互，还可以作为页内导航的目标。</p><p>实际开发中，一般不建议把ID属性作为CSS的“接入点”。利用类来添加样式往往能够让代码更简单也更容易维护。ID可以用于在文档中标识元素，但通常不用于添加样式。</p><h2 id="结构化元素"><a href="#结构化元素" class="headerlink" title="结构化元素"></a>结构化元素</h2><p>HTML5新增了一批结构化元素：</p><ul><li>section</li><li>header</li><li>footer</li><li>nav</li><li>article</li><li>aside</li><li>main</li></ul><p>增加这些新元素是为了在HTML文档中创建逻辑性区块。它们可以用于包含独立内容（article）、导航组件（nav）、特定区块的头部（header），等等。其中，main元素是最新增加的，用于高亮页面中包含主要内容的区域。</p><p>除了main之外，所有其他新元素都可以在一个文档中多次出现，以便让机器人和人更好地理解文档。在HTML5引入这些新元素之前，经常能看到带有类似类名的div元素，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>How I became a CSS Master<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Ten-thousand hours.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的div元素对文档而言并没有语义价值，只是借助类名作为添加样式的“接入点”而已。现在有了HTML5的新元素，这段标记可以改写成这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">header</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">h1</span>&gt;How <span class="selector-tag">I</span> became <span class="selector-tag">a</span> CSS Master&lt;/<span class="selector-tag">h1</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">header</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;Ten-thousand hours.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">article</span>&gt;</span><br></pre></td></tr></table></figure><p>经过修改，这段HTML的语义得到了增强，但同时也产生了意外的副作用。此时，只能通过article和header元素来添加样式了。添加样式的CSS可能会是这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>&#123;</span><br><span class="line"><span class="comment">/* 样式 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">header</span>&#123;</span><br><span class="line"><span class="comment">/* 其他样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但article和header都可能在同一个页面中多次出现。如果确实存在这种重用的情况，那么这段CSS代码就会应用于所有其他相同的元素上，此时，更好的做法是把这两个例子结合起来：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">article</span> class=&quot;post&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">header</span> class=&quot;post-<span class="selector-tag">header</span>&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">h1</span>&gt;How <span class="selector-tag">I</span> became <span class="selector-tag">a</span> CSS Master&lt;/<span class="selector-tag">h1</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">header</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;Ten-thousand hours.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">article</span>&gt;</span><br></pre></td></tr></table></figure><p>相应的CSS规则就可以使用类名为这段标记应用样式了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span>&#123;</span><br><span class="line"><span class="comment">/* 样式 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-header</span>&#123;</span><br><span class="line"><span class="comment">/* 其他样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h2><p>即使有了新语义元素，div元素依然不多余。在没有合适的语义元素的情况下，div仍然是给内容分组的一个不错的选择。</p><p>与div元素类似的还有span。同样，在无须表示语义、仅需添加样式的情况中，可以使用span。与div不同，span是文本级元素，可以用于在文本流中建立结构。不过在使用无语义的span之前，也一样要确保真的不需要使用任何语义元素。比如，使用time标记时间和日期，使用q标记引用，使用em标记需要强调的内容，使用strong标记需要重点强调的内容。</p><h2 id="重新定义的表现性文本元素"><a href="#重新定义的表现性文本元素" class="headerlink" title="重新定义的表现性文本元素"></a>重新定义的表现性文本元素</h2><p>时至今日，<code>&lt;b&gt;</code>和<code>&lt;i&gt;</code>可以算是幸存的表现型标记了，它们以前分别用于将文本标记为粗体（bold）和斜体（italic）。HTML5最终决定保留它们，但改变了它们的含义。多数情况下，应该选择使用<code>&lt;em&gt;</code>或<code>&lt;strong&gt;</code>，因为它们是用来强调及重点强调内容的语义正确的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组织代码&quot;&gt;&lt;a href=&quot;#组织代码&quot; class=&quot;headerlink&quot; title=&quot;组织代码&quot;&gt;&lt;/a&gt;组织代码&lt;/h1&gt;&lt;h2 id=&quot;HTML版本&quot;&gt;&lt;a href=&quot;#HTML版本&quot; class=&quot;headerlink&quot; title=&quot;HTML版</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/categories/web/css/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="css" scheme="http://pvnk1u.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(14)——网络</title>
    <link href="http://pvnk1u.github.io/2023/05/15/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(14)%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <id>http://pvnk1u.github.io/2023/05/15/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(14)%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C/</id>
    <published>2023-05-15T04:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.880Z</updated>
    
    <content type="html"><![CDATA[<p>2005 年，Jesse James Garrett 撰写了一篇文章，“Ajax—A New Approach to Web Applications”。这篇 文章中描绘了一个被他称作 Ajax（Asynchronous JavaScript+XML，即异步 JavaScript 加 XML）的技术。 这个技术涉及发送服务器请求额外数据而不刷新页面，从而实现更好的用户体验。Garrett 解释了这个技 术怎样改变自 Web 诞生以来就一直延续的传统单击等待的模式。</p><p>把 Ajax 推到历史舞台上的关键技术是 <code>XMLHttpRequest</code>（<code>XHR</code>）对象。这个对象最早由微软发明， 然后被其他浏览器所借鉴。在 <code>XHR</code> 出现之前，<code>Ajax</code> 风格的通信必须通过一些黑科技实现，主要是使用隐藏的窗格或内嵌窗格。<code>XHR</code> 为发送服务器请求和获取响应提供了合理的接口。这个接口可以实现异步从服务器获取额外数据，意味着用户点击不用页面刷新也可以获取数据。通过 <code>XHR</code> 对象获取数据后， 可以使用 <code>DOM</code> 方法把数据插入网页。虽然 <code>Ajax</code> 这个名称中包含 <code>XML</code>，但实际上 <code>Ajax </code>通信与数据格式无关。这个技术主要是可以实现在不刷新页面的情况下从服务器获取数据，格式并不一定是 <code>XML</code>。</p><p><code>XHR</code> 对象的 <code>API</code> 被普遍认为比较难用，而 <code>Fetch API</code> 自从诞生以后就迅速成为了 <code>XHR</code> 更现代的替代标准。<code>Fetch API</code> 支持期约（<code>promise</code>）和服务线程（service worker），已经成为极其强大的 Web 开发工具。</p><p>本章会全面介绍 <code>XMLHttpRequest</code>，但它实际上是过时 Web 规范的产物，应该只在旧版本浏览器中使用。实际开发中，应该尽可能使用 <code>fetch()</code>。</p><h1 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h1><p>所有现代浏览器都通过 <code>XMLHttpRequest</code> 构造函数原生支持 <code>XHR</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><h2 id="使用XHR"><a href="#使用XHR" class="headerlink" title="使用XHR"></a>使用XHR</h2><p>使用 <code>XHR</code> 对象首先要调用 <code>open()</code>方法，这个方法接收 3 个参数：请求类型（”get”、”post”等）、 请求 URL，以及表示请求是否异步的布尔值。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这行代码就可以向 <code>example.php</code> 发送一个同步的 <code>GET</code> 请求。关于这行代码需要说明几点。首先，这 里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，<strong>调用 <code>open()</code>不会实际发送请 求，只是为发送请求做好准备。</strong></p><p>要发送定义好的请求，必须像下面这样调用 <code>send()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 <code>null</code>， 因为这个参数在某些浏览器中是必需的。调用 <code>send()</code>之后，请求就会发送到服务器。</p><p>因为这个请求是同步的，所以 <code>JavaScript</code> 代码会等待服务器响应之后再继续执行。收到响应后，<code>XHR</code> 对象的以下属性会被填充上数据。</p><ol><li><p>responseText</p><p>作为响应体返回的文本</p></li><li><p>responseXML</p><p>如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，那就是包含响应 数据的 XML DOM 文档。</p></li><li><p>status</p><p>响应的HTTP状态</p></li><li><p>statusText</p><p>响应的HTTP状态描述</p></li></ol><p>收到响应后，第一步要检查 <code>status</code> 属性以确保响应成功返回。一般来说，HTTP 状态码为 2xx 表 示成功。此时，responseText 或 responseXML（如果内容类型正确）属性中会有内容。<strong>如果 HTTP 状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态</strong>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上代码可能显示服务器返回的内容，也可能显示错误消息，取决于 HTTP 响应的状态码。为确定下一步该执行什么操作，最好检查 status 而不是 statusText 属性，因为后者已经被证明在跨浏览器 的情况下不可靠。无论是什么响应内容类型，responseText 属性始终会保存响应体，而 responseXML则对于非 XML 数据是 null。</p><p>虽然可以像前面的例子一样发送同步请求，但多数情况下最好使用异步请求，这样可以不阻塞<code>JavaScript</code> 代码继续执行。<code>XHR</code> 对象有一个 <code>readyState</code> 属性，表示当前处在请求&#x2F;响应过程的哪个阶段。 这个属性有如下可能的值。</p><ul><li><p>0：未初始化(Uninitialized)</p><p>尚未调用open()方法</p></li><li><p>1：已打开（Open）</p><p>已调用open()方法，尚未调用send()方法</p></li><li><p>2：已发送（Sent）</p><p>已调用send()方法，尚未收到响应</p></li><li><p>3：接收中(Receiving)</p><p>已经收到部分响应</p></li><li><p>4：完成（Complete）</p><p>已经收到所有响应，可以使用了</p></li></ul><p>每次 readyState 从一个值变成另一个值，都会触发 <code>readystatechange</code> 事件。可以借此机会检 查 <code>readyState</code> 的值。一般来说，唯一关心的 <code>readyState</code> 值是 4，表示数据已就绪。为保证跨浏览器兼容，<code>onreadystatechange</code> 事件处理程序应该在调用 <code>open()</code>之前赋值。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>以上代码使用 DOM Level 0 风格为 XHR 对象添加了事件处理程序，因为并不是所有浏览器都支持 DOM Level 2 风格。与其他事件处理程序不同，<code>onreadystatechange</code> 事件处理程序不会收到 <code>event</code> 对象。在事件处理程序中，必须使用 XHR 对象本身来确定接下来该做什么。</p><p>在收到响应之前如果想取消异步请求，可以调用 <code>abort()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>调用这个方法后，<code>XHR</code> 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 <code>XHR</code> 对象的引用。由于内存问题，不推荐重用 <code>XHR</code> 对象。</p><h2 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h2><p>每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一 些方法暴露与请求和响应相关的头部字段。</p><p>默认情况下，XHR 请求会发送以下头部字段。</p><ol><li><p>Accept</p><p>浏览器可以处理的内容类型</p></li><li><p>Accept-Charset</p><p>浏览器可以显示的字符集类型</p></li><li><p>Accept-Encoding</p><p>浏览器可以处理的压缩编码类型</p></li><li><p>Accept-Language</p><p>浏览器使用的语言</p></li><li><p>Connection</p><p>浏览器与服务器的连接类型</p></li><li><p>Cookie</p><p>页面中设置的Cookie</p></li><li><p>Host</p><p>发送请求的页面所在的域</p></li><li><p>Referer</p><p>发送请求的页面的URI。这个字段在HTTP规范中就拼错了，所以考虑到兼容性也必须将错就错（正确的拼写应该是Referrer）</p></li><li><p>User-Agent</p><p>浏览器的用户代理字符串。</p></li></ol><p>虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。**如果需要发送额外的请求头部，可以使用<code>setRequestHeader()</code>方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在<code>open()</code>之后，<code>send()</code>之前调用<code>setRequestHeader()</code>**，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;MyHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>服务器通过读取自定义头部可以确定适当的操作。自定义头部一定要区别于浏览器正常发送的头部， 否则可能影响服务器正常响应。有些浏览器允许重写默认头部，有些浏览器则不允许。</p><p>可以使用 <code>getResponseHeader()</code>方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即 可。如果想取得所有响应头部，可以使用 <code>getAllResponseHeaders()</code>方法，这个方法会返回包含所有响应头部的字符串。下面是调用这两个方法的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myHeader = xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;MyHeader&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> allHeaders xhr.<span class="title function_">getAllResponseHeaders</span>(); </span><br></pre></td></tr></table></figure><p>服务器可以使用头部向浏览器传递额外的结构化数据。<code>getAllResponseHeaders()</code>方法通常返回 类似如下的字符串：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sun, 14 Nov 2004 18:04:03 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.29 (Unix)</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept</span><br><span class="line"><span class="attribute">X-Powered-By</span><span class="punctuation">: </span>PHP/4.3.8</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=iso-8859-1</span><br></pre></td></tr></table></figure><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL 后面添加查询字符串参数。对 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给 <code>open()</code>方法。</p><p>发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用 <code>encodeURIComponent()</code>编码，所有名&#x2F;值对必须以和号（&amp;）分隔，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php?name1=value1&amp;name2=value2&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可以使用以下函数将查询字符串参数添加到现有的 URL 末尾：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addURLParam</span>(<span class="params">url, name, value</span>) &#123;</span><br><span class="line">     url += (url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">     url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">     <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用这个函数构建请求 URL，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;example.php&quot;</span>;</span><br><span class="line"><span class="comment">// 添加参数</span></span><br><span class="line">url = <span class="title function_">addURLParam</span>(url, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line">url = <span class="title function_">addURLParam</span>(url, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;Professional JavaScript&quot;</span>);</span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在 请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据 可以是任意格式。要初始化 POST 请求，<code>open()</code>方法的第一个参数要传”post”，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>接下来就是要给 <code>send()</code>方法传入要发送的数据。因为 XHR 最初主要设计用于发送 XML，所以可以传入序列化之后的 XML DOM 文档作为请求体。当然，也可以传入任意字符串。</p><p>默认情况下，对服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST 数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此，第一步需要把 <code>ContentType</code> 头部设置为”application&#x2F;x-www-formurlencoded”，这是提交表单时使用的内容类型。第二 步是创建对应格式的字符串。<code>POST</code> 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表 单需要序列化并通过 <code>XHR</code> 发送到服务器，则可以使用 <code>serialize()</code>函数来创建相应的字符串，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">submitData</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">     xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">     xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">     <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">     xhr.<span class="title function_">send</span>(<span class="title function_">serialize</span>(form));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这个函数中，来自 ID 为”user-info”的表单中的数据被序列化之后发送给了服务器。PHP 文件 postexample.php 随后可以通过$_POST 取得 POST 的数据。比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: text/plain&quot;</span>);</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">Name: <span class="subst">&#123;$_POST[&#x27;user-name&#x27;]&#125;</span></span></span><br><span class="line"><span class="string">Email: <span class="subst">&#123;$_POST[&#x27;user-email&#x27;]&#125;</span></span></span><br><span class="line"><span class="string">EOF</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>假如没有发送 <code>Content-Type</code> 头部，PHP 的全局$_POST 变量中就不会包含数据，而需要通过 $HTTP_RAW_POST_DATA 来获取。</p><p>POST 请求相比 GET 请求要占用更多资源。从性能方面说，发送相同数量的数据， GET 请求比 POST 请求要快两倍。</p><h2 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h2><p>XHR 对象作为事实标准的迅速流行，也促使 W3C 为规范这一行为而制定了正式标准。 XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2 又进一步发展了 XHR 对象。并非所有浏览器都实现了 XMLHttpRequest Level 2 的所有部分，但所有浏览器都实现了其中部分功能。</p><ol><li><p>FormData类型</p><p>现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了 FormData 类型。FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR 发送。下面的代码创建了一个 FormData 对象，并填充了一些数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>append()</code>方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意 多个键&#x2F;值对数据。此外，通过直接给 FormData 构造函数传入一个表单元素，也可以将表单中的数据作为键&#x2F;值对填充进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>有了 <code>FormData</code> 实例，可以像下面这样直接传给 <code>XHR</code> 对象的 <code>send()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="keyword">new</span> <span class="title class_">FormData</span>(form));</span><br></pre></td></tr></table></figure><p>使用 <code>FormData</code> 的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能 够识别作为 <code>FormData</code> 实例传入的数据类型并自动配置相应的头部。</p></li><li><p>超时</p><p>IE8 给 <code>XHR</code> 对象增加了一个 <code>timeout</code> 属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的 <code>XHR</code> 实现中增加了这个属性。在给 <code>timeout</code> 属性设置了一个 时间且在该时间过后没有收到响应时，<code>XHR</code> 对象就会触发 <code>timeout</code> 事件，调用 <code>ontimeout</code> 事件处理 程序。这个特性后来也被添加到了 XMLHttpRequest Level 2 规范。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">            <span class="comment">// 假设由 ontimeout 处理</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;timeout.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">1000</span>; <span class="comment">// 设置 1 秒超时</span></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Request did not return in a second.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>); </span><br></pre></td></tr></table></figure><p>这个例子演示了使用 timeout 设置超时。给 timeout 设置 1000 毫秒意味着，如果请求没有在 1 秒钟内返回则会中断。此时则会触发 ontimeout 事件处理程序，readyState 仍然会变成 4，因此也 会调用 onreadystatechange 事件处理程序。不过，如果在超时之后访问 status 属性则会发生错误。 为做好防护，可以把检查 status 属性的代码封装在 try&#x2F;catch 语句中。</p></li><li><p>overrideMimeType()方法</p><p>Firefox 首先引入了 <code>overrideMimeType()</code>方法用于重写 <code>XHR</code> 响应的 <code>MIME</code> 类型。这个特性后来 也被添加到了 XMLHttpRequest Level 2。因为响应返回的 MIME 类型决定了 XHR 对象如何处理响应， 所以如果有办法覆盖服务器返回的类型，那么是有帮助的。</p><p>假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text&#x2F;plain。结果就会导致虽 然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType()可以保证将响应 当成 XML 而不是纯文本来处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;text.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&quot;text/xml&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>这个例子强制让 XHR 把响应当成 XML 而不是纯文本来处理。为了正确覆盖响应的 MIME 类型， 必须在调用 send()之前调用 <code>overrideMimeType()</code>。</p></li></ol><h1 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h1><p>Progress Events 是 W3C 的工作草案，定义了客户端-服务器端通信。这些事件最初只针对 XHR，现 在也推广到了其他类似的 API。有以下 6 个进度相关的事件。</p><ol><li><p>loadstart</p><p>在接收到响应的第一个字节时触发。</p></li><li><p>progress</p><p>在接收响应期间反复触发。</p></li><li><p>error</p><p>在请求出错时触发。</p></li><li><p>abort</p><p>在调用 abort()终止连接时触发。</p></li><li><p>load</p><p>在成功接收完响应时触发。</p></li><li><p>loadend</p><p>在通信完成时，且在 error、abort 或 load 之后触发。</p></li></ol><p>每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后以 loadend 事件结束。</p><p>这些事件大部分都很好理解，但其中有两个需要说明一下。</p><h2 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h2><p>Firefox 最初在实现 XHR 的时候，曾致力于简化交互模式。最终，增加了一个 load 事件用于替代 readystatechange 事件。load 事件在响应接收完成后立即触发，这样就不用检查 readyState 属性了。onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。不过，并不是所有浏览器都实现了这个事件的 event 对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>); </span><br></pre></td></tr></table></figure><p>只要是从服务器收到响应，无论状态码是什么，都会触发 load 事件。这意味着还需要检查 status 属性才能确定数据是否有效。Firefox、Opera、Chrome 和 Safari 都支持 load 事件。</p><h2 id="progress事件"><a href="#progress事件" class="headerlink" title="progress事件"></a>progress事件</h2><p>Mozilla 在 XHR 对象上另一个创新是 progress 事件，<strong>在浏览器接收数据期间，这个事件会反复触发。</strong>每次触发时，onprogress 事件处理程序都会收到 event 对象，其 target 属性是 XHR 对象，且 包含 3 个额外属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是 一个布尔值，表示进度信息是否可用；position 是接收到的字节数；totalSize 是响应的 ContentLength 头部定义的总字节数。有了这些信息，就可以给用户提供进度条了。以下代码演示了如何向用户展示进度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) ||</span><br><span class="line">        xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> divStatus = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">     divStatus.<span class="property">innerHTML</span> = <span class="string">&quot;Received &quot;</span> + event.<span class="property">position</span> + <span class="string">&quot; of &quot;</span> +</span><br><span class="line">     event.<span class="property">totalSize</span> +</span><br><span class="line">    <span class="string">&quot; bytes&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>为了保证正确执行，必须在调用 open()之前添加 onprogress 事件处理程序。在前面的例子中， 每次触发 progress 事件都会更新 HTML 元素中的信息。假设响应有 Content-Length 头部，就可以利用这些信息计算出已经收到响应的百分比。</p><h1 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h1><p>通过 XHR 进行 Ajax 通信的一个主要限制是跨源安全策略。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过，浏览器也需要支持合法跨源访问的能力。</p><p>跨源资源共享（CORS，<code>Cross-Origin Resource Sharing</code>）定义了浏览器与服务器如何实现跨源通信。 <code>CORS</code> 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。</p><p>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 <code>text/plain</code> 类型， 这样的请求在发送时会有一个额外的头部叫 <code>Origin</code>。<code>Origin</code> 头部包含发送请求的页面的源（协议、 域名和端口），以便服务器确定是否为其提供响应。下面是 <code>Origin</code> 头部的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure><p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源； 或者如果资源是公开的，那么就包含”*”。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure><p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。</p><p>现代浏览器通过 XMLHttpRequest 对象原生支持 CORS。在尝试访问不同源的资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR对象并给 open()方法传入一个绝对 URL， 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;http://www.somewhere-else.com/page/&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>跨域 XHR 对象允许访问 status 和 statusText 属性，也允许同步请求。出于安全考虑，跨域 XHR 对象也施加了一些额外限制。</p><ol><li>不能使用setRequestHeader()设置自定义头部</li><li>不能发送和接收cookie</li><li>getAllResponseHeaders()方法始终返回空字符串</li></ol><p>因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以更明确地区分使用场景，同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题。</p><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET 和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。</p><ol><li><p>Origin</p><p>与简单请求相同</p></li><li><p>Access-Control-Request-Method</p><p>请求希望使用的方法</p></li><li><p>Access-Control-Request-Headers</p><p>（可选）要使用的逗号分隔的自定义头部列表。</p></li></ol><p>下面是一个假设的 POST 请求，包含自定义的 NCZ 头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure><p>在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。</p><ol><li><p>Access-Control-Allow-Origin</p><p>与简单请求相同。</p></li><li><p>Access-Control-Allow-Methods</p><p>允许的方法（逗号分隔的列表）。</p></li><li><p>Access-Control-Allow-Headers</p><p>服务器允许的头部（逗号分隔的列表）</p></li><li><p>Access-Control-Max-Age</p><p>缓存预检请求的秒数。</p></li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Allow-Methods: POST, GET</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure><p>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的 请求时才会多发送一次额外的 HTTP 请求。</p><h1 id="替代性跨源技术"><a href="#替代性跨源技术" class="headerlink" title="替代性跨源技术"></a>替代性跨源技术</h1><p>CORS 出现之前，实现跨源 Ajax 通信是有点麻烦的。开发者需要依赖能够执行跨源请求的 DOM 特 性，在不使用 XHR 对象情况下发送某种类型的请求。虽然 CORS 目前已经得到广泛支持，但这些技术 仍然没有过时，因为它们不需要修改服务器。</p><h2 id="图片检测"><a href="#图片检测" class="headerlink" title="图片检测"></a>图片检测</h2><p>图片探测是利用<code>&lt;img&gt;</code>标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的 <code>onload</code> 和 <code>onerror</code> 事件处理程序得知何时收到响应。</p><p>这种动态创建图片的技术经常用于图片探测（image pings）。图片探测是与服务器之间简单、跨域、 单向的通信。数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为 204 的状态码。 浏览器通过图片探测拿不到任何数据，但可以通过监听 onload 和 onerror 事件知道什么时候能接收 到响应。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.example.com/test?name=Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure><p>这个例子创建了一个新的 Image 实例，然后为它的 onload 和 onerror 事件处理程序添加了同一 个函数。这样可以确保请求完成时无论什么响应都会收到通知。设置完 src 属性之后请求就开始了，这个例子向服务器发送了一个 name 值。</p><p>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，图片探测的缺点是只能发送 GET 请求和无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。</p><h1 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h1><p>Fetch API 能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在 Web 工作线程等现代 Web 工具中使用。XMLHttpRequest 可以选择异步，而 Fetch API 则必须是异步。Fetch API 是 WHATWG 的一个“活标准”（living standard），用规范原文说，就是“Fetch 标准定义请求、 响应，以及绑定二者的流程：获取（fetch）”。</p><p>Fetch API 本身是使用 JavaScript 请求资源的优秀工具，同时这个 API 也能够应用在服务线程 （service worker）中，提供拦截、重定向和修改通过 fetch()生成的请求接口。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>fetch()</code>方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法， 浏览器就会向给定 URL 发送请求。</p><ol><li><p>分派请求</p><p><code>fetch()</code>只有一个必需的参数 <code>input</code>。多数情况下，这个参数是要获取资源的 URL。这个方法返回 一个期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r); <span class="comment">// Promise &lt;pending&gt; </span></span><br></pre></td></tr></table></figure><p>URL 的格式（相对路径、绝对路径等）的解释与 XHR 对象一样。</p><p> 请求完成、资源可用时，期约会解决为一个 Response 对象。这个对象是 API 的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式， 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;bar.txt&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// Response &#123; type: &quot;basic&quot;, url: ... &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>读取响应</p><p>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到 <code>text()</code>方法。这个方法返回一个期约，会解决为取得资源的完整内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;bar.txt&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     response.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// bar.txt 的内容</span></span><br></pre></td></tr></table></figure><p>内容的结构通常是打平的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;bar.txt&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br><span class="line"><span class="comment">// bar.txt 的内容</span></span><br></pre></td></tr></table></figure></li><li><p>处理状态码和请求失败</p><p>Fetch API 支持通过 Response 的 status（状态码）和 statusText（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为 200 的状态码，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 200</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// OK</span></span><br><span class="line"> &#125;); </span><br></pre></td></tr></table></figure><p>请求不存在的资源通常会产生值为 404 的状态码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/does-not-exist&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 404</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// Not Found</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>请求的 URL 如果抛出服务器错误会产生值为 500 的状态码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/throw-server-error&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 500</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// Internal Server Error</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>可以显式地设置 <code>fetch()</code>在遇到重定向时的行为（本章后面会介绍），不过默认行为是跟随重定向 并返回状态码不是 300~399 的响应。跟随重定向时，响应对象的 redirected 属性会被设置为 true， 而状态码仍然是 200：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/permanent-redirect&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 默认行为是跟随重定向直到最终 URL</span></span><br><span class="line">     <span class="comment">// 这个例子会出现至少两轮网络请求</span></span><br><span class="line">     <span class="comment">// &lt;origin url&gt;/permanent-redirect -&gt; &lt;redirect url&gt;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 200</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// OK</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">redirected</span>); <span class="comment">// true</span></span><br><span class="line"> &#125;); </span><br></pre></td></tr></table></figure><p>在前面这几个例子中，虽然请求可能失败（如状态码为 500），但都只执行了期约的解决处理函数。 事实上，只要服务器返回了响应，fetch()期约都会解决。这个行为是合理的：系统级网络协议已经成 功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。</p><p>通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在 状态码非 200~299 时检查 Response 对象的 ok 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 200</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">ok</span>); <span class="comment">// true</span></span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/does-not-exist&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 404</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">ok</span>); <span class="comment">// false</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>因为服务器没有响应而导致浏览器超时，这样真正的 fetch()失败会导致期约被拒绝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/hangs-forever&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line"> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">//（浏览器超时后）</span></span><br><span class="line"><span class="comment">// TypeError: &quot;NetworkError when attempting to fetch resource.&quot; </span></span><br></pre></td></tr></table></figure><p>违反 CORS、无网络连接、HTTPS 错配及其他浏览器&#x2F;网络策略问题都会导致期约被拒绝。</p><p>可以通过 url 属性检查通过 fetch()发送请求时使用的完整 URL：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.com/bar/baz 发送的请求</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>); <span class="comment">// https://foo.com/bar/baz</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;qux&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>));</span><br><span class="line"><span class="comment">// https://foo.com/bar/qux</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/qux&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>));</span><br><span class="line"><span class="comment">// https://foo.com/qux</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//qux.com&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>));</span><br><span class="line"><span class="comment">// https://qux.com</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://qux.com&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>));</span><br><span class="line"><span class="comment">// https://qux.com</span></span><br></pre></td></tr></table></figure></li><li><p>自定义选项</p><p>只使用 URL 时，fetch()会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请 求，需要传入可选的第二个参数 init 对象。</p></li></ol><h2 id="常见fetch请求模式"><a href="#常见fetch请求模式" class="headerlink" title="常见fetch请求模式"></a>常见fetch请求模式</h2><p>与 XMLHttpRequest 一样，fetch()既可以发送数据也可以接收数据。使用 init 对象参数，可以配置 fetch()在请求体中发送各种序列化的数据。</p><ol><li><p>发送JSON数据</p><p>可以像下面这样发送简单 JSON 字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-json&#x27;</span>, &#123;</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line">     <span class="attr">body</span>: payload,</span><br><span class="line">     <span class="attr">headers</span>: jsonHeaders</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></li><li><p>在请求体中发送参数</p><p>因为请求体支持任意字符串值，所以可以通过它发送请求参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paramHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-params&#x27;</span>, &#123;</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line">     <span class="attr">body</span>: payload,</span><br><span class="line">     <span class="attr">headers</span>: paramHeaders</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送文件</p><p>因为请求体支持 FormData 实现，所以 fetch()也可以序列化并发送文件字段中的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">imageFormData.<span class="title function_">append</span>(<span class="string">&#x27;image&#x27;</span>, imageInput.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/img-upload&#x27;</span>, &#123;</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">     <span class="attr">body</span>: imageFormData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个 fetch()实现可以支持多个文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;][multiple]&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageInput.<span class="property">files</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line"> imageFormData.<span class="title function_">append</span>(<span class="string">&#x27;image&#x27;</span>, imageInput.<span class="property">files</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/img-upload&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"> <span class="attr">body</span>: imageFormData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>加载Blob文件</p><p>Fetch API也能提供 Blob 类型的响应，而 Blob 又可以兼容多种浏览器 API。一种常见的做法是明确将 图片文件加载到内存，然后将其添加到 HTML图片元素。为此，可以使用响应对象上暴露的 blob()方法。 这个方法返回一个期约，解决为一个 Blob 的实例。然后，可以将这个实例传给 URL.createObjectUrl() 以生成可以添加给图片元素 src 属性的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imageElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;my-image.png&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line"> imageElement.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送跨源请求</p><p>从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//cross-origin.com&#x27;</span>);</span><br><span class="line"><span class="comment">// TypeError: Failed to fetch</span></span><br><span class="line"><span class="comment">// No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span></span><br></pre></td></tr></table></figure><p>如果代码不需要访问响应，也可以发送 no-cors 请求。此时响应的 type 属性值为 opaque，因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//cross-origin.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;no-cors&#x27;</span> &#125;)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">type</span>));</span><br><span class="line"><span class="comment">// opaque</span></span><br></pre></td></tr></table></figure></li><li><p>中断请求</p><p>Fetch API 支持通过 AbortController&#x2F;AbortSignal 对中断请求。调用 AbortController. abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的 fetch()请求会 导致包含错误的拒绝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abortController = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;wikipedia.zip&#x27;</span>, &#123; <span class="attr">signal</span>: abortController.<span class="property">signal</span> &#125;)</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aborted!&#x27;</span>);</span><br><span class="line">           </span><br><span class="line"><span class="comment">// 10 毫秒后中断请求</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> abortController.<span class="title function_">abort</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经中断</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h2><p>Headers 对象是所有外发请求和入站响应头部的容器。每个外发的 Request 实例都包含一个空的 Headers 实例，可以通过 Request.prototype.headers 访问，每个入站 Response 实例也可以通过 Response.prototype.headers 访问包含着响应头部的 Headers 对象。这两个属性都是可修改属性。 另外，使用 new Headers()也可以创建一个新实例。</p><ol><li><p>Headers 与 Map 的相似之处</p><p>Headers 对象与 Map 对象极为相似。这是合理的，因为 HTTP 头部本质上是序列化后的键&#x2F;值对， 它们的 JavaScript 表示则是中间接口。Headers 与 Map 类型都有 get()、set()、has()和 delete() 等实例方法，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>();</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">// 设置键</span></span><br><span class="line">h.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// 检查键</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">has</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 更新值</span></span><br><span class="line">h.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得更新的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// baz</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 删除值</span></span><br><span class="line">h.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 确定值已经删除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Headers 和 Map 都可以使用一个可迭代对象来初始化，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seed = [[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]];</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(seed);</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(seed);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>而且，它们也都有相同的 keys()、values()和 entries()迭代器接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seed = [[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], [<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>]];</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(seed);</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(seed);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...h.<span class="title function_">keys</span>()); <span class="comment">// foo, baz</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...m.<span class="title function_">keys</span>()); <span class="comment">// foo, baz</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...h.<span class="title function_">values</span>()); <span class="comment">// bar, qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...m.<span class="title function_">values</span>()); <span class="comment">// bar, qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...h.<span class="title function_">entries</span>()); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...m.<span class="title function_">entries</span>()); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>Headers独有的特性</p><p>Headers 并不是与 Map 处处都一样。在初始化 Headers 对象时，也可以使用键&#x2F;值对形式的对象， 而 Map 则不可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seed = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(seed);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(seed);</span><br><span class="line"><span class="comment">// TypeError: object is not iterable</span></span><br></pre></td></tr></table></figure><p>一个 HTTP 头部字段可以有多个值，而 Headers 对象通过 append()方法支持添加多个值。在 Headers 实例中还不存在的头部上调用 append()方法相当于调用 set()。后续调用会以逗号为分隔符 拼接多个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>();</span><br><span class="line"></span><br><span class="line">h.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"></span><br><span class="line">h.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// &quot;bar, baz&quot; </span></span><br></pre></td></tr></table></figure></li><li><p>头部护卫</p><p>某些情况下，并非所有 HTTP 头部都可以被客户端修改，而 Headers 对象使用护卫来防止不被允 许的修改。不同的护卫设置会改变 set()、append()和 delete()的行为。违反护卫限制会抛出 TypeError。</p><p>Headers 实例会因来源不同而展现不同的行为，它们的行为由护卫来控制。JavaScript 可以决定 Headers 实例的护卫设置。下表列出了不同的护卫设置和每种设置对应的行为。</p><table><thead><tr><th>护卫</th><th>适用情形</th><th>限制</th></tr></thead><tbody><tr><td>none</td><td>在通过构造函数创建 Headers 实例时激活</td><td>无</td></tr><tr><td>Request</td><td>在通过构造函数初始化 Request对象，且 mode 值为非 no-cors 时激活</td><td>不允许修改禁止修改的头部（参见 MDN 文档中 的 forbidden header name 词条）</td></tr><tr><td>request-no-cors</td><td>在通过构造函数初始化 Request对象，且 mode 值为 no-cors 时激活</td><td>不允许修改非简单头部（参见 MDN 文档中的 simple header 词条）</td></tr><tr><td>response</td><td>在通过构造函数初始化 Response 对象时激活</td><td>不允许修改禁止修改的响应头部（参见 MDN 文 档中的 forbidden response header name 词条）</td></tr><tr><td>immutable</td><td>在通过 error()或 redirect()静态方法初始 化 Response 对象时激活</td><td>不允许修改任何头部</td></tr></tbody></table></li></ol><h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><p>顾名思义，Request 对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。</p><ol><li><p>创建Request对象</p><p>可以通过构造函数初始化 Request 对象。为此需要传入一个 input 参数，一般是 URL：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line"><span class="comment">// Request &#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>Request 构造函数也接收第二个参数——一个 init 对象。这个 init 对象与前面介绍的 fetch() 的 init 对象一样。没有在 init 对象中涉及的值则会使用默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用所有默认值创建 Request 对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="comment">// Request &#123;</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// cache: &quot;default&quot;</span></span><br><span class="line"><span class="comment">// credentials: &quot;same-origin&quot;</span></span><br><span class="line"><span class="comment">// destination: &quot;&quot;</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// integrity: &quot;&quot;</span></span><br><span class="line"><span class="comment">// keepalive: false</span></span><br><span class="line"><span class="comment">// method: &quot;GET&quot;</span></span><br><span class="line"><span class="comment">// mode: &quot;cors&quot;</span></span><br><span class="line"><span class="comment">// redirect: &quot;follow&quot;</span></span><br><span class="line"><span class="comment">// referrer: &quot;about:client&quot;</span></span><br><span class="line"><span class="comment">// referrerPolicy: &quot;&quot;</span></span><br><span class="line"><span class="comment">// signal: AbortSignal &#123;aborted: false, onabort: null&#125;</span></span><br><span class="line"><span class="comment">// url: &quot;&lt;current URL&gt;&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定的初始值创建 Request 对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;));</span><br><span class="line"><span class="comment">// Request &#123;</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// cache: &quot;default&quot;</span></span><br><span class="line"><span class="comment">// credentials: &quot;same-origin&quot;</span></span><br><span class="line"><span class="comment">// destination: &quot;&quot;</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// integrity: &quot;&quot;</span></span><br><span class="line"><span class="comment">// keepalive: false</span></span><br><span class="line"><span class="comment">// method: &quot;POST&quot;</span></span><br><span class="line"><span class="comment">// mode: &quot;cors&quot;</span></span><br><span class="line"><span class="comment">// redirect: &quot;follow&quot;</span></span><br><span class="line"><span class="comment">// referrer: &quot;about:client&quot;</span></span><br><span class="line"><span class="comment">// referrerPolicy: &quot;&quot;</span></span><br><span class="line"><span class="comment">// signal: AbortSignal &#123;aborted: false, onabort: null&#125;</span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>克隆Request对象</p><p>Fetch API 提供了两种不太一样的方式用于创建 Request 对象的副本：使用 Request 构造函数和使用 clone()方法。</p><p>将 Request 实例作为 input 参数传给 Request 构造函数，会得到该请求的一个副本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Request</span>(r1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">url</span>); <span class="comment">// https://foo.com/</span></span><br></pre></td></tr></table></figure><p>如果再传入 init 对象，则 init 对象的值会覆盖源对象中同名的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Request</span>(r1, &#123;<span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">method</span>); <span class="comment">// GET</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">method</span>); <span class="comment">// POST</span></span><br></pre></td></tr></table></figure><p>这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Request</span>(r1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>如果源对象与创建的新对象不同源，则 referrer 属性会被清除。此外，如果源对象的 mode 为 navigate，则会被转换为 same-origin。</p><p>第二种克隆 Request 对象的方式是使用 clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> r2 = r1.<span class="title function_">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">url</span>); <span class="comment">// https://foo.com/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">url</span>); <span class="comment">// https://foo.com/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>如果请求对象的 bodyUsed 属性为 true（即请求体已被读取），那么上述任何一种方式都不能用来创建这个对象的副本。在请求体被读取之后再克隆会导致抛出 TypeError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line">r.<span class="title function_">clone</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Request</span>(r);</span><br><span class="line"><span class="comment">// 没有错误</span></span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>(); <span class="comment">// 设置 bodyUsed 为 true</span></span><br><span class="line">r.<span class="title function_">clone</span>();</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Request&#x27;: Request body is already used</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Request</span>(r);</span><br><span class="line"><span class="comment">// TypeError: Failed to construct &#x27;Request&#x27;: Cannot construct a Request with a</span></span><br><span class="line"><span class="title class_">Request</span> object that has already been used.</span><br></pre></td></tr></table></figure></li><li><p>在fetch()中使用Request对象</p><p>fetch()和 Request 构造函数拥有相同的函数签名并不是巧合。在调用 fetch()时，可以传入已经创建好的 Request 实例而不是 URL。与 Request 构造函数一样，传给 fetch()的 init 对象会覆 盖传入请求对象的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 foo.com 发送 GET 请求</span></span><br><span class="line"><span class="title function_">fetch</span>(r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 foo.com 发送 POST 请求</span></span><br><span class="line"><span class="title function_">fetch</span>(r, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>fetch()会在内部克隆传入的 Request 对象。与克隆 Request 一样，fetch()也不能拿请求体已经用过的 Request 对象来发送请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(r);</span><br><span class="line"><span class="comment">// TypeError: Cannot construct a Request with a Request object that has already</span></span><br><span class="line">been used.</span><br></pre></td></tr></table></figure><p>关键在于，通过 fetch 使用 Request 会将请求体标记为已使用。也就是说，有请求体的 Request 只能在一次 fetch 中使用。（不包含请求体的请求不受此限制。）演示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(r);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(r);</span><br><span class="line"><span class="comment">// TypeError: Cannot construct a Request with a Request object that has already been used. </span></span><br></pre></td></tr></table></figure><p>要想基于包含请求体的相同 Request 对象多次调用 fetch()，必须在第一次发送 fetch()请求前 调用 clone()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 个都会成功</span></span><br><span class="line"><span class="title function_">fetch</span>(r.<span class="title function_">clone</span>());</span><br><span class="line"><span class="title function_">fetch</span>(r.<span class="title function_">clone</span>());</span><br><span class="line"><span class="title function_">fetch</span>(r); </span><br></pre></td></tr></table></figure></li></ol><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p>顾名思义，Response 对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p><ol><li><p>创建Response对象</p><p>可以通过构造函数初始化 Response 对象且不需要参数。此时响应实例的属性均为默认值，因为它并不代表实际的 HTTP 响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Response</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: true</span></span><br><span class="line"><span class="comment">// redirected: false</span></span><br><span class="line"><span class="comment">// status: 200</span></span><br><span class="line"><span class="comment">// statusText: &quot;OK&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;default&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>Response 构造函数接收一个可选的 body 参数。这个 body 可以是 null，等同于 fetch()参数 init 中的 body。还可以接收一个可选的 init 对象，这个对象可以包含下表所列的键和值。</p><table><thead><tr><th>键</th><th>值</th></tr></thead><tbody><tr><td>headers</td><td>必须是 Headers 对象实例或包含字符串键&#x2F;值对的常规对象实例，默认为没有键&#x2F;值对的 Headers 对象</td></tr><tr><td>status</td><td>表示 HTTP 响应状态码的整数，默认为 200</td></tr><tr><td>statusText</td><td>表示 HTTP 响应状态的字符串，默认为空字符串</td></tr></tbody></table><p>可以像下面这样使用 body 和 init 来构建 Response 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">status</span>: <span class="number">418</span>,</span><br><span class="line"> <span class="attr">statusText</span>: <span class="string">&#x27;I\&#x27;m a teapot&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: false</span></span><br><span class="line"><span class="comment">// redirected: false</span></span><br><span class="line"><span class="comment">// status: 418</span></span><br><span class="line"><span class="comment">// statusText: &quot;I&#x27;m a teapot&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;default&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>大多数情况下，产生 Response 对象的主要方式是调用 fetch()，它返回一个最后会解决为 Response 对象的期约，这个 Response 对象代表实际的 HTTP 响应。下面的代码展示了这样得到的 Response 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: true</span></span><br><span class="line"><span class="comment">// redirected: false</span></span><br><span class="line"><span class="comment">// status: 200</span></span><br><span class="line"><span class="comment">// statusText: &quot;OK&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;basic&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/&quot;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>Response 类还有两个用于生成 Response 对象的静态方法：Response.redirect()和 Response. error()。前者接收一个 URL 和一个重定向状态码（301、302、303、307 或 308），返回重定向的 Response 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Response</span>.<span class="title function_">redirect</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, <span class="number">301</span>));</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: false</span></span><br><span class="line"><span class="comment">// redirected: false</span></span><br><span class="line"><span class="comment">// status: 301</span></span><br><span class="line"><span class="comment">// statusText: &quot;&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;default&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>提供的状态码必须对应重定向，否则会抛出错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Response</span>.<span class="title function_">redirect</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// RangeError: Failed to execute &#x27;redirect&#x27; on &#x27;Response&#x27;: Invalid status code</span></span><br></pre></td></tr></table></figure><p>另一个静态方法 Response.error()用于产生表示网络错误的 Response 对象（网络错误会导致 fetch()期约被拒绝）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Response</span>.<span class="title function_">error</span>());</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: false</span></span><br><span class="line"><span class="comment">// redirected: false</span></span><br><span class="line"><span class="comment">// status: 0</span></span><br><span class="line"><span class="comment">// statusText: &quot;&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;error&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>读取响应状态信息</p><p>Response 对象包含一组只读属性，描述了请求完成后的状态，如下表所示。</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>headers</td><td>响应包含的 Headers 对象</td></tr><tr><td>ok</td><td>布尔值，表示 HTTP 状态码的含义。200~299 的状态码返回 true，其他状态码返回 false</td></tr><tr><td>redirected</td><td>布尔值，表示响应是否至少经过一次重定向</td></tr><tr><td>status</td><td>整数，表示响应的 HTTP 状态码</td></tr><tr><td>statusText</td><td>字符串，包含对 HTTP 状态码的正式描述。这个值派生自可选的 HTTP Reason-Phrase 字段，因此如果服务器以 Reason-Phrase 为由拒绝响应，这个字段可能是空字符串</td></tr><tr><td>type</td><td>字符串，包含响应类型。可能是下列字符串值之一<br />1、basic：表示标准的同源响应<br />2、cors：表示标准的跨源响应<br />3、error：表示响应对象是通过 Response.error()创建的<br />4、opaque：表示 no-cors 的 fetch()返回的跨源响应<br />5、opaqueredirect：表示对 redirect 设置为 manual 的请求的响应</td></tr><tr><td>url</td><td>包含响应 URL 的字符串。对于重定向响应，这是最终的 URL，非重定向响应就是它产生的</td></tr></tbody></table><p>以下代码演示了返回 200、302、404 和 500 状态码的 URL 对应的响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//foo.com&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: true</span></span><br><span class="line"><span class="comment">// redirected: false</span></span><br><span class="line"><span class="comment">// status: 200</span></span><br><span class="line"><span class="comment">// statusText: &quot;OK&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;basic&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//foo.com/redirect-me&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: true</span></span><br><span class="line"><span class="comment">// redirected: true</span></span><br><span class="line"><span class="comment">// status: 200</span></span><br><span class="line"><span class="comment">// statusText: &quot;OK&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;basic&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/redirected-url/&quot;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//foo.com/does-not-exist&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: false</span></span><br><span class="line"><span class="comment">// redirected: true</span></span><br><span class="line"><span class="comment">// status: 404</span></span><br><span class="line"><span class="comment">// statusText: &quot;Not Found&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;basic&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/does-not-exist/&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//foo.com/throws-error&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// Response &#123;</span></span><br><span class="line"><span class="comment">// body: (...)</span></span><br><span class="line"><span class="comment">// bodyUsed: false</span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// ok: false</span></span><br><span class="line"><span class="comment">// redirected: true</span></span><br><span class="line"><span class="comment">// status: 500</span></span><br><span class="line"><span class="comment">// statusText: &quot;Internal Server Error&quot;</span></span><br><span class="line"><span class="comment">// type: &quot;basic&quot;</span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/throws-error/&quot;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure></li><li><p>克隆Response对象</p><p>克隆 Response 对象的主要方式是使用 clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = r1.<span class="title function_">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果响应对象的 bodyUsed 属性为 true（即响应体已被读取），则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出 TypeError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line">r.<span class="title function_">clone</span>();</span><br><span class="line"><span class="comment">// 没有错误</span></span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>(); <span class="comment">// 设置 bodyUsed 为 true</span></span><br><span class="line"></span><br><span class="line">r.<span class="title function_">clone</span>();</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Response&#x27;: Response body is already used </span></span><br></pre></td></tr></table></figure><p>有响应体的 Response 对象只能读取一次。（不包含响应体的 Response 对象不受此限制。）比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar</span></span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure><p>要多次读取包含响应体的同一个 Response 对象，必须在第一次读取前调用 clone()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">clone</span>().<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar</span></span><br><span class="line">r.<span class="title function_">clone</span>().<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar</span></span><br><span class="line">r.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar </span></span><br></pre></td></tr></table></figure><p>此外，通过创建带有原始响应体的 Response 实例，可以执行伪克隆操作。关键是这样不会把第一 个 Response 实例标记为已读，而是会在两个响应之间共享：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Response</span>(r1.<span class="property">body</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">r2.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar</span></span><br><span class="line">r1.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Request、Response-及-Body-混入"><a href="#Request、Response-及-Body-混入" class="headerlink" title="Request、Response 及 Body 混入"></a>Request、Response 及 Body 混入</h2><p>Request 和 Response 都使用了 Fetch API 的 Body 混入，以实现两者承担有效载荷的能力。这个 混入为两个类型提供了只读的 body 属性（实现为 ReadableStream）、只读的 bodyUsed 布尔值（表 示 body 流是否已读）和一组方法，用于从流中读取内容并将结果转换为某种 JavaScript 对象类型。</p><p>通常，将 Request 和 Response 主体作为流来使用主要有两个原因。一个原因是有效载荷的大小 可能会导致网络延迟，另一个原因是流 API 本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。</p><p>Body 混入提供了 5 个方法，用于将 ReadableStream 转存到缓冲区的内存里，将缓冲区转换为某 种 JavaScript 对象类型，以及通过期约来产生结果。在解决之前，期约会等待主体流报告完成及缓冲被 解析。这意味着客户端必须等待响应的资源完全加载才能访问其内容。</p><ol><li><p>Body.text()</p><p>Body.text()方法返回期约，解决为将缓冲区转存得到的 UTF-8 格式字符串。下面的代码展示了 在 Response 对象上使用 Body.text()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment">// &lt;head&gt;</span></span><br><span class="line"><span class="comment">// &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">// ... </span></span><br></pre></td></tr></table></figure><p>以下代码展示了在 Request 对象上使用 Body.text()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;barbazqux&#x27;</span> &#125;);</span><br><span class="line"> </span><br><span class="line">request.<span class="title function_">text</span>()</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// barbazqux</span></span><br></pre></td></tr></table></figure></li><li><p>Body.json()</p><p>Body.json()方法返回期约，解决为将缓冲区转存得到的 JSON。下面的代码展示了在 Response 对象上使用 Body.json()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com/foo.json&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &#123;&quot;foo&quot;: &quot;bar&quot;&#125; </span></span><br></pre></td></tr></table></figure><p>以下代码展示了在 Request 对象上使用 Body.json()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span> &#125;) &#125;);</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">json</span>()</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;bar: &#x27;baz&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Body.formData()</p><p>浏览器可以将 FormData 对象序列化&#x2F;反序列化为主体。例如，下面这个 FormData 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">myFormData.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br></pre></td></tr></table></figure><p>在通过 HTTP 传送时，WebKit 浏览器会将其序列化为下列内容：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundarydR9Q2kOzE6nbN7eR</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;foo&quot; </span><br><span class="line">bar</span><br><span class="line">------WebKitFormBoundarydR9Q2kOzE6nbN7eR--</span><br></pre></td></tr></table></figure><p>Body.formData()方法返回期约，解决为将缓冲区转存得到的 FormData 实例。下面的代码展示 了在 Response 对象上使用 Body.formData()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com/form-data&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">formData</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">formData</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(formData.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">       </span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>以下代码展示了在 Request 对象上使用 Body.formData()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">myFormData.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: myFormData &#125;);</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">formData</span>()</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">formData</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(formData.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">// bar </span></span><br></pre></td></tr></table></figure></li><li><p>Body.arrayBuffer()</p><p>有时候，可能需要以原始二进制格式查看和修改主体。为此，可以使用 Body.arrayBuffer()将 主体内容转换为 ArrayBuffer 实例。Body.arrayBuffer()方法返回期约，解决为将缓冲区转存得到 的 ArrayBuffer 实例。下面的代码展示了在 Response 对象上使用 Body.arrayBuffer()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">arrayBuffer</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ArrayBuffer(...) &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>以下代码展示了在 Request 对象上使用 Body.arrayBuffer()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;abcdefg&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以整数形式打印二进制编码的字符串</span></span><br><span class="line">request.<span class="title function_">arrayBuffer</span>()</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">buf</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Int8Array</span>(buf)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Int8Array(7) [97, 98, 99, 100, 101, 102, 103] </span></span><br></pre></td></tr></table></figure></li><li><p>Body.blob()</p><p>有时候，可能需要以原始二进制格式使用主体，不用查看和修改。为此，可以使用 Body.blob() 将主体内容转换为 Blob 实例。Body.blob()方法返回期约，解决为将缓冲区转存得到的 Blob 实例。 下面的代码展示了在 Response 对象上使用 Body.blob()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>())</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Blob(...) &#123;size:..., type: &quot;...&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>以下代码展示了在 Request 对象上使用 Body.blob()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;abcdefg&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">blob</span>()</span><br><span class="line"> .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blob(7) &#123;size: 7, type: &quot;text/plain;charset=utf-8&quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>一次性流</p><p>因为 Body 混入是构建在 ReadableStream 之上的，所以主体流只能使用一次。这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> response.<span class="title function_">blob</span>()));</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">blob</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> request.<span class="title function_">blob</span>());</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure><p>即使是在读取流的过程中，所有这些方法也会在它们被调用时给 ReadableStream 加锁，以阻止其他读取器访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"> response.<span class="title function_">blob</span>(); <span class="comment">// 第一次调用给流加锁</span></span><br><span class="line"> response.<span class="title function_">blob</span>(); <span class="comment">// 第二次调用再次加锁会失败</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked</span></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">blob</span>(); <span class="comment">// 第一次调用给流加锁</span></span><br><span class="line">request.<span class="title function_">blob</span>(); <span class="comment">// 第二次调用再次加锁会失败</span></span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure><p>作为 Body 混入的一部分，bodyUsed 布尔值属性表示 ReadableStream 是否已摄受（disturbed）， 意思是读取器是否已经在流上加了锁。这不一定表示流已经被完全读取。下面的代码演示了这个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">request.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar</span></span><br><span class="line">response.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">bodyUsed</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">bodyUsed</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><p>Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript 中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP 的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务 器实现，而必须使用支持该协议的专有服务器。</p><p>因为 Web Socket使用了自定义协议，所以 URL方案（scheme）稍有变化：不能再使用 http:&#x2F;&#x2F;或 https:&#x2F;&#x2F;， 而要使用 ws:&#x2F;&#x2F;和 wss:&#x2F;&#x2F;。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包 含 URL 方案，因为将来有可能再支持其他方案。</p><p>使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。 使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。Web Socket 得到了所有主流浏 览器支持。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>要创建一个新的 Web Socket，就要实例化一个 WebSocket 对象并传入提供连接的 URL：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意，必须给 WebSocket 构造函数传入一个绝对 URL。同<strong>源策略不适用于 Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在握手阶段就可以确定请求来自哪里。）</strong></p><p>浏览器会在初始化 WebSocket 对象之后立即创建连接。与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态。不过，这个值与 XHR 中相应的值不一样。</p><ul><li>WebSocket.OPENING（0）：连接正在建立。</li><li>WebSocket.OPEN（1）：连接已经建立。</li><li>WebSocket.CLOSING（2）：连接正在关闭。</li><li>WebSocket.CLOSE（3）：连接已经关闭。</li></ul><p>WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件。 readyState 值从 0 开始。</p><p>任何时候都可以调用 close()方法关闭 Web Socket 连接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>调用 close()之后，readyState 立即变为 2（连接正在关闭），并会在关闭后变为 3（连接已经关闭）。</p><h2 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h2><p>打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用 send()方法并 传入一个字符串、ArrayBuffer 或 Blob，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stringData = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arrayBufferData = <span class="title class_">Uint8Array</span>.<span class="title function_">from</span>([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> blobData = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">send</span>(stringData);</span><br><span class="line">socket.<span class="title function_">send</span>(arrayBufferData.<span class="property">buffer</span>);</span><br><span class="line">socket.<span class="title function_">send</span>(blobData); </span><br></pre></td></tr></table></figure><p>服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件。这个 message 事件与其 他消息协议类似，可以通过 event.data 属性访问到有效载荷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> data = event.<span class="property">data</span>;</span><br><span class="line"> <span class="comment">// 对数据执行某些操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与通过 send()方法发送的数据类似，event.data 返回的数据也可能是 ArrayBuffer 或 Blob。 这由 WebSocket 对象的 binaryType 属性决定，该属性可能是”blob”或”arraybuffer”。</p><h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><p>WebSocket 对象在连接生命周期中有可能触发 3 个其他事件。</p><ul><li>open：在连接成功建立时触发。</li><li>error：在发生错误时触发。连接无法存续。</li><li>close：在连接关闭时触发。</li></ul><p>WebSocket 对象不支持 DOM Level 2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程 序来监听这些事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Connection established.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Connection error.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在这些事件中，只有 close 事件的 event 对象上有额外信息。这个对象上有 3 个额外属性： wasClean、code 和 reason。其中，wasClean 是一个布尔值，表示连接是否干净地关闭；code 是一 个来自服务器的数值状态码；reason 是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`as clean? <span class="subst">$&#123;event.wasClean&#125;</span> Code=<span class="subst">$&#123;event.code&#125;</span> Reason=<span class="subst">$&#123;event.reason&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2005 年，Jesse James Garrett 撰写了一篇文章，“Ajax—A New Approach to Web Applications”。这篇 文章中描绘了一个被他称作 Ajax（Asynchronous JavaScript+XML，即异步 JavaScr</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(13)——事件</title>
    <link href="http://pvnk1u.github.io/2023/05/13/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(13)%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/"/>
    <id>http://pvnk1u.github.io/2023/05/13/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(13)%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/</id>
    <published>2023-05-13T04:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.879Z</updated>
    
    <content type="html"><![CDATA[<p><code>JavaScript</code> 与 <code>HTML</code> 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。 可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫 “观察者模式”，其能够做到页面行为（在 <code>JavaScript</code> 中定义）与页面展示（在 <code>HTML</code> 和 <code>CSS</code> 中定义）的分离。</p><h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>在第四代 Web 浏览器开始开发时，开发团队碰到了一个有意思的问题：页面哪个部分拥有特定的事件呢？要理解这个问题，可以在一张纸上画几个同心圆。把手指放 到圆心上，则手指不仅是在一个圆圈里，而且是在所有的圆圈里。两家浏览器的开发团队都是以同样的 方式看待浏览器事件的。当你点击一个按钮时，实际上不光点击了这个按钮，还点击了它的容器以及整 个页面。</p><p>事件流描述了页面接收事件的顺序。结果非常有意思，IE 和 Netscape 开发团队提出了几乎完全相反的事件流方案。IE 将支持<strong>事件冒泡流</strong>，而 Netscape Communicator 将支持<strong>事件捕获流</strong>。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。比如有如下 <code>HTML</code> 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在点击页面中的<code>&lt;div&gt;</code>元素后，<code>click</code> 事件会以如下顺序发生：</p><ol><li><code>&lt;div&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;html&gt;</code></li><li><code>document</code></li></ol><p>也就是说，<code>&lt;div&gt;</code>元素，即被点击的元素，最先触发 click 事件。然后，click 事件沿 DOM 树一 路向上，在经过的每个节点上依次触发，直至到达 document 对象。</p><p>所有现代浏览器都支持事件冒泡。现代浏览器中的事件会一直冒泡到 <code>window</code> 对象。</p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>Netscape Communicator 团队提出了另一种名为事件捕获的事件流。事件捕获的意思是最不具体的节 点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。如果前面的例子使用事件捕获，则点击<code>&lt;div&gt;</code>元素会以下列顺序触发 click 事件：</p><ol><li>document</li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;div&gt;</code></li></ol><p>在事件捕获中，<code>click</code> 事件首先由 <code>document</code> 元素捕获，然后沿 <code>DOM</code> 树依次向下传播，直至到达 实际的目标元素<code>&lt;div&gt;</code>。</p><p>虽然这是 Netscape Communicator 唯一的事件流模型，但事件捕获得到了所有现代浏览器的支持。 实际上，所有浏览器都是从 <code>window</code> 对象开始捕获事件，而 <code>DOM2 Events</code>规范规定的是从 <code>document </code>开始。</p><p>由于旧版本浏览器不支持，因此实际当中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情 况下可以使用事件捕获。</p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p><code>DOM2 Events</code> 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生， 为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个 阶段响应事件。仍以前面那个简单的 <code>HTML</code> 为例，点击<code>&lt;div&gt;</code>元素会以如图所示的顺序触发事件。</p><p><img src="https://pvnk1u.github.io/images/EventFlow.PNG" alt="EventFlow"></p><p>在 <code>DOM</code> 事件流中，实际的目标（<code>&lt;div&gt;</code>元素）在捕获阶段不会接收到事件。这是因为捕获阶段从 <code>document</code> 到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就结束了。下一阶段，即会在<code>&lt;div&gt;</code>元素上触发事件的“到达目标” 阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后，冒泡阶段开始，事件反向传播至文档。</p><p>大多数支持 <code>DOM</code> 事件流的浏览器实现了一个小小的拓展。<strong>虽然 <code>DOM2 Events</code> 规范明确捕获阶段不命中事件目标，但现代浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。</strong></p><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><p><strong>事件意味着用户或浏览器执行的某种动作。比如，单击（<code>click</code>）、加载（<code>load</code>）、鼠标悬停 （<code>mouseover</code>）。为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字 以”on”开头，因此 <code>click</code> 事件的处理程序叫作 <code>onclick</code>，而 <code>load</code> 事件的处理程序叫作 <code>onload</code>。有 很多方式可以指定事件处理程序。</strong></p><h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><p>特定元素支持的每个事件都可以使用事件处理程序的名字以 <code>HTML</code> 属性的形式来指定。此时属性的值必须是能够执行的 <code>JavaScript</code> 代码。例如，要在按钮被点击时执行某些 <code>JavaScript</code> 代码，可以使用以下 <code>HTML</code> 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;Clicked&#x27;)&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure><p>点击这个按钮后，控制台会输出一条消息。这种交互能力是通过为 <code>onclick</code>属性指定 <code>JavaScript</code> 代码值来实现的。注意，因为属性的值是 <code>JavaScript</code> 代码，所以不能在未经转义的情况下使用 <code>HTML</code> 语 法字符，比如和号（&amp;）、双引号（”）、小于号（&lt;）和大于号（&gt;）。此时，为了避免使用 <code>HTML</code> 实体， 可以使用单引号代替双引号。如果确实需要使用双引号，则要把代码改成下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">onclick</span>=<span class="string">&quot;console.log(<span class="symbol">&amp;quot;</span>Clicked<span class="symbol">&amp;quot;</span>)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>HTML</code> 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showMessage()&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，单击按钮会调用 <code>showMessage()</code>函数。<code>showMessage()</code>函数是在单独的<code>&lt;script&gt;</code>元素中定义的，而且也可以在外部文件中定义。作为事件处理程序执行的代码可以访问全局作用域中的一切。</p><p>以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。<strong>这个函数有一个特殊的局部变量 <code>event</code>，其中保存的就是 <code>event</code> 对象:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出&quot;click&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(event.type)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了。</p><p><strong>在这个函数中，<code>this</code> 值相当于事件的目标元素，如下面的例子所示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出&quot;Click Me&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.value)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中， <code>document</code> 和元素自身的成员都可以被当成局部变量来访问。这是通过使用 <code>with</code> 实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">with</span>(<span class="params"><span class="variable language_">document</span></span>) &#123;</span><br><span class="line">     <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>) &#123;</span><br><span class="line">     <span class="comment">// 属性值</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着事件处理程序可以更方便地访问自己的属性。下面的代码与前面的示例功能一样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出&quot;Click Me&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(value)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>如果这个元素是一个表单输入框，则作用域链中还会包含表单元素</strong>，事件处理程序对应的函数等价于如下这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">with</span>(<span class="params"><span class="variable language_">document</span></span>) &#123;</span><br><span class="line">     <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span>.form</span>) &#123;</span><br><span class="line">         <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>) &#123;</span><br><span class="line">            <span class="comment">// 属性值</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，经过这样的扩展，事件处理程序的代码就可以不必引用表单元素，而直接访问同一表单中的其他成员了。下面的例子就展示了这种成员访问模式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Echo Username&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">onclick</span>=<span class="string">&quot;console.log(username.value)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击这个例子中的按钮会显示出文本框中包含的文本。注意，事件处理程序中的代码直接引用了 <code>username</code>。</p><p>在 <code>HTML</code> 中指定事件处理程序有一些问题。第一个问题是时机问题。有可能 <code>HTML</code> 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。比如在前面的例子中，如果 <code>showMessage()</code>函数是在页面后面，在按钮中代码的后面定义的，那么当用户在 <code>showMessage()</code>函数 被定义之前点击按钮时，就会发生错误。为此，大多数 <code>HTML</code> 事件处理程序会封装在 <code>try/catch</code> 块中， 以便在这种情况下静默失败，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;try&#123;showMessage();&#125;catch(ex) &#123;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，如果在 <code>showMessage()</code>函数被定义之前点击了按钮，就不会发生 <code>JavaScript</code>错误了，这是因为错误在浏览器收到之前已经被拦截了。</p><p>另一个问题是对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同 <code>JavaScript</code> 引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。</p><p>使用 <code>HTML</code> 指定事件处理程序的最后一个问题是 <code>HTML</code> 与 <code>JavaScript</code> 强耦合。如果需要修改事件处理程序，则必须在两个地方，即 <code>HTML</code> 和 <code>JavaScript</code> 中，修改代码。这也是很多开发者不使用 <code>HTML</code> 事件处理程序，而使用 <code>JavaScript</code> 指定事件处理程序的主要原因。</p><h2 id="DOM0事件处理程序"><a href="#DOM0事件处理程序" class="headerlink" title="DOM0事件处理程序"></a>DOM0事件处理程序</h2><p>在 <code>JavaScript</code> 中指定事件处理程序的传统方式是把一个函数赋值给（<code>DOM</code> 元素的）一个事件处理程序属性。这也是在第四代 Web 浏览器中开始支持的事件处理程序赋值方法，直到现在所有现代浏览器仍然都支持此方法，主要原因是简单。要使用 <code>JavaScript</code>指定事件处理程序，必须先取得要操作对象的引用。</p><p>每个元素（包括 <code>window</code> 和 <code>document</code>）都有通常小写的事件处理程序属性，比如 <code>onclick</code>。只要把这个属性赋值为一个函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里先从文档中取得按钮，然后给它的 <code>onclick</code> 事件处理程序赋值一个函数。注意，前面的代码在运行之后才会给事件处理程序赋值。因此如果在页面中上面的代码出现在按钮之后，则有可能出现用户点击按钮没有反应的情况。</p><p><strong>像这样使用 <code>DOM0</code> 方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 <code>this</code> 等于元素。</strong>下面的例子演示了使用 <code>this</code> 引用元素本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); <span class="comment">// &quot;myBtn&quot;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>点击按钮，这段代码会显示元素的 ID。这个 ID 是通过 <code>this.id</code> 获取的。不仅仅是 id，在事件处理程序里通过 <code>this</code> 可以访问元素的任何属性和方法。<strong>以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。</strong></p><p>通过将事件处理程序属性的值设置为 <code>null</code>，可以移除通过 <code>DOM0</code> 方式添加的事件处理程序，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>; <span class="comment">// 移除事件处理程序</span></span><br></pre></td></tr></table></figure><p>把事件处理程序设置为 <code>null</code>，再点击按钮就不会执行任何操作了。</p><h2 id="DOM2事件处理程序"><a href="#DOM2事件处理程序" class="headerlink" title="DOM2事件处理程序"></a>DOM2事件处理程序</h2><p><code>DOM2 Events</code> 为事件处理程序的赋值和移除定义了两个方法：<code>addEventListener()</code>和 <code>removeEventListener()</code>。<strong>这两个方法暴露在所有 <code>DOM</code> 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。</strong></p><p>仍以给按钮添加 <code>click</code> 事件处理程序为例，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><p>以上代码为按钮添加了会在事件冒泡阶段触发的 <code>onclick</code> 事件处理程序（因为最后一个参数值为 false）。与 <code>DOM0</code> 方式类似，这个事件处理程序同样在被附加到的元素的作用域中运行。<strong>使用 <code>DOM2</code> 方式的主要优势是可以为同一个事件添加多个事件处理程序。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这里给按钮添加了两个事件处理程序。多个事件处理程序以添加顺序来触发，因此前面的代码会先打印元素 ID，然后显示消息“Hello world!”。</p><p>通过 <code>addEventListener()</code>添加的事件处理程序只能使用 <code>removeEventListener()</code>并传入与添加时同样的参数来移除。这意味着使用 <code>addEventListener()</code>添加的匿名函数无法移除，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line"> &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 没有效果！</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><p>这个例子通过 <code>addEventListener()</code>添加了一个匿名函数作为事件处理程序。然后，又以看起来 相同的参数调用了 <code>removeEventListener()</code>。但实际上，第二个参数与传给 <code>addEventListener()</code> 的完全不是一回事。传给 <code>removeEventListener()</code>的事件处理函数必须与传给 <code>addEventListener()</code> 的是同一个，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); <span class="comment">// 有效果！</span></span><br></pre></td></tr></table></figure><p>这个例子有效，因为调用 <code>addEventListener()</code>和 <code>removeEventListener()</code>时传入的是同一个函数。</p><p><strong>大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。</strong></p><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p><strong>在 <code>DOM</code> 中发生事件时，所有相关信息都会被收集并存储在一个名为 <code>event</code> 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。 例如，鼠标操作导致的事件会生成鼠标位置信息，而键盘操作导致的事件会生成与被按下的键有关的信息。所有浏览器都支持这个 <code>event</code> 对象，尽管支持方式不同。</strong></p><h2 id="DOM事件对象"><a href="#DOM事件对象" class="headerlink" title="DOM事件对象"></a>DOM事件对象</h2><p>在 <code>DOM</code> 合规的浏览器中，<code>event</code> 对象是传给事件处理程序的唯一参数。不管以哪种方式（<code>DOM0</code> 或 <code>DOM2</code>）指定事件处理程序，都会传入这个 <code>event</code> 对象。下面的例子展示了在两种方式下都可以使用事件对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这个例子中的两个事件处理程序都会在控制台打出 <code>event.type</code> 属性包含的事件类型。这个属性中 始终包含被触发事件的类型，如”click”（与传给 <code>addEventListener()</code>和 <code>removeEventListener()</code> 方法的事件名一致）。</p><p>在通过 <code>HTML</code> 属性指定的事件处理程序中，同样可以使用变量 <code>event</code> 引用事件对象。下面的例子中演示了如何使用这个变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(event.type)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以这种方式提供 <code>event</code> 对象，可以让 <code>HTML</code> 属性中的代码实现与 <code>JavaScript</code> 函数同样的功能。</p><p>如前所述，事件对象包含与特定事件相关的属性和方法。不同的事件生成的事件对象也会包含不同 的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。</p><table><thead><tr><th>属性&#x2F;方法</th><th>类型</th><th>读&#x2F;写</th><th>说明</th></tr></thead><tbody><tr><td>bubbles</td><td>布尔值</td><td>只读</td><td>表示事件是否冒泡</td></tr><tr><td>cancelable</td><td>布尔值</td><td>只读</td><td>表示是否可以取消事件的默认行为</td></tr><tr><td>currentTarget</td><td>元素</td><td>只读</td><td>当前事件处理程序所在的元素</td></tr><tr><td>defaultPrevented</td><td>布尔值</td><td>只读</td><td>true 表示已经调用 preventDefault()方法（DOM3 Events 中新增）</td></tr><tr><td>detail</td><td>整数</td><td>只读</td><td>事件相关的其他信息</td></tr><tr><td>eventPhase</td><td>整数</td><td>只读</td><td>表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段</td></tr><tr><td>preventDefault()</td><td>函数</td><td>只读</td><td>用于取消事件的默认行为。只有 cancelable 为 true 才 可以调用这个方法</td></tr><tr><td>stopImmediatePropagation()</td><td>函数</td><td>只读</td><td>用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增）</td></tr><tr><td>stopPropagation()</td><td>函数</td><td>只读</td><td>用于取消所有后续事件捕获或事件冒泡。只有 bubbles 为 true 才可以调用这个方法</td></tr><tr><td>target</td><td>元素</td><td>只读</td><td>事件目标</td></tr><tr><td>trusted</td><td>布尔值</td><td>只读</td><td>true 表示事件是由浏览器生成的。false 表示事件是开 发者通过 JavaScript 创建的（DOM3 Events 中新增）</td></tr><tr><td>type</td><td>字符串</td><td>只读</td><td>被触发的事件类型</td></tr><tr><td>View</td><td>AbstractView</td><td>只读</td><td>与事件相关的抽象视图。等于事件所发生的 window 对象</td></tr></tbody></table><p>在事件处理程序内部，<code>this</code> 对象始终等于 <code>currentTarget</code> 的值，而 <code>target</code> 只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 <code>this</code>、<code>currentTarget</code> 和 <code>target</code> 的值是一样 的。下面的例子展示了这两个属性都等于 <code>this</code> 的情形：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span> === <span class="variable language_">this</span>); <span class="comment">// true</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span> === <span class="variable language_">this</span>); <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码检测了 <code>currentTarget</code> 和 <code>target</code> 的值是否等于 <code>this</code>。因为 <code>click</code> 事件的目标是按钮，所以这 3 个值是相等的。如果这个事件处理程序是添加到按钮的父节点（如 <code>document.body</code>）上， 那么它们的值就不一样了。比如下面的例子在 <code>document.body</code> 上添加了单击处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span> === <span class="variable language_">document</span>.<span class="property">body</span>); <span class="comment">// true</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">document</span>.<span class="property">body</span>); <span class="comment">// true</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span> === <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种情况下点击按钮，<code>this</code> 和 <code>currentTarget</code> 都等于 <code>document.body</code>，这是因为它是注册事件处理程序的元素。而 <code>target</code> 属性等于按钮本身，这是因为那才是 <code>click</code> 事件真正的目标。由于按钮本身并没有注册事件处理程序，因此 <code>click</code> 事件冒泡到 <code>document.body</code>，从而触发了在它上面注册的处理程序。</p><p><code>type</code> 属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用了 <code>event.type</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">     <span class="keyword">switch</span>(event.<span class="property">type</span>) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;click&quot;</span>:</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;mouseover&quot;</span>:</span><br><span class="line">     event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;mouseout&quot;</span>:</span><br><span class="line">     event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="property">onclick</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseover</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseout</span> = handler;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>handler</code> 被用于处理 3 种不同的事件：<code>click</code>、<code>mouseover</code> 和 <code>mouseout</code>。 当按钮被点击时，应该在控制台打印一条消息，如前面的例子所示。而把鼠标放到按钮上，会导致按钮 背景变成红色，接着把鼠标从按钮上移开，背景颜色应该又恢复成默认值。这个函数使用 <code>event.type</code> 属性确定了事件类型，从而可以做出不同的响应。</p><p><code>preventDefault()</code>方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到 <code>href</code> 属性指定的 <code>URL</code>。如果想阻止这个导航行为，可以在 <code>onclick</code> 事件处理程序中取消，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLink&quot;</span>);</span><br><span class="line">link.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>任何可以通过 <code>preventDefault()</code>取消默认行为的事件，其事件对象的 <code>cancelable</code> 属性都会设置为 true。</p><p><code>stopPropagation()</code>方法用于立即阻止事件流在 <code>DOM</code> 结构中传播，取消后续的事件捕获或冒泡。 例如，直接添加到按钮的事件处理程序中调用 <code>stopPropagation()</code>，可以阻止 <code>document.body</code> 上注册的事件处理程序执行。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line"> event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body clicked&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果这个例子中不调用<code>stopPropagation()</code>，那么点击按钮就会打印两条消息。但这里由于<code>click</code> 事件不会传播到 <code>document.body</code>，因此 <code>onclick</code> 事件处理程序永远不会执行。</p><p><code>eventPhase</code> 属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则 <code>eventPhase</code> 等于 1；如果事件处理程序在目标上被调用，则 <code>eventPhase</code> 等于 2；如果事件处理程序在冒泡阶段被调用，则 <code>eventPhase</code> 等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的， 但其 <code>eventPhase</code> 仍然等于 2。下面的例子展示了 <code>eventPhase</code> 在不同阶段的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">eventPhase</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">eventPhase</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">eventPhase</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在这个例子中，点击按钮首先会触发注册在捕获阶段的 <code>document.body</code> 上的事件处理程序， 显示 <code>eventPhase</code> 为 1。接着，会触发按钮本身的事件处理程序（尽管是注册在冒泡阶段），此时显示 <code>eventPhase</code> 等于 2。最后触发的是注册在冒泡阶段的 <code>document.body</code> 上的事件处理程序，显示 <code>eventPhase</code> 为 3。而当 <code>eventPhase</code> 等于 2 时，<code>this</code>、<code>target</code> 和 <code>currentTarget</code> 三者相等。</p><h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p><code>Web</code> 浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。<code>DOM3 Events</code> 定义了如下事件类型。</p><ol><li><p>用户界面事件（UIEvent）</p><p>涉及与 <code>BOM</code> 交互的通用浏览器事件。</p></li><li><p>焦点事件（FocusEvent）</p><p>在元素获得和失去焦点时触发。</p></li><li><p>鼠标事件（MouseEvent）</p><p>使用鼠标在页面上执行某些操作时触发。</p></li><li><p>滚轮事件（WheelEvent）</p><p>使用鼠标滚轮（或类似设备）时触发。</p></li><li><p>输入事件（InputEvent）</p><p>向文档中输入文本时触发。</p></li><li><p>键盘事件（KeyboardEvent）</p><p>使用键盘在页面上执行某些操作时触发。</p></li><li><p>合成事件（CompositionEvent）</p><p>在使用某种 IME（Input Method Editor，输入法编辑器）输入 字符时触发。</p></li></ol><p>除了这些事件类型之外，<code>HTML5</code> 还定义了另一组事件，而浏览器通常在 <code>DOM</code> 和 <code>BOM</code> 上实现专有事件。这些专有事件基本上都是根据开发者需求而不是按照规范增加的，因此不同浏览器的实现可能不同。</p><p><code>DOM3 Events</code> 在 <code>DOM2 Events</code> 基础上重新定义了事件，并增加了新的事件类型。所有主流浏览器 都支持 <code>DOM2 Events</code> 和 <code>DOM3 Events</code>。</p><h2 id="用户界面事件"><a href="#用户界面事件" class="headerlink" title="用户界面事件"></a>用户界面事件</h2><p>用户界面事件或 <code>UI</code> 事件不一定跟用户操作有关。这类事件在 <code>DOM</code> 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。<code>UI</code> 事件主要有以下几种。</p><ol><li><p>DOMActivate</p><p>元素被用户通过鼠标或键盘操作激活时触发（比 <code>click</code> 或 <code>keydown</code> 更通用）。 这个事件在 <code>DOM3 Events</code> 中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。</p></li><li><p>load</p><p>在 <code>window</code> 上当页面加载完成后触发，在窗套（<code>&lt;frameset&gt;</code>）上当所有窗格（<code>&lt;frame&gt;</code>） 都加载完成后触发，在<code>&lt;img&gt;</code>元素上当图片加载完成后触发，在<code>&lt;object&gt;</code>元素上当相应对象加载完成后触发。</p></li><li><p>unload</p><p>在 <code>window</code> 上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在<code>&lt;object&gt;</code>元素上当相应对象卸载完成后触发。</p></li><li><p>abort</p><p>在<code>&lt;object&gt;</code>元素上当相应对象加载完成前被用户提前终止下载时触发。</p></li><li><p>error</p><p>在 <code>window</code> 上当 <code>JavaScript</code> 报错时触发，在<code>&lt;img&gt;</code>元素上当无法加载指定图片时触发， 在元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。</p></li><li><p>select</p><p>在文本框（<code>input</code>或 <code>textarea</code>）上当用户选择了一个或多个字符时触发。</p></li><li><p>resize</p><p>在 <code>window</code> 或窗格上当窗口或窗格被缩放时触发。</p></li><li><p>scroll</p><p>当用户滚动包含滚动条的元素时在元素上触发。<code>&lt;body&gt;</code>元素包含已加载页面的滚动条。</p></li></ol><p>大多数 <code>HTML</code> 事件与 <code>window</code> 对象和表单控件有关。</p><p> 除了 <code>DOMActivate</code>，这些事件在 <code>DOM2 Events</code> 中都被归为 <code>HTML Events</code>（<code>DOMActivate</code> 在 <code>DOM2</code> 中仍旧是 <code>UI</code> 事件）。</p><h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><p>焦点事件在页面元素获得或失去焦点时触发。这些事件可以与 <code>document.hasFocus()</code>和 <code>document.activeElement</code> 一起为开发者提供用户在页面中导航的信息。焦点事件有以下 6 种。</p><ol><li><p><code>blur</code></p><p>当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。</p></li><li><p><code>focus</code></p><p>当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。</p></li><li><p><code>focusin</code></p><p>当元素获得焦点时触发。这个事件是 <code>focus</code> 的冒泡版。</p></li><li><p><code>focusout</code></p><p>当元素失去焦点时触发。这个事件是 <code>blur</code> 的通用版。</p></li></ol><p>焦点事件中的两个主要事件是 <code>focus</code> 和 <code>blur</code>，这两个事件在 <code>JavaScript</code> 早期就得到了浏览器支持。 它们最大的问题是不冒泡。这导致 IE后来又增加了 <code>focusin</code> 和 <code>focusout</code>，IE 新增的这两个事件已经被 <code>DOM3 Events </code>标准化。</p><p><strong>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。</strong></p><ol><li><code>focuscout</code> 在失去焦点的元素上触发。</li><li><code>focusin</code> 在获得焦点的元素上触发。</li><li><code>blur</code> 在失去焦点的元素上触发。</li><li><code>focus</code> 在获得焦点的元素上触发。</li></ol><p>其中，<code>blur</code>、<code>focusout</code> 的事件目标是失去焦点的元素，而 <code>focus</code>和 <code>focusin</code> 的事件目标是获得焦点的元素。</p><h2 id="鼠标和滚轮事件"><a href="#鼠标和滚轮事件" class="headerlink" title="鼠标和滚轮事件"></a>鼠标和滚轮事件</h2><p>鼠标事件是 Web 开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。<code>DOM3 Events</code> 定义了 9 种鼠标事件。</p><ol><li><p>click</p><p>在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发 <code>onclick</code> 事件处理程序。</p></li><li><p>dblclick</p><p>在用户双击鼠标主键（通常是左键）时触发。这个事件不是在 <code>DOM2 Events</code> 中定义 的，但得到了很好的支持，<code>DOM3 Events</code> 将其进行了标准化。</p></li><li><p>mousedown</p><p>在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。</p></li><li><p>mouseenter</p><p>在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发。<code>mouseenter</code> 事件不是在 <code>DOM2 Events</code> 中定义的，而是 <code>DOM3 Events</code> 中新增的事件。</p></li><li><p>mouseleave</p><p>在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。<code>mouseleave</code> 事件不是在 <code>DOM2 Events</code> 中定义的，而是 <code>DOM3 Events</code> 中新增的事件。</p></li><li><p>mousemove</p><p>在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。</p></li><li><p>mouseout</p><p>在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。</p></li><li><p>mouseover</p><p>在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。</p></li><li><p>mouseup</p><p>在用户释放鼠标键时触发。这个事件不能通过键盘触发。</p></li></ol><p>页面中的所有元素都支持鼠标事件。除了 <code>mouseenter</code> 和 <code>mouseleave</code>，所有鼠标事件都会冒泡， 都可以被取消，而这会影响浏览器的默认行为。</p><p>由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。</p><p>比如，<code>click</code> 事件触发的前提是 <code>mousedown</code> 事件触发后，紧接着又在同一个元素上触发了 <code>mouseup</code> 事件。如果 <code>mousedown</code> 和 <code>mouseup</code> 中的任意一个事件被取消，那么 <code>click</code> 事件就不会触发。类似地， 两次连续的 <code>click</code> 事件会导致 <code>dblclick</code> 事件触发。只要有任何逻辑阻止了这两个 <code>click</code> 事件发生（比 如取消其中一个 <code>click</code> 事件或者取消 <code>mousedown</code> 或 <code>mouseup</code> 事件中的任一个），<code>dblclick</code>事件就不 会发生。这 4 个事件永远会按照如下顺序触发：</p><ol><li>mousedown</li><li>mouseup</li><li>click</li><li>mousedown</li><li>mouseup</li><li>click</li><li>dblclick</li></ol><p><code>click</code> 和 <code>dblclick</code> 在触发前都依赖其他事件触发，<code>mousedown</code> 和 <code>mouseup</code> 则不会受其他事件影响。</p><h2 id="键盘与输入事件"><a href="#键盘与输入事件" class="headerlink" title="键盘与输入事件"></a>键盘与输入事件</h2><p>键盘事件是用户操作键盘时触发的。<code>DOM2 Events</code> 最初定义了键盘事件，但该规范在最终发布前删除了相应内容。因此，键盘事件很大程度上是基于原始的 <code>DOM0</code> 实现的。</p><p><code>DOM3 Events</code> 为键盘事件提供了一个首先在 <code>IE9</code> 中完全实现的规范。其他浏览器也开始实现该规范， 但仍然存在很多遗留的实现。</p><p>键盘事件包含 3 个事件：</p><ol><li><p>keydown</p><p>用户按下键盘上某个键时触发，而且持续按住会重复触发。</p></li><li><p>keypress</p><p>用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc 键也会 触发这个事件。DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。</p></li><li><p>keyup</p><p>用户释放键盘上某个键时触发。</p></li></ol><p>虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。</p><p>输入事件只有一个，即 <code>textInput</code>。这个事件是对 <code>keypress</code> 事件的扩展，用于在文本显示给用 户之前更方便地截获文本输入。<code>textInput</code> 会在文本被插入到文本框之前触发。</p><p>当用户按下键盘上的某个字符键时，首先会触发 <code>keydown</code> 事件，然后触发 <code>keypress</code> 事件，最后 触发 <code>keyup</code> 事件。注意，这里 <code>keydown</code> 和 <code>keypress</code> 事件会在文本框出现变化之前触发，而 <code>keyup</code>事件会在文本框出现变化之后触发。如果一个字符键被按住不放，<code>keydown</code> 和 <code>keypress</code> 就会重复触 发，直到这个键被释放。</p><h1 id="内存与性能"><a href="#内存与性能" class="headerlink" title="内存与性能"></a>内存与性能</h1><p>在 <code>JavaScript</code> 中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理 程序所需访问 <code>DOM</code> 的次数会先期造成整个页面交互的延迟。只要在使用事件处理程序时多注意一些方 法，就可以改善页面性能。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件 处理程序来管理一种类型的事件。例如，<code>click</code> 事件冒泡到 <code>document</code>。这意味着可以为整个页面指定 一个 <code>onclick</code>事件处理程序，而不用为每个可点击元素分别指定事件处理程序。比如有以下 <code>HTML</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myLinks&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;goSomewhere&quot;</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>HTML</code> 包含 3 个列表项，在被点击时应该执行某个操作。对此，通常的做法是像这样指定 3 个事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;goSomewhere&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sayHi&quot;</span>);</span><br><span class="line">item1.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> location.<span class="property">href</span> = <span class="string">&quot;http:// www.wrox.com&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">item2.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">item3.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果对页面中所有需要使用 <code>onclick</code> 事件处理程序的元素都如法炮制，结果就会出现大片雷同的只为指定事件处理程序的代码。使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序， 就可以解决问题。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLinks&quot;</span>);</span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">switch</span>(target.<span class="property">id</span>) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;doSomething&quot;</span>:</span><br><span class="line">         <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;goSomewhere&quot;</span>:</span><br><span class="line">         location.<span class="property">href</span> = <span class="string">&quot;http:// www.wrox.com&quot;</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;sayHi&quot;</span>:</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>这里只给<code>&lt;div&gt;</code>元素添加了一个 <code>onclick</code> 事件处理程序。<strong>因为所有列表项都是这个元素的后代，所以它们的事件会向上冒泡，最终都会由这个函数来处理。但事件目标是每个被点击的列表项，只要检查 <code>event</code> 对象的 id 属性就可以确定，然后再执行相应的操作即可。</strong>相对于前面不使用事件委托的代码，这里的代码不会导致先期延迟，因为只访问了一个 <code>DOM</code> 元素和添加了一个事件处理程 序。结果对用户来说没有区别，但这种方式占用内存更少。所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 与 &lt;code&gt;HTML&lt;/code&gt; 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。 可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫 “观察者模式”，其能够做</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(12)——DOM扩展</title>
    <link href="http://pvnk1u.github.io/2023/05/11/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(12)%E2%80%94%E2%80%94DOM%E6%89%A9%E5%B1%95/"/>
    <id>http://pvnk1u.github.io/2023/05/11/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(12)%E2%80%94%E2%80%94DOM%E6%89%A9%E5%B1%95/</id>
    <published>2023-05-10T21:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selectors-API"><a href="#Selectors-API" class="headerlink" title="Selectors API"></a>Selectors API</h1><p>2008 年以前，大部分浏览器对 <code>DOM</code> 的扩展是专有的。此后，<code>W3C</code> 开始着手将这些已成为事实标准的专有扩展编制成正式规范。诞生了描述 <code>DOM</code> 扩展的两个标准：<code>Selectors API</code> 与 <code>HTML5</code>。这两个标准体现了社 区需求和标准化某些手段及 <code>API</code> 的愿景。另外还有较小的 <code>Element Traversal</code> 规范，增加了一些 <code>DOM </code>属性。</p><p><code>JavaScript</code> 库中最流行的一种能力就是根据 <code>CSS</code> 选择符的模式匹配 <code>DOM</code> 元素。比如，<code>jQuery</code> 就完全以 <code>CSS</code> 选择符查询 <code>DOM</code> 获取元素引用，而不是使用 <code>getElementById()</code>和 <code>getElementsByTagName()</code>。</p><p><code>Selectors API</code>（参见 <code>W3C</code> 网站上的 <code>Selectors API Level 1</code>）是 <code>W3C</code> 推荐标准，规定了浏览器原生支持的 <code>CSS</code> 查询 <code>API</code>。支持这一特性的所有 <code>JavaScript</code> 库都会实现一个基本的 <code>CSS</code> 解析器，然后使用已有 的 <code>DOM</code> 方法搜索文档并匹配目标节点。虽然库开发者在不断改进其性能，但 <code>JavaScript</code> 代码能做到的毕竟有限。通过浏览器原生支持这个 <code>API</code>，解析和遍历 <code>DOM</code> 树可以通过底层编译语言实现，性能也有了数量级的提升。</p><p><code>Selectors API Level 1</code> 的核心是两个方法：<code>querySelector()</code>和 <code>querySelectorAll()</code>。在兼容浏览器中，<code>Document</code> 类型和 <code>Element </code>类型的实例上都会暴露这两个方法。</p><p><code>Selectors API Level 2</code> 规范在 <code>Element</code> 类型上新增了更多方法，比如 <code>matches()</code>、<code>find()</code>和 <code>findAll()</code>。不过，目前还没有浏览器实现或宣称实现 <code>find()</code>和 <code>findAll()</code>。</p><h2 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h2><p><code>querySelector()</code>方法接收 <code>CSS </code>选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 <code>null</code>。下面是一些例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得&lt;body&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#myDiv&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类名为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.selected&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>在 <code>Document</code> 上使用 <code>querySelector()</code>方法时，会从文档元素开始搜索；在 <code>Element</code> 上使用 <code>querySelector()</code>方法时，则只会从当前元素的后代中查询。</strong></p><p>用于查询模式的 <code>CSS</code>选择符可繁可简，依需求而定。如果选择符有语法错误或碰到不支持的选择符， 则 <code>querySelector()</code>方法会抛出错误。</p><h2 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h2><p><code>querySelectorAll()</code>方法跟 <code>querySelector()</code>一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 <code>NodeList</code> 的静态实例。</p><p>再强调一次，<code>querySelectorAll()</code>返回的 <code>NodeList</code> 实例一个属性和方法都不缺，但它是一 个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 <code>NodeList </code>对象可能造成的性能问题。</p><p>以有效 <code>CSS</code> 选择符调用 <code>querySelectorAll()</code>都会返回 <code>NodeList</code>，无论匹配多少个元素都可以。 如果没有匹配项，则返回空的 <code>NodeList</code> 实例。</p><p>与 <code>querySelector()</code>一样，<code>querySelectorAll()</code>也可以在 <code>Document</code>、<code>DocumentFragment</code> 和 <code>Element</code> 类型上使用。下面是几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">querySelectorAll</span>(<span class="string">&quot;em&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得所有类名中包含&quot;selected&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.selected&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>);</span><br></pre></td></tr></table></figure><p>返回的 <code>NodeList</code> 对象可以通过 <code>for-of</code> 循环、<code>item()</code>方法或中括号语法取得个别元素。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strongElements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下 3 个循环的效果一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> strong <span class="keyword">of</span> strongElements) &#123;</span><br><span class="line"> strong.<span class="property">className</span> = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.<span class="property">length</span>; ++i) &#123;</span><br><span class="line"> strongElements.<span class="title function_">item</span>(i).<span class="property">className</span> = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.<span class="property">length</span>; ++i) &#123;</span><br><span class="line"> strongElements[i].<span class="property">className</span> = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>与 <code>querySelector()</code>方法一样，如果选择符有语法错误或碰到不支持的选择符，则 <code>querySelectorAll()</code>方法会抛出错误。</p><h2 id="matchs"><a href="#matchs" class="headerlink" title="matchs()"></a>matchs()</h2><p><code>matches()</code>方法（在规范草案中称为 <code>matchesSelector()</code>）接收一个 <code>CSS</code> 选择符参数，如果元素匹配则该选择符返回 true，否则返回 false。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">matches</span>(<span class="string">&quot;body.page1&quot;</span>))&#123;</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用这个方法可以方便地检测某个元素会不会被 <code>querySelector()</code>或 <code>querySelectorAll()</code>方法返回。</p><h1 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h1><p><code>IE9</code> 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了 <code>childNodes</code> 和 <code>firstChild</code> 等属性上的差异。为了弥补这个差异，同时不影响 <code>DOM</code> 规范，<code>W3C </code>通过新的 <code>Element Traversal </code>规范定义了一组新属性。</p><p><code>Element Traversal API</code> 为 <code>DOM</code> 元素添加了 5 个属性：</p><ol><li><p>childElementCount</p><p>返回子元素数量（不包含文本节点和注释）；</p></li><li><p>firstElementChild</p><p>指向第一个 Element 类型的子元素（Element 版 firstChild）；</p></li><li><p>lastElementChild</p><p>指向最后一个 Element 类型的子元素（Element 版 lastChild）；</p></li><li><p>previousElementSibling</p><p>指向前一个 Element 类型的同胞元素（ Element 版 previousSibling）；</p></li><li><p>nextElementSibling</p><p>指向后一个 Element 类型的同胞元素（Element 版 nextSibling）。</p></li></ol><p>在支持的浏览器中，所有 <code>DOM</code> 元素都会有这些属性，为遍历 <code>DOM</code> 元素提供便利。这样开发者就 不用担心空白文本节点的问题了。</p><p>过去要以跨浏览器方式遍历特定元素的所有子元素，代码大致是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> currentChildNode = parentElement.<span class="property">firstChild</span>;</span><br><span class="line"><span class="comment">// 没有子元素，firstChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildNode) &#123;</span><br><span class="line"> <span class="keyword">if</span> (currentChildNode.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// 如果有元素节点，则做相应处理</span></span><br><span class="line">     <span class="title function_">processChild</span>(currentChildNode);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (currentChildNode === parentElement.<span class="property">lastChild</span>) &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> currentChildNode = currentChildNode.<span class="property">nextSibling</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用 <code>Element Traversal</code> 属性之后，以上代码可以简化如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> currentChildElement = parentElement.<span class="property">firstElementChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有子元素，firstElementChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildElement) &#123;</span><br><span class="line"> <span class="comment">// 这就是元素节点，做相应处理</span></span><br><span class="line"> <span class="title function_">processChild</span>(currentChildElement);</span><br><span class="line"> <span class="keyword">if</span> (currentChildElement === parentElement.<span class="property">lastElementChild</span>) &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> currentChildElement = currentChildElement.<span class="property">nextElementSibling</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><p><code>HTML5</code> 代表着与以前的 <code>HTML</code> 截然不同的方向。在所有以前的 <code>HTML</code> 规范中，从未出现过描述 <code>JavaScript</code> 接口的情形，<code>HTML</code> 就是一个纯标记语言。<code>JavaScript</code> 绑定的事，一概交给 <code>DOM</code> 规范去定义。 然而，<code>HTML5</code> 规范却包含了与标记相关的大量 <code>JavaScript</code> API 定义。其中有的 <code>API</code> 与 <code>DOM</code> 重合， 定义了浏览器应该提供的 <code>DOM</code> 扩展。</p><h2 id="CSS类扩展"><a href="#CSS类扩展" class="headerlink" title="CSS类扩展"></a>CSS类扩展</h2><p>自 <code>HTML4</code> 被广泛采用以来，<code>Web</code> 开发中一个主要的变化是 <code>class</code> 属性用得越来越多，其用处是为 元素添加样式以及语义信息。自然地，<code>JavaScript</code> 与 <code>CSS</code> 类的交互就增多了，包括动态修改类名，以及 根据给定的一个或一组类名查询元素，等等。为了适应开发者和他们对 class 属性的认可，<code>HTML5</code> 增 加了一些特性以方便使用 <code>CSS</code> 类。</p><ol><li><p>getElementsByClassName()</p><p><code>getElementsByClassName()</code>是 <code>HTML5</code> 新增的最受欢迎的一个方法，暴露在 <code>document</code> 对象和 所有 <code>HTML</code> 元素上。这个方法脱胎于基于原有 <code>DOM</code> 特性实现该功能的 <code>JavaScript</code>库，提供了性能高好的原生实现。</p><p><code>getElementsByClassName()</code>方法接收一个参数，即包含一个或多个类名的字符串，返回类名中 包含相应类的元素的 <code>NodeList</code>。如果提供了多个类名，则顺序无关紧要。下面是几个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素</span></span><br><span class="line"><span class="comment">// 这两个类名的顺序无关紧要</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;username current&quot;</span>);</span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;selected&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个方法只会返回以调用它的对象为根元素的子树中所有匹配的元素。在 <code>document</code> 上调用 <code>getElementsByClassName()</code>返回文档中所有匹配的元素，而在特定元素上调用 <code>getElementsByClassName()</code>则返回该元素后代中匹配的元素。</p></li><li><p>classList 属性</p><p>要操作类名，可以通过 <code>className</code> 属性实现添加、删除和替换。但 <code>className</code> 是一个字符串， 所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。以下面的 <code>HTML</code> 代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bd user disabled&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这个<code>&lt;div&gt;</code>元素有 3 个类名。要想删除其中一个，就得先把 <code>className</code> 拆开，删除不想要的那个， 再把包含剩余类的字符串设置回去。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要删除&quot;user&quot;类</span></span><br><span class="line"><span class="keyword">let</span> targetClass = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把类名拆成数组</span></span><br><span class="line"><span class="keyword">let</span> classNames = div.<span class="property">className</span>.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到要删除类名的索引</span></span><br><span class="line"><span class="keyword">let</span> idx = classNames.<span class="title function_">indexOf</span>(targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有则删除</span></span><br><span class="line"><span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    classNames.<span class="title function_">splice</span>(i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设置类名</span></span><br><span class="line">div.<span class="property">className</span> = classNames.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><p>这就是从<code>&lt;div&gt;</code>元素的类名中删除”user”类要写的代码。替换类名和检测类名也要涉及同样的算 法。添加类名只涉及字符串拼接，但必须先检查一下以确保不会重复添加相同的类名。很多 <code>JavaScript</code> 库为这些操作实现了便利方法。</p><p><code>HTML5</code> 通过给所有元素增加 <code>classList</code> 属性为这些操作提供了更简单也更安全的实现方式。 <code>classList</code> 是一个新的集合类型 <code>DOMTokenList</code>的实例。与其他 <code>DOM</code>集合类型一样，<code>DOMTokenList</code> 也有 <code>length</code> 属性表示自己包含多少项，也可以通过 <code>item()</code>或中括号取得个别的元素。此外， <code>DOMTokenList</code> 还增加了以下方法。</p><ol><li><p>add(value)</p><p>向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</p></li><li><p>contains(value)</p><p>返回布尔值，表示给定的 value 是否存在。</p></li><li><p>remove(value)</p><p>从类名列表中删除指定的字符串值 value。</p></li><li><p>toggle(value)</p><p>如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</p></li></ol><p>这样以来，前面的例子中那么多行代码就可以简化成下面的一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure><p>这行代码可以在不影响其他类名的情况下完成删除。其他方法同样极大地简化了操作类名的复杂性，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;disabled&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;disabled&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加&quot;current&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;current&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换&quot;user&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测类名</span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;bd&quot;</span>) &amp;&amp; !div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;disabled&quot;</span>))&#123;</span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">class</span> <span class="title class_">of</span> div.<span class="property">classList</span>)&#123;</span><br><span class="line"> <span class="title function_">doStuff</span>(<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了 <code>classList</code> 属性之后，除非是完全删除或完全重写元素的 <code>class</code> 属性，否则 <code>className</code> 属性就用不到了。</p></li></ol><h2 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h2><p><code>HTML5</code> 增加了辅助 <code>DOM</code> 焦点管理的功能。首先是 <code>document.activeElement</code>，始终包含当前拥有焦点的 <code>DOM</code> 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 <code>focus()</code>方法）让某个元素自动获得焦点。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.<span class="title function_">focus</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">activeElement</span> === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>document.activeElement</code> 在页面刚加载完之后会设置为 <code>document.body</code>。而在页面完全加载之前，<code>document.activeElement</code> 的值为 <code>null</code>。</p><p>其次是 <code>document.hasFocus()</code>方法，该方法返回布尔值，表示文档是否拥有焦点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.<span class="title function_">focus</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">hasFocus</span>()); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面。 </p><p>第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点， 而这对于保证 Web 应用程序的无障碍使用是非常重要的。无障碍 Web 应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。</p><h2 id="HTMLDocument扩展"><a href="#HTMLDocument扩展" class="headerlink" title="HTMLDocument扩展"></a>HTMLDocument扩展</h2><p><code>HTML5</code> 扩展了 <code>HTMLDocument</code> 类型，增加了更多功能。与其他 <code>HTML5</code> 定义的 <code>DOM</code> 扩展一样， 这些变化同样基于所有浏览器事实上都已经支持的专有扩展。为此，即使这些扩展的标准化相对较晚， 很多浏览器也早就实现了相应的功能。</p><ol><li><p>readyState属性</p><p><code>readyState</code> 是 IE4 最早添加到 <code>document</code> 对象上的属性，后来其他浏览器也都依葫芦画瓢地支持 这个属性。最终，<code>HTML5</code> 将这个属性写进了标准。<code>document.readyState</code> 属性有两个可能的值：</p><ul><li><p>loading</p><p>表示文档正在加载</p></li><li><p>complete</p><p>表示文档加载完成</p></li></ul><p>实际开发中，最好是把 <code>document.readState</code> 当成一个指示器，以判断文档是否加载完毕。在这 个属性得到广泛支持以前，通常要依赖 <code>onload</code> 事件处理程序设置一个标记，表示文档加载完了。这个 属性的基本用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123;</span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compatMode属性</p><p>自从 <code>IE6</code> 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。 IE 为 <code>document</code> 添加了 <code>compatMode</code> 属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。 如下面的例子所示，标准模式下 <code>document.compatMode</code> 的值是”CSS1Compat”，而在混杂模式下， <code>document.compatMode</code> 的值是”BackCompat”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Standards mode&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Quirks mode&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>HTML5</code> 最终也把 <code>compatMode</code> 属性的实现标准化了。</p></li><li><p>head属性</p><p>作为对 <code>document.body</code>（指向文档的元素）的补充，<code>HTML5</code> 增加了 <code>document.head</code> 属 性，指向文档的元素。可以像下面这样直接取得元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="property">head</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h2><p><code>HTML5</code> 增加了几个与文档字符集有关的新属性。其中，<code>characterSet</code> 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是”UTF-16”，但可以通过元素或响应头， 以及新增的 <code>characterSeet</code> 属性来修改。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">characterSet</span>); <span class="comment">// &quot;UTF-16&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">characterSet</span> = <span class="string">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h2><p><code>HTML5</code> 允许给元素指定非标准的属性，但要使用前缀 <code>data-</code>以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，<code>data-</code>后 面跟什么都可以。下面是一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">data-appId</span>=<span class="string">&quot;12345&quot;</span> <span class="attr">data-myname</span>=<span class="string">&quot;Nicholas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义了自定义数据属性后，可以通过元素的 <code>dataset</code> 属性来访问。<code>dataset</code> 属性是一个 <code>DOMStringMap</code> 的实例，包含一组键&#x2F;值对映射。元素的每个 <code>data-name</code> 属性在 <code>dataset</code> 中都可以通过 <code>data-</code>后面的字符串作为键来访问（例如，属性 <code>data-myname</code>、<code>data-myName</code> 可以通过 <code>myname</code> 访 问，但要注意 <code>data-my-name</code>、<code>data-My-Name</code> 要通过 <code>myName</code> 来访问）。下面是一个使用自定义数据 属性的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例中使用的方法仅用于示范</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="comment">// 取得自定义数据属性的值</span></span><br><span class="line"><span class="keyword">let</span> appId = div.<span class="property">dataset</span>.<span class="property">appId</span>;</span><br><span class="line"><span class="keyword">let</span> myName = div.<span class="property">dataset</span>.<span class="property">myname</span>;</span><br><span class="line"><span class="comment">// 设置自定义数据属性的值</span></span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">appId</span> = <span class="number">23456</span>;</span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">myname</span> = <span class="string">&quot;Michael&quot;</span>;</span><br><span class="line"><span class="comment">// 有&quot;myname&quot;吗？</span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">dataset</span>.<span class="property">myname</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;div.dataset.myname&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识 页面的不同部分。另外，单页应用程序框架也非常多地使用了自定义数据属性。</p><h2 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h2><p><code>DOM</code> 虽然已经为操纵节点提供了很多 <code>API</code>，但向文档中一次性插入大量 <code>HTML</code> 时还是比较麻烦。 相比先创建一堆节点，再把它们以正确的顺序连接起来，直接插入一个 <code>HTML</code> 字符串要简单（快速） 得多。<code>HTML5</code> 已经通过以下 <code>DOM</code> 扩展将这种能力标准化了。</p><ol><li><p>innerHTML属性</p><p>在读取 <code>innerHTML</code> 属性时，会返回元素所有后代的 <code>HTML</code> 字符串，包括元素、注释和文本节点。 而在写入 <code>innerHTML</code> 时，则会根据提供的字符串值以新的 <code>DOM</code> 子树替代元素中原来包含的所有节点。 比如下面的 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这里的<code>&lt;div&gt;</code>元素而言，其 <code>innerHTML</code> 属性会返回以下字符串：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>在写入模式下，赋给 <code>innerHTML</code> 属性的值会被解析为 <code>DOM</code> 子树，并替代元素之前的所有节点。 因为所赋的值默认为 <code>HTML</code>，所以其中的所有标签都会以浏览器处理 <code>HTML</code> 的方式转换为元素。如果赋值中不包含任何 <code>HTML</code> 标签，则直接生成一个文本节点， 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为浏览器会解析设置的值，所以给 <code>innerHTML</code> 设置包含 <code>HTML</code> 的字符串时，结果会大不一样。 来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>这个操作的结果相当于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Hello <span class="symbol">&amp;amp;</span> welcome, <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="symbol">&amp;quot;</span>reader<span class="symbol">&amp;quot;</span>!<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置完<code>innerHTML</code>，马上就可以像访问其他节点一样访问这些新节点。</p></li><li><p>outerHTML 属性</p><p>读取 <code>outerHTML</code> 属性时，会返回调用它的元素（及所有后代元素）的 <code>HTML</code> 字符串。在写入 <code>outerHTML</code> 属性时，调用它的元素会被传入的 <code>HTML</code> 字符串经解释之后生成的 <code>DOM</code> 子树取代。比如 下面的 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个<code>&lt;div&gt;</code>元素上调用 <code>outerHTML</code> 会返回相同的字符串，包括<code>&lt;div&gt;</code>本身。</p><p>如果使用 <code>outerHTML</code> 设置 <code>HTML</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">outerHTML</span> = <span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>则会得到与执行以下脚本相同的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">p.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;This is a paragraph.&quot;</span>));</span><br><span class="line">div.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(p, div);</span><br></pre></td></tr></table></figure><p>新的<code>&lt;p&gt;</code>元素会取代 DOM 树中原来的<code>&lt;div&gt;</code>元素。</p></li><li><p>insertAdjacentHTML()与 insertAdjacentText()</p><p>关于插入标签的最后两个新增方法是 <code>insertAdjacentHTML()</code>和 <code>insertAdjacentText()</code>。这两 个方法最早源自 IE，它们都接收两个参数：要插入标记的位置和要插入的 <code>HTML</code> 或文本。第一个参数 必须是下列值中的一个：</p><ul><li><p>beforebegin</p><p>插入当前元素前面，作为前一个同胞节点；</p></li><li><p>afterbegin</p><p>插入当前元素内部，作为新的子节点或放在第一个子节点前面；</p></li><li><p>beforeend</p><p>插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</p></li><li><p>afterend</p><p>插入当前元素后面，作为下一个同胞节点。</p></li></ul><p>注意这几个值是不区分大小写的。第二个参数会作为 <code>HTML</code> 字符串解析（与 <code>innerHTML</code> 和 <code>outerHTML</code> 相同）或者作为纯文本解析（与 <code>innerText</code> 和 <code>outerText</code> 相同）。如果是 <code>HTML</code>，则会在解析出错时抛出错误。下面展示了基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同胞节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为第一个子节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为下一个同胞节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); element.</span><br><span class="line"><span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br></pre></td></tr></table></figure></li><li><p>内存与性能问题</p><p>使用本节介绍的方法替换子节点可能在浏览器（特别是 IE）中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他 <code>JavaScript</code> 对象（作为元素的属性），那它们之间的绑定关 系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 <code>innerHTML、 outerHTML</code> 和 <code>insertAdjacentHTML()</code>之前，最好手动删除要被替换的元素上关联的事件处理程序和 <code>JavaScript</code> 对象。</p><p>使用这些属性当然有其方便之处，特别是<code>innerHTML</code>。一般来讲，插入大量的新 <code>HTML</code> 使用 <code>innerHTML</code> 比使用多次 <code>DOM</code> 操作创建节点再插入来得更便捷。这是因为 <code>HTML</code> 解析器会解析设置给 <code>innerHTML</code>（或 <code>outerHTML</code>）的值。解析器在浏览器中是底层代码（通常是 <code>C++</code>代码），比 <code>JavaScript</code> 快得多。不过，<code>HTML</code> 解析器的构建与解构也不是没有代价，因此最好限制使用 <code>innerHTML</code> 和 <code>outerHTML</code> 的次数。比如，下面的代码使用 <code>innerHTML</code> 创建了一些列表项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values)&#123;</span><br><span class="line"> ul.<span class="property">innerHTML</span> += <span class="string">&#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;</span>; <span class="comment">// 别这样做！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码效率低，因为每次迭代都要设置一次 <code>innerHTML</code>。不仅如此，每次循环还要先读取 <code>innerHTML</code>，也就是说循环一次要访问两次 <code>innerHTML</code>。为此，最好通过循环先构建一个独立的字符串，最后再一次性把生成的字符串赋值给 <code>innerHTML</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> itemsHtml = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values)&#123;</span><br><span class="line"> itemsHtml += <span class="string">&#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ul.<span class="property">innerHTML</span> = itemsHtml;</span><br></pre></td></tr></table></figure><p>这样修改之后效率就高多了，因为只有对 <code>innerHTML</code> 的一次赋值。当然，像下面这样一行代码也可以搞定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.<span class="property">innerHTML</span> = values.<span class="title function_">map</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="string">&#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>跨站点脚本</p><p>尽管 <code>innerHTML</code> 不会执行自己创建的<code>&lt;script&gt;</code>标签，但仍然向恶意用户暴露了很大的攻击面，因 为通过它可以毫不费力地创建元素并执行 <code>onclick</code> 之类的属性。</p><p>如果页面中要使用用户提供的信息，则不建议使用 <code>innerHTML</code>。与使用 <code>innerHTML</code> 获得的方便相 比，防止 <code>XSS</code> 攻击更让人头疼。此时一定要隔离要插入的数据，在插入页面前必须毫不犹豫地使用相关的库对它们进行转义。</p></li></ol><h2 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView()"></a>scrollIntoView()</h2><p><code>DOM</code> 规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，<code>HTML5</code> 选择了标准化 <code>scrollIntoView()</code>。</p><p><code>scrollIntoView()</code>方法存在于所有 <code>HTML</code> 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：</p><ol><li><p>alignToTop是一个布尔值</p><ul><li><p>true</p><p>窗口滚动后元素的顶部与视口顶部对齐。</p></li><li><p>false</p><p>窗口滚动后元素的底部与视口底部对齐。</p></li></ul></li><li><p>scrollIntoViewOptions是一个选项对象。</p><ul><li><p>behavior</p><p>定义过渡动画，可取的值为”smooth”和”auto”，默认为”auto”。</p></li><li><p>block</p><p>定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “start”。</p></li><li><p>inline</p><p>定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “nearest”。</p></li></ul></li><li><p>不传参数等同于 alignToTop 为 true。</p></li></ol><p>来看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保元素可见</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将元素平滑地滚入视口</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览器将元素滚动到可见位置。</p><h1 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h1><p>除了已经标准化的，各家浏览器还有很多未被标准化的专有扩展。而这些功能后来则有可能被标准化，比如进入 <code>HTML5</code>。</p><h2 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h2><p><code>IE9</code> 之前的版本与其他浏览器在处理空白文本节点上的差异导致了 <code>children</code> 属性的出现。 <code>children</code> 属性是一个 <code>HTMLCollection</code>，只包含元素的 <code>Element </code>类型的子节点。如果元素的子节点类型全部是元素类型，那 <code>children</code> 和 <code>childNodes</code> 中包含的节点应该是一样的。可以像下面这样使 用 <code>children</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childCount = element.<span class="property">children</span>.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">let</span> firstChild = element.<span class="property">children</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains()方法"></a>contains()方法</h2><p><code>DOM</code> 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 <code>contains()</code>方法， 让开发者可以在不遍历 <code>DOM</code> 的情况下获取这个信息。<code>contains()</code>方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。</p><p>如果目标节点是被搜索节点的后代，<code>contains()</code>返回 true，否则返回 false。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">contains</span>(<span class="variable language_">document</span>.<span class="property">body</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>这个例子测试元素中是否包含元素，在格式正确的 <code>HTML</code> 中会返回 true。</p><h2 id="插入标记-1"><a href="#插入标记-1" class="headerlink" title="插入标记"></a>插入标记</h2><p><code>HTML5</code> 将 IE 发明的 <code>innerHTML</code> 和 <code>outerHTML</code> 纳入了标准，但还有两个属性没有入选。这两个剩 下的属性是 <code>innerText</code> 和 <code>outerText</code>。</p><ol><li><p>innerText属性</p><p><code>innerText</code> 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时， <code>innerText</code> 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，<code>innerText</code> 会移除元素的所有后代并插入一个包含该值的文本节点。来看下面的 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>对这个例子中的<code>&lt;div&gt;</code>而言，<code>innerText</code> 属性会返回以下字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is a paragraph with a list following it.</span><br><span class="line">Item 1</span><br><span class="line">Item 2</span><br><span class="line">Item 3 </span><br></pre></td></tr></table></figure><p>下面再看一个使用 <code>innerText</code> 设置<code>&lt;div&gt;</code>元素内容的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>执行这行代码后，<code>HTML</code> 页面中的这个<code>&lt;div&gt;</code>元素实际上会变成这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置 <code>innerText</code> 会移除元素之前所有的后代节点，完全改变 <code>DOM</code> 子树。此外，设置 <code>innerText</code> 也会编码出现在字符串中的 <code>HTML</code> 语法字符（小于号、大于号、引号及和号）。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = <span class="string">&quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;</span>; </span><br></pre></td></tr></table></figure><p>执行之后的结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Hello <span class="symbol">&amp;amp;</span> welcome, <span class="symbol">&amp;lt;</span>b<span class="symbol">&amp;gt;</span><span class="symbol">&amp;quot;</span>reader<span class="symbol">&amp;quot;</span>!<span class="symbol">&amp;lt;</span>/b<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过将 <code>innerText</code> 设置为等于 <code>innerText</code>，可以去除所有 <code>HTML</code> 标签而只剩文本，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = div.<span class="property">innerText</span>; </span><br></pre></td></tr></table></figure><p>执行以上代码后，容器元素的内容只会包含原先的文本内容。</p></li><li><p>outerText属性</p><p><code>outerText</code> 与 <code>innerText</code> 是类似的，只不过作用范围包含调用它的节点。要读取文本值时， <code>outerText</code> 与 <code>innerText</code> 实际上会返回同样的内容。但在写入文本值时，<code>outerText</code> 就大不相同了。 写入文本值时，<code>outerText</code> 不止会移除所有后代节点，而是会替换整个元素。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">outerText</span> = <span class="string">&quot;Hello world!&quot;</span>; </span><br></pre></td></tr></table></figure><p>这行代码的执行效果就相当于以下两行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">div.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(text, div);</span><br></pre></td></tr></table></figure><p>本质上，这相当于用新的文本节点替代 <code>outerText</code> 所在的元素。此时，原来的元素会与文档脱离关系，因此也无法访问。</p><p><code>outerText</code> 是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。</p></li></ol><h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><p>如前所述，滚动是 <code>HTML5</code> 之前 <code>DOM</code> 标准没有涉及的领域。虽然 <code>HTML5</code> 把 <code>scrollIntoView()</code> 标准化了，但不同浏览器中仍然有其他专有方法。比如，<code>scrollIntoViewIfNeeded()</code>作为 <code>HTMLElement</code> 类型的扩展可以在所有元素上调用。<code>scrollIntoViewIfNeeded(alingCenter)</code>会在 元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法 什么也不做。如果将可选的参数 <code>alingCenter</code> 设置为 true，则浏览器会尝试将其放在视口中央。<code>Safari</code>、 <code>Chrome </code>和 <code>Opera</code> 实现了这个方法。</p><p>考虑到 <code>scrollIntoView()</code>是唯一一个所有浏览器都支持的方法，所以只用它就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Selectors-API&quot;&gt;&lt;a href=&quot;#Selectors-API&quot; class=&quot;headerlink&quot; title=&quot;Selectors API&quot;&gt;&lt;/a&gt;Selectors API&lt;/h1&gt;&lt;p&gt;2008 年以前，大部分浏览器对 &lt;code&gt;DOM</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(11)——DOM</title>
    <link href="http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/"/>
    <id>http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/</id>
    <published>2023-04-16T21:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.878Z</updated>
    
    <content type="html"><![CDATA[<p>文档对象模型（<code>DOM</code>，<code>Document Object Model</code>）是 <code>HTML</code> 和 <code>XML</code> 文档的编程接口。<code>DOM</code> 表示 由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早 期的动态 <code>HTML</code>（<code>DHTML</code>，<code>Dynamic HTML</code>），<code>DOM</code> 现在是真正跨平台、语言无关的表示和操作网页 的方式。</p><p><code>DOM Level</code> 1 在 1998 年成为 <code>W3C</code> 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 <code>DOM</code>，主要因为它与浏览器中的 <code>HTML</code> 网页相关，并且在 <code>JavaScript</code> 中提供了 <code>DOM API</code>。</p><h1 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h1><p>任何 <code>HTML</code> 或 <code>XML</code> 文档都可以用 <code>DOM</code> 表示为一个由节点构成的层级结构。节点分很多类型，每 种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 <code>HTML</code> 为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果表示为层级结构，则如下图所示。</p><p><img src="https://pvnk1u.github.io/images/DOMLevel.PNG" alt="1679552057208"></p><p>其中，<code>document</code> 节点表示每个文档的根节点。在这里，根节点的唯一子节点是元素，称之为文档元素（<code>documentElement</code>）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 <code>HTML</code> 页面中，文档元素始终是元素。在 <code>XML</code> 文档中， 则没有这样预定义的元素，任何元素都可能成为文档元素。</p><p><code>HTML</code> 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 <code>HTML</code> 元素，属性 节点表示属性，文档类型节点表示文档类型，注释节点表示注释。<code>DOM</code> 中总共有 12 种节点类型，这些 类型都继承一种基本类型。</p><h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p><code>DOM Level</code> 1 描述了名为 <code>Node</code> 的接口，这个接口是所有 <code>DOM</code> 节点类型都必须实现的。<code>Node</code> 接口 在 <code>JavaScript</code>中被实现为 <code>Node</code> 类型，在除 <code>IE</code>之外的所有浏览器中都可以直接访问这个类型。在<code>JavaScript</code> 中，所有节点类型都继承 <code>Node</code> 类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有 <code>nodeType</code> 属性，表示该节点的类型。节点类型由定义在 <code>Node</code> 类型上的 12 个数值 常量表示：</p><ol><li>Node.ELEMENT_NODE（1）</li><li>Node.ATTRIBUTE_NODE（2）</li><li>Node.TEXT_NODE（3）</li><li>Node.CDATA_SECTION_NODE（4）</li><li>Node.ENTITY_REFERENCE_NODE（5） </li><li>Node.ENTITY_NODE（6）</li><li>Node.PROCESSING_INSTRUCTION_NODE（7）</li><li>Node.COMMENT_NODE（8）</li><li>Node.DOCUMENT_NODE（9）</li><li>Node.DOCUMENT_TYPE_NODE（10）</li><li>Node.DOCUMENT_FRAGMENT_NODE（11）</li><li>Node.NOTATION_NODE（12）</li></ol><p>节点类型可通过与这些常量比较来确定，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>)&#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Node is an element.&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个例子比较了 <code>someNode.nodeType</code> 与 <code>Node.ELEMENT_NODE</code> 常量。如果两者相等，则意味着 <code>someNode</code> 是一个元素节点。</p><p><strong>浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。</strong>本章后面会讨论每种节点受支持的程度及其用法。</p><ol><li><p><code>nodeName</code>与<code>nodeValue</code></p><p><code>nodeName</code> 与 <code>nodeValue</code> 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用 这两个属性前，最好先检测节点类型，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>)&#123;</span><br><span class="line"> value = someNode.<span class="property">nodeName</span>; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这个例子中，先检查了节点是不是元素。如果是，则将其 <code>nodeName</code> 的值赋给一个变量。对元素 而言，<code>nodeName</code> 始终等于元素的标签名，而 <code>nodeValue</code> 则始终为 <code>null</code>。</p></li><li><p>节点关系</p><p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。 在 <code>HTML</code> 中，<code>&lt;body&gt;</code>元素是<code>&lt;html&gt;</code>元素的子元素，而<code>&lt;html&gt;</code>元素则是<code>&lt;body&gt;</code>元素的父元素。 <code>&lt;head&gt;</code>元素是<code>&lt;body&gt;</code>元素的同胞元素，因为它们有共同的父元素<code>&lt;html&gt;</code>。</p><p>每个节点都有一个 <code>childNodes</code> 属性，其中包含一个 <code>NodeList</code> 的实例。<code>NodeList</code> 是一个类数组 对象，用于存储可以按位置存取的有序节点。注意，**<code>NodeList</code> 并不是 <code>Array</code> 的实例，但可以使用中括 号访问它的值，而且它也有 <code>length</code> 属性。<code>NodeList</code> 对象独特的地方在于，它其实是一个对 <code>DOM</code> 结 构的查询，因此 <code>DOM</code> 结构的变化会自动地在 <code>NodeList</code> 中反映出来。我们通常说 <code>NodeList</code> 是实时的 活动对象，而不是第一次访问时所获得内容的快照。**</p><p>下面的例子展示了如何使用中括号或使用 <code>item()</code>方法访问 <code>NodeList</code> 中的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChild = someNode.<span class="property">childNodes</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> secondChild = someNode.<span class="property">childNodes</span>.<span class="title function_">item</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> count = someNode.<span class="property">childNodes</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>无论是使用中括号还是 <code>item()</code>方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个 类数组对象。注意，**<code>length</code> 属性表示那一时刻 <code>NodeList</code> 中节点的数量。使用 <code>Array.prototype.slice()</code>可以像前面介绍 <code>arguments</code> 时一样把 <code>NodeList</code> 对象转换为数组。**比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(someNode.<span class="property">childNodes</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当然，使用 <code>ES6</code> 的 <code>Array.from()</code>静态方法，可以替换这种笨拙的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes = <span class="title class_">Array</span>.<span class="title function_">from</span>(someNode.<span class="property">childNodes</span>);</span><br></pre></td></tr></table></figure><p>每个节点都有一个 <code>parentNode</code> 属性，指向其 <code>DOM</code> 树中的父元素。<code>childNodes</code> 中的所有节点都有同一个父元素，因此它们的 <code>parentNode</code> 属性都指向同一个节点。此外，<code>childNodes</code> 列表中的每个 节点都是同一列表中其他节点的同胞节点。而使用 <code>previousSibling</code> 和 <code>nextSibling</code> 可以在这个列表的节点间导航。这个列表中第一个节点的 <code>previousSibling</code> 属性是 <code>null</code>，最后一个节点的 <code>nextSibling</code> 属性也是 <code>null</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nextSibling</span> === <span class="literal">null</span>)&#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Last node in the parent&#x27;s childNodes list.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.<span class="property">previousSibling</span> === <span class="literal">null</span>)&#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;First node in the parent&#x27;s childNodes list.&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意，如果 <code>childNodes</code> 中只有一个节点，则它的 <code>previousSibling</code> 和 <code>nextSibling</code> 属性都是 <code>null</code>。</p><p>父节点和它的第一个及最后一个子节点也有专门属性：<code>firstChild</code> 和 <code>lastChild</code> 分别指向 <code>childNodes</code> 中的第一个和最后一个子节点。<code>someNode.firstChild</code> 的值始终等于 <code>someNode. childNodes[0]</code>，而 <code>someNode.lastChild</code> 的值始终等于 <code>someNode.childNodes[someNode. childNodes.length-1]</code>。如果只有一个子节点，则 <code>firstChild</code> 和 <code>lastChild</code> 指向同一个节点。如 果没有子节点，则 <code>firstChild</code> 和 <code>lastChild</code> 都是 <code>null</code>。上述这些节点之间的关系为在文档树的节 点之间导航提供了方便。</p><p>有了这些关系，<code>childNodes</code> 属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是 <code>childNodes</code> 的最大亮点。还有一个便利的方法是 <code>hasChildNodes()</code>，这个方法如果返回 <code>true</code> 则说明节点有一个或多个子节点。相比查询 <code>childNodes </code>的 <code>length</code> 属性，这个方法无疑更方便。</p><p><strong>最后还有一个所有节点都共享的关系。<code>ownerDocument</code> 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。</strong></p></li><li><p>操纵节点</p><p>因为所有关系指针都是只读的，所以 <code>DOM</code> 又提供了一些操纵节点的方法。最常用的方法是 <code>appendChild()</code>，用于在 <code>childNodes</code> 列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。<code>appendChild()</code>方法返回新添加的节点，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(newNode);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(someNode.<span class="property">lastChild</span> == newNode); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>如果把文档中已经存在的节点传给 <code>appendChild()</code>，则这个节点会从之前的位置被转移到新位置。 即使 <code>DOM</code> 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此， 如果调用 <code>appendChild()</code>传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点</strong>， 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">firstChild</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果想把节点放到 <code>childNodes</code> 中的特定位置而不是末尾，则可以使用 <code>insertBefore()</code>方法。 这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是 <code>null</code>，则 <code>insertBefore()</code>与 <code>appendChild()</code>效果相同，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, <span class="literal">null</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为新的第一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">firstChild</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">lastChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">childNodes</span>[someNode.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>appendChild()</code> 和 <code>insertBefore()</code> 在插入节点时不会删除任何已有节点。相对地， <code>replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档 树中完全移除，要插入的节点会取而代之。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">lastChild</span>); </span><br></pre></td></tr></table></figure><p>使用 <code>replaceChild()</code>插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p><p>要移除节点而不是替换节点，可以使用 <code>removeChild()</code>方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerFirstChild = someNode.<span class="title function_">removeChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerLastChild = someNode.<span class="title function_">removeChild</span>(someNode.<span class="property">lastChild</span>); </span><br></pre></td></tr></table></figure><p>与 <code>replaceChild()</code>方法一样，通过 <code>removeChild()</code>被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p><p>上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使 用前面介绍的 <code>parentNode</code> 属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用 这些方法，则会导致抛出错误。</p></li><li><p>其他方法</p><p>所有节点类型还共享了两个方法。第一个是 <code>cloneNode()</code>，会返回与调用它的节点一模一样的节点。<code>cloneNode()</code>方法接收一个布尔值参数，表示是否深复制。在传入 true 参数时，会进行深复制， 即复制节点及其整个子 <code>DOM</code> 树。如果传入 false，则只会复制调用该方法的节点。复制返回的节点属 于文档所有，但尚未指定父节点，所以可称为孤儿节点（<code>orphan</code>）。可以通过 <code>appendChild()</code>、 <code>insertBefore()</code>或 <code>replaceChild()</code>方法把孤儿节点添加到文档中。以下面的 <code>HTML</code> 片段为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果<code>myList</code>保存着对这个元素的引用，则下列代码展示了使用<code>cloneNode()</code>方法的两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deepList = myList.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">alert</span>(deepList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 3（IE9 之前的版本）或 7（其他浏览器）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shallowList = myList.<span class="title function_">cloneNode</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="title function_">alert</span>(shallowList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>deepList</code> 保存着 <code>myList</code> 的副本。这意味着 <code>deepList</code>有 3 个列表项，每个列表项又各自包含文本。变量 <code>shallowList</code> 则保存着 <code>myList </code>的浅副本，因此没有子节点。 <code>deepList.childNodes.length</code> 的值会因 <code>IE8</code> 及更低版本和其他浏览器对空格的处理方式而不同。<code>IE9</code> 之前的版本不会为空格创建节点。</p><p>本节要介绍的最后一个方法是 <code>normalize()</code>。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或 <code>DOM</code> 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用 <code>normalize()</code>方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。 这个方法将在本章后面进一步讨论。</p></li></ol><h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p><code>Document</code> 类型是 <code>JavaScript</code> 中表示文档节点的类型。在浏览器中，文档对象 <code>document</code> 是 <code>HTMLDocument</code> 的实例（<code>HTMLDocument</code>继承 <code>Document</code>），表示整个 <code>HTML</code> 页面。<code>document</code> 是 <code>window</code> 对象的属性，因此是一个全局对象。<code>Document</code>类型的节点有以下特征：</p><ol><li><code>nodeType</code>等于9</li><li><code>nodeName</code>值为”#document”</li><li><code>nodeValue</code>值为<code>null</code></li><li><code>parentNode</code>值为<code>null</code></li><li><code>ownerDocument</code>值为<code>null</code></li><li>子节点可以是<code>DocumentType</code>(最多一个)、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code>或<code>Comment</code>类型。</li></ol><p><code>Document</code>类型可以表示<code>HTML</code>页面或其他<code>XML</code>文档，但最常用的还是通过<code>HTMLDocument</code>的实例取得<code>document</code>对象。<code>document</code>对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p><ol><li><p>文档子节点</p><p>虽然 <code>DOM</code> 规范规定 <code>Document</code> 节点的子节点可以是 <code>DocumentType</code>、<code>Element</code>、<code>ProcessingInstruction</code> 或 <code>Comment</code>，但也提供了两个访问子节点的快捷方式。第一个是 <code>documentElement</code> 属 性，始终指向 <code>HTML</code> 页面中的元素。虽然 <code>document.childNodes</code> 中始终有元素，但使用 <code>documentElement</code> 属性可以更快更直接地访问该元素。假如有以下简单的页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>浏览器解析完这个页面之后，文档只有一个子节点，即元素。这个元素既可以通过 <code>documentElement</code> 属性获取，也可以通过 <code>childNodes</code> 列表访问，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">childNodes</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">firstChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个例子表明 <code>documentElement</code>、<code>firstChild</code> 和 <code>childNodes[0]</code>都指向同一个值，即元素。</p><p>作为 <code>HTMLDocument</code> 的实例，<code>document</code> 对象还有一个 <code>body</code> 属性，直接指向元素。因为 这个元素是开发者使用最多的元素，所以 <code>JavaScript</code> 代码中经常可以看到 <code>document.body</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">// 取得对&lt;body&gt;的引用</span></span><br></pre></td></tr></table></figure><p>所有主流浏览器都支持 <code>document.documentElement</code> 和 <code>document.body</code>。</p><p><code>Document</code> 类型另一种可能的子节点是 <code>DocumentType</code>。标签是文档中独立的部分， 其信息可以通过 <code>doctype</code> 属性（在浏览器中是 <code>document.doctype</code>）来访问，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>; <span class="comment">// 取得对&lt;!doctype&gt;的引用</span></span><br></pre></td></tr></table></figure><p>另外，严格来讲出现在元素外面的注释也是文档的子节点，它们的类型是 <code>Comment</code>。不过， 由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下 <code>HTML</code> 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一条注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二条注释 --&gt;</span> </span><br></pre></td></tr></table></figure><p>这个页面看起来有 3 个子节点：注释、元素、注释。逻辑上讲，<code>document.childNodes</code> 应该包含 3 项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待元素外部的 注释，比如忽略一个或两个注释。</p><p>一般来说，<code>appendChild()</code>、<code>removeChild()</code>和 <code>replaceChild()</code>方法不会用在 <code>document</code> 对象 上。这是因为文档类型（如果存在）是只读的，而且只能有一个 <code>Element</code> 类型的子节点（即<code>&lt;html&gt;</code>， 已经存在了）。</p></li><li><p>文档信息</p><p><code>document</code> 作为 <code>HTMLDocument</code> 的实例，还有一些标准 <code>Document</code> 对象上所没有的属性。这些属性 提供浏览器所加载网页的信息。其中第一个属性是 <code>title</code>，包含<code>&lt;title&gt;</code>元素中的文本，通常显示在浏 览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题 栏上。不过，修改 title 属性并不会改变<code>&lt;title&gt;</code>元素。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文档标题</span></span><br><span class="line"><span class="keyword">let</span> originalTitle = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文档标题</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;New page title&quot;</span>; </span><br></pre></td></tr></table></figure><p>接下来要介绍的 3 个属性是 <code>URL</code>、<code>domain</code> 和 <code>referrer</code>。其中，<code>URL</code> 包含当前页面的完整 <code>URL</code>（地址栏中的 <code>URL</code>），<code>domain</code> 包含页面的域名，而 <code>referrer</code> 包含链接到当前页面的那个页面的 <code>URL</code>。如 果当前页面没有来源，则 <code>referrer</code> 属性包含空字符串。所有这些信息都可以在请求的 <code>HTTP</code> 头部信息 中获取，只是在 <code>JavaScript</code> 中通过这几个属性暴露出来而已，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得完整的 URL</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="variable language_">document</span>.<span class="property">URL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得域名</span></span><br><span class="line"><span class="keyword">let</span> domain = <span class="variable language_">document</span>.<span class="property">domain</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得来源</span></span><br><span class="line"><span class="keyword">let</span> referrer = <span class="variable language_">document</span>.<span class="property">referrer</span>;</span><br></pre></td></tr></table></figure><p><code>URL</code> 跟域名是相关的。比如，如果 <code>document.URL</code> 是 <code>http://www.wrox.com/WileyCDA/</code>，则 <code>document.domain</code> 就是 <code>www.wrox.com</code>。</p><p>在这些属性中，只有 <code>domain</code> 属性是可以设置的。出于安全考虑，给 <code>domain</code> 属性设置的值是有限制的。如果 <code>URL</code>包含子域名如 <code>p2p.wrox.com</code>，则可以将 <code>domain</code> 设置为”wrox.com”（<code>URL</code>包含“www” 时也一样，比如 <code>www.wrox.com</code>）。不能给这个属性设置 <code>URL</code> 中不包含的值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 成功</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;nczonline.net&quot;</span>; <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><p>当页面中包含来自某个不同子域的窗格（<code>&lt;frame&gt;</code>）或内嵌窗格（<code>&lt;iframe&gt;</code>)时，设置<code>document.domain</code>是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过<code>JavaScript</code>通信。此时，在每个页面上把 <code>document.domain</code> 设置为相同的值，这些页面就可以访问对方的 <code>JavaScript</code> 对象了。比如，一个加载自 <code>www.wrox.com</code> 的页面中包含一个内嵌窗格，其中的页面加载自 <code>p2p.wrox.com</code>。这两个页面的 <code>document.domain</code> 包含不同的字符串，内部和外部页面相互之间不能 访问对方的 <code>JavaScript</code>对象。如果每个页面都把 <code>document.domain</code> 设置为 <code>wrox.com</code>，那这两个页面之间就可以通信了。</p><p>浏览器对 <code>domain</code> 属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把 <code>document.domain</code> 设置为”wrox.com”之后，就不能再将其设置回”p2p.wrox.com”，后者会导致错误，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 放松，成功</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;p2p.wrox.com&quot;</span>; <span class="comment">// 收紧，错误</span></span><br></pre></td></tr></table></figure></li><li><p>定位元素</p><p>使用 <code>DOM</code> 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。 <code>document</code> 对象上暴露了一些方法，可以实现这些操作。<code>getElementById()</code>和 <code>getElementsByTagName()</code>就是 <code>Document</code> 类型提供的两个方法。</p><p><code>getElementById()</code>方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果 没找到则返回 <code>null</code>。参数 ID 必须跟元素在页面中的 id 属性值完全匹配，包括大小写。比如页面中有以下元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Some text<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>可以使用如下代码取得这个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); <span class="comment">// 取得对这个&lt;div&gt;元素的引用</span></span><br></pre></td></tr></table></figure><p>但参数大小写不匹配会返回 null：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mydiv&quot;</span>); <span class="comment">// null </span></span><br></pre></td></tr></table></figure><p>如果页面中存在多个具有相同 ID 的元素，则 <code>getElementById()</code>返回在文档中出现的第一个元素。</p><p><code>getElementsByTagName()</code>是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 <code>NodeList</code>。在 <code>HTML</code> 文档中，这个方法返回一个 <code>HTMLCollection</code> 对象。考虑到二者都是“实时”列表，<code>HTMLCollection</code> 与 <code>NodeList</code> 是很相似的。 例如，下面的代码会取得页面中所有的<code>&lt;img&gt;</code>元素并返回包含它们的 <code>HTMLCollection</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> images = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里把返回的 <code>HTMLCollection</code> 对象保存在了变量 <code>images</code> 中。与 <code>NodeList</code> 对象一样，也可以 使用中括号或 <code>item()</code>方法从 <code>HTMLCollection</code> 取得特定的元素。而取得元素的数量同样可以通过 <code>length</code> 属性得知，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(images.<span class="property">length</span>); <span class="comment">// 图片数量</span></span><br><span class="line"><span class="title function_">alert</span>(images[<span class="number">0</span>].<span class="property">src</span>); <span class="comment">// 第一张图片的 src 属性</span></span><br><span class="line"><span class="title function_">alert</span>(images.<span class="title function_">item</span>(<span class="number">0</span>).<span class="property">src</span>); <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p><code>HTMLCollection</code> 对象还有一个额外的方法 <code>namedItem()</code>，可通过标签的 <code>name</code> 属性取得某一项 的引用。例如，假设页面中包含如下的<code>&lt;img&gt;</code>元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.gif&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myImage&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>那么也可以像这样从 <code>images</code> 中取得对这个<code>&lt;img&gt;</code>元素的引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = images.<span class="title function_">namedItem</span>(<span class="string">&quot;myImage&quot;</span>); </span><br></pre></td></tr></table></figure><p>这样，<code>HTMLCollection</code> 就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了 便利。对于 <code>name</code> 属性的元素，还可以直接使用中括号来获取，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = images[<span class="string">&quot;myImage&quot;</span>];</span><br></pre></td></tr></table></figure><p>对 <code>HTMLCollection</code> 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台， 数值索引会调用 <code>item()</code>，字符串索引会调用 <code>namedItem()</code>。</p><p>要取得文档中的所有元素，可以给 <code>getElementsByTagName()</code>传入<code>*</code>。在 <code>JavaScript</code> 和 <code>CSS</code> 中，<code>*</code> 一般被认为是匹配一切的字符。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allElements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure><p>这行代码可以返回包含页面中所有元素的 <code>HTMLCollection</code> 对象，顺序就是它们在页面中出现的 顺序。因此第一项是<code>&lt;html&gt;</code>元素，第二项是<code>&lt;head&gt;</code>元素，以此类推。</p><p><code>HTMLDocument</code> 类型上定义的获取元素的第三个方法是 <code>getElementsByName()</code>。顾名思义，这个 方法会返回具有给定 <code>name</code> 属性的所有元素。<code>getElementsByName()</code>方法最常用于单选按钮，因为同 一字段的单选按钮必须具有相同的 <code>name</code> 属性才能确保把正确的值发送给服务器，比如下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorRed&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorRed&quot;</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorGreen&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorGreen&quot;</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorBlue&quot;</span>&gt;</span> </span><br><span class="line">             <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorBlue&quot;</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里所有的单选按钮都有名为”color”的 <code>name</code> 属性，但它们的 <code>ID</code> 都不一样。这是因为 <code>ID</code> 是为了 匹配对应的元素，而 <code>name</code> 相同是为了保证只将三个中的一个值发送给服务器。然后就可以像 下面这样取得所有单选按钮：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radios = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;color&quot;</span>); </span><br></pre></td></tr></table></figure><p>与 <code>getElementsByTagName()</code>一样，<code>getElementsByName()</code>方法也返回 <code>HTMLCollection</code>。不 过在这种情况下，<code>namedItem()</code>方法只会取得第一项（因为所有项的 <code>name</code> 属性都一样）。</p></li><li><p>特殊集合</p><p><code>document</code> 对象上还暴露了几个特殊集合，这些集合也都是 <code>HTMLCollection</code> 的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。</p><ul><li><code>document.anchors</code>包含文档中所有带 <code>name</code> 属性的<code>&lt;a&gt;</code>元素。</li><li><code>document.applets</code> 包含文档中所有元素（因为元素已经不建议使用，所 以这个集合已经废弃）。</li><li><code>document.forms</code> 包含文档中所有元素（与 <code>document.getElementsByTagName (&quot;form&quot;) </code>返回的结果相同）。</li><li><code>document.images</code> 包含文档中所有<code>&lt;img&gt;</code>元素（与 <code>document.getElementsByTagName (&quot;img&quot;)</code> 返回的结果相同)。</li><li><code>document.links</code> 包含文档中所有带 <code>href</code> 属性的<code>&lt;a&gt;</code>元素。</li></ul><p>这些特殊集合始终存在于 <code>HTMLDocument</code> 对象上，而且与所有 <code>HTMLCollection</code> 对象一样，其内容也会实时更新以符合当前文档的内容。</p></li><li><p>DOM兼容性检测</p><p>由于 <code>DOM</code> 有多个 <code>Level</code>和多个部分，因此确定浏览器实现了 <code>DOM</code> 的哪些部分是很必要的。 <code>document.implementation</code> 属性是一个对象，其中提供了与浏览器 <code>DOM</code> 实现相关的信息和能力。 <code>DOM Level</code> 1 在 <code>document.implementation</code> 上只定义了一个方法，即 <code>hasFeature()</code>。这个方法接收两个参数：特性名称和 <code>DOM</code> 版本。如果浏览器支持指定的特性和版本，则 <code>hasFeature()</code>方法返回 true，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasXmlDom = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;XML&quot;</span>, <span class="string">&quot;1.0&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于实现不一致，因此 <code>hasFeature()</code>的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回 true。</p></li><li><p>文档写入</p><p><code>document</code> 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：<code>write()</code>、 <code>writeln()</code>、<code>open()</code>和 <code>close()</code>。其中，<code>write()</code>和 <code>writeln()</code>方法都接收一个字符串参数，可以将这个字符串写入网页中。<code>write()</code>简单地写入文本，而 <code>writeln()</code>还会在字符串末尾追加一个换行符 （\n）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>The current date and time is:</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;strong&gt;&quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>() + <span class="string">&quot;&lt;/strong&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这个例子会在页面加载过程中输出当前日期和时间。日期放在了<code>&lt;strong&gt;</code>元素中，如同它们之前 就包含在 <code>HTML</code> 页面中一样。这意味着会创建一个 <code>DOM</code> 元素，以后也可以访问。通过<code> write()</code>和 <code>writeln()</code>输出的任何 <code>HTML</code> 都会以这种方式来处理。</p><p><code>write()</code>和 <code>writeln()</code>方法经常用于动态包含外部资源，如 <code>JavaScript</code> 文件。在包含 <code>JavaScript</code> 文 件时，记住不能像下面的例子中这样直接包含字符串””，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        document.write(&quot;<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>&quot;<span class="attr">text</span>/<span class="attr">javascript</span>\&quot; <span class="attr">src</span>=<span class="string">\</span>&quot;<span class="attr">file.js</span>\&quot;&gt;</span>&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">         &quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;);</span><br><span class="line">     <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>虽然这样写看起来没错，但输出之后的”<code>&lt;/script&gt;</code>“会匹配最外层的<code>&lt;script&gt;</code>标签，导致页面中 显示出”);。为避免出现这个问题，需要对前面的例子稍加修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">         document.write(&quot;<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>&quot;<span class="attr">text</span>/<span class="attr">javascript</span>\&quot; <span class="attr">src</span>=<span class="string">\</span>&quot;<span class="attr">file.js</span>\&quot;&gt;</span>&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">         &quot;&lt;\/script&gt;&quot;);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">     </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的字符串”<code>&lt;\/script&gt;</code>“不会再匹配最外层的<code>&lt;script&gt;</code>标签，因此不会在页面中输出额外内容。</p><p>前面的例子展示了在页面渲染期间通过 <code>document.write()</code>向文档中输出内容。如果是在页面加 载完之后再调用 <code>document.write()</code>，则输出的内容会重写整个页面，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some content that you won&#x27;t get to see because it will be</span><br><span class="line"> overwritten.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     &#125;;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这个例子使用了 <code>window.onload</code> 事件处理程序，将调用 <code>document.write()</code>的函数推迟到页面 加载完毕后执行。执行之后，字符串”Hello world!”会重写整个页面内容。</p><p><code>open()</code>和 <code>close()</code>方法分别用于打开和关闭网页输出流。在调用 <code>write()</code>和 <code>writeln()</code>时，这两 个方法都不是必需的。</p></li></ol><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>除了<code>Document</code> 类型，<code>Element</code> 类型就是<code>Web</code>开发中最常用的类型了。<code>Element</code> 表示<code>XML</code>或<code>HTML</code> 元素，对外暴露出访问元素标签名、子节点和属性的能力。<code>Element</code> 类型的节点具有以下特征：</p><ol><li><code>nodeType</code>等于1</li><li><code>nodeName</code>值为元素的标签名</li><li><code>nodeValue</code>值为<code>null</code></li><li><code>parentNode</code>值为<code>Document</code>或<code>Element</code>对象</li><li>子节点可以是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDTASection</code>、<code>EntityReference</code>类型。</li></ol><p>可以通过 <code>nodeName </code>或 <code>tagName</code> 属性来获取元素的标签名。这两个属性返回同样的值（添加后一 个属性明显是为了不让人误会）。比如有下面的元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以像这样取得这个元素的标签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span>); <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span> == div.<span class="property">nodeName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>例子中的元素标签名为 <code>div</code>，<code>ID</code> 为”myDiv”。注意，<code>div.tagName</code> 实际上返回的是”DIV”而不是 “div”。在 <code>HTML</code> 中，元素标签名始终以全大写表示；在 <code>XML</code>（包括 <code>XHTML</code>）中，标签名始终与源 代码中的大小写一致。如果不确定脚本是在 <code>HTML</code> 文档还是 <code>XML</code> 文档中运行，最好将标签名转换为小写形式，以便于比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">tagName</span> == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 不要这样做，可能出错！</span></span><br><span class="line"> <span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 推荐，适用于所有文档</span></span><br><span class="line"> <span class="comment">// 做点什么</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li><p>HTML元素</p><p>所有 <code>HTML</code> 元素都通过 <code>HTMLElement</code> 类型表示，包括其直接实例和间接实例。另外，<code>HTMLElement</code> 直接继承 <code>Element</code> 并增加了一些属性。每个属性都对应下列属性之一，它们是所有 <code>HTML</code> 元素上都有 的标准属性：</p><ul><li><code>id</code>，元素在文档中的唯一标识符</li><li><code>title</code>，包含元素的额外信息，通常以提示条形式展示</li><li><code>lang</code>，元素内容的语言代码（很少用）</li><li><code>dir</code>，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右向左，同样很少用）</li><li><code>className</code>，相当于class属性，用于指定元素的 <code>CSS</code> 类（因为 <code>class</code> 是 <code>ECMAScript</code> 关键字， 所以不能直接用这个名字）。</li></ul><p>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 <code>HTML</code> 元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个元素中的所有属性都可以使用下列 <code>JavaScript</code> 代码读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">id</span>); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">className</span>); <span class="comment">// &quot;bd&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">title</span>); <span class="comment">// &quot;Body text&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">lang</span>); <span class="comment">// &quot;en&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">dir</span>); <span class="comment">// &quot;ltr&quot; </span></span><br></pre></td></tr></table></figure><p>而且，可以使用下列代码修改元素的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;someOtherId&quot;</span>;</span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;ft&quot;</span>;</span><br><span class="line">div.<span class="property">title</span> = <span class="string">&quot;Some other text&quot;</span>;</span><br><span class="line">div.<span class="property">lang</span> = <span class="string">&quot;fr&quot;</span>;</span><br><span class="line">div.<span class="property">dir</span> =<span class="string">&quot;rtl&quot;</span>; </span><br></pre></td></tr></table></figure><p>并非所有这些属性的修改都会对页面产生影响。比如，把 <code>id</code> 或 <code>lang</code> 改成其他值对用户是不可见 的（假设没有基于这两个属性应用 <code>CSS</code> 样式），而修改 <code>title </code>属性则只会在鼠标移到这个元素上时才会 反映出来。修改 <code>dir</code> 会导致页面文本立即向左或向右对齐。修改 <code>className</code> 会立即反映应用到新类名 的 <code>CSS</code> 样式（如果定义了不同的样式）。</p><p>如前所述，所有 <code>HTML</code> 元素都是 <code>HTMLElement</code> 或其子类型的实例。下表列出了所有 <code>HTML</code> 元素 及其对应的类型（斜体表示已经废弃的元素）。</p><table><thead><tr><th>元素</th><th>类型</th><th>元素</th><th>类型</th></tr></thead><tbody><tr><td>A</td><td>HTMLAnchorElement</td><td>COL</td><td>HTMLTableColElement</td></tr><tr><td>ABBR</td><td>HTMLElement</td><td>COLGROUP</td><td>HTMLTableColElement</td></tr><tr><td>ACRONYM</td><td>HTMLElement</td><td>DD</td><td>HTMLElement</td></tr><tr><td>ADDRESS</td><td>HTMLElement</td><td>DEL</td><td>HTMLModElement</td></tr><tr><td><em>APPLET</em></td><td><em>HTMLAppletElement</em></td><td>DFN</td><td>HTMLElement</td></tr><tr><td>AREA</td><td>HTMLAreaElement</td><td><em>DIR</em></td><td><em>HTMLDirectoryElement</em></td></tr><tr><td>B</td><td>HTMLElement</td><td>DIV</td><td>HTMLDivElement</td></tr><tr><td>BASE</td><td>HTMLBaseElement</td><td>DL</td><td>HTMLDListElement</td></tr><tr><td><em>BASEFONT</em></td><td><em>HTMLBaseFontElement</em></td><td>DT</td><td>HTMLElement</td></tr><tr><td>BDO</td><td>HTMLElement</td><td>EM</td><td>HTMLElement</td></tr><tr><td>BIG</td><td>HTMLElement</td><td>FIELDSET</td><td>HTMLFieldSetElement</td></tr><tr><td>BLOCKQUOTE</td><td>HTMLQuoteElement</td><td><em>FONT</em></td><td><em>HTMLFontElement</em></td></tr><tr><td>BODY</td><td>HTMLBodyElement</td><td>FORM</td><td>HTMLFormElement</td></tr><tr><td>BR</td><td>HTMLBRElement</td><td>FRAME</td><td>HTMLFrameElement</td></tr><tr><td>BUTTON</td><td>HTMLButtonElement</td><td>FRAMESET</td><td>HTMLFrameSetElement</td></tr><tr><td>CAPTION</td><td>HTMLTableCaptionElement</td><td>H1</td><td>HTMLHeadingElement</td></tr><tr><td><em>CENTER</em></td><td><em>HTMLElement</em></td><td>H2</td><td>HTMLHeadingElement</td></tr><tr><td>CITE</td><td>HTMLElement</td><td>H3</td><td>HTMLHeadingElement</td></tr><tr><td>CODE</td><td>HTMLElement</td><td>H4</td><td>HTMLHeadingElement</td></tr><tr><td>H5</td><td>HTMLHeadingElement</td><td>PRE</td><td>HTMLPreElement</td></tr><tr><td>H6</td><td>HTMLHeadingElement</td><td>Q</td><td>HTMLQuoteElement</td></tr><tr><td>HEAD</td><td>HTMLHeadElement</td><td><em>S</em></td><td>HTMLElement</td></tr><tr><td>HR</td><td>HTMLHRElement</td><td>SAMP</td><td>HTMLElement</td></tr><tr><td>HTML</td><td>HTMLHtmlElement</td><td>SCRIPT</td><td>HTMLScriptElement</td></tr><tr><td>I</td><td>HTMLElement</td><td>SELECT</td><td>HTMLSelectElement</td></tr><tr><td>IFRAME</td><td>HTMLIFrameElement</td><td>SMALL</td><td>HTMLElement</td></tr><tr><td>IMG</td><td>HTMLImageElement</td><td>SPAN</td><td>HTMLElement</td></tr><tr><td>INPUT</td><td>HTMLInputElement</td><td><em>STRIKE</em></td><td><em>HTMLElement</em></td></tr><tr><td>INS</td><td>HTMLModElement</td><td>STRONG</td><td>HTMLElement</td></tr><tr><td><em>ISINDEX</em></td><td><em>HTMLIsIndexElement</em></td><td>STYLE</td><td>HTMLStyleElement</td></tr><tr><td>KBD</td><td>HTMLElement</td><td>SUB</td><td>HTMLElement</td></tr><tr><td>LABEL</td><td>HTMLLabelElement</td><td>SUP</td><td>HTMLElement</td></tr><tr><td>LEGEND</td><td>HTMLLegendElement</td><td>TABLE</td><td>HTMLTableElement</td></tr><tr><td>LI</td><td>HTMLLIElement</td><td>TBODY</td><td>HTMLTableSectionElement</td></tr><tr><td>LINK</td><td>HTMLLinkElement</td><td>TD</td><td>HTMLTableCellElement</td></tr><tr><td>MAP</td><td>HTMLMapElement</td><td>TEXTAREA</td><td>HTMLTextAreaElement</td></tr><tr><td><em>MENU</em></td><td><em>HTMLMenuElement</em></td><td>TFOOT</td><td>HTMLTableSectionElement</td></tr><tr><td>META</td><td>HTMLMetaElement</td><td>TH</td><td>HTMLTableCellElement</td></tr><tr><td>NOFRAMES</td><td>HTMLElement</td><td>THEAD</td><td>HTMLTableSectionElement</td></tr><tr><td>NOSCRIPT</td><td>HTMLElement</td><td>TITLE</td><td>HTMLTitleElement</td></tr><tr><td>OBJECT</td><td>HTMLObjectElement</td><td>TR</td><td>HTMLTableRowElement</td></tr><tr><td>OL</td><td>HTMLOListElement</td><td>TT</td><td>HTMLElement</td></tr><tr><td>OPTGROUP</td><td>HTMLOptGroupElement</td><td><em>U</em></td><td><em>HTMLElement</em></td></tr><tr><td>OPTION</td><td>HTMLOptionElement</td><td>UL</td><td>HTMLUListElement</td></tr><tr><td>P</td><td>HTMLParagraphElement</td><td>VAR</td><td>HTMLElement</td></tr><tr><td>PARAM</td><td>HTMLParamElement</td><td></td><td></td></tr></tbody></table><p>这里列出的每种类型都有关联的属性和方法。接下来的内容会涉及其中的很多类型。</p></li><li><p>取得属性</p><p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 <code>DOM</code> 方法 主要有 3 个：<code>getAttribute()</code>、<code>setAttribute()</code>和 <code>removeAttribute()</code>。这些方法主要用于操纵属性，包括在 <code>HTMLElement</code> 类型上定义的属性。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;class&quot;</span>)); <span class="comment">// &quot;bd&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>)); <span class="comment">// &quot;Body text&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;lang&quot;</span>)); <span class="comment">// &quot;en&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;dir&quot;</span>)); <span class="comment">// &quot;ltr&quot;</span></span><br></pre></td></tr></table></figure><p>注意传给 <code>getAttribute()</code>的属性名与它们实际的属性名是一样的，因此这里要传”class”而非”className”（<code>className</code> 是作为对象属性时才那么拼写的）。如果给定的属性不存在，则 <code>getAttribute()</code> 返回 <code>null</code>。</p><p><code>getAttribute()</code>方法也能取得不是 <code>HTML</code> 语言正式属性的自定义属性的值。比如下面的元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">my_special_attribute</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这个元素有一个自定义属性 <code>my_special_attribute</code>，值为”hello!”。可以像其他属性一样使用 <code>getAttribute()</code>取得这个属性的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = div.<span class="title function_">getAttribute</span>(<span class="string">&quot;my_special_attribute&quot;</span>); </span><br></pre></td></tr></table></figure><p>注意，属性名不区分大小写，因此”ID”和”id”被认为是同一个属性。另外，根据 <code>HTML5</code> 规范的 要求，自定义属性名应该前缀 <code>data-</code>以方便验证。</p><p>元素的所有属性也可以通过相应 <code>DOM</code> 元素对象的属性来取得。当然，这包括 <code>HTMLElement</code> 上定义的直接映射对应属性的 5 个属性，还有所有公认（非自定义）的属性也会被添加为 <code>DOM</code> 对象的属性。 比如下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span> <span class="attr">my_special_attribute</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 <code>id</code> 和 <code>align</code> 在 <code>HTML</code> 中是元素公认的属性，所以 <code>DOM</code> 对象上也会有这两个属性。但 <code>my_special_attribute</code> 是<strong>自定义属性，因此不会成为 <code>DOM</code> 对象的属性。</strong></p><p>通过 <code>DOM</code> 对象访问的属性中有两个返回的值跟使用 <code>getAttribute()</code>取得的值不一样。首先是 <code>style</code> 属性，这个属性用于为元素设定 <code>CSS</code> 样式。在使用 <code>getAttribute()</code>访问 <code>style</code> 属性时，返回的 是 <code>CSS </code>字符串。而在通过 <code>DOM</code> 对象的属性访问时，<code>style</code> 属性返回的是一个（<code>CSSStyleDeclaration</code>） 对象。<code>DOM</code> 对象的 <code>style</code> 属性用于以编程方式读写元素样式，因此不会直接映射为元素中 <code>style</code> 属性的字符串值。</p><p>第二个属性其实是一类，即事件处理程序（或者事件属性），比如 <code>onclick</code>。在元素上使用事件属 性时（比如 <code>onclick</code>），属性的值是一段 <code>JavaScript</code> 代码。如果使用 <code>getAttribute()</code>访问事件属性， 则返回的是字符串形式的源代码。而通过 <code>DOM</code> 对象的属性访问事件属性时返回的则是一个 <code>JavaScript</code> 函数（未指定该属性则返回 <code>null</code>）。这是因为 <code>onclick</code> 及其他事件属性是可以接受函数作为值的。</p><p>考虑到以上差异，开发者在进行<code>DOM</code>编程时通常会放弃使用<code>getAttribute()</code>而只使用对象属性。 <code>getAttribute()</code>主要用于取得自定义属性的值。</p></li><li><p>设置属性</p><p>与 <code>getAttribute()</code>配套的方法是 <code>setAttribute()</code>，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则 <code>setAttribute()</code>会以指定的值替换原来的值；如果属性不存在， 则 <code>setAttribute()</code>会以指定的值创建该属性。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;someOtherId&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;ft&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Some other text&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;lang&quot;</span>,<span class="string">&quot;fr&quot;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;dir&quot;</span>, <span class="string">&quot;rtl&quot;</span>); </span><br></pre></td></tr></table></figure><p><code>setAttribute()</code>适用于 <code>HTML</code> 属性，也适用于自定义属性。另外，使用 <code>setAttribute()</code>方法 设置的属性名会规范为小写形式，因此”ID”会变成”id”。</p><p>因为元素属性也是 <code>DOM</code> 对象属性，所以直接给 <code>DOM</code> 对象的属性赋值也可以设置元素属性的值， 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;someOtherId&quot;</span>;</span><br><span class="line">div.<span class="property">align</span> = <span class="string">&quot;left&quot;</span>; </span><br></pre></td></tr></table></figure><p>注意，在 <code>DOM</code> 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">mycolor</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;mycolor&quot;</span>)); <span class="comment">// null（IE 除外）</span></span><br></pre></td></tr></table></figure><p>这个例子添加了一个自定义属性 <code>mycolor</code> 并将其值设置为”red”。在多数浏览器中，这个属性不 会自动变成元素属性。因此调用 <code>getAttribute()</code>取得 <code>mycolor</code> 的值会返回 <code>null</code>。</p><p>最后一个方法 <code>removeAttribute()</code>用于从元素中删除属性。这样不单单是清除属性的值，而是会 把整个属性完全从元素中去掉，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">removeAttribute</span>(<span class="string">&quot;class&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个方法用得并不多，但在序列化 <code>DOM</code> 元素时可以通过它控制要包含的属性。</p></li><li><p>attributes属性</p><p><code>Element</code> 类型是唯一使用 <code>attributes</code> 属性的 <code>DOM</code> 节点类型。<code>attributes</code> 属性包含一个 <code>NamedNodeMap</code> 实例，是一个类似 <code>NodeList</code> 的“实时”集合。元素的每个属性都表示为一个 <code>Attr</code> 节 点，并保存在这个 <code>NamedNodeMap</code> 对象中。<code>NamedNodeMap</code> 对象包含下列方法：</p><ul><li><code>getNamedItem(name)</code>，返回 <code>nodeName</code> 属性等于 <code>name</code> 的节点；</li><li><code>removeNamedItem(name)</code>，删除 <code>nodeName</code> 属性等于 <code>name</code> 的节点；</li><li><code>setNamedItem(node)</code>，向列表中添加 <code>node</code> 节点，以其 <code>nodeName</code> 为索引；</li><li><code>item(pos)</code>，返回索引位置 <code>pos</code> 处的节点。</li></ul><p><code>attributes</code>属性中的每个节点的 <code>nodeName</code> 是对应属性的名字，<code>nodeValue</code> 是属性的值。比如， 要取得元素 id 属性的值，可以使用以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = element.<span class="property">attributes</span>.<span class="title function_">getNamedItem</span>(<span class="string">&quot;id&quot;</span>).<span class="property">nodeValue</span>;</span><br></pre></td></tr></table></figure><p>下面是使用中括号访问属性的简写形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = element.<span class="property">attributes</span>[<span class="string">&quot;id&quot;</span>].<span class="property">nodeValue</span>;</span><br></pre></td></tr></table></figure><p>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 <code>nodeValue</code> 设置为新值，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">attributes</span>[<span class="string">&quot;id&quot;</span>].<span class="property">nodeValue</span> = <span class="string">&quot;someOtherId&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>removeNamedItem()</code>方法与元素上的 <code>removeAttribute()</code>方法类似，也是删除指定名字的属性。 下面的例子展示了这两个方法唯一的不同之处，就是<code>removeNamedItem()</code>返回表示被删除属性的<code>Attr</code> 节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldAttr = element.<span class="property">attributes</span>.<span class="title function_">removeNamedItem</span>(<span class="string">&quot;id&quot;</span>); </span><br></pre></td></tr></table></figure><p><code>setNamedItem()</code>方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">attributes</span>.<span class="title function_">setNamedItem</span>(newAttr); </span><br></pre></td></tr></table></figure><p>一般来说，因为使用起来更简便，通常开发者更喜欢使用 <code>getAttribute()</code>、<code>removeAttribute()</code> 和 <code>setAttribute()</code>方法，而不是刚刚介绍的 <code>NamedNodeMap</code> 对象的方法。</p><p><code>attributes</code> 属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 <code>DOM</code> 结构 序列化为 <code>XML</code> 或 <code>HTML</code> 字符串。比如，以下代码能够迭代一个元素上的所有属性并以 <code>attribute1= &quot;value1&quot; attribute2=&quot;value2&quot;</code>的形式生成格式化字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outputAttributes</span>(<span class="params">element</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> pairs = [];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = element.<span class="property">attributes</span>.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">     <span class="keyword">const</span> attribute = element.<span class="property">attributes</span>[i];</span><br><span class="line">     pairs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;attribute.nodeName&#125;</span>=&quot;<span class="subst">$&#123;attribute.nodeValue&#125;</span>&quot;`</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> pairs.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个函数使用数组存储每个名&#x2F;值对，迭代完所有属性后，再将这些名&#x2F;值对用空格拼接在一起。（这 个技术常用于序列化为长字符串。）这个函数中的 <code>for</code> 循环使用 <code>attributes.length</code> 属性迭代每个属 性，将每个属性的名字和值输出为字符串。不同浏览器返回的 <code>attributes</code> 中的属性顺序也可能不一样。 <code>HTML</code> 或 <code>XML</code> 代码中属性出现的顺序不一定与 <code>attributes</code> 中的顺序一致。</p></li><li><p>创建元素</p><p>可以使用 <code>document.createElement()</code>方法创建新元素。这个方法接收一个参数，即要创建元素 的标签名。在 <code>HTML</code> 文档中，标签名是不区分大小写的，而 <code>XML</code> 文档（包括 <code>XHTML</code>）是区分大小写 的。要创建元素，可以使用下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br></pre></td></tr></table></figure><p>使用 <code>createElement()</code>方法创建新元素的同时也会将其 <code>ownerDocument</code> 属性设置为 <code>document</code>。 此时，可以再为其添加属性、添加更多子元素。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;myNewDiv&quot;</span>;</span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;box&quot;</span>;</span><br></pre></td></tr></table></figure><p>在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用 <code>appendChild()</code>、<code>insertBefore()</code>或<code> replaceChild()</code>。 比如，以下代码会把刚才创建的元素添加到文档的元素中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br></pre></td></tr></table></figure><p>元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。</p></li><li><p>元素后代</p><p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<code>childNodes</code> 属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在 识别这些节点时的表现有明显不同。比如下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>在解析以上代码时，<code>&lt;ul&gt;</code>元素会包含 7 个子元素，其中 3 个是<code>&lt;li&gt;</code>元素，还有 4 个 Text 节点（表示<code>&lt;li&gt;</code>元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有浏览器解析上面的代码后，<code>&lt;ul&gt;</code>元素都会包含 3 个子节点。考虑到这种情况，通常在执行某个 操作之后需要先检测一下节点的 <code>nodeType</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = element.<span class="property">childNodes</span>.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">     <span class="keyword">if</span> (element.<span class="property">childNodes</span>[i].<span class="property">nodeType</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行某个操作</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上代码会遍历某个元素的子节点，并且只在 <code>nodeType</code> 等于 1（即 <code>Element</code> 节点）时执行某个操作。</p><p>要取得某个元素的子节点和其他后代节点，可以使用元素的 <code>getElementsByTagName()</code>方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面<code>&lt;ul&gt;</code>的例子，可以像下面这样取得其所有的<code>&lt;li&gt;</code>元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myList&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> items = ul.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里例子中的<code>&lt;ul&gt;</code>元素只有一级子节点，如果它包含更多层级，则所有层级中的<code>&lt;li&gt;</code>元素都会返回。</p></li></ol><h2 id="Text节点"><a href="#Text节点" class="headerlink" title="Text节点"></a>Text节点</h2><p><code>Text</code> 节点由 <code>Text</code> 类型表示，包含按字面解释的纯文本，也可能包含转义后的 <code>HTML</code> 字符，但不含 <code>HTML</code> 代码。<code>Text</code> 类型的节点具有以下特征：</p><ul><li><code>nodeType</code> 等于 3；</li><li><code>nodeName</code> 值为”#text”；</li><li><code>nodeValue </code>值为节点中包含的文本；</li><li><code>parentNode</code> 值为 <code>Element</code> 对象；</li><li>不支持子节点。</li></ul><p><code>Text</code> 节点中包含的文本可以通过 <code>nodeValue</code> 属性访问，也可以通过 <code>data</code> 属性访问，这两个属性包含相同的值。修改 <code>nodeValue</code> 或 <code>data</code> 的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：</p><ul><li><code>appendData(text)</code>，向节点末尾添加文本 <code>text</code>；</li><li><code>deleteData(offset, count)</code>，从位置 <code>offset</code> 开始删除 <code>count</code> 个字符；</li><li><code>insertData(offset, text)</code>，在位置 <code>offset</code> 插入 <code>text</code>；</li><li><code>replaceData(offset, count, text)</code>，用 <code>text</code> 替换从位置 <code>offset</code> 到 <code>offset + count</code> 的 文本；</li><li><code>splitText(offset)</code>，在位置 <code>offset</code> 将当前文本节点拆分为两个文本节点；</li><li><code>substringData(offset, count)</code>，提取从位置 <code>offset</code> 到 <code>offset + count</code> 的文本。</li></ul><p>除了这些方法，还可以通过 <code>length</code> 属性获取文本节点中包含的字符数量。这个值等于 <code>nodeValue. length</code> 和 <code>data.length</code>。</p><p>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有内容，因此没有文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有空格，因此有一个文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有内容，因此有一个文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例中的第一个<code>&lt;div</code>&gt;元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个<code>&lt;div</code>&gt;元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的 <code>nodeValue</code> 就是一个空格。第三个<code>&lt;div</code>&gt;元素也有一个文本节点的子节点，其<code>nodeValue</code> 的值为”Hello World!”。下列代码可以用来访问这个文本节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = div.<span class="property">firstChild</span>; <span class="comment">// 或 div.childNodes[0]</span></span><br></pre></td></tr></table></figure><p>取得文本节点的引用后，可以像这样来修改它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> = <span class="string">&quot;Some other message&quot;</span>;</span><br></pre></td></tr></table></figure><p>只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是 <code>HTML</code> 或 <code>XML</code> 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot;</span></span><br><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> = <span class="string">&quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;</span>;</span><br></pre></td></tr></table></figure><p>这实际上是在将 <code>HTML</code> 字符串插入 <code>DOM</code> 文档前进行编码的有效方式。</p><ol><li><p>创建文本节点</p><p><code>document.createTextNode()</code>可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。 跟设置已有文本节点的值一样，这些要插入的文本也会应用 <code>HTML</code> 或 <code>XML</code> 编码，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建新文本节点后，其 <code>ownerDocument</code> 属性会被设置为 <code>document</code>。但在把这个节点添加到文档 树之前，我们不会在浏览器中看到它。以下代码创建了一个元素并给它添加了一段文本消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br></pre></td></tr></table></figure><p>这个例子首先创建了一个<code>&lt;div&gt;</code>元素并给它添加了值为”message”的 <code>class</code> 属性，然后又创建了 一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</p><p>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element); </span><br></pre></td></tr></table></figure><p><strong>在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。</strong></p></li><li><p>规范化文本节点</p><p><code>DOM</code> 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，<code> DOM</code> 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法 叫 <code>normalize()</code>，是在 <code>Node</code> 类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用 <code>normalize()</code>时，所有同胞文本节点会被合并为一个文本节点，这个 文本节点的 <code>nodeValue</code> 就等于之前所有同胞节点 <code>nodeValue</code> 拼接在一起得到的字符串。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">element.<span class="title function_">normalize</span>();</span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello world!Yippee!&quot;</span></span><br></pre></td></tr></table></figure><p><strong>浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 <code>DOM</code> 脚本生成的文档树中。</strong></p></li><li><p>拆分文本节点</p><p><code>Text</code> 类型定义了一个与 <code>normalize()</code>相反的方法——<code>splitText()</code>。这个方法可以在指定的偏移位置拆分 <code>nodeValue</code>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到 偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点 相同的 <code>parentNode</code>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newNode = element.<span class="property">firstChild</span>.<span class="title function_">splitText</span>(<span class="number">5</span>);</span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(newNode.<span class="property">nodeValue</span>); <span class="comment">// &quot; world!&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>在这个例子中，包含”Hello world!”的文本节点被从位置 5 拆分成两个文本节点。位置 5 对应 “Hello”和”world!”之间的空格，因此原始文本节点包含字符串”Hello”，而新文本节点包含文本” world!”（包含空格）。</p><p><strong>拆分文本节点最常用于从文本节点中提取数据的 <code>DOM</code> 解析技术。</strong></p></li></ol><h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p><code>DOM</code> 中的注释通过<code>Comment</code>类型表示。<code>Comment</code>类型的节点具有以下特征：</p><ul><li><code>nodeType</code>等于8</li><li><code>nodeName</code>值为”#comment”；</li><li><code>nodeValue</code> 值为注释的内容；</li><li><code>parentNode</code> 值为 <code>Document</code> 或 <code>Element</code> 对象；</li><li>不支持子节点。</li></ul><p><code>Comment</code> 类型与 <code>Text</code> 类型继承同一个基类（<code>CharacterData</code>），因此拥有除 <code>splitText()</code>之外 <code>Text</code> 节点所有的字符串操作方法。与 <code>Text</code> 类型相似，注释的实际内容可以通过 <code>nodeValue</code> 或 <code>data</code> 属性获得。</p><p>注释节点可以作为父节点的子节点来访问。比如下面的 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="comment">&lt;!-- A comment --&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的注释是<code>&lt;div&gt;</code>元素的子节点，这意味着可以像下面这样访问它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> comment = div.<span class="property">firstChild</span>;</span><br><span class="line"><span class="title function_">alert</span>(comment.<span class="property">data</span>); <span class="comment">// &quot;A comment&quot;</span></span><br></pre></td></tr></table></figure><h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><p>很多时候，操作 <code>DOM</code> 是很直观的。通过 <code>HTML</code> 代码能实现的，也一样能通过 <code>JavaScript</code> 实现。但 有时候，<code>DOM</code> 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 <code>DOM</code> 的某些方面会复杂一些。</p><h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><p><code>&lt;script&gt;</code>元素用于向网页中插入 <code>JavaScript</code> 代码，可以是 <code>src</code> 属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 <code>DOM</code> 包含的脚本。与对应的 <code>HTML</code> 元素一样，有两种方式通过<code>&lt;script&gt;</code>动态为网页添加脚本：引入外部文件和直接插入源代码。</p><p>动态加载外部文件很容易实现，比如下面的<code>&lt;script&gt;</code>元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;foo.js&quot;</span>&gt;&lt;/script&gt; </span><br></pre></td></tr></table></figure><p>可以像这样通过 <code>DOM</code> 编程创建这个节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;foo.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>这里的 <code>DOM</code> 代码实际上完全照搬了它要表示的 <code>HTML</code> 代码。注意，在上面最后一行把<code>&lt;script&gt;</code>元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到<code>&lt;head&gt;</code>元素，同样可以实 现动态脚本加载。这个过程可以抽象为一个函数，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">url</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">     script.<span class="property">src</span> = url;</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以像下面这样加载外部 <code>JavaScript</code> 文件了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadScript</span>(<span class="string">&quot;client.js&quot;</span>); </span><br></pre></td></tr></table></figure><p>加载之后，这个脚本就可以对页面执行操作了。这里有个问题：怎么能知道脚本什么时候加载完？ 这个问题并没有标准答案，具体情况取决于使用的浏览器。</p><p>另一个动态插入 <code>JavaScript</code> 的方式是嵌入源代码，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"> <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>); </span></span><br><span class="line"><span class="language-javascript"> &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>DOM</code>，可以实现以下逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>));</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script); </span><br></pre></td></tr></table></figure><p>以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在 全局作用域中把源代码传给 <code>eval()</code>方法。</p><p>注意，通过 <code>innerHTML</code> 属性创建的<code>&lt;script&gt;</code>元素永远不会执行。浏览器会尽责地创建<code>script</code>元素，以及其中的脚本文本，但解析器会给这个<code>&lt;script&gt;</code>元素打上永不执行的标签。只要是使用 <code>innerHTML</code> 创建的<code>&lt;script&gt;</code>元素，以后也没有办法强制其执行。</p><h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p><code>CSS</code> 样式在 <code>HTML</code>页面中可以通过两个元素加载。元素用于包含 <code>CSS</code> 外部文件，而<code>&lt;style&gt;</code>元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。</p><p>来看下面这个典型的<code>&lt;link&gt;</code>元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个元素很容易使用 <code>DOM</code> 编程创建出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">link.<span class="property">href</span> = <span class="string">&quot;styles.css&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(link); </span><br></pre></td></tr></table></figure><p>以上代码在所有主流浏览器中都能正常运行。注意应该把<code>&lt;link&gt;</code>元素添加到<code>&lt;head&gt;</code>元素而不是<code>&lt;body&gt;</code>元素，这样才能保证所有浏览器都能正常运行。这个过程可以抽象为以下通用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadStyles</span>(<span class="params">url</span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line"> link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line"> link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line"> link.<span class="property">href</span> = url;</span><br><span class="line"> <span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"> head.<span class="title function_">appendChild</span>(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以这样调用这个 <code>loadStyles()</code>函数了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadStyles</span>(<span class="string">&quot;styles.css&quot;</span>); </span><br></pre></td></tr></table></figure><p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 <code>JavaScript</code> 代码并没有先后 顺序。一般来说，也没有必要知道样式什么时候加载完成。</p><p>另一种定义样式的方式是使用<code>&lt;script&gt;</code>元素包含嵌入的 <code>CSS</code> 规则，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑上，下列 <code>DOM</code> 代码会有同样的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">style.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">style.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(style); </span><br></pre></td></tr></table></figure><h2 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h2><p>表格是 <code>HTML</code> 中最复杂的结构之一。通过 <code>DOM</code> 编程创建<code>&lt;table&gt;</code>元素，通常要涉及大量标签，包 括表行、表元、表题，等等。因此，通过 <code>DOM</code> 编程创建和修改表格时可能要写很多代码。假设要通过 <code>DOM</code> 来创建以下 <code>HTML </code>表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就是以 <code>DOM</code> 编程方式重建这个表格的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>;</span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>);</span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"><span class="keyword">let</span> row1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row1);</span><br><span class="line"><span class="keyword">let</span> cell1_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell1_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell1_1);</span><br><span class="line"><span class="keyword">let</span> cell2_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell2_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell2_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line"><span class="keyword">let</span> row2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row2);</span><br><span class="line"><span class="keyword">let</span> cell1_2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell1_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>));</span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell1_2);</span><br><span class="line"><span class="keyword">let</span> cell2_2= <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">cell2_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>));</span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell2_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure><p>以上代码相当烦琐，也不好理解。为了方便创建表格，<code>HTML</code> <code>DOM</code> 给<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tr&gt;</code>元素添加了一些属性和方法。</p><p><code>&lt;table&gt;</code>&gt;元素添加了以下属性和方法：</p><ul><li><code>caption</code>，指向&#96;&#96;<caption>&#96;元素的指针（如果存在）</li><li><code>tBodies</code>，包含<code>&lt;tbody&gt;</code>元素的 <code>HTMLCollection</code>；</li><li><code>tFoot</code>，指向<code>&lt;tfoot&gt;</code>元素（如果存在）</li><li><code>tHead</code>，指向<code>&lt;thead&gt;</code>元素（如果存在）</li><li><code>rows</code>，包含表示所有行的 <code>HTMLCollection</code>；</li><li><code>createTHead()</code>，创建<code>&lt;thead&gt;</code>元素，放到表格中，返回引用；</li><li><code>createTFoot()</code>，创建<code>&lt;tfoot&gt;</code>元素，放到表格中，返回引用；</li><li><code>createCaption()</code>，创建<code>&lt;caption&gt;</code>元素，放到表格中，返回引用；</li><li><code>deleteTHead()</code>，删除<code>&lt;thead&gt;</code>元素；</li><li><code>deleteTFoot()</code>，删除<code>&lt;tfoot&gt;</code>元素；</li><li><code>deleteCaption()</code>，删除<code>&lt;caption&gt;</code>元素；</li><li><code>deleteRow(pos)</code>，删除给定位置的行；</li><li><code>insertRow(pos)</code>，在行集合中给定位置插入一行。</li></ul><p><code>&lt;tbody&gt;</code>元素添加了以下属性和方法：</p><ul><li><code>rows</code>，包含<code>&lt;tbody&gt;</code>元素中所有行的 <code>HTMLCollection</code>；</li><li><code>deleteRow(pos)</code>，删除给定位置的行；</li><li><code>insertRow(pos)</code>，在行集合中给定位置插入一行，返回该行的引用。</li></ul><p><code>&lt;tr&gt;</code>元素添加了以下属性和方法：</p><ul><li><code>cells</code>，包含<code>&lt;tr&gt;</code>元素所有表元的 <code>HTMLCollection</code>；</li><li><code>deleteCell(pos)</code>，删除给定位置的表元；</li><li><code>insertCell(pos)</code>，在表元集合给定位置插入一个表元，返回该表元的引用。</li></ul><p>这些属性和方法极大地减少了创建表格所需的代码量。例如，使用这些方法重写前面的代码之后是 这样的（加粗代码表示更新的部分）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>;</span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>);</span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line">tbody.<span class="title function_">insertRow</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="title function_">insertCell</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">0</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>));</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="title function_">insertCell</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.<span class="title function_">insertRow</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="title function_">insertCell</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="property">cells</span>[<span class="number">0</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>));</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="title function_">insertCell</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure><p>这里创建<code>&lt;table&gt;</code>和<code>&lt;tbody&gt;</code>元素的代码没有变。变化的是创建两行的部分，这次使用了 <code>HTML DOM</code> 表格的属性和方法。创建第一行时，在<code>&lt;tbody&gt;</code>元素上调用了 <code>insertRow()</code>方法。传入参数 0， 表示把这一行放在什么位置。然后，使用 <code>tbody.rows[0]</code>来引用这一行，因为这一行刚刚创建并被添 加到了<code>&lt;tbody&gt;</code>的位置 0。</p><p>创建表元的方式也与之类似。在<code>&lt;tr&gt;</code>元素上调用 <code>insertCell()</code>方法，传入参数 0，表示把这个表元放在什么位置上。然后，使用 <code>tbody.rows[0].cells[0]</code>来引用这个表元，因为这个表元刚刚创建 并被添加到了<code>&lt;tr&gt;</code>的位置 0。</p><p>虽然以上两种代码在技术上都是正确的，但使用这些属性和方法创建表格让代码变得更有逻辑性， 也更容易理解。</p><h2 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h2><p>理解 <code>NodeList</code> 对象和相关的 <code>NamedNodeMap</code>、<code>HTMLCollection</code>，是理解 <code>DOM</code> 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，<code>NodeList</code> 就是基于 <code>DOM</code> 文档的实时查询。例如，下面的代码会导致无穷循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i)&#123;</span><br><span class="line">     <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用 <code>ES6</code> 迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导 致无穷循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>))&#123;</span><br><span class="line"> <span class="keyword">let</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDiv);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>任何时候要迭代 <code>NodeList</code>，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这 个变量进行比较，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = divs.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line"> <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这个例子中，又初始化了一个保存集合长度的变量 <code>len</code>。因为 <code>len</code> 保存着循环开始时集合的长度， 而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。本章还会使用这种技术来演示迭代 <code>NodeList</code> 对象的首选方式。</p><p>另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = divs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"> <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，最好限制操作 <code>NodeList</code> 的次数。因为每次查询都会搜索整个文档，所以最好把查询到 的 <code>NodeList</code> 缓存起来。</p><h1 id="MutationObserver接口"><a href="#MutationObserver接口" class="headerlink" title="MutationObserver接口"></a>MutationObserver接口</h1><p>不久前添加到 <code>DOM</code> 规范中的 <code>MutationObserver</code> 接口，可以在 <code>DOM</code> 被修改时异步执行回调。使 用 <code>MutationObserver</code> 可以观察整个文档、<code>DOM</code> 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>MutationObserver</code> 的实例要通过调用 <code>MutationObserver</code> 构造函数并传入一个回调函数来创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM was mutated!&#x27;</span>));</span><br></pre></td></tr></table></figure><ol><li><p>observe()方法</p><p>新创建的 <code>MutationObserver</code> 实例不会关联 <code>DOM</code> 的任何部分。要把这个 <code>observer</code> 与 <code>DOM</code> 关 联起来，需要使用 <code>observe()</code>方法。这个方法接收两个必需的参数：要观察其变化的 <code>DOM</code> 节点，以及 一个 <code>MutationObserverInit</code> 对象。</p><p><code>MutationObserverInit</code> 对象用于控制观察哪些方面的变化，是一个键&#x2F;值对形式配置选项的字典。 例如，下面的代码会创建一个观察者（<code>observer</code>）并配置它观察元素上的属性变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br></pre></td></tr></table></figure><p>执行以上代码后，<code>&lt;body&gt;</code>元素上任何属性发生变化都会被这个 <code>MutationObserver</code> 实例发现，然 后就会异步执行注册的回调函数。元素后代的修改或其他非属性修改都不会触发回调进入任务 队列。可以通过以下代码来验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Changed body class&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Changed body class</span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure><p>注意，回调中的<code>console.log()</code>是后执行的。这表明回调并非与实际的 <code>DOM</code> 变化同步执行。</p></li><li><p>回调与<code>MutationRecord</code></p><p>每个回调都会收到一个 <code>MutationRecord</code> 实例的数组。<code>MutationRecord </code>实例包含的信息包括发 生了什么变化，以及 <code>DOM</code> 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 <code>MutationRecord</code> 实例的数组。</p><p>下面展示了反映一个属性变化的 <code>MutationRecord</code> 实例的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"> </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// previousSibling: null</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// target: body</span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><p>下面是一次涉及命名空间的类似变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttributeNS</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// attributeNamespace: &quot;baz&quot;,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// previousSibling: null</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// target: body</span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><p>连续修改会生成多个 <code>MutationRecord</code> 实例，下次回调执行时就会收到包含所有这些实例的数组， 顺序为变化事件发生的顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure><p>下表列出了 <code>MutationRecord</code> 实例的属性。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>被修改影响的目标节点</td></tr><tr><td>type</td><td>字符串，表示变化的类型：”attributes”、”characterData”或”childList”</td></tr><tr><td>oldValue</td><td>如果在 MutationObserverInit 对象中启用（attributeOldValue 或 characterData OldValue 为 true），”attributes”或”characterData”的变化事件会设置这个属性为被替代的值 “childList”类型的变化始终将这个属性设置为 null</td></tr><tr><td>attributeName</td><td>对于”attributes”类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null</td></tr><tr><td>attributeNamespace</td><td>对于使用了命名空间的”attributes”类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null</td></tr><tr><td>addedNodes</td><td>对于”childList”类型的变化，返回包含变化中添加节点的 NodeList 默认为空 NodeList</td></tr><tr><td>removedNodes</td><td>对于”childList”类型的变化，返回包含变化中删除节点的 NodeList 默认为空 NodeList</td></tr><tr><td>previousSibling</td><td>对于”childList”类型的变化，返回变化节点的前一个同胞 Node 默认为 null</td></tr><tr><td>nextSibling</td><td>对于”childList”类型的变化，返回变化节点的后一个同胞 Node 默认为 null</td></tr></tbody></table><p>传给回调函数的第二个参数是观察变化的 <code>MutationObserver</code> 的实例，演示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords, mutationObserver</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords,</span><br><span class="line">mutationObserver));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="comment">// [MutationRecord], MutationObserver</span></span><br></pre></td></tr></table></figure></li><li><p><code>disconnect()</code>方法</p><p>默认情况下，只要被观察的元素不被垃圾回收，<code>MutationObserver</code> 的回调就会响应 <code>DOM</code> 变化事 件，从而被执行。要提前终止执行回调，可以调用 <code>disconnect()</code>方法。下面的例子演示了同步调用 <code>disconnect()</code>之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（没有日志输出）</span></span><br></pre></td></tr></table></figure><p>要想让已经加入任务队列的回调执行，可以使用 <code>setTimeout()</code>让已经入列的回调执行完毕再调用 <code>disconnect()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     observer.<span class="title function_">disconnect</span>();</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure></li><li><p>复用 <code>MutationObserver</code></p><p>多次调用 <code>observe()</code>方法，可以复用一个 <code>MutationObserver</code> 对象观察多个不同的目标节点。此 时，<code>MutationRecord</code> 的 <code>target</code> 属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">x.<span class="property">target</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line"> childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;span&gt;]</span></span><br></pre></td></tr></table></figure><p><code>disconnect()</code>方法是一个“一刀切”的方案，调用它会停止观察所有目标：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">x.<span class="property">target</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line"> childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （没有日志输出）</span></span><br></pre></td></tr></table></figure></li><li><p>重用 <code>MutationObserver</code></p><p>调用 <code>disconnect()</code>并不会结束 <code>MutationObserver</code> 的生命。还可以重新使用这个观察者，再将 它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与元素的关联：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes</span></span><br><span class="line"><span class="string">changed&#x27;</span>));</span><br><span class="line">                                                      </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     observer.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这行代码不会触发变化事件</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// Reattach</span></span><br><span class="line">     observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="MutationObserverInit-与观察范围"><a href="#MutationObserverInit-与观察范围" class="headerlink" title="MutationObserverInit 与观察范围"></a><code>MutationObserverInit</code> 与观察范围</h2><p><code>MutationObserverInit</code> 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p><p>下表列出了 <code>MutationObserverInit</code> 对象的属性。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>subtree</td><td>布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是 <code>false</code>，则只观察目标节点的变化；如果是 <code>true</code>，则观察目标节点及其整个子树 默认为 <code>false</code></td></tr><tr><td>attributes</td><td>布尔值，表示是否观察目标节点的属性变化 默认为 false</td></tr><tr><td><code>attributeFilter</code></td><td>字符串数组，表示要观察哪些属性的变化 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为观察所有属性</td></tr><tr><td><code>attributeOldValue</code></td><td>布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的属性值 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为 false</td></tr><tr><td><code>characterData</code></td><td>布尔值，表示修改字符数据是否触发变化事件 默认为 false</td></tr><tr><td><code>characterDataOldValue</code></td><td>布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的字符数据 把这个值设置为 true 也会将 <code>characterData</code> 的值转换为 true 默认为 false</td></tr><tr><td><code>childList</code></td><td>布尔值，表示修改目标节点的子节点是否触发变化事件 默认为 <code>false</code></td></tr></tbody></table><p>在调用 <code>observe()</code>时，<code>MutationObserverInit</code> 对象中的 <code>attribute</code>、<code>characterData</code> 和 <code>childList</code> 属性必须至少有一项为 true（无论是直接设置这几个属性，还是通过设置 <code>attributeOldValue</code> 等属性间接导致它们的值转换为 <code>true</code>）。否则会抛出错误，因为没有任何变化事件可能触发回调。</p><ol><li><p>观察属性</p><p><code>MutationObserver</code> 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 <code>MutationObserverInit</code> 对象中将 <code>attributes</code> 属性设置为 true，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure><p>把 <code>attributes</code> 设置为 true 的默认行为是观察所有属性，但不会在 <code>MutationRecord</code> 对象中记 录原来的属性值。如果想观察某个或某几个属性，可以使用 <code>attributeFilter</code> 属性来设置白名单，即 一个属性名字符串数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeFilter</span>: [<span class="string">&#x27;foo&#x27;</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加白名单属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加被排除的属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有 foo 属性的变化被记录了</span></span><br><span class="line"><span class="comment">// [MutationRecord] </span></span><br></pre></td></tr></table></figure><p>如果想在变化记录中保存属性原来的值，可以将 <code>attributeOldValue</code> 属性设置为 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>)));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeOldValue</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [null, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>观察字符数据</p><p><code>MutationObserver</code> 可以观察文本节点（如 <code>Text</code>、<code>Comment</code>或 <code>ProcessingInstruction</code> 节点） 中字符的添加、删除和修改。要为字符数据注册回调，需要在 <code>MutationObserverInit</code>对象中将 <code>characterData</code> 属性设置为 true，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要观察的文本节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值为相同的字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值为新字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过节点设置函数赋值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure><p>将 <code>characterData</code> 属性设置为 true 的默认行为不会在 <code>MutationRecord</code> 对象中记录原来的字符 数据。如果想在变化记录中保存原来的字符数据，可以将 <code>characterDataOldValue</code> 属性设置为 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>)));</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterDataOldValue</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p>观察子节点</p><p><code>MutationObserver</code> 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 <code>MutationObserverInit</code> 对象中将 <code>childList</code> 属性设置为 true。</p><p>下面的例子演示了添加子节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[div],</span></span><br><span class="line"><span class="comment">// attributeName: null,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// previousSibling: null,</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// target: body,</span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>下面的例子演示了移除子节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"> </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// attributeName: null,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// previousSibling: null,</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[div],</span></span><br><span class="line"><span class="comment">// target: body,</span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><p>对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移 除和再添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个初始子节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换子节点顺序</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">lastChild</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生了两次变化：第一次是节点被移除，第二次是节点被添加</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// attributeName: null,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// previousSibling: div,</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[span],</span></span><br><span class="line"><span class="comment">// target: body,</span></span><br><span class="line"><span class="comment">// type: childList,</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[span],</span></span><br><span class="line"><span class="comment">// attributeName: null,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// nextSibling: div,</span></span><br><span class="line"><span class="comment">// previousSibling: null,</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// target: body,</span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure></li><li><p>观察子树</p><p>默认情况下，<code>MutationObserver</code> 将观察的范围限定为一个元素及其子节点的变化。可以把观察 的范围扩展到这个元素的子树（所有后代节点），这需要在 <code>MutationObserverInit</code> 对象中将 <code>subtree</code> 属性设置为 true。</p><p>下面的代码展示了观察元素及其后代节点属性的变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"><span class="comment">// 创建一个后代</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察&lt;body&gt;元素及其子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// 修改&lt;body&gt;元素的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// 记录了子树变化的事件</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// previousSibling: null,</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[],</span></span><br><span class="line"><span class="comment">// target: div,</span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><p>有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</p><p>下面的代码演示了这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subtreeRoot = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line"> subtreeLeaf = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建包含两层的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(subtreeRoot);</span><br><span class="line">subtreeRoot.<span class="title function_">appendChild</span>(subtreeLeaf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(subtreeRoot, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把节点转移到其他子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(subtreeLeaf, subtreeRoot);</span><br><span class="line"></span><br><span class="line">subtreeLeaf.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移出的节点仍然触发变化事件</span></span><br><span class="line"><span class="comment">// [MutationRecord]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="异步回调与记录队列"><a href="#异步回调与记录队列" class="headerlink" title="异步回调与记录队列"></a>异步回调与记录队列</h2><p><code>MutationObserver</code> 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在 大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 <code>MutationRecord</code> 实例中，然后添加到记录队列。这个队列对每个 <code>MutationObserver</code> 实例都是唯一的，是所有 DOM 变化事件的有序列表。</p><ol><li><p>记录队列</p><p>每次 <code>MutationRecord</code> 被添加到 <code>MutationObserver</code> 的记录队列时，仅当之前没有已排期的微任 务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 <code>MutationObserver</code> 时传入） 作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。 不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一 个 <code>MutationRecord</code> 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一 个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 <code>MutationRecord</code> 就用不着了， 因此记录队列会被清空，其内容会被丢弃。</p></li><li><p>takeRecords()方法</p><p>调用 <code>MutationObserver</code> 实例的 <code>takeRecords()</code>方法可以清空记录队列，取出并返回其中的所 有 <code>MutationRecord</code> 实例。看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br><span class="line"><span class="comment">// [] </span></span><br></pre></td></tr></table></figure><p>这在希望断开与观察目标的联系，但又希望处理由于调用 <code>disconnect()</code>而被抛弃的记录队列中的 <code>MutationRecord</code> 实例时比较有用。</p></li></ol><h2 id="性能、内存与垃圾回收"><a href="#性能、内存与垃圾回收" class="headerlink" title="性能、内存与垃圾回收"></a>性能、内存与垃圾回收</h2><p>DOM Level 2 规范中描述的 <code>MutationEvent</code> 定义了一组会在各种 <code>DOM</code> 变化时触发的事件。由于 浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。 <code>MutationObserver</code> 接口就是为替代这些事件而设计的更实用、性能更好的方案。</p><p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 <code>MutationObserver</code> 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p><p>无论如何，使用 <code>MutationObserver</code> 仍然不是没有代价的。因此理解什么时候避免出现这种情况就很重要了。</p><ol><li><p><code>MutationObserver</code> 的引用</p><p><code>MutationObserver</code> 实例与目标节点之间的引用关系是非对称的。<code>MutationObserver</code> 拥有对要 观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p><p>然而，目标节点却拥有对 <code>MutationObserver</code> 的强引用。如果目标节点从 <code>DOM</code> 中被移除，随后 被垃圾回收，则关联的 <code>MutationObserver</code> 也会被垃圾回收。</p></li><li><p><code>MutationRecord</code> 的引用</p></li></ol><p>   记录队列中的每个 <code>MutationRecord</code> 实例至少包含对已有 <code>DOM</code> 节点的一个引用。如果变化是 <code>childList</code> 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理 每个 <code>MutationRecord</code>，然后让它们超出作用域并被垃圾回收。</p><p>   有时候可能需要保存某个观察者的完整变化记录。保存这些 <code>MutationRecord</code> 实例，也就会保存 它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 <code>MutationRecord</code> 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 <code>MutationRecord</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文档对象模型（&lt;code&gt;DOM&lt;/code&gt;，&lt;code&gt;Document Object Model&lt;/code&gt;）是 &lt;code&gt;HTML&lt;/code&gt; 和 &lt;code&gt;XML&lt;/code&gt; 文档的编程接口。&lt;code&gt;DOM&lt;/code&gt; 表示 由多层节点构成的文档，</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(10)——BOM</title>
    <link href="http://pvnk1u.github.io/2023/04/16/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(10)%E2%80%94%E2%80%94BOM/"/>
    <id>http://pvnk1u.github.io/2023/04/16/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(10)%E2%80%94%E2%80%94BOM/</id>
    <published>2023-04-15T21:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.878Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 <code>ECMAScript</code> 把浏览器对象模型（<code>BOM</code>，<code>Browser Object Model</code>）描述为 <code>JavaScript</code> 的核心，但 实际上 <code>BOM</code> 是使用 <code>JavaScript</code> 开发 <code>Web</code> 应用程序的核心。<code>BOM</code> 提供了与网页无关的浏览器功能对象。 多年来，<code>BOM</code> 是在缺乏规范的背景下发展起来的，因此既充满乐趣又问题多多。毕竟，浏览器开发商 都按照自己的意愿来为它添砖加瓦。最终，浏览器实现之间共通的部分成为了事实标准，为 <code>Web</code> 开发 提供了浏览器间互操作的基础。<code>HTML5</code> 规范中有一部分涵盖了 <code>BOM</code> 的主要内容，因为 <code>W3C</code> 希望将 <code>JavaScript</code> 在浏览器中最基础的部分标准化。</p><h1 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h1><p><code>BOM</code> 的核心是 <code>window</code> 对象，表示浏览器的实例。<code>window</code> 对象在浏览器中有两重身份，一个是 <code>ECMAScript</code> 中的 <code>Global</code> 对象，另一个就是浏览器窗口的 <code>JavaScript</code> 接口。这意味着网页中定义的所有 对象、变量和函数都以 <code>window</code>作为其 <code>Global</code>对象，都可以访问其上定义的 <code>parseInt()</code>等全局方法。</p><h2 id="Global作用域"><a href="#Global作用域" class="headerlink" title="Global作用域"></a>Global作用域</h2><p>因为 <code>window</code> 对象被复用为 <code>ECMAScript</code>的 <code>Global</code> 对象，所以通过 <code>var</code> 声明的所有全局变量和函数都会变成 <code>window</code> 对象的属性和方法。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sayAge</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// 29</span></span><br><span class="line"><span class="title function_">sayAge</span>(); <span class="comment">// 29</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayAge</span>(); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><p>这里，变量 <code>age</code> 和函数 <code>sayAge()</code>被定义在全局作用域中，它们自动成为了 <code>window</code> 对象的成员。 因此，变量 <code>age</code> 可以通过 <code>window.age</code> 来访问，而函数 <code>sayAge()</code>也可以通过 <code>window.sayAge()</code>来访问。 因为 <code>sayAge()</code>存在于全局作用域，<code>this.age</code> 映射到 <code>window.age</code>，所以就可以显示正确的结果了。</p><p>如果在这里使用 <code>let</code> 或 <code>const</code> 替代 <code>var</code>，则不会把变量添加给全局对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sayAge</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">sayAge</span>(); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayAge</span>(); <span class="comment">// TypeError: window.sayAge is not a function</span></span><br></pre></td></tr></table></figure><p>另外，访问未声明的变量会抛出错误，但是可以在 <code>window</code> 对象上查询是否存在可能未声明的变量。 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这会导致抛出错误，因为 oldValue 没有声明</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue;</span><br><span class="line"><span class="comment">// 这不会抛出错误，因为这里是属性查询</span></span><br><span class="line"><span class="comment">// newValue 会被设置为 undefined</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="variable language_">window</span>.<span class="property">oldValue</span>;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 中有很多对象都暴露在全局作用域中，比如 <code>location</code> 和 <code>navigator</code>，因而它们也是 <code>window</code> 对象的属性。</p><h2 id="窗口关系"><a href="#窗口关系" class="headerlink" title="窗口关系"></a>窗口关系</h2><p><code>top</code> 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 <code>parent</code> 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 <code>parent</code> 等于 <code>top</code>（都等于 <code>window</code>）。最上层的 <code>window</code> 如果不是通过 <code>window.open()</code>打开的，那么其 <code>name</code> 属性就不会包含值。</p><p>还有一个 <code>self</code> 对象，它是终极 <code>window</code> 属性，始终会指向 <code>window</code>。实际上，<code>self</code> 和 <code>window</code> 就 是同一个对象。之所以还要暴露 <code>self</code>，就是为了和 <code>top</code>、<code>parent</code> 保持一致。</p><p>这些属性都是 <code>window</code> 对象的属性，因此访问 <code>window.parent</code>、<code>window.top</code> 和 <code>window.self</code> 都可以。这意味着可以把访问多个窗口的 <code>window</code> 对象串联起来，比如 <code>window.parent.parent</code>。</p><h2 id="窗口位置与像素比"><a href="#窗口位置与像素比" class="headerlink" title="窗口位置与像素比"></a>窗口位置与像素比</h2><p><code>window</code> 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 <code>screenLeft</code> 和 <code>screenTop</code> 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 <code>CSS</code> 像素。</p><p>可以使用 <code>moveTo()</code>和 <code>moveBy()</code>方法移动窗口。这两个方法都接收两个参数，其中 <code>moveTo()</code>接收要移动到的新位置的绝对坐标 x 和 y；而 <code>moveBy()</code>则接收相对当前位置在两个方向上移动的像素数。 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把窗口移动到左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把窗口向下移动 100 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveBy</span>(<span class="number">0</span>, <span class="number">100</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把窗口移动到坐标位置(200, 300)</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveTo</span>(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把窗口向左移动 50 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveBy</span>(-<span class="number">50</span>, <span class="number">0</span>); </span><br></pre></td></tr></table></figure><h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>在不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持 4 个属性： <code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code> 和 <code>outerHeight</code>。<code>outerWidth</code> 和 <code>outerHeight</code> 返回浏 览器窗口自身的大小（不管是在最外层 <code>window</code> 上使用，还是在窗格中使用）。<code>innerWidth</code> 和 <code>innerHeight</code> 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。</p><p><code>document.documentElement.clientWidth</code> 和 <code>document.documentElement.clientHeight</code> 返回页面视口的宽度和高度。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>JavaScript</code> 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就 执行相应的代码。<code>setTimeout()</code>用于指定在一定时间后执行某些代码，而 <code>setInterval()</code>用于指定 每隔一段时间执行某些代码。</p><p><code>setTimeout()</code>方法通常接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）。第 一个参数可以是包含 <code>JavaScript</code> 代码的字符串（类似于传给 <code>eval()</code>的字符串）或者一个函数，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 1 秒后显示警告框</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>第二个参数是要等待的毫秒数，而不是要执行代码的确切时间。<code>JavaScript</code> 是单线程的，所以每次 只能执行一段代码。为了调度不同代码的执行，<code>JavaScript</code> 维护了一个任务队列。其中的任务会按照添 加到队列的先后顺序执行。<code>setTimeout()</code>的第二个参数只是告诉 <code>JavaScript</code> 引擎在指定的毫秒数过后 把任务添加到这个队列。<strong>如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待 前面的任务执行完才能执行。</strong></p><p>调用 <code>setTimeout()</code>时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 <code>clearTimeout()</code>方法并传入超 时 ID，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时任务</span></span><br><span class="line"><span class="keyword">let</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消超时任务</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timeoutId);</span><br></pre></td></tr></table></figure><p>只要是在指定时间到达之前调用 <code>clearTimeout()</code>，就可以取消超时任务。在任务执行后再调用 <code>clearTimeout()</code>没有效果。</p><p><code>setInterval()</code>与 <code>setTimeout()</code>的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。<code>setInterval()</code>同样可以接收两个参数：要执行的代码（字符 串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>这里的关键点是，第二个参数，也就是间隔时间，指的是向队列添加新任务之前等 待的时间。比如，调用 <code>setInterval()</code>的时间为 <code>01:00:00</code>，间隔时间为 3000 毫秒。这意 味着 <code>01:00:03</code> 时，浏览器会把任务添加到执行队列。浏览器不关心这个任务什么时候执行 或者执行要花多长时间。因此，到了 <code>01:00:06</code>，它会再向队列中添加一个任务。由此可看 出，执行时间短、非阻塞的回调函数比较适合 <code>setInterval()</code>。</p><p><code>setInterval()</code>方法也会返回一个循环定时 ID，可以用于在未来某个时间点上取消循环定时。要 取消循环定时，可以调用 <code>clearInterval()</code>并传入定时 ID。相对于 <code>setTimeout()</code>而言，取消定时的能力对 <code>setInterval()</code>更加重要。毕竟，如果一直不管它，那么定时任务会一直执行到页面卸载。</p><p><code>setIntervale()</code>在实践中很少会在 生产环境下使用，因为一个任务结束和下一个任务开始之间的时间间隔是无法保证的，有些循环定时任务可能会因此而被跳过。而像前面这个例子中一样使用 <code>setTimeout()</code>则能确保不会出现这种情况。一 般来说，最好不要使用 <code>setInterval()</code>。</p><h2 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h2><p>使用 <code>alert()</code>、<code>confirm()</code>和 <code>prompt()</code>方法，可以让浏览器调用系统对话框向用户显示消息。这 些对话框与浏览器中显示的网页无关，而且也不包含 <code>HTML</code>。它们的外观由操作系统或者浏览器决定， 无法使用 <code>CSS</code> 设置。此外，这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行， 在它们消失以后，代码才会恢复执行。</p><p>确认框，通过调用 <code>confirm()</code>来显示。确认框跟警告框类似，都会向用户显示消 息。但不同之处在于，确认框有两个按钮：“Cancel”（取消）和“OK”（确定）。用户通过单击不同的按 钮表明希望接下来执行什么操作。要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值：true 表示单击 了 OK 按钮，false 表示单击了 Cancel 按钮或者通过单击某一角上的 X 图标关闭了确认框。</p><p>最后一种对话框是提示框，通过调用 <code>prompt()</code>方法来显示。提示框的用途是提示用户输入消息。 除了 OK 和 Cancel 按钮，提示框还会显示一个文本框，让用户输入内容。<code>prompt()</code>方法接收两个参数： 要显示给用户的文本，以及文本框的默认值（可以是空字符串）。</p><p>如果用户单击了 OK 按钮，则 <code>prompt()</code>会返回文本框中的值。如果用户单击了 <code>Cancel</code> 按钮，或者 对话框被关闭，则 <code>prompt()</code>会返回 <code>null</code>。</p><h1 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h1><p><code>location</code> 是最有用的 <code>BOM</code> 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。 这个对象独特的地方在于，它既是 <code>window</code> 的属性，也是 <code>document</code> 的属性。也就是说， <code>window.location</code> 和 <code>document.location</code> 指向同一个对象。<code>location</code> 对象不仅保存着当前加载文 档的信息，也保存着把 <code>URL</code> 解析为离散片段后能够通过属性访问的信息。</p><p>假设浏览器当前加载的 URL 是 <code>http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</code>，<code>location</code> 对象的内容如下表所示。</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>location.hash</td><td>“#contents”</td><td>URL 散列值（井号后跟零或多个字符），如果没有则 为空字符串</td></tr><tr><td>location.host</td><td>“<a href="http://www.wrox.com/">www.wrox.com:80</a>“</td><td>服务器名及端口号</td></tr><tr><td>location.hostname</td><td>“<a href="http://www.wrox.com/">www.wrox.com</a>“</td><td>服务器名</td></tr><tr><td>location.href</td><td>“<a href="http://www.wrox.com/WileyCDA/">http://www.wrox.com:80/WileyCDA/</a> ?q&#x3D;javascript#contents”</td><td>当前加载页面的完整 URL。location 的 toString() 方法返回这个值</td></tr><tr><td>location.pathname</td><td>“&#x2F;WileyCDA&#x2F;“</td><td>URL 中的路径和（或）文件名</td></tr><tr><td>location.port</td><td>“80</td><td>请求的端口。如果 URL中没有端口，则返回空字符串</td></tr><tr><td>location.protocol</td><td>“http:”</td><td>页面使用的协议。通常是”http:”或”https:”</td></tr><tr><td>location.search</td><td>“?q&#x3D;javascript”</td><td>URL 的查询字符串。这个字符串以问号开头</td></tr><tr><td>location.username</td><td>“foouser”</td><td>域名前指定的用户名</td></tr><tr><td>location.password</td><td>“barpassword”</td><td>域名前指定的密码</td></tr><tr><td>location.origin</td><td>“<a href="http://www.wrox.com/">http://www.wrox.com</a>“</td><td>URL 的源地址。只读</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然 &lt;code&gt;ECMAScript&lt;/code&gt; 把浏览器对象模型（&lt;code&gt;BOM&lt;/code&gt;，&lt;code&gt;Browser Object Model&lt;/code&gt;）描述为 &lt;code&gt;JavaScript&lt;/code&gt; 的核心，但 实际上 &lt;code&gt;BOM&lt;/c</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(9)——期约与异步函数</title>
    <link href="http://pvnk1u.github.io/2023/03/14/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(9)%E2%80%94%E2%80%94%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    <id>http://pvnk1u.github.io/2023/03/14/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(9)%E2%80%94%E2%80%94%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-13T18:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.884Z</updated>
    
    <content type="html"><![CDATA[<p><code>ECMAScript</code> 6 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特 性。<code>ECMAScript</code> 6 新增了正式的 <code>Promise</code>（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用 <code>async</code>和 <code>await</code> 关键字定义异步函数的机制。</p><p>本章示例将大量使用异步日志输出的方式 <code>setTimeout(console.log, 0, ... params)</code>，旨在演示执行顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约等返回的值达到其最终状态。</p><p>此外，浏览器控制台的输出经常能打印出 <code>JavaScript</code> 运行中无法获取的对象信息（比如期约的状态）。</p><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>同步行为和异步行为的对立统一是计算机科学的一个基本概念。<strong>特别是在 <code>JavaScript</code> 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。</strong></p><p>重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线 程执行，那么任何时候都可以使用。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。</p><p>同步操作的例子可以是执行一次简单的数学计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">x = x + <span class="number">4</span>; </span><br></pre></td></tr></table></figure><p>在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。</p><p>这两行 <code>JavaScript</code> 代码对应的低级指令（从 <code>JavaScript</code> 到 <code>x86</code>）并不难想象。首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。</p><p>相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p><p>异步操作的例子可以是在定时回调中执行一次简单的数学计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> x = x + <span class="number">4</span>, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure><p>这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值 何时会改变，因为这取决于回调何时从消息队列出列并执行。</p><p>异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发 这个中断，这对 <code>JavaScript</code> 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前 线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法 知道系统状态何时变化。</p><p>为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。</p><p>设计一个能够知道 x 什么时候可以读取的系统是非常难的。<code>JavaScript</code> 在实现这样一个系统的过程中也经历了几次迭代。</p><h2 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h2><p>异步行为是 <code>JavaScript</code> 的基础，但以前的实现不理想。在早期的 <code>JavaScript</code> 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回 调地狱”）来解决。</p><p>假设有以下异步函数，使用了 <code>setTimeout</code> 在一秒钟之后执行某些操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。<code>setTimeout</code> 可以定义一个 在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，<code>JavaScript</code> 运行时会把回 调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 <code>JavaScript</code> 代码 就完全不可见了。还有一点，<code>double()</code>函数在 <code>setTimeout</code> 成功调度异步操作之后会立即退出。</p><ol><li><p>异步返回值</p><p><strong>假设 <code>setTimeout</code> 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, callback</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I was given: <span class="subst">$&#123;x&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I was given: 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这里的 <code>setTimeout</code> 调用告诉 <code>JavaScript</code> 运行时在 1000 毫秒之后把一个函数推到消息队列上。这 个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。</p></li><li><p>失败处理</p><p>异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, success, failure</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="title function_">success</span>(<span class="number">2</span> * value);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">failure</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">successCallback</span> = (<span class="params">x</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">failureCallback</span> = (<span class="params">e</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"><span class="title function_">double</span>(<span class="string">&#x27;b&#x27;</span>, successCallback, failureCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Success: 6（大约 1000 毫秒之后）</span></span><br><span class="line"><span class="comment">// Failure: Must provide number as first argument（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。</p></li><li><p>嵌套异步回调</p><p>如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这 就要求嵌套回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, success, failure</span>) &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="title function_">success</span>(<span class="number">2</span> * value);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">failure</span>(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="number">1000</span>);     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">successCallback</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line"> <span class="title function_">double</span>(x, <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Success: <span class="subst">$&#123;y&#125;</span>`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">failureCallback</span> = (<span class="params">e</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Success: 12（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。 嵌套回调的代码维护起来就是噩梦。</p></li></ol><h1 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h1><h2 id="Promises-x2F-A-规范"><a href="#Promises-x2F-A-规范" class="headerlink" title="Promises&#x2F;A+规范"></a>Promises&#x2F;A+规范</h2><p>早期的期约机制在 <code>jQuery</code> 和 <code>Dojo</code> 中是以 <code>Deferred API</code> 的形式出现的。到了 2010 年，<code>CommonJS</code> 项 目实现的 <code>Promises/A</code> 规范日益流行起来。<code>Q</code> 和 <code>Bluebird</code> 等第三方 <code>JavaScript</code> 期约库也越来越得到社区认 可，虽然这些库的实现多少都有些不同。为弥合现有实现之间的差异，2012 年 <code>Promises/A+</code>组织分叉（<code>fork</code>） 了 <code>CommonJS</code> 的 <code>Promises/A</code> 建议，并以相同的名字制定了 <code>Promises/A+</code>规范。这个规范最终成为了 <code>ECMAScript</code> 6 规范实现的范本。</p><p><code>ECMAScript</code> 6 增加了对 <code>Promises/A+</code>规范的完善支持，即 <code>Promise</code> 类型。一经推出，<code>Promise</code> 就 大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 <code>ES6</code> 期约，很多其他浏览器 <code>API</code>（如 <code>fetch()</code>和 <code>Battery Status API</code>）也以期约为基础。</p><h2 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h2><p><code>ECMAScript</code> 6 新增的引用类型 <code>Promise</code>，可以通过 <code>new</code> 操作符来实例化。创建新期约时需要传入执行器（<code>executor</code>）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解释器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure><p>之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 <code>SyntaxError</code>。</p><ol><li><p>期约状态机</p><p>在把一个期约实例传给 <code>console.log()</code>时，控制台输出（可能因浏览器不同而略有差异）表明该 实例处于待定（<code>pending</code>）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一：</p><ul><li>待定（pending）</li><li>兑现（fulfilled，有时候也称之为”解决”，resolved）</li><li>拒绝（rejected）</li></ul><p><strong>待定（<code>pending</code>）是期约的最初始状态。在待定状态下，期约可以落定（<code>settled</code>）为代表成功的兑现 （<code>fulfilled</code>）状态，或者代表失败的拒绝（<code>rejected</code>）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（<code>resolve</code>）还是拒绝（<code>reject</code>），甚至永远处于待定（<code>pending</code>）状态，都应该具有恰当的行为。</strong></p><p><strong>重要的是，期约的状态是私有的，不能直接通过 <code>JavaScript</code>检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 <code>JavaScript</code> 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。</strong></p></li><li><p>解决值、拒绝理由及期约用例</p><p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定” 表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。</p><p>某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。比如，假设期约要向服务器发送一个 <code>HTTP</code> 请求。请求返回 <code>200~299</code> 范围内的状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在 <code>200~299</code> 这个范围内， 那么就会把期约状态切换为“拒绝”。</p><p>在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。比如，假设期约向服务器发送一个 <code>HTTP</code> 请求并预定会返回一个 <code>JSON</code>。如果请求返回范围在 <code>200~299</code> 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 <code>JSON</code> 字符串。类似地，如果请求返回的状 态码不在 <code>200~299</code> 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 <code>Error</code> 对象，包含着 <code>HTTP</code> 状态码及相关错误消息。</p><p>为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（<code>value</code>）。类似地， 每个期约只要状态切换为拒绝，就会有一个私有的内部理由（<code>reason</code>）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 <code>undefined</code>。在期约到达某个落定状 态时执行的异步代码始终会收到这个值或理由。</p></li><li><p>通过执行函数控制期约状态</p><p><strong>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 <code>resolve()</code>和 <code>reject()</code>。调用 <code>resolve()</code>会把状态切换为兑现，调用 <code>reject()</code>会把状态切换为拒绝。另外，调用 <code>reject()</code>也会抛 出错误（后面会讨论这个错误）。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught error (in promise)</span></span><br></pre></td></tr></table></figure><p>在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// executor</span></span><br><span class="line"><span class="comment">// promise initialized</span></span><br></pre></td></tr></table></figure><p>添加 <code>setTimeout</code> 可以推迟切换状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br></pre></td></tr></table></figure><p>无论 <code>resolve()</code>和 <code>reject()</code>中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="title function_">resolve</span>();</span><br><span class="line">     <span class="title function_">reject</span>(); <span class="comment">// 没有效果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt; </span></span><br></pre></td></tr></table></figure><p>为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 <code>setTimeout</code> 设置一个 10 秒钟后无论如何都会拒绝期约的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(reject, <span class="number">10000</span>); <span class="comment">// 10 秒后调用 reject()</span></span><br><span class="line">     <span class="comment">// 执行函数的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">11000</span>, p); <span class="comment">// 11 秒后再检查状态</span></span><br><span class="line"><span class="comment">// (After 10 seconds) Uncaught error</span></span><br><span class="line"><span class="comment">// (After 11 seconds) Promise &lt;rejected&gt;</span></span><br></pre></td></tr></table></figure><p><strong>因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。</strong></p></li><li><p>Promise.resolve()</p><p>期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用 <code>Promise.resolve()</code>静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure><p>这个解决的期约的值对应着传给 <code>Promise.resolve()</code>的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 4 </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此， <code>Promise.resolve()</code>可以说是一个幂等方法，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个幂等性会保留传入期约的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.reject()</p><p>与 <code>Promise.resolve()</code>类似，**<code>Promise.reject()</code>会实例化一个拒绝的期约并抛出一个异步错误 （这个错误不能通过 <code>try/catch</code> 捕获，而只能通过拒绝处理程序捕获）。**下面的两个期约实例实际上是 一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br></pre></td></tr></table></figure><p>这个拒绝的期约的理由就是传给 <code>Promise.reject()</code>的第一个参数。这个参数也会传给后续的拒绝处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3</span></span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>关键在于，<code>Promise.reject()</code>并没有照搬 <code>Promise.resolve()</code>的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>同步&#x2F;异步执行的二元性</p><p><code>Promise</code> 的设计很大程度上会导致一种完全不同于 <code>JavaScript</code> 的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure><p>第一个 <code>try/catch</code> 抛出并捕获了错误，第二个 <code>try/catch</code> 抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。<strong>这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。</strong></p><p>在这个例子中，<strong>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，<code>try/catch</code> 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。</strong></p></li></ol><h2 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h2><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p><ol><li><p>实现Thenable接口</p><p>在 <code>ECMAScript</code> 暴露的异步结构中，任何对象都有一个 <code>then()</code>方法。这个方法被认为实现了 <code>Thenable</code> 接口。下面的例子展示了实现这一接口的最简单的类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThenable</span> &#123;</span><br><span class="line"> <span class="title function_">then</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>ECMAScript</code> 的 <code>Promise</code> 类型实现了 <code>Thenable</code> 接口。这个简化的接口跟 <code>TypeScript</code> 或其他包中的接口或类型定义不同，它们都设定了 <code>Thenable</code> 接口更具体的形式。</p></li><li><p>Promise.prototype.then()</p><p><code>Promise.prototype.then()</code>是<strong>为期约实例添加处理程序的主要方法</strong>。这个 <code>then()</code>方法接收最多 两个参数：<code>onResolved</code> 处理程序和 <code>onRejected</code> 处理程序。<strong>这两个参数都是可选的，如果提供的话， 则会在期约分别进入“兑现”和“拒绝”状态时执行。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onResolved</span>(<span class="params">id</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">id</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&#x27;p1&#x27;</span>),</span><br><span class="line"> <span class="function">() =&gt;</span> <span class="title function_">onRejected</span>(<span class="string">&#x27;p1&#x27;</span>));</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&#x27;p2&#x27;</span>),</span><br><span class="line"> <span class="function">() =&gt;</span> <span class="title function_">onRejected</span>(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">//（3 秒后）</span></span><br><span class="line"><span class="comment">// p1 resolved</span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure><p>因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。</p><p>如前所述，两个处理程序参数都是可选的。而且，<strong>传给 <code>then()</code>的任何非函数类型的参数都会被静默忽略。如果想只提供 <code>onRejected</code> 参数，那就要在 <code>onResolved</code> 参数的位置上传入 <code>undefined</code>。这 样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onResolved</span>(<span class="params">id</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">id</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非函数处理程序会被静默忽略，不推荐</span></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="string">&#x27;gobbeltygook&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传 onResolved 处理程序的规范写法</span></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title function_">onRejected</span>(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2 rejected（3 秒后）</span></span><br></pre></td></tr></table></figure><p><code>Promise.prototype.then()</code>方法返回一个新的期约实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个新期约实例基于 <code>onResovled</code> 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 <code>Promise.resolve()</code>包装来生成新期约。如果没有提供这个处理程序，则 <code>Promise.resolve()</code>就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 <code>Promise.resolve()</code>会包装默认的返回值 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若调用 then()时不传处理程序，则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br></pre></td></tr></table></figure><p>如果有显式的返回值，则 <code>Promise.resolve()</code>会包装这个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined </span></span><br></pre></td></tr></table></figure><p>抛出异常会返回拒绝的期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt; baz </span></span><br></pre></td></tr></table></figure><p>注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure><p><strong><code>onRejected</code> 处理程序也与之类似：<code>onRejected</code> 处理程序返回的值也会被 <code>Promise.resolve()</code> 包装。乍一看这可能有点违反直觉，但是想一想，<code>onRejected</code> 处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。</strong></p><p>下面的代码片段展示了用 <code>Promise.reject()</code>替代之前例子中的 <code>Promise.resolve()</code>之后的 结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 then()时不传处理程序则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"><span class="comment">// Uncaught (in promise) foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.prototype.catch()</p><p><code>Promise.prototype.catch()</code>方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： <code>onRejected</code> 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 <code>Promise.prototype.then(null, onRejected)</code>。</p><p>下面的代码展示了这两种同样的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected); <span class="comment">// rejected</span></span><br><span class="line">p.<span class="title function_">catch</span>(onRejected); <span class="comment">// rejected </span></span><br></pre></td></tr></table></figure><p><code>Promise.prototype.catch()</code>返回一个新的期约实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">catch</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>在返回新期约实例方面，<code>Promise.prototype.catch()</code>的行为与 <code>Promise.prototype.then() </code>的 <code>onRejected</code> 处理程序是一样的。</p></li><li><p>Promise.prototype.finally()</p><p><code>Promise.prototype.finally()</code>方法用于给期约添加 <code>onFinally</code> 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 <code>onResolved</code> 和 <code>onRejected</code> 处理程序中出现冗余代码。但 <code>onFinally</code> 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用 于添加清理代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;Finally!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">finally</span>(onFinally); <span class="comment">// Finally</span></span><br><span class="line">p2.<span class="title function_">finally</span>(onFinally); <span class="comment">// Finally</span></span><br></pre></td></tr></table></figure><p><code>Promise.prototype.finally()</code>方法返回一个新的期约实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>这个新期约实例不同于 <code>then()</code>或 <code>catch()</code>方式返回的实例。因为 <code>onFinally</code>被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里都会原样后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>();</span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure><p>如果返回的是一个待定的期约，或者 <code>onFinally</code> 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br></pre></td></tr></table></figure><p>返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略解决的值</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>), <span class="number">100</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2), <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200 毫秒后：</span></span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure></li><li><p>非重入期约方法</p><p><strong>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 <code>JavaScript</code> 运行时保证，被称为“非重入”（<code>non-reentrancy</code>） 特性。</strong>下面的例子演示了这个特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建解决的期约</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加解决处理程序</span></span><br><span class="line"><span class="comment">// 直觉上，这个处理程序会等期约一解决就执行</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onResolved handler&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步输出，证明 then()已经返回</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then() returns&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// then() returns</span></span><br><span class="line"><span class="comment">// onResolved handler</span></span><br></pre></td></tr></table></figure><p>在这个例子中，在一个解决期约上调用 <code>then()</code>会把 <code>onResolved</code> 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 <code>then()</code>后面的同步代码一定先于处理程序执行。</p><p>先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。下面的例子展示了即使先添加了 <code>onResolved</code> 处理程序，再同步调用 <code>resolve()</code>，处理程序也不会进入同步线程执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个期约并将解决函数保存在一个局部变量中</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">     synchronousResolve = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1: invoking resolve()&#x27;</span>);</span><br><span class="line">         <span class="title function_">resolve</span>();</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2: resolve() returns&#x27;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4: then() handler executes&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;0: first of all&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">synchronousResolve</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 0: first of all</span></span><br><span class="line"><span class="comment">// 1: invoking resolve()</span></span><br><span class="line"><span class="comment">// 2: resolve() returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes </span></span><br></pre></td></tr></table></figure><p>在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。</p><p>非重入适用于 <code>onResolved/onRejected</code> 处理程序、<code>catch()</code>处理程序和 <code>finally()</code>处理程序。 下面的例子演示了这些处理程序都只能异步执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1.then() onResolved&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1.then() returns&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2.then() onRejected&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2.then() returns&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line">p3.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3.catch() onRejected&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3.catch() returns&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p4.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4.finally() onFinally&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4.finally() returns&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1.then() returns</span></span><br><span class="line"><span class="comment">// p2.then() returns</span></span><br><span class="line"><span class="comment">// p3.catch() returns</span></span><br><span class="line"><span class="comment">// p4.finally() returns</span></span><br><span class="line"><span class="comment">// p1.then() onResolved</span></span><br><span class="line"><span class="comment">// p2.then() onRejected</span></span><br><span class="line"><span class="comment">// p3.catch() onRejected</span></span><br><span class="line"><span class="comment">// p4.finally() onFinally </span></span><br></pre></td></tr></table></figure></li><li><p>邻近处理程序的执行顺序</p><p><strong>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 <code>then()</code>、<code>catch()</code>还是 <code>finally()</code>添加的处理程序都是如此。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8 </span></span><br></pre></td></tr></table></figure></li><li><p>传递解决值和拒绝理由</p><p><strong>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 <code>JSON</code> 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 <code>onResolved</code> 处理程序继续处理。当然，失败的网络请求也应该把 <code>HTTP</code> 状态码传给 <code>onRejected</code> 处理程序。</strong></p><p><strong>在执行函数中，解决的值和拒绝的理由是分别作为 <code>resolve()</code>和 <code>reject()</code>的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 <code>onResolved</code> 或 <code>onRejected</code> 处理程序的唯一 参数。</strong>下面的例子展示了上述传递过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>和 <code>Promise.reject()</code>在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 <code>onResolved </code>或 <code>onRejected </code>处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></li><li><p>拒绝期约与拒绝错误处理</p><p><strong>拒绝期约类似于 <code>throw()</code>表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期 约都会以一个错误对象为由被拒绝：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;rejected&gt;: Error: foo </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会抛出 4 个未捕获错误</span></span><br></pre></td></tr></table></figure><p><strong>期约可以以任何理由拒绝，包括 <code>undefined</code>，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。</strong>例如，前面例子中抛出的 4 个错误的栈追踪信息如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> (<span class="keyword">in</span> promise) <span class="title class_">Error</span>: foo</span><br><span class="line">     at <span class="title class_">Promise</span> (test.<span class="property">html</span>:<span class="number">5</span>)</span><br><span class="line">     at <span class="keyword">new</span> <span class="title class_">Promise</span> (&lt;anonymous&gt;)</span><br><span class="line">     at test.<span class="property">html</span>:<span class="number">5</span></span><br><span class="line"><span class="title class_">Uncaught</span> (<span class="keyword">in</span> promise) <span class="title class_">Error</span>: foo</span><br><span class="line">     at <span class="title class_">Promise</span> (test.<span class="property">html</span>:<span class="number">6</span>)</span><br><span class="line">     at <span class="keyword">new</span> <span class="title class_">Promise</span> (&lt;anonymous&gt;)</span><br><span class="line">     at test.<span class="property">html</span>:<span class="number">6</span></span><br><span class="line"><span class="title class_">Uncaught</span> (<span class="keyword">in</span> promise) <span class="title class_">Error</span>: foo</span><br><span class="line"> at test.<span class="property">html</span>:<span class="number">8</span></span><br><span class="line"><span class="title class_">Uncaught</span> (<span class="keyword">in</span> promise) <span class="title class_">Error</span>: foo</span><br><span class="line"> at <span class="title class_">Promise</span>.<span class="property">resolve</span>.<span class="property">then</span> (test.<span class="property">html</span>:<span class="number">7</span>) </span><br></pre></td></tr></table></figure><p><strong>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：<code>Promise.resolve().then()</code>的错误最后才出现，这是因为它需要在运行时消息队列中 添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。</strong></p><p>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过 <code>throw()</code>关键字抛出错误时， <code>JavaScript</code> 运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 这一行不会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught Error: foo</span></span><br></pre></td></tr></table></figure><p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: foo</span></span><br></pre></td></tr></table></figure><p>如本章前面的 <code>Promise.reject()</code>示例所示，异步错误只能通过异步的 <code>onRejected</code>处理程序 捕获：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 <code>try/catch</code> 在执行函数 中捕获错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br></pre></td></tr></table></figure><p><code>then()</code>和 <code>catch()</code>的 <code>onRejected</code> 处理程序在语义上相当于 <code>try/catch</code>。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，<code>onRejected</code> 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;begin synchronous execution&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;continue synchronous execution&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// begin synchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: foo</span></span><br><span class="line"><span class="comment">// continue synchronous execution</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;begin asynchronous execution&#x27;</span>);</span><br><span class="line"> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;continue asynchronous execution&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// begin asynchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: bar</span></span><br><span class="line"><span class="comment">// continue asynchronous execution</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="期约连锁与合约生成"><a href="#期约连锁与合约生成" class="headerlink" title="期约连锁与合约生成"></a>期约连锁与合约生成</h2><p><strong>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</strong></p><ol><li><p>期约连锁</p><p>把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方 法（<code>then()</code>、<code>catch()</code>和 <code>finally()</code>）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>);</span><br><span class="line">     <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;third&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fourth&#x27;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">// fourth </span></span><br></pre></td></tr></table></figure><p>这个实现最终执行了一连串同步任务。正因为如此，这种方式执行的任务没有那么有用，毕竟分别 使用 4 个同步函数也可以做到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>))();</span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second&#x27;</span>))();</span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;third&#x27;</span>))();</span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fourth&#x27;</span>))(); </span><br></pre></td></tr></table></figure><p>要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务。比如，可以像下面这样让每个期约在一定时间后解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure><p>把生成期约的代码提取到一个工厂函数中，就可以写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delayedResolve</span>(<span class="params">str</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">         <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title function_">delayedResolve</span>(<span class="string">&#x27;p1 executor&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p2 executor&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p3 executor&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p4 executor&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure><p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。假如这种情况下不使用期约，那么前面的代码可能就要这样写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delayedExecute</span>(<span class="params">str, callback = <span class="literal">null</span></span>) &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">         callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">     &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">delayedExecute</span>(<span class="string">&#x27;p1 callback&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="title function_">delayedExecute</span>(<span class="string">&#x27;p2 callback&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="title function_">delayedExecute</span>(<span class="string">&#x27;p3 callback&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="title function_">delayedExecute</span>(<span class="string">&#x27;p4 callback&#x27;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1 callback（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 callback（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 callback（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 callback（4 秒后）</span></span><br></pre></td></tr></table></figure><p>可以发现，这不正是期约所要解决的回调地狱问题吗？</p><p>因为 <code>then()</code>、<code>catch()</code>和 <code>finally()</code>都返回期约，所以串联这些方法也很直观。下面的例子同时 使用这 3 个实例方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;initial promise rejects&#x27;</span>);</span><br><span class="line"> <span class="title function_">reject</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject handler&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve handler&#x27;</span>))</span><br><span class="line"> .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally handler&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// initial promise rejects</span></span><br><span class="line"><span class="comment">// reject handler</span></span><br><span class="line"><span class="comment">// resolve handler</span></span><br><span class="line"><span class="comment">// finally handler</span></span><br></pre></td></tr></table></figure></li><li><p>期约图</p><p><strong>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等 待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。</strong></p><p>下面的例子展示了一种期约有向图，也就是二叉树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  A</span></span><br><span class="line"><span class="comment">// / \</span></span><br><span class="line"><span class="comment">// B  C</span></span><br><span class="line"><span class="comment">///\  /\</span></span><br><span class="line"><span class="comment">//D E F G</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"> <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> B = A.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> C = A.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line">B.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">C.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">C.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;G&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// E</span></span><br><span class="line"><span class="comment">// F</span></span><br><span class="line"><span class="comment">// G </span></span><br></pre></td></tr></table></figure><p>注意，日志的输出语句是对二叉树的层序遍历。如前所述，<strong>期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。</strong></p></li><li><p>Promise.all()和Promise.race()</p><p><code>Promise</code> 类提供两个将多个期约实例组合成一个期约的静态方法：<code>Promise.all()</code>和 <code>Promise.race()</code>。 而合成后期约的行为取决于内部期约的行为。</p><ul><li><p>Promise.all()</p><p><code>Promise.all()</code>静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 Promise.resolve()</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure><p>合成的期约只会在每个包含的期约都解决之后才解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;all() resolved!&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// all() resolved!（大约 1 秒后）</span></span><br></pre></td></tr></table></figure><p><strong>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure><p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4]</span></span><br></pre></td></tr></table></figure><p><strong>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作</strong>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.race()</p><p><code>Promise.race()</code>静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">race</span>();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure><p><strong><code>Promise.race()</code>不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，<code>Promise.race()</code>就会包装其解决值或拒绝理由并返回新期约：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5 </span></span><br></pre></td></tr></table></figure><p><strong>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 <code>Promise.all()</code> 类似，合成的期约会静默处理所有包含期约的拒绝操作</strong>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>串行期约合成</p><p>到目前为止，讨论期约连锁一直围绕期约的串行执行，忽略了<strong>期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数</strong>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">addFive</span>(<span class="title function_">addTwo</span>(<span class="title function_">addThree</span>(x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addTen</span>(<span class="number">7</span>)); <span class="comment">// 17</span></span><br></pre></td></tr></table></figure><p>在这个例子中，有 3 个函数基于一个值合成为一个函数。类似地，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x)</span><br><span class="line"> .<span class="title function_">then</span>(addTwo)</span><br><span class="line"> .<span class="title function_">then</span>(addThree)</span><br><span class="line"> .<span class="title function_">then</span>(addFive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>使用 <code>Array.prototype.reduce()</code>可以写成更简洁的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> [addTwo, addThree, addFive]</span><br><span class="line"> .<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18 </span></span><br></pre></td></tr></table></figure><p>这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连 锁。这个通用的合成函数可以这样实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTen = <span class="title function_">compose</span>(addTwo, addThree, addFive);</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18 </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="期约扩展"><a href="#期约扩展" class="headerlink" title="期约扩展"></a>期约扩展</h2><p><code>ES6</code> 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 <code>ECMAScript</code> 规范却未涉及的两个特性：期约取消和进度追踪。</p><ol><li><p>期约取消</p><p><strong>经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。这时候如果能够取消期约就 好了。</strong>某些第三方库，比如 <code>Bluebird</code>，就提供了这个特性。实际上，<code>TC39</code> 委员会也曾准备增加这个特性， 但相关提案最终被撤回了。结果，**<code>ES6</code> 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。**</p><p><strong>实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。</strong>基本使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> downloadBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.download&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> abortBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.abort&#x27;</span>);</span><br><span class="line"></span><br><span class="line">downloadBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, fetchVideo);</span><br><span class="line"></span><br><span class="line">abortBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  controller.<span class="title function_">abort</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Download aborted&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">fetch</span>(url, &#123;signal&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">   reports.<span class="property">textContent</span> = <span class="string">&#x27;Download error: &#x27;</span> + e.<span class="property">message</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的关键点，也就是在 <code>fetch</code> 调用的时候多传一个 <code>signal</code>，然后后续如果想取消，就调用 <code>controller.abort</code> ，<code>fetch</code> 可以检测到 <code>signal</code> 的变化，从而中断请求。</p><p>根据这个特性，我们扩展一个可取消的 <code>fetch API</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeCancelableFetch</span>(<span class="params">url: string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">  <span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="title function_">fetch</span>(url, &#123;signal&#125;)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">cancel</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    controller.<span class="title function_">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    promise,</span><br><span class="line">    cancel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;promise, cancel&#125; = <span class="title function_">makeCancelableFetch</span>(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line"><span class="title function_">cancel</span>()</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;) <span class="comment">// DOMException: The user aborted a request.</span></span><br></pre></td></tr></table></figure></li><li><p>期约进度通知</p><p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期 约的执行进度会很有用。<code>ECMAScript</code> 6 期约并不支持进度追踪，但是可以通过扩展来实现。</p><p>一种实现方式是扩展 <code>Promise</code> 类，为它添加 <code>notify()</code>方法，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrackablePromise</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123;</span><br><span class="line">     <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">         <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line"></span><br><span class="line">         <span class="variable language_">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 执行期约执行器函数调用指定的handler输出期约进度通知</span></span><br><span class="line">             <span class="keyword">return</span> <span class="title function_">executor</span>(resolve, reject, <span class="function">(<span class="params">statusContent</span>) =&gt;</span> &#123;</span><br><span class="line">                notifyHandlers.<span class="title function_">map</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> <span class="title function_">handler</span>(statusContent));</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">notifyHandlers</span> = notifyHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="title function_">notify</span>(<span class="params">notifyHandler</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">notifyHandlers</span>.<span class="title function_">push</span>(notifyHandler);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的printFunc是上边return executor方法里的第三个参数的函数：</span></span><br><span class="line"><span class="comment">// (statusContent) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//    notifyHandlers.map((handler) =&gt; handler(statusContent));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">TrackablePromise</span>(<span class="function">(<span class="params">resolve, reject, printFunc</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">x</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="title function_">printFunc</span>(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="title function_">countdown</span>(<span class="number">5</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定Promise的notifyHandler为 (x) =&gt; setTimeout(console.log, 0, &#x27;progress:&#x27;, x)</span></span><br><span class="line">p.<span class="title function_">notify</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;progress:&#x27;</span>, x));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// （约 1 秒后）80% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后）60% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后）40% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后）20% remaining</span></span><br><span class="line"><span class="comment">// （约 5 秒后）completed </span></span><br></pre></td></tr></table></figure><p>这个期约会连续5次递归地设置1000毫秒的超时。每个超时回调都会调用<code>notify()</code>并传入状态值。</p><p><code>notify()</code>函数会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的 每条消息分别执行一遍，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">p.<span class="title function_">notify</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;a:&#x27;</span>, x))</span><br><span class="line">.<span class="title function_">notify</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;b:&#x27;</span>, x));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"><span class="comment">// （约 1 秒后） a: 80% remaining</span></span><br><span class="line"><span class="comment">// （约 1 秒后） b: 80% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后） a: 60% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后） b: 60% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后） a: 40% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后） b: 40% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后） a: 20% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后） b: 20% remaining</span></span><br><span class="line"><span class="comment">// （约 5 秒后） completed </span></span><br></pre></td></tr></table></figure><p>注意：<code>ES6</code> 不支持取消期约和进度通知，一个主要原因就是这样会导致期约连锁和期约合成 过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了 通知，那么接下来应该发生什么完全说不清楚。毕竟，如果取消了 <code>Promise.all()</code>中的一个 期约，或者期约连锁中前面的期约发送了一个通知，那么接下来应该怎么办才比较合理呢？</p></li></ol><h1 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h1><p>异步函数，也称为“async&#x2F;await”（语法关键字），是 <code>ES6</code> 期约模式在 <code>ECMAScript</code> 函数中的应用。 <code>async/await</code> 是 <code>ES8</code> 规范新增的。这个特性从行为和语法上都增强了 <code>JavaScript</code>，让以同步方式写的代码能够异步执行。下面来看一个最简单的例子，这个期约在超时之后会解决为一个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>)); </span><br></pre></td></tr></table></figure><p>这个期约在 1000 毫秒之后解决为数值 3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x); &#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.<span class="title function_">then</span>(handler); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式 来接收这个值。也就是说，代码照样还是要放到处理程序里。<code>ES8</code> 为此提供了 <code>async/await</code> 关键字。</p><h2 id="异步函数-1"><a href="#异步函数-1" class="headerlink" title="异步函数"></a>异步函数</h2><p><code>ES8</code> 的 <code>async/await</code> 旨在解决利用异步结构组织代码的问题。为此，<code>ECMAScript</code> 对函数进行了扩展， 为其增加了两个新关键字：<code>async</code> 和 <code>await</code>。</p><ol><li><p><code>async</code></p><p><code>async</code> 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qux</span> &#123;</span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>async</code> 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭 包方面，异步函数仍然具有普通 <code>JavaScript</code> 函数的正常行为。正如下面的例子所示，<code>foo()</code>函数仍然会 在后面的指令之前被求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>不过，异步函数如果使用 <code>return</code> 关键字返回了值（如果没有 <code>return</code> 则会返回 <code>undefined</code>），这 个值会被 <code>Promise.resolve()</code>包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>当然，直接返回一个期约对象也是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>异步函数的返回值期待（但实际上并不要求）一个实现 <code>thenable</code> 接口的对象，但常规的值也可以。 如果返回的是实现 <code>thenable</code> 接口的对象，则这个对象可以由提供给 <code>then()</code>的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。</strong>下面的代码演示了这些情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> thenable = &#123;</span><br><span class="line"> <span class="title function_">then</span>(<span class="params">callback</span>) &#123; <span class="title function_">callback</span>(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">qux</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure><p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>不过，拒绝期约的错误不会被异步函数捕获：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3 </span></span><br></pre></td></tr></table></figure></li><li><p><code>await</code></p><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 <code>await</code> 关键字可以暂停异步函数代码的执行，等待期约解决。来看下面这个本章开始就出现过的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>使用 <code>async/await</code> 可以写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>注意，<code>await</code> 关键字会暂停执行异步函数后面的代码，让出 <code>JavaScript</code> 运行时的执行线程。这个行为与生成器函数中的 <code>yield</code> 关键字是一样的。<code>await</code> 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p><p><code>await</code> 关键字的用法与 <code>JavaScript</code> 的一元操作一样。它可以单独使用，也可以在表达式中使用，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步打印&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步打印&quot;bar&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000 毫秒后异步打印&quot;baz&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"><span class="comment">// baz（1000 毫秒后）</span></span><br></pre></td></tr></table></figure><p><code>await</code> 关键字期待（但实际上并不要求）一个实现 <code>thenable</code> 接口的对象，但常规的值也可以。如 果是实现 <code>thenable</code> 接口的对象，则这个对象可以由 <code>await</code> 来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> [<span class="string">&#x27;bar&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">        <span class="title function_">then</span>(<span class="params">callback</span>) &#123; <span class="title function_">callback</span>(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">qux</span>();</span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure><p>等待会抛出错误的同步操作，会返回拒绝的期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="number">3</span>; &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如前面的例子所示，单独的 <code>Promise.reject()</code>不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 <code>await</code> 则会释放（<code>unwrap</code>）错误值（将拒绝期约返回）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>await</code>的限制</p><p><code>await</code> 关键字必须在异步函数中使用，不能在顶级上下文如<code>&lt;script&gt;</code>标签或模块中使用。不过， 定义并立即调用异步函数是没问题的。下面两段代码实际是相同的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即调用的异步函数表达式</span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>此外，异步函数的特质不会扩展到嵌套函数。因此，<code>await</code> 关键字也只能直接出现在异步函数的定 义中。在同步函数内部使用 <code>await</code> 会抛出 <code>SyntaxError</code>。</p><p>下面展示了一些会出错的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许：await 出现在了箭头函数中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="title function_">syncFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数声明中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">syncFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数表达式中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> syncFn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许：IIFE 使用同步函数表达式或箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line">     (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>)); &#125;)();</span><br><span class="line">     (<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>)))();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h2 id="停止和恢复执行"><a href="#停止和恢复执行" class="headerlink" title="停止和恢复执行"></a>停止和恢复执行</h2><p>使用 <code>await</code> 关键字之后的区别其实比看上去的还要微妙一些。比如，下面的例子中按顺序调用了 3 个函数，但它们的输出结果顺序是相反的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// foo </span></span><br></pre></td></tr></table></figure><p><code>async/await</code> 中真正起作用的是 <code>await</code>。<code>async</code> 关键字，无论从哪方面来看，都不过是一个标识符。 毕竟，异步函数如果不包含 <code>await</code> 关键字，其执行基本上跟普通函数没有什么区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>要完全理解 <code>await</code> 关键字，必须知道它并非只是等待一个值可用那么简单。<code>JavaScript</code> 运行时在碰 到 <code>await</code> 关键字时，会记录在哪里暂停执行。等到 <code>await</code> 右边的值可用了，<code>JavaScript</code> 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。</strong></p><p><strong>因此，即使 <code>await</code> 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。</strong>下面的例子演示了这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4 </span></span><br></pre></td></tr></table></figure><p>控制台中输出结果的顺序很好地解释了运行时的工作过程：</p><ol><li>打印1</li><li>调用异步函数<code>foo()</code></li><li>(在<code>foo()</code>中)打印2</li><li>(在<code>foo()</code>中)<code>await</code>关键字暂停执行，为立即可用的值 <code>null</code> 向消息队列中添加一个任务；</li><li><code>foo()</code>退出</li><li>打印3</li><li>同步线程的代码执行完毕</li><li><code>JavaScript</code>运行时从消息队列中取出任务，恢复异步函数执行</li><li>(在<code>foo</code>中)恢复执行，<code>await</code>取得<code>null</code>值（这里并没有使用）</li><li>(在<code>foo()</code>中)打印4</li><li><code>foo()</code>返回</li></ol><p>如果 <code>await</code> 后面是一个期约，则问题会稍微复杂一些。<code>TC39</code> 对 <code>await</code> 后面是期约的情况如何处理做过一次修改。修改后，<code>await</code>后面是期约的情况只会生成一个 异步任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">8</span>));</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="number">6</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>实际开发中，对于并行的异步操作我们通常 更关注结果，而不依赖执行顺序。</p><h2 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h2><p>因为简单实用，所以异步函数很快成为 <code>JavaScript </code>项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。</p><ol><li><p>实现sleep()</p><p>很多人在刚开始学习 <code>JavaScript</code> 时，想找到一个类似 <code>Java</code> 中 <code>Thread.sleep()</code>之类的函数，好在程序中加入非阻塞的暂停。以前，这个需求基本上都通过 <code>setTimeout()</code>利用 <code>JavaScript</code> 运行时的行为来 实现的。</p><p>有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现 <code>sleep()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>); <span class="comment">// 暂停约 1500 毫秒</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 1502</span></span><br></pre></td></tr></table></figure></li><li><p>利用平行执行</p><p>如果使用 <code>await</code> 时不留心，则很可能错过平行加速的机会。来看下面的例子，其中顺序等待了 5 个随机的超时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">     <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">     <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">         <span class="title function_">resolve</span>();</span><br><span class="line">     &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">4</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure><p>用一个 for 循环重写，就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">     <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">     <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">         <span class="title function_">resolve</span>();</span><br><span class="line">     &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">randomDelay</span>(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure><p>就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序， 但总执行时间会变长。</p><p><strong>如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。</strong>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">     <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">     <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">         <span class="title function_">resolve</span>();</span><br><span class="line">     &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">     <span class="keyword">const</span> p0 = <span class="title function_">randomDelay</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">const</span> p1 = <span class="title function_">randomDelay</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">const</span> p2 = <span class="title function_">randomDelay</span>(<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">const</span> p3 = <span class="title function_">randomDelay</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="keyword">const</span> p4 = <span class="title function_">randomDelay</span>(<span class="number">4</span>);</span><br><span class="line">     <span class="keyword">await</span> p0;</span><br><span class="line">     <span class="keyword">await</span> p1;</span><br><span class="line">     <span class="keyword">await</span> p2;</span><br><span class="line">     <span class="keyword">await</span> p3;</span><br><span class="line">     <span class="keyword">await</span> p4;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure><p>用数组和 for 循环再包装一下就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">     <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">     <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">         <span class="title function_">resolve</span>();</span><br><span class="line">     &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">     <span class="keyword">const</span> promises = <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">randomDelay</span>(i));</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        <span class="keyword">await</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure><p>注意，虽然期约没有按照顺序执行，但 <code>await</code> 按顺序收到了每个期约的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">     <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">     <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">         <span class="title function_">resolve</span>(id);</span><br><span class="line">     &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> promises = <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">randomDelay</span>(i));</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`awaited <span class="subst">$&#123;<span class="keyword">await</span> p&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// awaited 0</span></span><br><span class="line"><span class="comment">// awaited 1</span></span><br><span class="line"><span class="comment">// awaited 2</span></span><br><span class="line"><span class="comment">// awaited 3</span></span><br><span class="line"><span class="comment">// awaited 4</span></span><br><span class="line"><span class="comment">// 645ms elapsed</span></span><br></pre></td></tr></table></figure></li><li><p>串行执行期约</p><p>使用 <code>async/await</code>，期约连锁会变得很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">         x = <span class="keyword">await</span> <span class="title function_">fn</span>(x);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><p>这里，<code>await</code> 直接传递了每个函数的返回值，结果通过迭代产生。当然，这个例子并没有使用期约， 如果要使用期约，则可以把所有函数都改成异步函数。这样它们就都返回期约了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">         x = <span class="keyword">await</span> <span class="title function_">fn</span>(x);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19 </span></span><br></pre></td></tr></table></figure></li><li><p>栈追踪与内存管理</p><p>期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。看看下面的例子， 它展示了拒绝期约的栈追踪信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br><span class="line"><span class="comment">// setTimeout (async)</span></span><br><span class="line"><span class="comment">// fooPromiseExecutor</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p> <code>JavaScript</code> 引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时， 调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息 会占用内存，从而带来一些计算和存储成本。</p><p>如果在前面的例子中使用的是异步函数，那又会怎样呢？比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// async function (async)</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p>这样一改，栈追踪信息就准确地反映了当前的调用栈。<code>fooPromiseExecutor()</code>已经返回，所以它不在错误信息中。但 <code>foo()</code>此时被挂起了，并没有退出。<code>JavaScript</code> 运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;ECMAScript&lt;/code&gt; 6 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特 性。&lt;code&gt;ECMAScript&lt;/code&gt; 6 新增了正式的 &lt;code&gt;Promise&lt;/code&gt;（期约）引用类型，支持优雅地定义和组织</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(8)——函数</title>
    <link href="http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <id>http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-08T04:26:39.000Z</published>
    <updated>2023-11-27T15:34:23.883Z</updated>
    
    <content type="html"><![CDATA[<p>函数是 <code>ECMAScript</code>中最有意思的部分之一，这主要是因为<strong>函数实际上是对象</strong>。<strong>每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code> 也有属性和方法，跟其他引用类型一样。</strong> <strong>因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义</strong>，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意函数定义最后没有加分号。</p><p>另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，代码定义了一个变量 <code>sum</code> 并将其初始化为一个函数。注意 <code>function</code> 关键字后面没有名称，因为不需要。这个函数可以通过变量 <code>sum</code> 来引用。</p><p>还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function），如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后一种定义函数的方式是使用 <code>Function</code> 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p><code>ECMAScript 6</code> 新增了使用胖箭头（<code>=&gt;</code>）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">arrowSum</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> functionExpressionSum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrowSum</span>(<span class="number">5</span>, <span class="number">8</span>)); <span class="comment">// 13</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">functionExpressionSum</span>(<span class="number">5</span>, <span class="number">8</span>)); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>箭头函数简洁的语法非常适合嵌入函数的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">i</span>) &#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;)); <span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; <span class="keyword">return</span> i + <span class="number">1</span> &#125;)); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = (<span class="params">x</span>) =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">triple</span> = x =&gt; &#123; <span class="keyword">return</span> <span class="number">3</span> * x; &#125;;</span><br><span class="line"><span class="comment">// 没有参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getRandom</span> = (<span class="params"></span>) =&gt; &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>(); &#125;;</span><br><span class="line"><span class="comment">// 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, <span class="function"><span class="params">b</span> =&gt;</span> &#123; <span class="keyword">return</span> a * b; &#125;;</span><br></pre></td></tr></table></figure><p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以 在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码， 比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效，而且返回相应的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = (<span class="params">x</span>) =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">triple</span> = (<span class="params">x</span>) =&gt; <span class="number">3</span> * x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">setName</span> = (<span class="params">x</span>) =&gt; x.<span class="property">name</span> = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line"><span class="title function_">setName</span>(value);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">name</span>); <span class="comment">// &quot;Matt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">multiply</span> = (<span class="params">a, b</span>) =&gt; <span class="keyword">return</span> a * b;</span><br></pre></td></tr></table></figure><p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 <code>arguments</code>、<code>super</code> 和 <code>new.target</code>，也不能用作构造函数。此外，箭头函数也没有 <code>prototype</code> 属性。</p><h1 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h1><p>因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>以上代码定义了一个名为 <code>sum()</code>的函数，用于求两个数之和。然后又声明了一个变量 <code>anotherSum</code>， 并将它的值设置为等于 <code>sum</code>。注意，使用不带括号的函数名会访问函数指针，而不会执行函数。此时， <code>anotherSum</code> 和 <code>sum</code> 都指向同一个函数。调用 <code>anotherSum()</code>也可以返回结果。把 <code>sum</code> 设置为 <code>null</code>之后，就切断了它与函数之间的关联。而 <code>anotherSum()</code>还是可以照常调用，没有问题。</p><p><code>ECMAScript 6</code> 的所有函数对象都会暴露一个只读的 <code>name</code> 属性，其中包含关于函数的信息。多数情 况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称， 也会如实显示成空字符串。如果它是使用 <code>Function</code> 构造函数创建的，则会标识成”anonymous”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>); <span class="comment">// foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>); <span class="comment">// baz</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>); <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure><p><strong>如果函数是一个获取函数、设置函数，或者使用 <code>bind()</code>实例化，那么标识符前面会加上一个前缀</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>); <span class="comment">// bound foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line"> <span class="attr">years</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newAge</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">years</span> = newAge;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(dog, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>); <span class="comment">// get age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">set</span>.<span class="property">name</span>); <span class="comment">// set age</span></span><br></pre></td></tr></table></figure><h1 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h1><p><code>ECMAScript</code> 函数的参数跟大多数其他语言不同。**<code>ECMAScript</code> 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。可以传一 个、三个，甚至一个也不传，解释器都不会报错。**</p><p>之所以会这样，<strong>主要是因为 <code>ECMAScript</code> 函数的参数在内部表现为一个数组。函数被调用时总会接 收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元 素超出了要求，那也没问题。事实上，在使用 <code>function</code> 关键字定义（非箭头）函数时，可以在函数内部访问 <code>arguments </code>对象，从中取得传进来的每个参数值。</strong></p><p><code>arguments</code> 对象是一个类数组对象（但不是 <code>Array</code> 的实例），因此可以使用中括号语法访问其中的 元素（第一个参数是 <code>arguments[0]</code>，第二个参数是 <code>arguments[1]</code>）。而要确定传进来多少个参数， 可以访问 <code>arguments.length</code> 属性。</p><p>在下面的例子中，<code>sayHi()</code>函数的第一个参数叫 <code>name</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 <code>arguments[0]</code>取得相同的参数值。因此，把函数重写成不声明参数也可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + <span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在重写后的代码中，没有命名参数。<code>name</code> 和 <code>message</code> 参数都不见了，但函数照样可以调用。这就 表明，<code>ECMAScript</code> 函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在 <code>ECMAScript </code>中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名 参数的机制。</p><p>也可以通过 <code>arguments</code> 对象的 <code>length</code> 属性检查传入的参数个数。下面的例子展示了在每调用一 个函数时，都会打印出传入的参数个数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">howManyArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">howManyArgs</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="number">12</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个例子分别打印出 2、0 和 1（按顺序）。既然如此，那么开发者可以想传多少参数就传多少参数。 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doAdd</span>(<span class="number">10</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="title function_">doAdd</span>(<span class="number">30</span>, <span class="number">20</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>这个函数 <code>doAdd()</code>在只传一个参数时会加 10，在传两个参数时会将它们相加，然后返回。因此 <code>doAdd(10)</code>返回 20，而 <code>doAdd(30,20)</code>返回 50。<strong>虽然不像真正的函数重载那么明确，但这已经足以弥 补 <code>ECMAScript</code> 在这方面的缺失了。</strong></p><p>还有一个必须理解的重要方面，那就是 <code>arguments</code> 对象可以跟命名参数一起使用，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + <span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 <code>doAdd()</code>函数中，同时使用了两个命名参数和 <code>arguments</code> 对象。命名参数 <code>num1</code> 保存着与 <code>arugments[0]</code>一样的值，因此使用谁都无所谓。（同样，<code>num2</code> 也保存着跟 <code>arguments[1]</code>一样的值。）</p><p><code>arguments </code>对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">     <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个 <code>doAdd()</code>函数把第二个参数的值重写为 10。因为 <code>arguments</code> 对象的值会自动同步到对应的命 名参数，所以修改 <code>arguments[1]</code>也会修改 <code>num2</code> 的值，因此两者的值都是 10。<strong>但这并不意味着它们都 访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。</strong>另外还要记住一点：<strong>如果只传了一个参数，然后把 <code>arguments[1]</code>设置为某个值，那么这个值并不会反映到第二个命名参数。这是 因为 <code>arguments</code> 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">     <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(num1);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(num2);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">doAdd</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 <code>undefined</code>。这就类似于 定义了变量而没有初始化。比如，如果只给 <code>doAdd()</code>传了一个参数，那么 <code>num2</code> 的值就是 <code>undefined</code>。</p><p>严格模式下，<code>arguments</code> 会有一些变化。首先，像前面那样给 <code>arguments[1]</code>赋值不会再影响 <code>num2</code> 的值。就算把 <code>arguments[1]</code>设置为 10，<code>num2</code> 的值仍然还是传入的值。其次，在函数中尝试重写 <code>arguments</code> 对象会导致语法错误。（代码也不会执行。）</p><p><strong>箭头函数中的参数</strong></p><p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 <code>arguments</code> 关键字访问，而只能通过定义的命名参数访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">5</span>); <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure><p>虽然箭头函数中没有 <code>arguments</code> 对象，但可以在包装函数中把它提供给箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong><code>ECMAScript</code> 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</strong></p><h1 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h1><p><code>ECMAScript</code> 函数不能像传统编程那样重载。在其他语言比如 <code>Java</code> 中，一个函数可以有两个定义， 只要签名（接收参数的类型和数量）不同就行。如前所述，**<code>ECMAScript</code> 函数没有签名，因为参数是由 包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载**。</p><p>如果在 <code>ECMAScript</code> 中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addSomeNumber</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addSomeNumber</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addSomeNumber</span>(<span class="number">100</span>); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure><p>前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。</p><p><strong>把函数名当成指针也有助于理解为什么 <code>ECMAScript</code> 没有函数重载。</strong>在前面的例子中，定义两个同名的函数显然会导致后定义的重写先定义的。而那个例子几乎跟下面这个是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addSomeNumber = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">addSomeNumber = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addSomeNumber</span>(<span class="number">100</span>); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure><p>看这段代码应该更容易理解发生了什么。在创建第二个函数时，变量 <code>addSomeNumber</code> 被重写成保存第二个函数对象了。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h1><p>在 <code>ECMAScript5.1</code> 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 <code>undefined</code>， 如果是则意味着没有传这个参数，那就给它赋一个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name</span>) &#123;</span><br><span class="line">     name = (<span class="keyword">typeof</span> name !== <span class="string">&#x27;undefined&#x27;</span>) ? name : <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br></pre></td></tr></table></figure><p><code>ECMAScript 6</code> 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价 的 <code>ES6</code> 写法，只要在函数定义中的参数后面用&#x3D;就可以为参数赋一个默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br></pre></td></tr></table></figure><p>给参数传 <code>undefined</code> 相当于没有传值，不过这样可以利用多个独立的默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="literal">undefined</span>, <span class="string">&#x27;VI&#x27;</span>)); <span class="comment">// &#x27;King Henry VI&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>在使用默认参数时，<code>arguments</code> 对象的值不反映参数的默认值，只反映传给函数的参数。当然， 跟 <code>ES5</code> 严格模式一样，修改命名参数也不会影响 <code>arguments</code> 对象，它始终以调用函数时传入的值为准：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) &#123;</span><br><span class="line">     name = <span class="string">&#x27;Louis&#x27;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King undefined&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis&#x27; </span></span><br></pre></td></tr></table></figure><p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romanNumerals = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> ordinality = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNumerals</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 每次调用后递增</span></span><br><span class="line">     <span class="keyword">return</span> romanNumerals[ordinality++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = getNumerals()</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry I&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>, <span class="string">&#x27;XVI&#x27;</span>)); <span class="comment">// &#x27;King Louis XVI&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry II&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry III&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</strong></p><p>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">makeKing</span> = (<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) =&gt; <span class="string">`King <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// King Henry</span></span><br></pre></td></tr></table></figure><p><strong>默认参数作用域与暂时性死区</strong></p><p>因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。</p><p>给多个参数定义默认值实际上跟使用 <code>let</code> 关键字顺序声明变量一样。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// King Henry VIII</span></span><br></pre></td></tr></table></figure><p>这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象一下这个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> name = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">     <span class="keyword">let</span> numerals = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = name</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// King Henry Henry</span></span><br></pre></td></tr></table></figure><p><strong>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第一个参数会报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = numerals, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第二个参数会报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = defaultNumeral</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> defaultNumeral = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="参数扩展与收集"><a href="#参数扩展与收集" class="headerlink" title="参数扩展与收集"></a>参数扩展与收集</h1><p><strong><code>ECMAScript 6</code> 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。 扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</strong></p><h2 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h2><p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。 </p><p>假设有如下函数定义，它会将所有传入的参数累加起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line"> sum += <span class="variable language_">arguments</span>[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个函数希望将所有加数逐个传进来，然后通过迭代 <code>arguments</code> 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 <code>apply()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getSum.<span class="title function_">apply</span>(<span class="literal">null</span>, values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>但在 <code>ECMAScript 6</code> 中，可以通过扩展操作符极为简洁地实现这种操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p><p>比如，<strong>使用扩展操作符可以将前面例子中的数组像这样直接传给函数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值， 包括使用扩展操作符传其他参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(-<span class="number">1</span>, ...values)); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...values, <span class="number">5</span>)); <span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(-<span class="number">1</span>, ...values, <span class="number">5</span>)); <span class="comment">// 14</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p>对函数中的 <code>arguments</code> 对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countArguments</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countArguments</span>(-<span class="number">1</span>, ...values); <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">countArguments</span>(...values, <span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">countArguments</span>(-<span class="number">1</span>, ...values, <span class="number">5</span>); <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">countArguments</span>(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]); <span class="comment">// 7 </span></span><br></pre></td></tr></table></figure><p><code>arguments</code> 对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getSum</span> = (<span class="params">a, b, c = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProduct</span>(...[<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProduct</span>(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProduct</span>(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...[<span class="number">0</span>,<span class="number">1</span>])); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h2><p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似 <code>arguments</code> 对象的构造机制，只不过收集参数的结果会得到一个 <code>Array</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">     <span class="comment">// 顺序累加 values 中的所有值</span></span><br><span class="line">     <span class="comment">// 初始值的总和为 0</span></span><br><span class="line">     <span class="keyword">return</span> values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6 </span></span><br></pre></td></tr></table></figure><p>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。<strong>因为收集参数的结果可变，所以只能把它作为最后一个参数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProduct</span>(<span class="params">...values, lastValue</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ignoreFirst</span>(<span class="params">firstValue, ...values</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ignoreFirst</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="title function_">ignoreFirst</span>(<span class="number">1</span>); <span class="comment">// []</span></span><br><span class="line"><span class="title function_">ignoreFirst</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line"><span class="title function_">ignoreFirst</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><p>箭头函数虽然不支持 <code>arguments</code> 对象，但支持收集参数的定义方式，因此也可以实现与使用 <code>arguments</code> 一样的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">getSum</span> = (<span class="params">...values</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>另外，使用收集参数并不影响 <code>arguments</code> 对象，它仍然反映调用时传给函数的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(values); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h1 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h1><p>到目前为止一直没有把函数声明和函数表达式区分得很清楚。事实上，**<code>JavaScript</code> 引擎在加载数据时对函数声明和函数表达式是区别对待的。** <strong><code>JavaScript</code> 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作<strong>函数声明提升</strong>（<code>function declaration hoisting</code>）。<strong>在执行代码时，<code>JavaScript</code> 引擎会先执行一遍扫描， 把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把 函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。 这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。这并不是因为使用 let 而导致的，使用 <code>var</code> 关键字也会碰到同样的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。</p><h1 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h1><p><strong>因为函数名在 <code>ECMAScript</code> 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">someFunction</span>(someArgument);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传给这个函数的值。任何函数都可以像下面这样作为参数传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add10</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">callSomeFunction</span>(add10, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">callSomeFunction</span>(getGreeting, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// &quot;Hello, Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p><code>callSomeFunction()</code>函数是通用的，第一个参数传入的是什么函数都可以，而且它始终返回调用 作为第一个参数传入的函数的结果。<strong>要注意的是，如果是访问函数而不是调用函数，那就必须不带括号</strong>， 所以传给 <code>callSomeFunction()</code>的必须是 <code>add10</code> 和 <code>getGreeting</code>，而不能是它们的执行结果。</p><p><strong>从一个函数中返回另一个函数也是可以的，而且非常有用</strong>。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个 <code>sort()</code>方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">         <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个函数的语法乍一看比较复杂，但实际上就是在一个函数中返回另一个函数，注意那个 <code>return</code> 操作符。内部函数可以访问 <code>propertyName</code> 参数，并通过中括号语法取得要比较的对象的相应属性值。 取得属性值以后，再按照 <code>sort()</code>方法的需要返回比较值就行了。这个函数可以像下面这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">     &#123;<span class="attr">name</span>: <span class="string">&quot;Zachary&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">     &#123;<span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;</span><br><span class="line">];</span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Nicholas</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Zachary</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，数组 data 中包含两个结构相同的对象。每个对象都有一个 <code>name</code> 属性和一个 <code>age</code> 属性。默认情况下，<code>sort()</code>方法要对这两个对象执行 <code>toString()</code>，然后再决定它们的顺序，但这样 得不到有意义的结果。而通过调用 <code>createComparisonFunction(&quot;name&quot;)</code>来创建一个比较函数，就 可以根据每个对象 <code>name</code> 属性的值来排序，结果 <code>name</code> 属性值为”Nicholas”、<code>age</code> 属性值为 29 的对象 会排在前面。而调用 <code>createComparisonFunction(&quot;age&quot;)</code>则会创建一个根据每个对象 <code>age</code> 属性的值 来排序的比较函数，结果 <code>name</code> 属性值为”Zachary”、<code>age</code> 属性值为 28 的对象会排在前面。</p><h1 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h1><p>在 <code>ECMAScript 5</code> 中，函数内部存在两个特殊的对象：<code>arguments</code> 和 <code>this</code>。<code>ECMAScript 6</code> 又新增 了 <code>new.target</code> 属性。</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><code>arguments</code> 对象前面讨论过多次了，它是一个类数组对象，包含调用函数时传入的所有参数。这 个对象只有以 <code>function</code> 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 <code>arguments</code> 对象其实还有一个 <code>callee</code> 属性，是一个指向 <code>arguments</code> 对象所在函数的指针。来看下面这个经典的阶乘函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 <code>factorial</code>，从而导致 了紧密耦合。使用 <code>arguments.callee</code> 就可以让函数逻辑与函数名解耦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个重写之后的 <code>factorial()</code>函数已经用 <code>arguments.callee</code> 代替了之前硬编码的 <code>factorial</code>。 这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">trueFactorial</span>(<span class="number">5</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">factorial</span>(<span class="number">5</span>)); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p>这里，<code>trueFactorial</code> 变量被赋值为 <code>factorial</code>，实际上把同一个函数的指针又保存到了另一个 位置。然后，<code>factorial</code> 函数又被重写为一个返回 0 的函数。如果像 <code>factorial()</code>最初的版本那样不 使用 <code>arguments.callee</code>，那么像上面这样调用 <code>trueFactorial()</code>就会返回 0。不过，通过将函数与 名称解耦，<code>trueFactorial()</code>就可以正确计算阶乘，而 <code>factorial()</code>则只能返回 0。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>另一个特殊的对象是 <code>this</code>，它在标准函数和箭头函数中有不同的行为。 </p><p><strong>在标准函数中，<code>this</code> 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 <code>this</code> 值（在 网页的全局上下文中调用函数时，<code>this</code> 指向 <code>windows</code>）。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">// &#x27;blue&#x27; </span></span><br></pre></td></tr></table></figure><p>定义在全局上下文中的函数 <code>sayColor()</code>引用了 <code>this</code> 对象。这个 <code>this</code> 到底引用哪个对象必须到 函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用 <code>sayColor()</code>，这结果会输出”red”，因为 <code>this</code> 指向 <code>window</code>，而 <code>this.color</code> 相当于 <code>window.color</code>。 而在把 <code>sayColor()</code>赋值给 o 之后再调用 <code>o.sayColor()</code>，<code>this</code> 会指向 o，即 <code>this.color</code> 相当于 <code>o.color</code>，所以会显示”blue”。</p><p>在箭头函数中，<code>this</code>引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对<code>sayColor()</code> 的两次调用中，<code>this</code> 引用的都是 <code>window</code> 对象，因为这个箭头函数是在 <code>window</code> 上下文中定义的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>在事件回调或定时回调中调用某个函数时，<code>this</code> 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 <code>this</code> 会保留定义该函数时的上下文：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">royaltyName</span> = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">     <span class="comment">// this 引用 King 的实例</span></span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">royaltyName</span>), <span class="number">1000</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Queen</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">royaltyName</span> = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line">     <span class="comment">// this 引用 window 对象</span></span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">royaltyName</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Queen</span>(); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p>注意：函数名只是保存指针的变量。因此全局定义的 ·<code>ayColor()</code>函数和 <code>o.sayColor()</code> 是同一个函数，只不过执行的上下文不同。</p><h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p><code>ECMAScript 5</code> 也会给函数对象上添加一个属性：<code>caller</code>。虽然<code>ECMAScript 3</code> 中并没有定义，但所 有浏览器除了早期版本的 <code>Opera</code> 都支持这个属性。<strong>这个属性引用的是调用当前函数的函数，或者如果是 在全局作用域中调用的则为 <code>null</code>。</strong>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(inner.<span class="property">caller</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure><p>以上代码会显示 <code>outer()</code>函数的源代码。这是因为 <code>ourter()</code>调用了 <code>inner()</code>，<code>inner.caller</code> 指向 <code>outer()</code>。如果要降低耦合度，则可以通过 <code>arguments.callee.caller</code> 来引用同样的值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">caller</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure><p>在严格模式下访问 <code>arguments.callee</code>会报错。<code>ECMAScript 5</code> 也定义了 <code>arguments.caller</code>，但 在严格模式下访问它会报错，在非严格模式下则始终是 <code>undefined</code>。这是为了分清 <code>arguments.caller</code> 和函数的 <code>caller</code> 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同 一上下文中运行的其他代码。</p><h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><p><code>ECMAScript</code> 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。 <code>ECMAScript 6</code> 新增了检测函数是否使用 <code>new</code>关键字调用的 <code>new.target</code> 属性。如果函数是正常调用的，则 <code>new.target</code> 的值是 <code>undefined</code>；如果是使用 <code>new</code>关键字调用的，则 <code>new.target</code> 将引用被调用的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// King instantiated using &quot;new&quot;</span></span><br><span class="line"><span class="title class_">King</span>(); <span class="comment">// Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure><h1 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h1><p>前面提到过，<code>ECMAScript</code> 中的函数是对象，因此有属性和方法。每个函数都有两个属性：<code>length</code> 和 <code>prototype</code>。其中，<code>length</code> 属性保存函数定义的命名参数的个数，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayName.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi.<span class="property">length</span>); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p>以上代码定义了 3 个函数，每个函数的命名参数个数都不一样。<code>sayName()</code>函数有 1 个命名参数， 所以其 <code>length</code> 属性为 1。类似地，<code>sum()</code>函数有两个命名参数，所以其 <code>length</code> 属性是 2。而 <code>sayHi()</code> 没有命名参数，其 <code>length</code> 属性为 0。</p><p><code>prototype</code> 属性也许是 <code>ECMAScript</code> 核心中最有趣的部分。<code>prototype</code> 是保存引用类型所有实例方法的地方，这意味着 <code>toString()</code>、<code>valueOf()</code>等方法实际上都保存在 <code>prototype</code> 上，进而由所有实 例共享。这个属性在自定义类型时特别重要。（相关内容已经在对象、类与面向对象一章详细介绍过了。）在 <code>ECMAScript 5</code> 中，<code>prototype</code> 属性是不可枚举的，因此使用 <code>for-in</code> 循环不会返回这个属性。</p><p>函数还有两个方法：<code>apply()</code>和 <code>call()</code>。这两个方法都会以指定的 <code>this</code> 值来调用函数，即会设置调用函数时函数体内 <code>this</code> 对象的值。<code>apply()</code>方法接收两个参数：函数内 <code>this</code> 的值和一个参数数组。第二个参数可以是 <code>Array</code> 的实例，但也可以是 <code>arguments</code> 对象。来看下面的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSum1</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> sum.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSum2</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> sum.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">callSum1</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">callSum2</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>callSum1()</code>会调用 <code>sum()</code>函数，将 <code>this</code> 作为函数体内的 <code>this</code> 值（这里等于 <code>window</code>，因为是在全局作用域中调用的）传入，同时还传入了 <code>arguments</code> 对象。<code>callSum2()</code>也会调 用 <code>sum()</code>函数，但会传入参数的数组。这两个函数都会执行并返回正确的结果。</p><p>在严格模式下，调用函数时如果没有指定上下文对象，则 <code>this</code> 值不会指向 <code>window</code>。 除非使用 <code>apply()</code>或 <code>call()</code>把函数指定给一个对象，否则 <code>this</code> 的值会变成<code>undefined</code>。</p><p><code>call()</code>方法与 <code>apply()</code>的作用一样，只是传参的形式不同。第一个参数跟 <code>apply()</code>一样，也是 <code>this</code> 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 <code>call()</code>向函数传参时，必须将参数一个一个地列出来，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> sum.<span class="title function_">call</span>(<span class="variable language_">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">callSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>这里的 <code>callSum()</code>函数必须逐个地把参数传给 <code>call()</code>方法。结果跟 <code>apply()</code>的例子一样。到底是使用 <code>apply()</code>还是 <code>call()</code>，完全取决于怎么给要调用的函数传参更方便。如果想直接传 <code>arguments</code> 对象或者一个数组，那就用 <code>apply()</code>；否则，就用 <code>call()</code>。当然，如果不用给被调用的函数传参，则 使用哪个方法都一样。</p><p><code>apply()</code>和 <code>call()</code>真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 <code>this</code> 值的能力。考虑下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">sayColor.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.<span class="title function_">call</span>(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>这个例子是在之前那个关于 <code>this</code> 对象的例子基础上修改而成的。同样，<code>sayColor()</code>是一个全局 函数，如果在全局作用域中调用它，那么会显示”red”。这是因为 <code>this.color</code> 会求值为 <code>window.color</code>。 如果在全局作用域中显式调用 <code>sayColor.call(this)</code>或者 <code>sayColor.call(window)</code>，则同样都会显示”red”。而在使用 <code>sayColor.call(o)</code>把函数的执行上下文即 <code>this</code> 切换为对象 o 之后，结果就变成 了显示”blue”了。</p><p>使用 <code>call()</code>或 <code>apply()</code>的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。在前面例子最初的版本中，为切换上下文需要先把 <code>sayColor()</code>直接赋值为 o 的属性，然后再 调用。而在这个修改后的版本中，就不需要这一步操作了。</p><p><code>ECMAScript 5</code> 出于同样的目的定义了一个新方法：<code>bind()</code>。<code>bind()</code>方法会创建一个新的函数实例， 其 <code>this</code> 值会被绑定到传给 <code>bind()</code>的对象。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.<span class="title function_">bind</span>(o);</span><br><span class="line"><span class="title function_">objectSayColor</span>(); <span class="comment">// blue </span></span><br></pre></td></tr></table></figure><p>这里，在 <code>sayColor()</code>上调用 <code>bind()</code>并传入对象 o 创建了一个新函数 <code>objectSayColor()</code>。 <code>objectSayColor()</code>中的 <code>this</code> 值被设置为 o，因此直接调用这个函数，即使是在全局作用域中调用， 也会返回字符串”blue”。</p><p>对函数而言，继承的方法 <code>toLocaleString()</code>和 <code>toString()</code>始终返回函数的代码。返回代码的 具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚 至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在 调试中使用它们。继承的方法 <code>valueOf()</code>返回函数本身。</p><h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>函数表达式虽然更强大，但也更容易让人迷惑。我们知道，定义函数有两种方式：函数声明和函数表达式。函数声明是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, arg2</span>) &#123;</span><br><span class="line"> <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明 可以出现在调用它的代码之后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子不会抛出错误，因为 <code>JavaScript</code> 引擎会先读取函数声明，然后再执行代码。 第二种创建函数的方式就是函数表达式。函数表达式有几种不同的形式，最常见的是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) &#123;</span><br><span class="line"> <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 <code>functionName</code>。这样创建的函数叫作匿名函数（<code>anonymous funtion</code>），因为 <code>function</code> 关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 <code>name</code> 属性是空字符串。</p><p>函数表达式跟 JavaScript 中的其他表达式一样，需要先赋值再使用。下面的例子会导致错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// Error! function doesn&#x27;t exist yet</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎 意料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yo!&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码看起来很正常，就是如果 <code>condition</code> 为 true，则使用第一个 <code>sayHi()</code>定义；否则，就 使用第二个。事实上，这种写法在 <code>ECAMScript</code> 中不是有效的语法。<code>JavaScript</code> 引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略 <code>condition</code> 直接返回第二个声明。Firefox 会在 <code>condition</code> 为 true 时返回第一个声明。这种写法很危险，不要使用。不过， 如果把上面的函数声明换成函数表达式就没问题了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> sayHi;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">     sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个例子可以如预期一样，根据 <code>condition</code> 的值为变量 <code>sayHi</code> 赋予相应的函数。 创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">         <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里的 <code>createComparisonFunction()</code>函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在 <code>createComparisonFunction()</code>内部，那个函数是匿名的。任何时候， 只要函数被当作值来使用，它就是一个函数表达式。本章后面会介绍，这并不是使用函数表达式的唯一 方式。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归函数通常的形式是一个函数通过名称调用自己，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherFactorial</span>(<span class="number">4</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>这里把 <code>factorial()</code>函数保存在了另一个变量 <code>anotherFactorial</code> 中，然后将 <code>factorial</code> 设置 为 <code>null</code>，于是只保留了一个对原始函数的引用。而在调用 <code>anotherFactorial()</code>时，要递归调用 <code>factorial()</code>，但因为它已经不是函数了，所以会出错。在写递归函数时使用 <code>arguments.callee</code> 可以避免这个问题。</p><p><code>arguments.callee</code> 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这里else分支里的这一行一样，把函数名称替换成 <code>arguments.callee</code>，可以确保无论通过什么变量 调用这个函数都不会出问题。因此在编写递归函数时，<code>arguments.callee</code> 是引用当前函数的首选。</p><p>不过，在严格模式下运行的代码是不能访问 <code>arguments.callee</code> 的，因为访问会出错。此时，可 以使用命名函数表达式（<code>named function expression</code>）达到目的。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="title function_">f</span>(num - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里创建了一个命名函数表达式 f()，然后将它赋值给了变量 <code>factorial</code>。即使把函数赋值给另 一个变量，函数表达式的名称 f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。</p><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p><code>ECMAScript 6</code> 规范新增了一项内存管理优化机制，让 <code>JavaScript</code> 引擎在满足条件时可以重用栈帧。 具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ES6</code> 优化之前，执行这个例子会在内存中发生如下操作。</p><ol><li>执行到 <code>outerFunction</code> 函数体，第一个栈帧被推到栈上。</li><li>执行 <code>outerFunction</code> 函数体，到 <code>return</code> 语句。计算返回值必须先计算 <code>innerFunction</code>。</li><li>执行到 <code>innerFunction</code> 函数体，第二个栈帧被推到栈上。</li><li>执行 <code>innerFunction</code> 函数体，计算其返回值。</li><li>将返回值传回 <code>outerFunction</code>，然后 <code>outerFunction</code> 再返回值。</li><li>将栈帧弹出栈外。</li></ol><p>在 <code>ES6</code> 优化之后，执行这个例子会在内存中发生如下操作。</p><ol><li>执行到 <code>outerFunction</code> 函数体，第一个栈帧被推到栈上。</li><li>执行 <code>outerFunction</code> 函数体，到达 <code>return</code> 语句。为求值返回语句，必须先求值 <code>innerFunction</code>。</li><li>引擎发现把第一个栈帧弹出栈外也没问题，因为 <code>innerFunction</code> 的返回值也是 <code>outerFunction</code> 的返回值。</li><li>弹出 <code>outerFunction</code> 的栈帧。</li><li>执行到 <code>innerFunction</code> 函数体，栈帧被推到栈上。</li><li>执行 <code>innerFunction</code> 函数体，计算其返回值。</li><li>将 <code>innerFunction</code> 的栈帧弹出栈外。</li></ol><p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多 少次嵌套函数，都只有一个栈帧。这就是 <code>ES6</code> 尾调用优化的关键：<strong>如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</strong></p><h2 id="尾调用优化的条件"><a href="#尾调用优化的条件" class="headerlink" title="尾调用优化的条件"></a>尾调用优化的条件</h2><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：</p><ol><li>代码在严格模式下执行</li><li>外部函数的返回值是对尾调用函数的调用；</li><li>尾调用函数返回后不需要执行额外的逻辑；</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包。</li></ol><p>下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">innerFunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> innerFunctionResult = <span class="title function_">innerFunction</span>();</span><br><span class="line"> <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>().<span class="title function_">toString</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">innerFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是几个符合尾调用优化条件的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">innerFunction</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">condition</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> condition ? <span class="title function_">innerFunctionA</span>() : <span class="title function_">innerFunctionB</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>差异化尾调用和递归尾调用是容易让人混淆的地方。<strong>无论是递归尾调用还是非递归尾调用，都可以应用优化。</strong>引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，<strong>这个优化在递归场景下的效 果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</strong></p><h2 id="尾调用优化的代码"><a href="#尾调用优化的代码" class="headerlink" title="尾调用优化的代码"></a>尾调用优化的代码</h2><p>可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">6</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，<code>fib(n)</code>的栈 帧数的内存复杂度是 <code>O(2^n)</code>。因此，即使这么一个简单的调用也可以给浏览器带来麻烦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fib</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实 现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">fibImpl</span>(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibImpl</span>(<span class="params">a, b, n</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">fibImpl</span>(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样重构之后，就可以满足尾调用优化的所有条件，再调用 <code>fib(1000)</code>就不会对浏览器造成威胁了。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>匿名函数经常被人误认为是闭包（<code>closure</code>）。<strong>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</strong>比如，下面是之前展示的 <code>createComparisonFunction()</code>函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">     <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line"><span class="keyword">let</span> value2 = object2[propertyName];</span><br></pre></td></tr></table></figure><p>两行代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 <code>propertyName</code>。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含 <code>createComparisonFunction()</code>函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么。</p><p><strong>理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 <code>arguments</code> 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。</strong></p><p>在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compare</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这里定义的 <code>compare()</code>函数是在全局上下文中调用的。第一次调用 <code>compare()</code>时，会为它创建一 个包含 <code>arguments</code>、<code>value1</code> 和 <code>value2</code> 的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是 <code>compare()</code>作用域链上的第二个对象，其中包含 <code>this</code>、<code>result</code> 和 <code>compare</code>。</p><p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义 <code>compare()</code>函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的<code>[[Scope]]</code>中。在 调用这个函数时，会创建相应的执行上下文，然后通过复制函数的<code>[[Scope]]</code>来创建其作用域链。接着 会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 <code>compare() </code>函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p><p><strong>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。</strong></p><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 <code>createComparisonFunction()</code>函数中，匿名函数的作用域链中实际上包含 <code>createComparisonFunction()</code>的活动对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = <span class="title function_">createComparisonFunction</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compare</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>在 <code>createComparisonFunction()</code>返回匿名函数后，它的作用域链被初始化为包含 <code>createComparisonFunction()</code>的活动对象和全局变量对象。这样，匿名函数就可以访问到 <code>createComparisonFunction()</code>可以访问的所有变量。另一个有意思的副作用就是，<code>createComparisonFunction()</code>的 活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 <code>createComparisonFunction()</code>执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> compareNames = <span class="title function_">createComparisonFunction</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compareNames</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除对函数的引用，这样就可以释放内存了</span></span><br><span class="line">compareNames = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><p>这里，创建的比较函数被保存在变量 <code>compareNames</code> 中。把 <code>compareNames</code> 设置为等于 <code>null</code> 会 解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p><p>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭 包可能导致内存过度占用，因此建议仅在十分必要时使用。</p><h2 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h2><p>在闭包中使用 <code>this</code> 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 <code>this</code> 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 <code>this</code> 在非严格模式下等于 <code>window</code>，在严 格模式下等于 <code>undefined</code>。如果作为某个对象的方法调用，则 <code>this</code> 等于这个对象。匿名函数在这种情 况下不会绑定到某个对象，这就意味着 <code>this</code> 会指向 <code>window</code>，除非在严格模式下 <code>this</code> 是 <code>undefined</code>。 不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">     <span class="attr">identity</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">     <span class="title function_">getIdentityFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">identity</span>;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getIdentityFunc</span>()()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure><p>这里先创建了一个全局变量 <code>identity</code>，之后又创建一个包含 <code>identity</code> 属性的对象。这个对象还 包含一个 <code>getIdentityFunc()</code>方法，返回一个匿名函数。这个匿名函数返回 <code>this.identity</code>。因为 <code>getIdentityFunc()</code>返回函数，所以 <code>object.getIdentityFunc()()</code>会立即调用这个返回的函数， 从而得到一个字符串。可是，此时返回的字符串是”The Winodw”，即全局变量 <code>identity</code> 的值。为什么匿名函数没有使用其包含作用域（<code>getIdentityFunc()</code>）的 <code>this</code> 对象呢？</p><p>前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：<code>this</code> 和 <code>arguments</code>。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把 <code>this</code> 保存到闭包可以访问的另一个变量中， 则是行得通的。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line"> <span class="attr">identity</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line"> <span class="title function_">getIdentityFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> that.<span class="property">identity</span>;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getIdentityFunc</span>()()); <span class="comment">// &#x27;My Object&#x27;</span></span><br></pre></td></tr></table></figure><p>这里加粗的代码展示了与前面那个例子的区别。在定义匿名函数之前，先把外部函数的 <code>this</code> 保存 到变量 <code>that</code> 中。然后在定义闭包时，就可以让它访问 <code>that</code>，因为这是包含函数中名称没有任何冲突的 一个变量。即使在外部函数返回之后，<code>that</code> 仍然指向 <code>object</code>，所以调用 <code>object.getIdentityFunc()()</code> 就会返回”My Object”。</p><p>注意：<code>this</code> 和 <code>arguments</code> 都是不能直接在内部函数中访问的。如果想访问包含作用域中 的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p><p>在一些特殊情况下，<code>this</code> 值可能并不是我们所期待的值。比如下面这个修改后的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">     <span class="attr">identity</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">     getIdentity () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">identity</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>getIdentity()</code>方法就是返回 <code>this.identity</code> 的值。以下是几种调用 <code>object.getIdentity()</code> 的方式及返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.<span class="title function_">getIdentity</span>(); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.<span class="property">getIdentity</span>)(); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.<span class="property">getIdentity</span> = object.<span class="property">getIdentity</span>)(); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure><p>第一行调用 <code>object.getIdentity()</code>是正常调用，会返回”My Object”，因为 <code>this.identity</code> 就是 <code>object.identity</code>。第二行在调用时把 <code>object.getIdentity</code> 放在了括号里。虽然加了括号之 后看起来是对一个函数的引用，但 <code>this</code> 值并没有变。这是因为按照规范，<code>object.getIdentity</code> 和 <code>(object.getIdentity)</code>是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，<code>this</code> 值不再与任何对象绑定，所以返回的是”The Window”。</p><p>一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道， 即使语法稍有不同，也可能影响 <code>this</code> 的值。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line"> element.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个闭包，即 <code>element</code> 元素的事件处理程序（事件处理程序将在后续讨论）。 而这个处理程序又创建了一个循环引用。匿名函数引用着 <code>assignHandler()</code>的活动对象，阻止了对 <code>element</code> 的引用计数归零。只要这个匿名函数存在，<code>element</code> 的引用计数就至少等于 1。也就是说， 内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line">     <span class="keyword">let</span> id = element.<span class="property">id</span>;</span><br><span class="line">     element.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">     element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个修改后的版本中，闭包改为引用一个保存着 <code>element.id</code> 的变量 id，从而消除了循环引用。 不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含 <code>element</code>。即使闭包没有直接引用 <code>element</code>，包含函数的活动对象上还是保存着对它的引用。因此，必 须再把 <code>element</code> 设置为 <code>null</code>。这样就解除了对这个 <code>COM</code> 对象的引用，其引用计数也会减少，从而确 保其内存可以在适当的时候被回收。</p><h1 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h1><p>立即调用的匿名函数又被称作立即调用的函数表达式（<code>IIFE</code>，<code>Immediately Invoked Function Expression</code>）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组 括号后面的第二组括号会立即调用前面的函数表达式。下面是一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用 <code>IIFE</code> 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。<code>ECMAScript</code> 5 尚未支持块级作用域，使用 <code>IIFE</code> 模拟块级作用域是相当普遍的。比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>前面的代码在执行到 <code>IIFE</code> 外部的 <code>console.log()</code>时会出错，因为它访问的变量是在 <code>IIFE</code> 内部定义 的，在外部访问不到。在 <code>ECMAScript 5.1</code> 及以前，为了防止变量定义外泄，<code>IIFE</code> 是个非常有效的方式。 这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕， 其作用域链就可以被销毁。</p><p>在 <code>ECMAScript 6</code> 以后，<code>IIFE</code> 就没有那么必要了，因为块级作用域中的变量无须 <code>IIFE</code> 就可以实现同样的隔离。下面展示了两种不同的块级作用域形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">let</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="comment">// 循环的块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>说明 <code>IIFE</code> 用途的一个实际的例子，就是可以用它锁定参数值。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">     divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里使用 <code>var</code> 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 <code>for</code> 循环的块级作用域内。 因此，渲染到页面上之后，点击每个<code>&lt;div&gt;</code>都会弹出<strong>元素总数</strong>。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。</p><p>以前，为了实现点击第几个就显示相应的索引值，需要借助 <code>IIFE</code> 来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;</span><br><span class="line"> divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, (<span class="keyword">function</span>(<span class="params">frozenCounter</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(frozenCounter);</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;)(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用 <code>ECMAScript</code> 块级作用域变量，就不用这么大动干戈了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">     divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样就可以让每次点击都显示正确的索引了。这里，事件处理程序执行时就会引用 <code>for</code> 循环块级作用域中的索引值。这是因为在 <code>ECMAScript</code> 6 中，如果对 <code>for</code> 循环使用块级作用域变量关键字(在这里就是 <code>let</code>)，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。</p><p>但要注意，如果把变量声明拿到 <code>for</code> 循环外部，那就不行了。下面这种写法会碰到跟在循环中使用 <code>var i = 0</code> 同样的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">     divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>严格来讲，<code>JavaScript</code> 没有私有成员的概念，所有对象属性都是公有的。不过，倒是有私有变量的概 念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的 变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这个函数中，函数 <code>add()</code>有 3 个私有变量：<code>num1</code>、<code>num2</code> 和 <code>sum</code>。这几个变量只能在函数内部使 用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部 的这 3 个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。</p><p>特权方法（<code>privileged method</code>）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有 两种方式创建特权方法。第一种是在构造函数中实现，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">     <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 特权方法</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">     &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访 问构造函数中定义的所有变量和函数的能力。在这个例子中，变量 <code>privateVariable</code> 和函数 <code>privateFunction()</code>只能通过 <code>publicMethod()</code>方法来访问。在创建 <code>MyObject</code> 的实例后，没有办法 直接访问 <code>privateVariable</code> 和 <code>privateFunction()</code>，唯一的办法是使用 <code>publicMethod()</code>。</p><p>如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person.<span class="title function_">setName</span>(<span class="string">&#x27;Greg&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Greg&#x27;</span></span><br></pre></td></tr></table></figure><p>这段代码中的构造函数定义了两个特权方法：<code>getName()</code>和 <code>setName()</code>。每个方法都可以构造函 数外部调用，并通过它们来读写私有的 <code>name</code> 变量。在 <code>Person</code> 构造函数外部，没有别的办法访问 <code>name</code>。 因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问 <code>name</code> 的闭包。私有变量 <code>name</code> 对每个 <code>Person</code> 实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。 不过这样也有个问题：必须通过构造函数来实现这种隔离。<strong>而构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。</strong></p><h2 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h2><p>特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 构造函数</span></span><br><span class="line"> <span class="title class_">MyObject</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 公有和特权方法</span></span><br><span class="line"> <span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> privateVariable++;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure><p>在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后又定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。注意，这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里并不是必需的。基于同样的原因（但操作相反），<strong>这里声明 <code>MyObject</code> 并没有使 用任何关键字。因为不使用关键字声明的变量会创建在全局作用域中，所以 <code>MyObject</code> 变成了全局变量， 可以在这个私有作用域外部被访问。注意在严格模式下给未声明的变量赋值会导致错误。</strong></p><p><strong>这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> name = value;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> name = value;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person1.<span class="title function_">setName</span>(<span class="string">&#x27;Matt&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Michael&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Michael&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Michael&#x27; </span></span><br></pre></td></tr></table></figure><p>这里的 <code>Person</code> 构造函数可以访问私有变量 <code>name</code>，跟 <code>getName()</code>和 <code>setName()</code>方法一样。使用这种模式，<code>name</code> 变成了静态变量（因为原型方法<code>getName()</code>和<code>setName()</code>中使用了<code>name</code>变量，所以把<code>name</code>变提升为了原型变量），可供所有实例使用。这意味着在任何实例上调用 <code>setName()</code>修改这个 变量都会影响其他实例。调用 <code>setName()</code>或创建新的 <code>Person</code> 实例都要把 <code>name</code> 变量设置为一个新值。 而所有实例都会返回相同的值。</p><p>像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。</p><h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的 <code>Douglas Crockford</code> 所说的 模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（<code>singleton</code>）就是只有一个实例的对象。按照惯例，<code>JavaScript</code>是通过对象字面量来创建单例对象的，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line">     <span class="attr">name</span>: value,</span><br><span class="line">     <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 方法的代码</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">publicProperty</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="title function_">publicMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;(); </span><br></pre></td></tr></table></figure><p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后， 创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因 为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函 数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line"> components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BaseComponent</span>());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 公共接口</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="title function_">getComponentCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="title function_">registerComponent</span>(<span class="params">component</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            components.<span class="title function_">push</span>(component);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;(); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Web 开发中，经常需要使用单例对象管理应用程序级的信息。上面这个简单的例子创建了一个 <code>application</code> 对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组 <code>components</code>， 然后将一个 <code>BaseComponent</code> 组件的新实例添加到数组中。（<code>BaseComponent</code> 组件的代码并不重要，在这里用它只是为了说明模块模式的用法。）对象字面量中定义的 <code>getComponentCount()</code>和 <code>registerComponent()</code>方法都是可以访问 <code>components</code> 私有数组的特权方法。前一个方法返回注册组件的数量， 后一个方法负责注册新组件。</p><p>在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以 通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 <code>Object</code> 的实例，因为最终单例都 由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以可以避免使用 <code>instanceof</code> 操作符确定参数是不是对象类型的需求。</p><h2 id="模块增强模式"><a href="#模块增强模式" class="headerlink" title="模块增强模式"></a>模块增强模式</h2><p>另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类 型的实例，但又必须给它添加额外属性或方法的场景。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 创建对象</span></span><br><span class="line"> <span class="keyword">let</span> object = <span class="keyword">new</span> <span class="title class_">CustomType</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line"> object.<span class="property">publicProperty</span> = <span class="literal">true</span>;</span><br><span class="line"> object.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     privateVariable++;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 返回对象</span></span><br><span class="line"> <span class="keyword">return</span> object;</span><br><span class="line">&#125;(); </span><br></pre></td></tr></table></figure><p>如果前一节的 <code>application</code> 对象必须是 <code>BaseComponent</code> 的实例，那么就可以使用下面的代码来 创建它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line"> components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BaseComponent</span>());</span><br><span class="line"> <span class="comment">// 创建局部变量保存实例</span></span><br><span class="line"> <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">BaseComponent</span>();</span><br><span class="line"> <span class="comment">// 公共接口</span></span><br><span class="line"> app.<span class="property">getComponentCount</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> app.<span class="property">registerComponent</span> = <span class="keyword">function</span>(<span class="params">component</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        components.<span class="title function_">push</span>(component);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 返回实例</span></span><br><span class="line"> <span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>在这个重写的 <code>application</code> 单例对象的例子中，首先定义了私有变量和私有函数，跟之前例子中 一样。主要区别在于这里创建了一个名为 <code>app</code> 的变量，其中保存了 <code>BaseComponent</code> 组件的实例。这是 最终要变成 <code>application</code> 的那个对象的局部版本。在给这个局部变量 <code>app</code> 添加了能够访问私有变量的 公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给 <code>application</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数是 &lt;code&gt;ECMAScript&lt;/code&gt;中最有意思的部分之一，这主要是因为&lt;strong&gt;函数实际上是对象&lt;/strong&gt;。&lt;strong&gt;每个函数都是 &lt;code&gt;Function&lt;/code&gt;类型的实例，而 &lt;code&gt;Function&lt;/code&gt; 也</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(7)——代理与反射</title>
    <link href="http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2023-03-07T19:54:39.000Z</published>
    <updated>2023-11-27T15:34:23.883Z</updated>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</p><p>在 <code>ES6</code> 之前，<code>ECMAScript</code> 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的 <code>ECMAScript </code>代码，因为代理的行为实际上是无可替代的。<strong>为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。</strong></p><h1 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h1><p>代理是目标对象的抽象。它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。</p><h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p><p>代理是使用 <code>Proxy</code> 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 <code>TypeError</code>。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p><p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// id 属性会访问同一个值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为两个对象访问的是同一个值</span></span><br><span class="line">target.<span class="property">id</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方</span></span><br><span class="line"><span class="comment">// 都会应用到目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy.prototype 是 undefined</span></span><br><span class="line"><span class="comment">// 因此不能使用 instanceof 操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（<code>trap</code>）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p><p>捕获器（<code>trap</code>）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。</p><p>例如，可以定义一个 <code>get()</code>捕获器，在 <code>ECMAScript</code> 操作以某种形式调用 <code>get()</code>时触发。下面的例子定义了一个 <code>get()</code>捕获器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>这样，当通过代理对象执行 <code>get()</code>操作时，就会触发定义的 <code>get()</code>捕获器。当然，<code>get()</code>不是<code>ECMAScript</code> 对象可以调用的方法。这个操作在 <code>JavaScript</code> 代码中可以通过多种形式触发并被 <code>get()</code>捕获器拦截到。<code>proxy[property]</code>、<code>proxy.property</code> 或 <code>Object.create(proxy)[property]</code>等操作都会触发基本的 <code>get()</code>操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 <code>get()</code>捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"><span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// handler override</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// handler override</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(target)[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// handler override</span></span><br></pre></td></tr></table></figure><h2 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，<code>get()</code>捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(trapTarget === target);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(property);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(receiver === proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>有了这些参数，就可以重建被捕获方法的原始行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 <code>get()</code>那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 <code>Reflect</code> 对象上（封装了原始行为）的同名方法来轻松重建。</p><p>处理程序对象中所有可以捕获的方法都有对应的反射（<code>Reflect</code>）<code>API</code> 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 <code>API</code> 也可以像下面这样定义出空代理对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>甚至还可以写得更简洁一些：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"><span class="attr">get</span>: <span class="title class_">Reflect</span>.<span class="property">get</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 <code>API</code> 的空代理，那么甚至不需要定义处理程序对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, <span class="title class_">Reflect</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>反射 <code>API</code> 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> decoration = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (property === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">            decoration = <span class="string">&#x27;!!!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar!!!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>); <span class="comment">// qux</span></span><br></pre></td></tr></table></figure><h2 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h2><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 <code>ECMAScript</code> 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（<code>trap invariant</code>）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p><p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 <code>TypeError</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。<strong>对于使用 <code>new Proxy()</code>创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</strong></p><p><code>Proxy</code> 也暴露了 <code>revocable()</code>方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（<code>revoke()</code>）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 <code>TypeError</code>。</p><p>撤销函数和代理对象是在实例化时同时生成的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="实用反射API"><a href="#实用反射API" class="headerlink" title="实用反射API"></a>实用反射API</h2><p>某些情况下应该优先使用反射 <code>API</code>，这是有一些理由的。</p><ol><li><p>反射<code>API</code>与对象<code>API</code></p><p>在使用反射 <code>API</code> 时，要记住：</p><ol><li>反射 <code>API</code> 并不限于捕获处理程序；</li><li>大多数反射 <code>API</code> 方法在 <code>Object</code> 类型上有对应的方法。</li></ol><p>通常，<code>Object</code> 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p></li><li><p>状态标记</p><p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 <code>API</code> 方法更有用。例如，可以使用反射<code>API</code> 对下面的代码进行重构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义新属性时如果发生问题，<code>Reflect.defineProperty()</code>会返回 <code>false</code>，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下反射方法都会提供状态标记：</p><ul><li>Reflect.defineProperty()</li><li>Reflect.preventExtensions()</li><li>Reflect.setPropertyOf()</li><li>Reflect.set()</li><li>Relect.deleteProperty()</li></ul></li><li><p>用一等函数替代操作符</p><p>以下反射方法提供只有通过操作符才能完成的操作</p><ul><li>Reflect.get()：可以替代对象属性访问操作符</li><li>Reflect.set()：可以替代&#x3D;赋值操作符</li><li>Reflect.has()：可以替代in操作符或with()</li><li>Reflect.deleteProperty()：可以替代delete操作符</li><li>Reflect.construct()：可以替代new操作符</li></ul></li><li><p>安全地应用函数</p><p>在通过<code>apply</code>方法调用函数时，被调用的函数可能也定义了自己的<code>apply</code>属性(虽然可能性极小)。为绕过这个问题，可以使用定义在<code>Function</code>原型上的<code>apply</code>方法，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(myFunc, thisVal, argumentList);</span><br></pre></td></tr></table></figure><p>这种可怕的代码完全可以使用 <code>Reflect.apply</code> 来避免：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(myFunc, thisVal, argumentsList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h2><p>代理可以拦截反射<code>API</code>的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first proxy&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second proxy&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h2 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h2><p>代理是在 <code>ECMAScript</code> 现有基础之上构建起来的一套新 <code>API</code>，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 <code>ECMAScript</code>机制很好地协同。</p><ol><li><p>代理中的this</p><p>代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="title function_">thisValEqualsProxy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> === proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">thisValEqualsProxy</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">thisValEqualsProxy</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 <code>proxy.outerMethod()</code>，而这个方法进而又会调用另一个方法，如 <code>this.innerMethod()</code>，实际上都会调用 <code>proxy.innerMethod()</code>。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">id</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInstanceProxy.<span class="property">id</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这是因为 <code>User</code> 实例一开始使用目标对象作为 <code>WeakMap</code> 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 <code>User</code> 实例改为代理 <code>User</code> 类本身。之后再创建代理的实例就会以代理实例作为 <code>WeakMap</code> 的键了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserClassProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="title class_">UserClassProxy</span>(<span class="number">456</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyUser.<span class="property">id</span>);</span><br></pre></td></tr></table></figure></li><li><p>代理与内部槽位</p><p>代理与内置引用类型（比如 <code>Array</code>）的实例通常可以很好地协同，但有些 <code>ECMAScript</code> 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p><p>一个典型的例子就是 <code>Date</code> 类型。根据 <code>ECMAScript</code> 规范，<code>Date</code> 类型方法的执行依赖 <code>this</code> 值上的内部槽位<code>[[NumberDate]]</code>。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 <code>get()</code>和 <code>set()</code>操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 <code>TypeError</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: &#x27;this&#x27; is not a Date object</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h1><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 <code>API</code> 方法、参数、关联 <code>ECMAScript</code>操作和不变式。</p><p>正如前面示例所展示的，有几种不同的 JavaScript 操作会调用同一个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</p><p>只要在代理上调用，所有捕获器都会拦截它们对应的反射 <code>API</code> 操作。</p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get()</code>捕获器会在获取属性值的操作中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.get()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">// get()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p>返回值无限制</p></li><li><p>拦截的操作</p><ul><li>proxy.property</li><li>proxy[property]</li><li>Object.create(proxy)[property]</li><li>Reflect.get(proxy,property,receiver)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>property：引用的目标对象上的字符串键属性</li><li>receiver：代理对象或继承代理对象的对象</li></ul></li><li><p>捕获器不变式</p><p>如果 <code>target.property</code> 不可写且不可配置，则处理程序返回的值必须与 <code>target.property</code> 匹配。如果 <code>target.property</code> 不可配置且<code>[[Get]]</code>特性为 <code>undefined</code>，处理程序的返回值也必须是 <code>undefined</code>。</p></li></ol><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.set()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// set()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p>返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 <code>TypeError</code>。</p></li><li><p>拦截的操作</p><ul><li>proxy.property &#x3D; value</li><li>proxy[property] &#x3D; value</li><li>Object.create(proxy)[property] &#x3D; value</li><li>Reflect.set(proxy,property,value,receiver)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>property：引用的目标对象上的字符串键属性</li><li>value：要赋给属性的值</li><li>receiver：接收最初赋值的对象</li></ul></li><li><p>捕获器不变式</p><p>如果 <code>target.property</code> 不可写且不可配置，则不能修改目标属性的值。</p><p>如果 <code>target.property</code> 不可配置且<code>[[Set]]</code>特性为 <code>undefined</code>，则不能修改目标属性的值。在严格模式下，处理程序中返回 false 会抛出 <code>TypeError</code>。</p></li></ol><h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p><code>has()</code>捕获器会在 <code>in</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.has()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">// has()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>has()</code>必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</p></li><li><p>拦截的操作</p><ul><li>property in proxy</li><li>property in Object.create(proxy)</li><li>with(proxy) {(property);}</li><li>Reflect.has(proxy,property)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>property：引用的目标对象上的字符串键属性</li></ul></li><li><p>捕获器不变式</p><p>如果 <code>target.property</code> 存在且不可配置，则处理程序必须返回 true。<br>如果 <code>target.property</code> 存在且目标对象不可扩展，则处理程序必须返回 true。</p></li></ol><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h2><p><code>defineProperty()</code>捕获器会在 <code>Object.defineProperty()</code>中被调用。对应的反射 <code>API </code>方法为<code>Reflect.defineProperty()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(<span class="params">target, property, descriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proxy, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// defineProperty()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>defineProperty()</code>必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</p></li><li><p>拦截的操作</p><ul><li>Object.defineProperty(proxy, property, descriptor)</li><li>Reflect.defineProperty(proxy, property, descriptor)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>property：引用的目标对象上的字符串键属性</li><li>descriptor：包含可选的enumerable、configurable、writable、value、get和set定义的对象</li></ul></li><li><p>捕获器不变式</p><p>如果目标对象不可扩展，则无法定义属性。<br>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。<br>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</p></li></ol><h2 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h2><p><code>getOwnPropertyDescriptor()</code>捕获器会在 <code>Object.getOwnPropertyDescriptor()</code>中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.getOwnPropertyDescriptor()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line"><span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getOwnPropertyDescriptor()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>getOwnPropertyDescriptor()</code>必须返回对象，或者在属性不存在时返回 <code>undefined</code>。</p></li><li><p>拦截的操作</p><ul><li>Object.getOwnPropertyDescriptor(proxy,property)</li><li>Reflect.getOwnPropertyDescriptor(proxy,property)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>property：引用的目标对象上的字符串键属性</li></ul></li><li><p>捕获器不变式</p><p>如果自有的 <code>target.property</code> 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。<br>如果自有的 <code>target.property</code> 存在且可配置，则处理程序必须返回表示该属性可配置的对象。<br>如果自有的 <code>target.property</code> 存在且 <code>target</code> 不可扩展，则处理程序必须返回一个表示该属性存在的对象。<br>如果 <code>target.property</code> 不存在且 <code>target</code> 不可扩展，则处理程序必须返回 <code>undefined</code> 表示该属性不存在。<br>如果 <code>target.property</code> 不存在，则处理程序不能返回表示该属性可配置的对象。</p><h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h2><p><code>deleteProperty()</code>捕获器会在 <code>delete</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.deleteProperty()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;deleteProperty()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>deleteProperty()</code>必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</p></li><li><p>拦截的操作</p><ul><li>delete proxy.property</li><li>delete proxy[property]</li><li>Reflect.deleteProperty(proxy, property)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>property：引用的目标对象上的字符串键属性</li></ul></li><li><p>捕获器不变式</p><p>如果自有的 <code>target.property</code> 存在且不可配置，则处理程序不能删除这个属性。</p></li></ol></li></ol><h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h2><p><code>ownKeys()</code>捕获器会在 <code>Object.keys()</code>及类似方法中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.ownKeys()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ownKeys()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy);</span><br><span class="line"><span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p>ownKeys()必须返回包含字符串或符号的可枚举对象。</p></li><li><p>拦截的操作</p><ul><li>Object.getOwnPropertyNames(proxy)</li><li>Object.getOwnPropertySymbols(proxy)</li><li>Object.keys(proxy)</li><li>Reflect.ownKeys(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li></ul></li><li><p>捕获器不定式</p><p>返回的可枚举对象必须包含 <code>target</code> 的所有不可配置的自有属性。<br>如果 <code>target</code> 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</p></li></ol><h2 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h2><p><code>getPrototypeOf()</code>捕获器会在 <code>Object.getPrototypeOf()</code>中被调用。对应的反射 <code>API</code> 方法为<code>Reflect.getPrototypeOf()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getPrototypeOf()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy);</span><br><span class="line"><span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>getPrototypeOf()</code>必须返回对象或 <code>null</code>。</p></li><li><p>拦截的操作</p><ul><li>Object.getPrototypeOf(proxy)</li><li>Reflect.getPrototypeOf(proxy)</li><li><code>proxy.__proxy__</code></li><li>Object.prototype.isPrototypeOf(proxy)</li><li>proxy instanceof Object</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li></ul></li><li><p>捕获器不变式</p><p>如果 <code>target</code> 不可扩展，则 <code>Object.getPrototypeOf(proxy)</code>唯一有效的返回值就是 <code>Object.getPrototypeOf(target)</code>的返回值。</p></li></ol><h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h2><p><code>setPrototypeOf()</code>捕获器会在 <code>Object.setPrototypeOf()</code>中被调用。对应的反射 <code>API</code> 方法为<code>Reflect.setPrototypeOf()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">setPrototypeOf</span>(<span class="params">target, prototype</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setPrototypeOf()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, <span class="title class_">Object</span>);</span><br><span class="line"><span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>setPrototypeOf()</code>必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</p></li><li><p>拦截的操作</p><ul><li>Object.setPrototypeOf(proxy)</li><li>Reflect.setPrototypeOf(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标参数</li><li>prototype：target的替代原型，如果是顶级原型则为null</li></ul></li><li><p>捕获器不变式</p><p>如果 <code>target</code> 不可扩展，则唯一有效的 <code>prototype</code> 参数就是 <code>Object.getPrototypeOf(target)</code>的返回值。</p></li></ol><h2 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h2><p><code>isExtensible()</code>捕获器会在 <code>Object.isExtensible()</code>中被调用。对应的反射 <code>API</code> 方法为<code>Reflect.isExtensible()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isExtensible()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy);</span><br><span class="line"><span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>isExtensible()</code>必须返回布尔值，表示 <code>target</code> 是否可扩展。返回非布尔值会被转型为布尔值。</p></li><li><p>拦截的操作</p><ul><li>Object.isExtenible(proxy)</li><li>Reflect.isEntensible(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li></ul></li><li><p>捕获器不变式</p><p>如果 target 可扩展，则处理程序必须返回 true。<br>如果 target 不可扩展，则处理程序必须返回 false。</p></li></ol><h2 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h2><p><code>preventExtensions()</code>捕获器会在 <code>Object.preventExtensions()</code>中被调用。对应的反射 <code>API</code>方法为 <code>Reflect.preventExtensions()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;preventExtensions()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy);</span><br><span class="line"><span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>preventExtensions()</code>必须返回布尔值，表示 <code>target</code> 是否已经不可扩展。返回非布尔值会被转型为布尔值。</p></li><li><p>拦截的操作</p><ul><li>Object.preventExtensions(proxy)</li><li>Reflect.preventExtensions(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li></ul></li><li><p>捕获器不变式</p><p>如果Object.isExtensible(proxy)是false，则处理程序必须返回true。</p></li></ol><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p><code>apply()</code>捕获器会在调用函数时中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.apply()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p>返回值无限制</p></li><li><p>拦截的操作</p><ul><li>proxy(…argumentsList)</li><li>Function.prototype.apply(thisArg, argumentsList)</li><li>Function.prototype.call(thisArg, …argumentsList)</li><li>Reflect.apply(target, thisArgument, argumentsList)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标对象</li><li>thisArg：调用函数时的this参数</li><li>argumentsList：调用函数时的参数列表</li></ul></li><li><p>捕获器不变式</p><p>target必须是一个函数对象</p></li></ol><h2 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h2><p><code>construct()</code>捕获器会在 <code>new</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.construct()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;construct()&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy;</span><br><span class="line"><span class="comment">// construct()</span></span><br></pre></td></tr></table></figure><ol><li><p>返回值</p><p><code>construct()</code>必须返回一个对象。</p></li><li><p>拦截的操作</p><ul><li>new Proxy(…argumentsList)</li><li>Reflect.construct(target,argumentsList,newTarget)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target：目标构造函数</li><li>argumentsList：传给目标构造函数的参数列表</li><li>newTarget：最初被调用的构造函数</li></ul></li><li><p>捕获器不定式</p><p>target必须可以用作构造函数</p></li></ol><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>使用代理可以在代码中实现一些有用的编程模式。</p><h2 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h2><p>通过捕获 <code>get</code>、<code>set</code> 和 <code>has</code> 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></table></figure><h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p><strong>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举</strong>。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">bar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><p>因为所有赋值操作都会触发 <code>set()</code>捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, &#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&#x27;Non-number argument provided&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="string">&#x27;7&#x27;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br></pre></td></tr></table></figure><p>类似地，可以要求实例化时必须给构造函数传参：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;User cannot be instantiated without id&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></table></figure><h2 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p><p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        userList.<span class="title function_">push</span>(newUser);</span><br><span class="line">        <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&#x27;Jacob&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&#x27;Jingleheimerschmidt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userList); <span class="comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span></span><br></pre></td></tr></table></figure><p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="title function_">emit</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">&#x27;Jacob&#x27;</span>);</span><br><span class="line"><span class="comment">// Jacob</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;ECMAScript 6&lt;/code&gt; 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(6)——对象、类与面向对象编程</title>
    <link href="http://pvnk1u.github.io/2023/02/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://pvnk1u.github.io/2023/02/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2023-02-08T03:56:39.000Z</published>
    <updated>2023-11-27T15:34:23.882Z</updated>
    
    <content type="html"><![CDATA[<p><code>ECMA-262</code>将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把 <code>ECMAScript</code> 的对象想象成一张散列表，其中的内容就是一组名&#x2F;值对，值可以是数据或者函数。</p><h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>创建自定义对象的通常方式是创建 <code>Object</code> 的一个新实例，然后再给它添加属性和方法，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>早期 <code>JavaScript</code> 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这个例子中的 <code>person</code> 对象跟前面例子中的 <code>person</code>对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 <code>JavaScript</code> 中的行为。</p><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p><code>ECMA-262</code> 使用一些内部特性来描述属性的特征。这些特性是由为<code> JavaScript</code> 实现引擎的规范定义 的。因此，开发者不能在 <code>JavaScript </code>中直接访问这些特性。**为了将某个特性标识为内部特性，规范会用 两个中括号把特性的名称括起来，比如[[Enumerable]]**。</p><p>属性分两种：数据属性和访问器属性。</p><ol><li><p>数据属性</p><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4 个特性描述它们的行为。</p><ol><li><p>[[Configurable]]</p><p>表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特 性都是 true，如前面的例子所示。</p></li><li><p>[[Enumerable]]</p><p>表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[Writable]]</p><p>表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的 这个特性都是 true，如前面的例子所示。</p></li><li><p>[[Value]]</p><p>包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性 的默认值为 undefined。</p></li></ol><p>在像前面例子中那样将属性显式添加到对象之后，[[Configurable]]、[[Enumerable]]和 [[Writable]]都会被设置为 true，而[[Value]]特性会被设置为指定的值。</p><p>要修改属性的默认特性，就必须使用 <code>Object.defineProperty()</code>方法。这个方法接收 3 个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包 含：<code>configurable</code>、<code>enumerable</code>、<code>writable</code> 和 <code>value</code>，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>在严格模式下，尝试修改只读属性 的值会抛出错误。</p><p>类似的规则也适用于创建不可配置的属性。比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除。非严格模式下对 这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就 不能再变回可配置的了。再次调用 <code>Object.defineProperty()</code>并修改任何非 <code>writable</code> 属性会导致错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因此，虽然可以对同一个属性多次调用 <code>Object.defineProperty()</code>，但在把 <code>configurable</code> 设 置为 false 之后就会受限制了。</p><p>在调用 <code>Object.defineProperty()</code>时，<code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 的值如果不 指定，则都默认为 false。多数情况下，可能都不需要 <code>Object.defineProperty()</code>提供的这些强大的设置，但要理解 <code>JavaScript </code>对象，就要理解这些概念。</p></li><li><p>访问器属性</p><p>访问器属性不包含数据值。相反，它们包含一个获取（<code>getter</code>）函数和一个设置（<code>setter</code>）函数，不 过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。</p><ol><li><p>[[Configurable]]</p><p>表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[Enumerable]]</p><p>表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。</p></li><li><p>[[Get]]</p><p>获取函数，在读取属性时调用。默认值为 undefined。</p></li><li><p>[[Set]]</p><p>设置函数，在写入属性时调用。默认值为 undefined。</p></li></ol><p>**访问器属性是不能直接定义的，必须使用 <code>Object.defineProperty()</code>**。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员 year_和公共成员 edition </span></span><br><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line"> <span class="attr">year_</span>: <span class="number">2017</span>, </span><br><span class="line"> <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123; </span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; </span><br><span class="line">     <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">year_</span> = newValue; </span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line">book.<span class="property">year</span> = <span class="number">2018</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>在这个例子中，对象 <code>book</code> 有两个默认属性：<code>year_</code>和 <code>edition</code>。<code>year_</code>中的下划线常用来表示该 属性并不希望在对象方法的外部被访问。另一个属性 <code>year </code>被定义为一个访问器属性，其中获取函数简 单地返回 <code>year</code>_的值，而设置函数会做一些计算以决定正确的版本（<code>edition</code>）。因此，把 <code>year </code>属性修改 为 2018 会导致<code> year_</code>变成 2018，<code>edition</code> 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽 略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性 是不能读取的，非严格模式下读取会返回 <code>undefined</code>，严格模式下会抛出错误。 在不支持 <code>Object.defineProperty()</code>的浏览器中没有办法修改<code>[[Configurable]]</code>或<code>[[Enumerable]]</code>。</p></li></ol><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，<code>ECMAScript</code> 提供了 <code>Object.defineProperties()</code>方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添 加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123; </span><br><span class="line"> <span class="attr">year_</span>: &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="number">2017</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">edition</span>: &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="number">1</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">year</span>: &#123; </span><br><span class="line">     <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>; </span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; </span><br><span class="line">         <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">year_</span> = newValue; </span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>; </span><br><span class="line">         &#125; </span><br><span class="line">  &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>这段代码在 book 对象上定义了两个数据属性 <code>year_</code>和 <code>edition</code>，还有一个访问器属性 <code>year</code>。 最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的<code> configurable</code>、<code>enumerable</code> 和 <code>writable</code> 特性值都是<code> false</code>。</p><h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 <code>Object.getOwnPropertyDescriptor()</code>方法可以取得指定属性的属性描述符。这个方法接 收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 <code>configurable</code>、<code>enumerable</code>、<code>get</code> 和 <code>set</code> 属性，对于数据属性包含 <code>configurable</code>、<code>enumerable</code>、 <code>writable</code> 和 <code>value</code> 属性。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123; </span><br><span class="line"> <span class="attr">year_</span>: &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="number">2017</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">edition</span>: &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="number">1</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">year</span>: &#123; </span><br><span class="line">     <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>; </span><br><span class="line">     &#125;, </span><br><span class="line">     <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123; </span><br><span class="line">         <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">year_</span> = newValue; </span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book, <span class="string">&quot;year_&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">value</span>); <span class="comment">// 2017 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">configurable</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> descriptor.<span class="property">get</span>); <span class="comment">// &quot;undefined&quot; </span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book, <span class="string">&quot;year&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">value</span>); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">enumerable</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> descriptor.<span class="property">get</span>); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><p><code>ECMAScript</code> 2017 新增了 <code>Object.getOwnPropertyDescriptors()</code>静态方法。这个方法实际上 会在每个自有属性上调用 <code>Object.getOwnPropertyDescriptor()</code>并在一个新对象中返回它们。对于 前面的例子，使用这个静态方法会返回如下对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123; </span><br><span class="line"> <span class="attr">year_</span>: &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="number">2017</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">edition</span>: &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="number">1</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">year</span>: &#123; </span><br><span class="line">     <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>; </span><br><span class="line">   &#125;, </span><br><span class="line">     <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123; </span><br><span class="line">         <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">year_</span> = newValue; </span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(book)); </span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// edition: &#123; </span></span><br><span class="line"><span class="comment">// configurable: false, </span></span><br><span class="line"><span class="comment">// enumerable: false, </span></span><br><span class="line"><span class="comment">// value: 1, </span></span><br><span class="line"><span class="comment">// writable: false </span></span><br><span class="line"><span class="comment">// &#125;, </span></span><br><span class="line"><span class="comment">// year: &#123; </span></span><br><span class="line"><span class="comment">// configurable: false, </span></span><br><span class="line"><span class="comment">// enumerable: false, </span></span><br><span class="line"><span class="comment">// get: f(), </span></span><br><span class="line"><span class="comment">// set: f(newValue), </span></span><br><span class="line"><span class="comment">// &#125;, </span></span><br><span class="line"><span class="comment">// year_: &#123; </span></span><br><span class="line"><span class="comment">// configurable: false, </span></span><br><span class="line"><span class="comment">// enumerable: false, </span></span><br><span class="line"><span class="comment">// value: 2017, </span></span><br><span class="line"><span class="comment">// writable: false </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p><code>JavaScript</code> 开发者经常觉得“合并”（<code>merge</code>）两个对象很有用。更具体地说，就是把源对象所有的 本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（<code>mixin</code>），因为目标对象通过混入 源对象的属性得到了增强。</p><p><code>ECMAScript</code> 6 专门为合并对象提供了 <code>Object.assign()</code>方法。这个方法接收一个目标对象和一个 或多个源对象作为参数，然后将每个源对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回 true） 和自有（<code>Object.hasOwnProperty()</code>返回 true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标 对象上的[[Set]]设置属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">&#x27;src&#x27;</span> &#125;; </span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src); </span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; id: src &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; id: src &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 多个源对象</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123;&#125;; </span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; a: foo, b: bar &#125; </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123; </span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">src = &#123; </span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">a</span>() &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked src getter&#x27;</span>); </span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src); </span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数&quot;foo&quot; </span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>Object.assign()</code>实际上对每个源对象执行的是浅复制(只复制对象的引用)。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目 标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&#x27;dest&#x27;</span> &#125;; </span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;src1&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;src2&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// Object.assign 会覆盖重复的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; id: src2, a: foo, b: bar &#125; </span></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖的过程：</span></span><br><span class="line">dest = &#123; </span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;first&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;second&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;third&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// first </span></span><br><span class="line"><span class="comment">// second </span></span><br><span class="line"><span class="comment">// third </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src); </span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; a :&#123;&#125; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。<code>Object.assign()</code>没有“回滚”之前 赋值的概念，<strong>因此它是一个尽力而为、可能只会完成部分复制的方法。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; </span><br><span class="line">     <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span>, </span><br><span class="line">     <span class="keyword">get</span> <span class="title function_">b</span>() &#123; </span><br><span class="line">         <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(); </span><br><span class="line">     &#125;, </span><br><span class="line">     <span class="attr">c</span>: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; a: foo &#125;</span></span><br></pre></td></tr></table></figure><h2 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h2><p> <code>ECMAScript</code> 6 之前，有些特殊情况即使是&#x3D;&#x3D;&#x3D;操作符也无能为力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些是===符合预期的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> === <span class="number">1</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; === &#123;&#125;); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span> === <span class="number">2</span>); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN() </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为改善这类情况，<code>ECMAScript</code> 6 规范新增了 <code>Object.is()</code>，这个方法与&#x3D;&#x3D;&#x3D;很像，但同时也考虑 到了上述边界情形。这个方法必须接收两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="literal">true</span>, <span class="number">1</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 正确的 0、-0、+0 相等/不等判定</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 正确的 NaN 相等判定</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要检查超过两个值，递归地利用相等性传递即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) &#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(x, rest[<span class="number">0</span>]) &amp;&amp; </span><br><span class="line">     (rest.<span class="property">length</span> &lt; <span class="number">2</span> || <span class="title function_">recursivelyCheckEqual</span>(...rest)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><p><code>ECMAScript</code> 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎 的行为，但极大地提升了处理对象的方便程度。</p><ol><li><p>属性值简写</p><p>在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"><span class="attr">name</span>: name </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p>为此，简写属性名语法出现了。简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同 名的属性键。如果没有找到同名变量，则会抛出 <code>ReferenceError</code>。</p><p>以下代码和之前的代码是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> name </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。以下面的代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> &#123; </span><br><span class="line"> name </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">makePerson</span>(<span class="string">&#x27;Matt&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt </span></span><br></pre></td></tr></table></figure></li><li><p>可计算属性</p><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line">person[nameKey] = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line">person[ageKey] = <span class="number">27</span>; </span><br><span class="line">person[jobKey] = <span class="string">&#x27;Software engineer&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时 将其作为 JavaScript 表达式而不是字符串来求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> [nameKey]: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> [ageKey]: <span class="number">27</span>, </span><br><span class="line"> [jobKey]: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUniqueKey</span>(<span class="params">key</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> [<span class="title function_">getUniqueKey</span>(nameKey)]: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> [<span class="title function_">getUniqueKey</span>(ageKey)]: <span class="number">27</span>, </span><br><span class="line"> [<span class="title function_">getUniqueKey</span>(jobKey)]: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name_0: &#x27;Matt&#x27;, age_1: 27, job_2: &#x27;Software engineer&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p><strong>可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副 作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。</strong></p></li><li><p>简写方法名</p><p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">person.<span class="title function_">sayName</span>(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure><p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数命名通常没什么用）。相应地，这样也可以明显缩短方法声明。</p><p>以下代码和之前的代码在行为上是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">person.<span class="title function_">sayName</span>(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure><p>简写方法名对获取函数和设置函数也是适用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name_</span>: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name_</span> = name; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name_&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure><p>简写方法名与可计算属性键相互兼容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&#x27;sayName&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     [methodKey](name) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">person.<span class="title function_">sayName</span>(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><code>ECMAScript</code> 6 新增了对象解构语法，<strong>可以在一条语句中使用嵌套数据实现一个或多个赋值操作</strong>。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p><p>下面的例子展示了两段等价的代码，首先是不使用对象解构的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personName = person.<span class="property">name</span>, </span><br><span class="line">personAge = person.<span class="property">age</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personAge); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>然后，是使用对象解构的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personAge); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, job &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(job); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">&#x27;Software engineer&#x27;</span> &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(job); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure><p>解构在内部使用函数 <code>ToObject()</code>（不能在运行时环境中直接访问）把源数据结构转换为对象。这 意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 <code>ToObject()</code>的定义），<code>null</code> 和 <code>undefined</code> 不能被解构，否则会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length); <span class="comment">// 6 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c === <span class="title class_">Number</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>; <span class="comment">// TypeError </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError </span></span><br></pre></td></tr></table></figure><p>解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27 </span></span><br></pre></td></tr></table></figure><ol><li><p>嵌套解构</p><p>解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span>, </span><br><span class="line">     <span class="attr">job</span>: &#123; </span><br><span class="line">     <span class="attr">title</span>: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">(&#123; </span><br><span class="line">     <span class="attr">name</span>: personCopy.<span class="property">name</span>, </span><br><span class="line">     <span class="attr">age</span>: personCopy.<span class="property">age</span>, </span><br><span class="line">     <span class="attr">job</span>: personCopy.<span class="property">job</span> </span><br><span class="line">&#125; = person); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy </span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">&#x27;Hacker&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125; </span></span><br></pre></td></tr></table></figure><p>解构赋值可以使用嵌套结构，以匹配嵌套的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span>, </span><br><span class="line">     <span class="attr">job</span>: &#123; </span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 声明 title 变量并将 person.job.title 的值赋给它</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure><p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">job</span>: &#123; </span><br><span class="line"> <span class="attr">title</span>: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;; </span><br><span class="line"><span class="comment">// 视图把源对象上的foo对象下的bar 值赋值给目标对象的bar 但foo 在源对象上是 undefined </span></span><br><span class="line">(&#123; </span><br><span class="line"> <span class="attr">foo</span>: &#123; </span><br><span class="line"> <span class="attr">bar</span>: personCopy.<span class="property">bar</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; = person); </span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;. </span></span><br><span class="line"><span class="comment">// 视图把源对象上的job对象里的title赋值给目标对象personCopy里的job对象里的title，但job 在目标对象上是 undefined </span></span><br><span class="line">(&#123; </span><br><span class="line"> <span class="attr">job</span>: &#123; </span><br><span class="line"> <span class="attr">title</span>: personCopy.<span class="property">job</span>.<span class="property">title</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; = person); </span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;title&#x27; of undefined </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>部分解构</p><p>需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及 多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge; </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="comment">// person.foo 是 undefined，因此会抛出错误</span></span><br><span class="line"> (&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personBar, personAge); </span><br><span class="line"><span class="comment">// Matt, undefined, undefined</span></span><br></pre></td></tr></table></figure></li><li><p>上下文参数匹配</p><p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 <code>arguments</code> 对象，但可以在函数签名中声明在函数体内使用局部变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line">     <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">foo, &#123;name, age&#125;, bar</span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson2</span>(<span class="params">foo, &#123;name: personName, age: personAge&#125;, bar</span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">printPerson</span>(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>); </span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;] </span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27 </span></span><br><span class="line"><span class="title function_">printPerson2</span>(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>); </span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;] </span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27 </span></span><br></pre></td></tr></table></figure></li></ol><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>虽然使用 <code>Object</code> 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ECMAScript</code> 5.1 并没有正式支持面向对象的结构，比如类或继承。但是，正如接下来会介绍的，巧妙地运用原型式继承可以成功地模拟类或继承。</p><p><code>ECMAScript</code> 6 开始正式支持类和继承。**<code>ES6</code> 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，<code>ES6</code>的类都仅仅是封装了 <code>ES5.1 </code>构造函数加原型继承的语法糖而已。**</p><p>采用面向对象编程模式的 <code>JavaScript</code> 代码还是应该使用 <code>ECMAScript</code> 6 的 类。但不管怎么说，理解 <code>ES6</code> 类出现之前的惯例总是有益无害的。特别是 <code>ES6</code> 的类定义本身就相当于对原有结构的封装。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。下面的例子展示了一种按照特定接口创 建对象的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">     o.<span class="property">name</span> = name; </span><br><span class="line">     o.<span class="property">age</span> = age; </span><br><span class="line">     o.<span class="property">job</span> = job; </span><br><span class="line">     o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">     &#125;; </span><br><span class="line">     <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，函数 <code>createPerson()</code>接收 3 个参数，根据这几个参数构建了一个包含 <code>Person</code> 信息的对象。 可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但<strong>没有解决对象标识问题（即新创建的对象是什么类型）</strong>。</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p><code>ECMAScript</code> 中的构造函数是用于创建特定类型对象的。像 <code>Object</code> 和 <code>Array</code> 这 样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p><p>比如，前面的例子使用构造函数模式可以这样写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">     &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg </span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Person()</code>构造函数代替了 <code>createPerson()</code>工厂函数。实际上，<code>Person()</code>内部的代码跟 <code>createPerson()</code>基本是一样的，只是有如下区别。</p><ol><li>没有显式创建对象</li><li>属性和方法直接赋值给了this</li><li>没有return</li></ol><p>另外，要注意函数名 <code>Person</code> 的首字母大写了。按照惯例，<strong>构造函数名称的首字母都是要大写的， 非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在 <code>ECMAScript</code> 中区分构造函数和普通函数。毕竟 <code>ECMAScript</code> 的构造函数就是能创建对象的函数。</strong></p><p>要创建 <code>Person</code> 的实例，应使用 <code>new</code> 操作符。以这种方式调用构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象</li><li><strong>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</strong></li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li><strong>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</strong></li></ol><p>上一个例子的最后，<code>person1</code> 和 <code>person2</code> 分别保存着 <code>Person</code>的不同实例。这两个对象都有一个 <code>constructor</code> 属性指向 <code>Person</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><code>constructor</code> 本来是用于标识对象类型的。不过，一般认为 <code>instanceof</code> 操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是 <code>Object</code> 的实例，同时也是 <code>Person</code> 的实例，如下面调用 <code>instanceof</code> 操作符的结果所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><strong>定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。</strong>在 这个例子中，**<code>person1</code> 和 <code>person2</code> 之所以也被认为是 <code>Object</code> 的实例，是因为所有自定义对象都继承 自 <code>Object</code>**（后面再详细讨论这一点）。</p><p>构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params">name, age, job</span>) &#123; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">     &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><strong>在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">     &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Jake </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Jake </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><ol><li><p>构造函数也是函数</p><p><strong>构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。</strong>并没有把某个函数定义为构造函数的特殊语法。<strong>任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操 作符调用的函数就是普通函数。</strong>比如，前面的例子中定义的 Person()可以像下面这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数 </span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到 window 对象</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Greg&quot; </span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>); </span><br><span class="line">o.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Kristen&quot; </span></span><br></pre></td></tr></table></figure><p>这个例子一开始展示了典型的构造函数调用方式，即使用 new 操作符创建一个新对象。然后是普通函数的调用方式，<strong>这时候没有使用 new 操作符调用 Person()，结果会将属性和方法添加到 window 对象。</strong>这里要记住，<strong>在调用一个函数而没有明确设置 this 值的情况下（即没有作为对象的方法调用，或者没有使用 call()&#x2F;apply()调用），this 始终指向 Global 对象（在浏览器中就是 window 对象）。 因此在上面的调用之后，window 对象上就有了一个 <code>sayName()</code>方法，调用它会返回”Greg”。</strong>最后展示的调用方式是通过 <code>call()</code>（或 <code>apply()</code>）调用函数，同时将特定对象指定为作用域。这里的调用将对象 o 指定为 <code>Person()</code>内部的 <code>this</code> 值，因此执行完函数代码后，所有属性和 <code>sayName()</code>方法都会添 加到对象 <code>o</code> 上面。</p></li><li><p>构造函数的问题</p><p>构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，<code>person1</code> 和 <code>person2</code> 都有名为 <code>sayName()</code>的方法，但这两个方 法不是同一个 <code>Function</code> 实例。我们知道，<code>ECMAScript</code> 中的函数是对象，因此每次定义函数时，都会 初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;console.log(this.name)&quot;</span>); <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样理解这个构造函数可以更清楚地知道，每个 <code>Person</code> 实例都会有自己的 <code>Function</code> 实例用于显示 <code>name</code> 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 <code>Function</code> 实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因为都是做一样的事，所以没必要定义两个不同的 <code>Function</code> 实例。况且，<code>this</code> 对象可以把函数与对象的绑定推迟到运行时。</p><p>要解决这个问题，可以把函数定义转移到构造函数外部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg </span></span><br></pre></td></tr></table></figure><p>在这里，<code>sayName()</code>被定义在了构造函数外部。在构造函数内部，<code>sayName</code> 属性等于全局 <code>sayName()</code> 函数。因为这一次 <code>sayName</code> 属性中包含的只是一个指向外部函数的指针，所以 <code>person1</code> 和 <code>person2</code> 共享了定义在全局作用域上的 <code>sayName()</code>函数。这样虽然解决了相同逻辑的函数重复定义的问题，但 全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法， 那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p></li></ol><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每<strong>个函数本身都会创建一个<code>prototype</code>属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法</strong>。实际上，**这个对象就是通过调用构造函数创建的对象的原型。 **  <strong>使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型</strong>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用函数表达式也可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>这里，所有属性和 <code>sayName()</code>方法都直接添加到了 <code>Person</code> 的 <code>prototype</code> 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 <code>person1</code> 和 <code>person2</code> 访问的 都是相同的属性和相同的 <code>sayName()</code>函数。要理解这个过程，就必须理解 <code>ECMAScript</code> 中原型的本质。</p><ol><li><p>理解原型</p><p><strong>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 <code>prototype</code> 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 <code>constructor</code> 的属性，指回与之关联的构造函数。对前面的例子而言，<code>Person.prototype.constructor</code> 指向 <code>Person</code>。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。</strong></p><p>在自定义构造函数时，原型对象默认只会获得 <code>constructor</code> 属性，其他的所有方法都继承自 <code>Object</code>。每次调用构造函数创建一个新实例，这个实例的内部<code>[[Prototype]]</code>指针就会被赋值为构造函数的原型对象。脚本中没有访问这个<code>[[Prototype]]</code>特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露<code>__proto__</code>属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之 间没有。</p><p>这种关系不好可视化，但可以通过下面的代码来理解原型的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造函数可以是函数表达式</span></span><br><span class="line"><span class="comment"> * 也可以是函数声明，因此以下两种形式都可以：</span></span><br><span class="line"><span class="comment"> * function Person() &#123;&#125; </span></span><br><span class="line"><span class="comment"> * let Person = function() &#123;&#125; </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 声明之后，构造函数就有了一个</span></span><br><span class="line"><span class="comment"> * 与之关联的原型对象：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// constructor: f Person(), </span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如前所述，构造函数有一个 prototype 属性</span></span><br><span class="line"><span class="comment"> * 引用其原型对象，而这个原型对象也有一个</span></span><br><span class="line"><span class="comment"> * constructor 属性，引用这个构造函数</span></span><br><span class="line"><span class="comment"> * 换句话说，两者循环引用：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 正常的原型链都会终止于 Object 的原型对象</span></span><br><span class="line"><span class="comment"> * Object 原型的原型是 null </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// constructor: f Object(), </span></span><br><span class="line"><span class="comment">// toString: ... </span></span><br><span class="line"><span class="comment">// hasOwnProperty: ... </span></span><br><span class="line"><span class="comment">// isPrototypeOf: ... </span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(), </span><br><span class="line"> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造函数、原型对象和实例</span></span><br><span class="line"><span class="comment"> * 是 3 个完全不同的对象：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 !== <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 !== <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> !== <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 实例通过__proto__链接到原型对象，</span></span><br><span class="line"><span class="comment"> * 它实际上指向隐藏特性[[Prototype]] </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造函数通过 prototype 属性链接到原型对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line">conosle.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例</span></span><br><span class="line"><span class="comment"> * 共享同一个原型对象：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span> === person2.<span class="property">__proto__</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * instanceof 检查实例的原型链中</span></span><br><span class="line"><span class="comment"> * 是否包含指定构造函数的原型：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true，构造函数的原型对象也是由Object的原型对象派生的</span></span><br></pre></td></tr></table></figure><p><img src="https://pvnk1u.github.io/images/PersonRel.PNG" alt="image-20230301223624889"></p><p>上图展示了 Person 构造函数、Person 的原型对象和 Person 现有两个实例之间的关系。注意，<code>Person.prototype</code> 指向原型对象，而 <code>Person.prototype.contructor</code> 指回 Person 构造函数。原型对象包含 constructor 属性和其他后来添加的属性。Person 的两个实例 <code>person1</code> 和 <code>person2</code> 都只有一个内部属性指回 <code>Person.prototype</code>，而且两者都与构造函数没有直接联系。另外要注意，虽然这两个实例都没有属性和方法，但 <code>person1.sayName()</code>可以正常调用。这是由于对象属性查找机制的原因。</p><p>虽然不是所有实现都对外暴露了<code>[[Prototype]]</code>，但可以使用<code> isPrototypeOf()</code>方法确定两个对象之间的这种关系。本质上，<code>isPrototypeOf()</code>会在传入参数的<code>[[Prototype]]</code>指向调用它的对象时返回 true，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里通过原型对象调用 <code>isPrototypeOf()</code>方法检查了 <code>person1</code> 和 <code>person2</code>。因为这两个例子内部都有链接指向 <code>Person.prototype</code>，所以结果都返回 true。</p><p><code>ECMAScript</code> 的 <code>Object</code> 类型有一个方法叫 <code>Object.getPrototypeOf()</code>，返回参数的内部特性<code>[[Prototype]]</code>的值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1).<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>第一行代码简单确认了 <code>Object.getPrototypeOf()</code>返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上 name 属性的值，即”Nicholas”。使用 <code>Object.getPrototypeOf()</code>可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要。</p><p>Object 类型还有一个 <code>setPrototypeOf()</code>方法，可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line"><span class="attr">numLegs</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person, biped);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.setPrototypeOf()</code>可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 <code>Object.setPrototypeOf()</code>语句那么简单，而是会涉及所有访问了那些修改过<code>[[Prototype]]</code>的对象的代码。”</p><p>为避免使用 <code>Object.setPrototypeOf()</code>可能造成的性能下降，可以通过 <code>Object.create()</code>来创建一个新对象，同时为其指定原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line"><span class="attr">numLegs</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(biped);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>原型层级</p><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。因此，在调用 <code>person1.sayName()</code>时，会发生两步搜索。首先，<code>JavaScript</code> 引擎会问：“<code>person1</code> 实例有 <code>sayName</code> 属性吗？”答案是没有。然后，继续搜索并问：“<code>person1</code> 的原型有<code> sayName</code> 属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用 <code>person2.sayName()</code>时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。</p><p>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>person1</code> 的 <code>name</code> 属性遮蔽了原型对象上的同名属性。虽然 <code>person1.name</code> 和<code>person2.name</code> 都返回了值，但前者返回的是”Greg”（来自实例），后者返回的是”Nicholas”（来自原型）。当 <code>console.log()</code>访问 <code>person1.name</code> 时，会先在实例上搜索个属性。因为这个属性在实例上存在，所以就不会再搜索原型对象了。而在访问<code> person2.name</code> 时，并没有在实例上找到这个属性，所以会继续搜索原型对象并使用定义在原型上的属性。</p><p><strong>只要给对象实例添加一个属性，这个属性就会遮蔽（<code>shadow</code>）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为 <code>null</code>，也不会恢复它和原型的联系。不过，使用 <code>delete </code>操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure><p><code>hasOwnProperty()</code>方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 <code>Object</code>的，会在属性存在于调用它的对象实例上时返回 true，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在这个例子中，通过调用 <code>hasOwnProperty()</code>能够清楚地看到访问的是实例属性还是原型属性。调用 <code>person1.hasOwnProperty(&quot;name&quot;)</code>只在重写 <code>person1</code> 上 name 属性的情况下才返回 true，表明此时 name 是一个实例属性，不是原型属性。</p><p><code>ECMAScript</code> 的<code> Object.getOwnPropertyDescriptor()</code>方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用 <code>Object.getOwnProperty-Descriptor()</code>。</p></li><li><p>原型和in操作符</p><p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用 <code>hasOwnProperty()</code>和 <code>in</code> 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypeProperty</span>(<span class="params">object, name</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> !object.<span class="title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>for-in</code> 循环中使用 <code>in</code> 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（<code>[[Enumerable]]</code>特性被设置为 false）属性的实例属性也会在 <code>for-in</code> 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p><p>要获得对象上所有可枚举的实例属性，可以使用 <code>Object.keys()</code>方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// &quot;name,age,job,sayName&quot;</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.<span class="property">age</span> = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure><p>这里，keys 变量保存的数组中包含”name”、”age”、”job”和”sayName”。这是正常情况下通过<code>for-in</code> 返回的顺序。而在 <code>Person</code> 的实例上调用时，<code>Object.keys()</code>返回的数组中只包含”name”和”age”两个属性。</p><p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 <code>Object.getOwnPropertyNames()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// &quot;[constructor,name,age,job,sayName]&quot;</span></span><br></pre></td></tr></table></figure><p>注意，返回的结果中包含了一个不可枚举的属性 <code>constructor</code>。<code>Object.keys()</code>和 <code>Object.getOwnPropertyNames()</code>在适当的时候都可用来代替 <code>for-in</code> 循环。</p><p>在 <code>ECMAScript</code> 6 新增符号类型之后，相应地出现了增加一个 <code>Object.getOwnPropertyNames()</code>的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，<code>Object.getOwnPropertySymbols()</code>方法就出现了，这个方法与 <code>Object.getOwnPropertyNames()</code>类似，只是针对符号而已:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">k2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [k1]: <span class="string">&#x27;k1&#x27;</span>,</span><br><span class="line">    [k2]: <span class="string">&#x27;k2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure></li><li><p>属性枚举顺序</p><p><code>for-in</code> 循环、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>以及 <code>Object.assign()</code>在属性枚举顺序方面有很大区别。<code>for-in</code> 循环和 <code>Object.keys()</code>的枚举顺序是不确定的，取决于 <code>JavaScript</code> 引擎，可能因浏览器而异。</p><p><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>和 <code>Object.assign()</code>的枚举顺序是确定性的。<strong>先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">k2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">first</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">    [k1]: <span class="string">&#x27;sym2&#x27;</span>,</span><br><span class="line">    <span class="attr">second</span>: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.<span class="property">third</span> = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o));</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>在 <code>JavaScript</code> 有史以来的大部分时间内，迭代对象属性都是一个难题。<code>ECMAScript</code> 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法<code>Object.values()</code>和 <code>Object.entries()</code>接收一个对象，返回它们内容的数组。<code>Object.values()</code>返回对象值的数组，<code>Object.entries()</code>返回键&#x2F;值对的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o));</span><br><span class="line">/ [<span class="string">&quot;bar&quot;</span>, <span class="number">1</span>, &#123;&#125;]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>((o)));</span><br><span class="line"><span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure><p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line"><span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o)[<span class="number">0</span>] === o.<span class="property">qux</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(o)[<span class="number">0</span>][<span class="number">1</span>] === o.<span class="property">qux</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>符号属性会被忽略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">[sym]: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o));</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>((o)));</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure><ol><li><p>其他原型语法</p><p>在前面的例子中，每次定义一个属性或方法都会把 <code>Person.prototype</code> 重写一遍。为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Person.prototype</code> 被设置为等于一个通过对象字面量创建的新对象。最终结果是一样的，只有一个问题：这样重写之后，<code>Person.prototype</code> 的 <code>constructor</code> 属性就不指向 <code>Person</code>了。在创建函数时，也会创建它的 <code>prototype</code> 对象，同时会自动给这个原型的 <code>constructor</code> 属性赋值。而上面的写法完全重写了默认的 <code>prototype </code>对象，因此其 <code>constructor</code> 属性也指向了完全不同的新对象（Object 构造函数），不再指向原来的构造函数。虽然 <code>instanceof</code> 操作符还能可靠地返回值，但我们不能再依靠 <code>constructor</code> 属性来识别类型了，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend.<span class="property">constructor</span> == <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里，<code>instanceof</code> 仍然对<code>Object</code> 和<code>Person</code> 都返回true。但<code>constructor</code> 属性现在等于<code>Object</code>而不是 <code>Person</code> 了。如果 <code>constructor</code> 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但要注意，以这种方式恢复 <code>constructor</code> 属性会创建一个<code>[[Enumerable]]</code>为 true 的属性。而原生 <code>constructor</code> 属性默认是不可枚举的。因此，如果你使用的是兼容<code> ECMAScript</code> 的<code>JavaScript</code>引擎，那可能会改为使用 <code>Object.defineProperty()</code>方法来定义 <code>constructor</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 恢复 constructor 属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>原型的动态性</p><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;hi&quot;，没问题！</span></span><br></pre></td></tr></table></figure><p>以上代码先创建一个 <code>Person</code> 实例并保存在 <code>friend</code> 中。然后一条语句在 <code>Person.prototype</code> 上添加了一个名为 <code>sayHi()</code>的方法。虽然 <code>friend</code> 实例是在添加方法之前创建的，但它仍然可以访问这个方法。之所以会这样，主要原因是实例与原型之间松散的联系。在调用 <code>friend.sayHi()</code>时，首先会从这个实例中搜索名为 <code>sayHi</code> 的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到 <code>sayHi</code> 属性并返回这个属性保存的函数。</p><p><strong>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的<code>[[Prototype]]</code>指针是在调用构造函数时自动赋值的，即使把原型修改为不同的对象，实例的这个指针指向的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">friend.<span class="title function_">sayName</span>(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Person</code> 的新实例是在重写原型对象之前创建的。在调用 <code>friend.sayName()</code>的时候，会导致错误。这是因为 <code>firend</code> 指向的原型还是最初的原型，而这个原型上并没有 <code>sayName</code> 属性。下图展示了这里边的原因：</p><p><img src="https://pvnk1u.github.io/images/Prototype8.3.PNG" alt="image-20230302221921453"></p><p><strong>重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。</strong></p></li><li><p>原生对象原型</p><p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括 <code>Object</code>、<code>Array</code>、<code>String</code> 等）都在原型上定义了实例方法。比如，数组实例的 <code>sort()</code>方法就是 <code>Array.prototype</code> 上定义的，而字符串包装对象的 <code>substring()</code>方法也是在 <code>String.prototype</code> 上定义的，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sort</span>); <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">substring</span>); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给 <code>String</code>原始值包装类型的实例添加了一个 <code>startsWith()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(text) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="title function_">startsWith</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果给定字符串的开头出现了调用 <code>startsWith()</code>方法的文本，那么该方法会返回 true。因为这个方法是被定义在 <code>String.prototype</code> 上，所以当前环境下所有的字符串都可以使用这个方法。msg是个字符串，在读取它的属性时，后台会自动创建 String 的包装实例，从而找到并调用 <code>startsWith()</code>方法。</p><p>尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。</p></li><li><p>原型的问题</p><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。<strong>原型的最主要问题源自它的共享特性</strong>。</p><p>原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，如前面例子中所示，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。<strong>真正的问题来自包含引用值的属性</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>],</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里，<code>Person.prototype</code> 有一个名为 <code>friends</code>的属性，它包含一个字符串数组。然后这里创建了两个 <code>Person</code> 的实例。<code>person1.friends</code> 通过 <code>push</code> 方法向数组中添加了一个字符串。由于这个friends 属性存在于 <code>Person.prototype</code> 而非 <code>person1</code> 上，新加的这个字符串也会在（指向同一个数组的）<code>person2.friends</code> 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p></li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是面向对象编程中讨论最多的话题。<strong>很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法</strong>。接口继承在 <code>ECMAScript</code> 中是不可能的，因为函数没有签名。实现继承是 <code>ECMAScript</code> 唯一支持的继承方式，而这主要是通过原型链实现的。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><code>ECMA-262</code> 把原型链定义为 <code>ECMAScript</code> 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><p>实现原型链涉及如下代码模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以上代码定义了两个类型：<code>SuperType</code> 和 <code>SubType</code>。这两个类型分别定义了一个属性和一个方法。这两个类型的主要区别是 <code>SubType </code>通过创建 <code>SuperType</code> 的实例并将其赋值给自己的原型 <code>SubTtype.prototype</code> 实现了对 <code>SuperType</code> 的继承。这个赋值重写了 <code>SubType</code> 最初的原型，将其替换为<code>SuperType</code> 的实例。这意味着 <code>SuperType</code> 实例可以访问的所有属性和方法也会存在于 <code>SubType.prototype</code>。这样实现继承之后，代码紧接着又给 <code>SubType.prototype</code>，也就是这个 <code>SuperType</code> 的实例添加了一个新方法。最后又创建了 <code>SubType</code> 的实例并调用了它继承的 <code>getSuperValue()</code>方法。</p><p>下图展示了子类的实例与两个构造函数及其对应的原型之间的关系：</p><p><img src="https://pvnk1u.github.io/images/ConstructorAndPrototypeRel.PNG" alt="image-20230302224009783"></p><p><strong>这个例子中实现继承的关键，是 <code>SubType</code> 没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是 <code>SuperType</code> 的实例。这样一来，<code>SubType</code> 的实例不仅能从 <code>SuperType</code> 的实例中继承属性和方法，而且还与 <code>SuperType</code> 的原型挂上了钩。于是 <code>instance</code>（通过内部的<code>[[Prototype]]</code>）指向<code>SubType.prototype</code>，而 <code>SubType.prototype</code>（作为 <code>SuperType</code> 的实例又通过内部的<code>[[Prototype]]</code>）指向 <code>SuperType.prototype</code>。注意，<code>getSuperValue()</code>方法还在 <code>SuperType.prototype</code> 对象上，而 <code>property</code> 属性则在 <code>SubType.prototype</code> 上。这是因为 <code>getSuperValue()</code>是一个原型方法，而<code>property</code> 是一个实例属性。<code>SubType.prototype</code> 现在是 <code>SuperType</code> 的一个实例，因此 <code>property</code>才会存储在它上面。还要注意，由于 <code>SubType.prototype</code> 的 <code>constructor</code> 属性被重写为指向<code>SuperType</code>，所以<code> instance.constructor</code> 也指向 <code>SuperType</code>。</strong></p><p>原型链扩展了前面描述的原型搜索机制。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。对前面的例子而言，调用 <code>instance.getSuperValue()</code>经过了 3 步搜索：<code>instance</code>、<code>SubType.prototype</code> 和 <code>SuperType.prototype</code>，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。</p><ol><li><p>默认原型</p><p>实际上，原型链中还有一环。<strong>默认情况下，所有引用类型都继承自 <code>Object</code>，这也是通过原型链实现的。任何函数的默认原型都是一个 <code>Object</code> 的实例，这意味着这个实例有一个内部指针指向<code>Object.prototype</code>。这也是为什么自定义类型能够继承包括 <code>toString()</code>、<code>valueOf()</code>在内的所有默认方法的原因。</strong>因此前面的例子还有额外一层继承关系。下图展示了完整的原型链：</p><p><img src="https://pvnk1u.github.io/images/PrototypeLink.PNG" alt="image-20230307160229332"></p><p><code>SubType</code> 继承 <code>SuperType</code>，而 <code>SuperType</code> 继承 <code>Object</code>。在调用 <code>instance.toString()</code>时，实际上调用的是保存在 <code>Object.prototype</code> 上的方法。</p></li><li><p>原型与继承关系</p><p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用 <code>instanceof</code> 操作符，如果一个实例的原型链中出现过相应的构造函数，则 <code>instanceof</code> 返回 true。如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SuperType</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SubType</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从技术上讲，<code>instance</code> 是 <code>Object</code>、<code>SuperType</code> 和 <code>SubType</code> 的实例，因为 <code>instance</code> 的原型链中包含这些构造函数的原型。结果就是 <code>instanceof</code> 对所有这些构造函数都返回 true。</p><p>确定这种关系的第二种方式是使用 <code>isPrototypeOf()</code>方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>关于方法</p><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，加粗的部分涉及两个方法。第一个方法 <code>getSubValue()</code>是 <code>SubType</code> 的新方法，而第二个方法 <code>getSuperValue()</code>是原型链上已经存在但在这里被遮蔽的方法。后面在 <code>SubType</code> 实例上调用 <code>getSuperValue()</code>时调用的是这个方法。而 <code>SuperType</code> 的实例仍然会调用最初的方法。重点在于上述两个方法都是在把原型赋值为 <code>SuperType</code> 的实例之后定义的。</p><p>另一个要理解的重点是，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="comment">// 通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">getSubValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">someOtherMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><p>在这段代码中，子类的原型在被赋值为 <code>SuperType</code> 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 <code>Object</code> 的实例，而不再是 <code>SuperType</code> 的实例。因此之前的原型链就断了。<code>SubType</code>和 <code>SuperType</code> 之间也没有关系了。</p></li><li><p>原型链的问题</p><p>原型链虽然是实现继承的强大工具，但它也有问题。<strong>主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。</strong>下面的例子揭示了这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>SuperType</code> 构造函数定义了一个 <code>colors</code> 属性，其中包含一个数组（引用值）。每个 <code>SuperType</code> 的实例都会有自己的 <code>colors</code> 属性，包含自己的数组。但是，当 <code>SubType</code> 通过原型继承<code>SuperType</code> 后，<code>SubType.prototype</code> 变成了 <code>SuperType</code> 的一个实例，因而也获得了自己的 <code>colors</code>属性。这类似于创建了 <code>SubType.prototype.colors</code> 属性。最终结果是，<code>SubType</code> 的所有实例都会共享这个 <code>colors</code> 属性。这一点通过 <code>instance1.colors</code> 上的修改也能反映到 <code>instance2.colors</code>上就可以看出来。</p><p>原型链的第二个问题是，<strong>子类型在实例化时不能给父类型的构造函数传参。事实上，无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</strong></p></li></ol><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（<code>constructor stealing</code>）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用<code>apply()</code>和 <code>call()</code>方法以新创建的对象为上下文执行构造函数。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继承 SuperType</span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例中的代码展示了盗用构造函数的调用。通过使用 <code>call()</code>（或 <code>apply()</code>）方法，<code>SuperType</code>构造函数在为 <code>SubType</code> 的实例创建的新对象的上下文中执行了。这相当于新的 <code>SubType </code>对象上运行了<code>SuperType()</code>函数中的所有初始化代码。结果就是每个实例都会有自己的 <code>colors </code>属性。</strong></p><ol><li><p>传递参数</p><p>相比于使用原型链，<strong>盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继承 SuperType 并传参</span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>SuperType</code> 构造函数接收一个参数 <code>name</code>，然后将它赋值给一个属性。在 <code>SubType</code>构造函数中调用 <code>SuperType</code> 构造函数时传入这个参数，实际上会在 <code>SubType</code> 的实例上定义 <code>name</code> 属性。为确保 <code>SuperType</code> 构造函数不会覆盖 <code>SubType</code> 定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。</p></li><li><p>盗用构造函数的问题</p><p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：<strong>必须在构造函数中定义方法，因此函数不能重用。</strong> <strong>此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</strong></p></li></ol><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。<strong>基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</strong>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Greg&quot;;</span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>SuperType</code> 构造函数定义了两个属性，<code>name</code> 和 <code>colors</code>，而它的原型上也定义了一个方法<code>sayName()</code>。<code>SubType</code>构造函数调用了 <code>SuperType</code> 构造函数，传入了 <code>name</code> 参数，然后又定义了自己的属性 <code>age</code>。此外，<code>SubType.prototype</code> 也被赋值为 <code>SuperType</code> 的实例。原型赋值之后，又在这个原型上添加了新方法 <code>sayAge()</code>。这样，就可以创建两个 <code>SubType</code> 实例，让这两个实例都有自己的属性，包括<code> colors</code>，同时还共享相同的方法。</p><p>组合继承弥补了原型链和盗用构造函数的不足，是 <code>JavaScript</code> 中使用最多的继承模式。而且组合继承也保留了 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code>方法识别合成对象的能力。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>2006 年，<code>Douglas Crockford</code> 写了一篇文章：《JavaScript 中的原型式继承》（“<code>Prototypal Inheritance in JavaScript</code>”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>object()</code>函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，<code>object()</code>是对传入的对象执行了一次浅复制。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p><code>Crockford</code> 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 <code>object()</code>，然后再对返回的对象进行适当修改。在这个例子中，<code>person</code> 对象定义了另一个对象也应该共享的信息，把它传给 <code>object()</code>之后会返回一个新对象。这个新对象的原型是 <code>person</code>，意味着它的原型上既有原始值属性又有引用值属性。这也意味着 <code>person.friends</code> 不仅是<code>person</code> 的属性，也会跟 <code>anotherPerson</code> 和 <code>yetAnotherPerson</code> 共享。这里实际上克隆了两个 <code>person</code>。</p><p><code>ECMAScript 5</code> 通过增加 <code>Object.create()</code>方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，<code>Object.create()</code>与这里的 <code>object()</code>方法效果相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p><code>Object.create()</code>的第二个参数与 <code>Object.defineProperties()</code>的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Greg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherPerson.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;</span></span><br></pre></td></tr></table></figure><p><strong>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</strong>。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>与原型式继承比较接近的一种继承方式是寄生式继承（<code>parasitic inheritance</code>），也是 <code>Crockford</code> 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title function_">object</span>(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>createAnother()</code>函数接收一个参数，就是新对象的基准对象。这个对象 <code>original</code>会被传给 <code>object()</code>函数，然后将返回的新对象赋值给 <code>clone</code>。接着给 <code>clone</code> 对象添加一个新方法<code>sayHi()</code>。最后返回这个对象。可以像下面这样使用 <code>createAnother()</code>函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">createAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子基于 <code>person</code> 对象返回了一个新对象。新返回的 <code>anotherPerson</code> 对象具有 <code>person</code> 的所有属性和方法，还有一个新方法叫 <code>sayHi()</code>。</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p><strong>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。</strong>本质上，<strong>子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</strong>再来看一看这个组合继承的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); <span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码执行后，<code>SubType.prototype</code>上会有两个属性：<code>name</code> 和 <code>colors</code>。它们都是 <code>SuperType</code> 的实例属性，但现在成为了 <code>SubType</code> 的原型属性。<strong>在调用 <code>SubType</code> 构造函数时，也会调用 <code>SuperType</code> 构造函数，这一次会在新对象上创建实例属性 <code>name</code> 和 <code>colors</code>。这两个实例属性会遮蔽原型上同名的属性。</strong></p><p>上面的代码执行完之后，有两组 <code>name</code> 和 <code>colors</code> 属性：一组在实例上，另一组在 <code>SubType</code> 的原型上。这是调用两次 <code>SuperType</code> 构造函数的结果。好在有办法解决这个问题。</p><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。<strong>基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</strong>寄生式组合继承的基本模式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = subType; <span class="comment">// 增强对象</span></span><br><span class="line">subType.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>inheritPrototype()</code>函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的<code>prototype</code> 对象设置 <code>constructor</code> 属性，解决由于重写原型导致默认 <code>constructor</code> 丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用 <code>inheritPrototype()</code>就可以实现前面例子中的子类型原型赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">prototype.<span class="property">constructor</span> = subType; <span class="comment">// 增强对象</span></span><br><span class="line">subType.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只调用了一次 <code>SuperType</code> 构造函数，避免了 <code>SubType.prototype</code> 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 <code>instanceof</code> 操作符和<code>isPrototypeOf()</code>方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>前几节深入讲解了如何只使用 <code>ECMAScript 5</code> 的特性来模拟类似于类（<code>class-like</code>）的行为。不难看出，各种策略都有自己的问题，也有相应的妥协。正因为如此，实现继承的代码也显得非常冗长和混乱。</p><p>为解决这些问题，<code>ECMAScript 6</code> 新引入的 <code>class</code> 关键字具有正式定义类的能力。类（<code>class</code>）是<code>ECMAScript</code> 中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然 <code>ECMAScript 6</code> 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 <code>class</code> 关键字加大括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = <span class="keyword">class</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>与函数表达式类似，类表达式在它们被求值前也不能引用。不过，<strong>与函数定义不同的是，虽然函数声明可以提升，但类定义不能</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionExpression</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FunctionExpression</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionExpression</span>); <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionDeclaration</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassExpression</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ClassExpression</span> = <span class="keyword">class</span> &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassExpression</span>); <span class="comment">// class &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDeclaration</span> &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// class ClassDeclaration &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">FunctionDeclaration</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ClassDeclaration</span> &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br></pre></td></tr></table></figure><p><strong>类的构成：</strong></p><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。</p><p>与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例（比如，通过 <code>class Foo &#123;&#125;</code>创建实例 <code>foo</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空类定义，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有构造函数的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有获取函数的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> &#123;</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有静态方法的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qux</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">myQux</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">PersonName</span> &#123;</span><br><span class="line">    <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>, <span class="title class_">PersonName</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">identify</span>(); <span class="comment">// PersonName PersonName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">// PersonName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PersonName</span>); <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><p><code>constructor</code> 关键字用于在类定义块内部创建类的构造函数。方法名 <code>constructor</code> 会告诉解释器在使用 <code>new</code> 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p><ol><li><p>实例化</p><p>使用 <code>new</code> 操作符实例化 <code>Person</code> 的操作等于使用 <code>new</code> 调用其构造函数。唯一可感知的不同之处就是，<code>JavaScript</code> 解释器知道使用 <code>new</code> 和类意味着应该使用 <code>constructor</code> 函数进行实例化。</p><p>使用 new 调用类的构造函数会执行如下操作。</p><ul><li>在内存中创建一个新对象</li><li>这个新对象内部的<code>[[Prototype]]</code>指针被赋值为构造函数的prototype属性。</li><li>构造函数内部的this被赋值为这个新对象（即this指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ul><p>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person ctor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person ctor</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vegetable</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="property">color</span>); <span class="comment">// orange</span></span><br></pre></td></tr></table></figure><p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jake&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3.<span class="property">name</span>); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure><p>默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 <code>instanceof</code> 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">override</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (override) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">bar</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(),</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// Person&#123; foo: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 <code>new</code> 操作符。而普通构造函数如果不使用 <code>new</code> 调用，那么就会以全局的 <code>this</code>（通常是 <code>window</code>）作为内部对象。调用类构造函数时如果忘了使用 <code>new</code> 则会抛出错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 window 作为 this 来构建实例</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法（但作为类构造函数，仍然要使用 <code>new</code> 调用）。因此，实例化之后可以在实例上引用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 使用类创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="comment">// 使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure></li><li><p>把类当成特殊函数</p></li></ol><p>   <code>ECMAScript</code> 中没有正式的类这个类型。从各方面来看，<code>ECMAScript</code> 类就是一种特殊函数。声明一个类之后，通过 <code>typeof</code> 操作符检测类标识符，表明它是一个函数：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>); <span class="comment">// class Person &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p>   类标识符有 <code>prototype</code> 属性，而这个原型也有一个 <code>constructor</code> 属性指向类自身：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123; constructor: f() &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>   与普通构造函数一样，可以使用<code>instanceof</code> 操作符检查构造函数原型是否存在于实例的原型链中:</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>   由此可知，可以使用  <code>instanceof</code> 操作符检查一个对象与类构造函数，以确定这个对象是不是类的实例。只不过此时的类构造函数要使用类标识符，比如，在前面的例子中要检查 <code>p</code> 和 <code>Person</code>。</p><p>   如前所述，类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用 <code>new</code> 调用时就会被当成构造函数。重点在于，类中定义的 <code>constructor</code> 方法不会被当成构造函数，在对它使用<code>instanceof</code> 操作符时会返回 false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 <code>instanceof</code> 操作符的返回值会反转：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>   类是 <code>JavaScript</code> 的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line">    <span class="keyword">class</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`instance <span class="subst">$&#123;<span class="variable language_">this</span>.id_&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">classDefinition, id</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">classDefinition</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="title function_">createInstance</span>(classList[<span class="number">0</span>], <span class="number">3141</span>); <span class="comment">// instance 3141</span></span><br></pre></td></tr></table></figure><p>   与立即调用函数表达式相似，类也可以立即实例化：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为是一个类表达式，所以类名是可选的</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p); <span class="comment">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p><ol><li><p>实例成员</p><p>每次通过<code>new</code> 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（<code>this</code>）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。</p><p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 这个例子先使用对象包装类型定义一个字符串</span></span><br><span class="line">        <span class="comment">// 为的是在下面测试两个对象的相等性</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(),</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">sayName</span>(); <span class="comment">// Jack</span></span><br><span class="line">p2.<span class="title function_">sayName</span>(); <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span> === p2.<span class="property">name</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">sayName</span> === p2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">nicknames</span> === p2.<span class="property">nicknames</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = p1.<span class="property">nicknames</span>[<span class="number">0</span>];</span><br><span class="line">p2.<span class="property">name</span> = p2.<span class="property">nicknames</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">sayName</span>(); <span class="comment">// Jake</span></span><br><span class="line">p2.<span class="title function_">sayName</span>(); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure></li><li><p>原型方法与访问器</p><p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">    <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">locate</span>(); <span class="comment">// instance</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>(); <span class="comment">// prototype</span></span><br></pre></td></tr></table></figure><p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token</span></span><br></pre></td></tr></table></figure><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="title class_">Symbol</span>(<span class="string">&#x27;symbolKey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">stringKey</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoked stringKey&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [symbolKey]() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoked symbolKey&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="string">&#x27;computed&#x27;</span> + <span class="string">&#x27;Key&#x27;</span>]() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoked computedKey&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">stringKey</span>(); <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey](); <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.<span class="title function_">computedKey</span>(); <span class="comment">// invoked computedKey</span></span><br></pre></td></tr></table></figure><p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name_</span> = newName;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure></li><li><p>静态类方法</p><p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。</p><p>静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">    <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prototype&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义在类本身上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">locate</span>(); <span class="comment">// instance, Person &#123;&#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>(); <span class="comment">// prototype, &#123;constructor: ... &#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">locate</span>(); <span class="comment">// class, class Person &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>静态类方法非常适合作为实例工厂：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age_</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age_</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 使用随机年龄创建并返回一个 Person 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">create</span>()); <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>非函数原型和类成员</p><p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">greeting</span> = <span class="string">&#x27;My name is&#x27;</span>;</span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">sayName</span>(); <span class="comment">// My name is Jake</span></span><br></pre></td></tr></table></figure><p>类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 this引用的数据。</p></li><li><p>迭代器与生成器方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">    *<span class="title function_">createNicknameIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">    <span class="keyword">static</span> *<span class="title function_">createJobIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Candlestick maker&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jobIter = <span class="title class_">Person</span>.<span class="title function_">createJobIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Butcher</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Baker</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Candlestick maker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.<span class="title function_">createNicknameIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Jake</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> *<span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><p>也可以只返回迭代器实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>本章前面花了大量篇幅讨论如何使用 <code>ES5</code> 的机制实现继承。<code>ECMAScript 6</code> 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p><ol><li><p>继承基础</p><p><code>ES6</code> 类支持单继承。使用 <code>extends</code> 关键字，就可以继承任何拥有<code>[[Construct]]</code>和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bus</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> <span class="title class_">Engineer</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">Engineer</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">identifyPrototype</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">identifyClass</span>(<span class="params">id</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">identifyPrototype</span>(<span class="string">&#x27;bus&#x27;</span>); <span class="comment">// bus, Bus &#123;&#125;</span></span><br><span class="line">v.<span class="title function_">identifyPrototype</span>(<span class="string">&#x27;vehicle&#x27;</span>); <span class="comment">// vehicle, Vehicle &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identifyClass</span>(<span class="string">&#x27;bus&#x27;</span>); <span class="comment">// bus, class Bus &#123;&#125;</span></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="title function_">identifyClass</span>(<span class="string">&#x27;vehicle&#x27;</span>); <span class="comment">// vehicle, class Vehicle &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><code>extends</code> 关键字也可以在类表达式中使用，因此 <code>let Bar = class extends Foo &#123;&#125;</code>是有效的语法。</p></li><li><p>构造函数、HomeObject和super()</p><p><strong>派生类的方法可以通过 <code>super</code> 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部</strong>。在类构造函数中使用 <code>super</code> 可以调用父类构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasEngine</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 不要在调用 super()之前引用 this，否则会抛出 ReferenceError</span></span><br><span class="line">        <span class="variable language_">super</span>(); <span class="comment">// 相当于 super.constructor()</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br></pre></td></tr></table></figure><p>在静态方法中可以通过 super 调用继承的类上定义的静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;vehicle&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">identify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identify</span>(); <span class="comment">// vehicle</span></span><br></pre></td></tr></table></figure><p>在使用 super 时要注意几个问题。</p><ul><li><p>super 只能在派生类构造函数和静态方法中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>);</span><br><span class="line">        <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用 super()会调用父类构造函数，并将返回的实例赋值给 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">licensePlate</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">licensePlate</span> = licensePlate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">licensePlate</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(licensePlate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">licensePlate</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">licensePlate</span> = licensePlate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在类构造函数中，不能在调用 super()之前引用 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class</span></span><br><span class="line"><span class="comment">// before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure></li><li><p>如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Van</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Car</span>()); <span class="comment">// Car &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>()); <span class="comment">// Bus &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Van</span>()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>抽象基类</p><p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 <code>ECMAScript</code> 没有专门支持这种类的语法 ，但通过 <code>new.target</code> 也很容易实现。<code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数。通过在实例化时检测 <code>new.target</code> 是不是抽象基类，可以阻止对抽象基类的实例化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vehicle</span>(); <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure><p>另外，<strong>通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">foo</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line"><span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Van</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Van</span>(); <span class="comment">// Error: Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure></li><li><p>继承内置类型</p><p><code>ES6</code> 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">    <span class="title function_">shuffle</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 洗牌算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">            [<span class="variable language_">this</span>[i], <span class="variable language_">this</span>[j]] = [<span class="variable language_">this</span>[j], <span class="variable language_">this</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.<span class="title function_">shuffle</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3, 1, 4, 5, 2]</span></span><br></pre></td></tr></table></figure><p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果想覆盖这个默认行为，则可以覆盖 <code>Symbol.species</code> 访问器，这个访问器决定在创建返回的实例时使用的类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>类混入</p><p>把不同类的行为集中到一个类是一种常见的 <code>JavaScript</code> 模式。虽然 <code>ES6</code> 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。</p><p>注意：<code>Object.assign()</code>方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用<code>Object.assign()</code>就可以了。</p><p>在下面的代码片段中，<code>extends</code> 关键字后面是一个 <code>JavaScript</code> 表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。这个表达式会在求值类定义时被求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getParentClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;evaluated expression&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Vehicle</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">getParentClass</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 可求值的表达式</span></span><br></pre></td></tr></table></figure><p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。如果 Person 类需要组合 A、B、C，则需要某种机制实现 B 继承 A，C 继承 B，而 Person再继承 C，从而把 A、B、C 组合到这个超类中。实现这种模式有不同的策略。</p><p>一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FooMixin</span>(<span class="title class_">BarMixin</span>(<span class="title class_">BazMixin</span>(<span class="title class_">Vehicle</span>))) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line">b.<span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>(); <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>通过写一个辅助函数，可以把嵌套调用展开：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">BaseClass, ...Mixins</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Mixins</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> <span class="title function_">current</span>(accumulator), <span class="title class_">BaseClass</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mix</span>(<span class="title class_">Vehicle</span>, <span class="title class_">FooMixin</span>, <span class="title class_">BarMixin</span>, <span class="title class_">BazMixin</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line">b.<span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>(); <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>注意：很多 <code>JavaScript</code> 框架（特别是 <code>React</code>）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（<code>composition over inheritance</code>）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;ECMA-262&lt;/code&gt;将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把 &lt;code&gt;ECMAScript&lt;/code</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(5)——迭代器与生成器</title>
    <link href="http://pvnk1u.github.io/2023/02/07/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://pvnk1u.github.io/2023/02/07/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2023-02-07T07:11:39.000Z</published>
    <updated>2023-11-27T15:34:23.881Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发领域，“迭代” 的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。<code>ECMAScript 6</code> 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。</p><h1 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h1><p>在JavaScript 中，计数循环就是一种最简单的迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循 环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。</p><p>迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是<code>JavaScript</code>中有序集合的最典型例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; collection.<span class="property">length</span>; ++index) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(collection[index]); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。 由于如下原因，通过这种循环来执行例程并不理想。</p><ol><li><p><strong>迭代之前需要事先知道如何使用数据结构</strong></p><p>数组中的每一项都只能先通过引用取得数组对象， 然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。</p></li><li><p><strong>遍历顺序并不是数据结构固有的</strong></p><p>通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。</p></li></ol><p><code>ES5</code> 新增了 <code>Array.prototype.forEach()</code>方法，向通用迭代需求迈进了一步（但仍然不够理想）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line">collection.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item));</span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>这个方法解决了单独记录索引和通过数组对象取得值的问题。<strong>不过，没有办法标识迭代何时终止。 因此这个方法只适用于数组，而且回调结构也比较笨拙。</strong></p><p> 在 <code>ECMAScript</code> 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其他很多语言都对这个模式提供了完备的支持。<code>JavaScript</code> 在 <code>ECMAScript 6</code> 以后也支持了迭代器模式。</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（特别是在 <code>ECMAScript</code> 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（<code>iterable</code>），因为它们实现了正式的 <code>Iterable</code> 接口，而且可以通过迭代器 <code>Iterator</code> 消费。</p><p>可迭代对象是一种抽象的说法。<strong>基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的元素是有限的</span></span><br><span class="line"><span class="comment">// 递增索引可以按序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="comment">// 集合的元素是有限的</span></span><br><span class="line"><span class="comment">// 可以按插入顺序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">3</span>).<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>不过，<strong>可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构</strong>，比如开头提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。</p><p>任何实现 <code>Iterable</code> 接口的数据结构都可以被实现 <code>Iterator</code> 接口的结构“消费”（<code>consume</code>）。迭代器（<code>iterator</code>）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 <code>API</code>。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是 <code>Iterable</code> 和 <code>Iterator</code> 的强大之处。</p><h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p>实现 <code>Iterable</code> 接口（可迭代协议）要求同时具备两种能力：<strong>支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力</strong>。在 <code>ECMAScript</code>中，这意味着必须暴露一个属性作为“默认迭代器”，而 且这个属性必须使用特殊的 <code>Symbol.iterator</code> 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p><p>很多内置类型都实现了 <code>Iterable</code> 接口：</p><ol><li>字符串</li><li>数组</li><li>映射</li><li>集合</li><li>arguments对象</li><li>NodeList等DOM集合模型</li></ol><p>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;; </span><br><span class="line"><span class="comment">// 这两种类型没有实现迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>).<span class="title function_">set</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> els = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="comment">// 这些类型都实现了迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="comment">// 调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// StringIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// ArrayIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// MapIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// SetIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器</strong>。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：</p><ol><li><code>for-of</code> 循环</li><li>数组解构</li><li>扩展操作符</li><li><code>Array.from()</code></li><li>创建集合</li><li>创建映射</li><li><code>Promise.all()</code>接收由期约组成的可迭代对象</li><li><code>Promise.race()</code>接收由期约组成的可迭代对象</li><li><code>yield*</code>操作符，在生成器中使用</li></ol><p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="comment">// for-of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> arr) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(el); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// foo, bar, baz </span></span><br><span class="line"><span class="comment">// 扩展操作符</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] </span></span><br><span class="line"><span class="comment">// Array.from() </span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] </span></span><br><span class="line"><span class="comment">// Set 构造函数</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set(3) &#123;&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 构造函数</span></span><br><span class="line"><span class="keyword">let</span> pairs = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">x, i</span>) =&gt;</span> [x, i]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pairs); <span class="comment">// [[&#x27;foo&#x27;, 0], [&#x27;bar&#x27;, 1], [&#x27;baz&#x27;, 2]] </span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(pairs); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(3) &#123; &#x27;foo&#x27;=&gt;0, &#x27;bar&#x27;=&gt;1, &#x27;baz&#x27;=&gt;2 &#125; </span></span><br></pre></td></tr></table></figure><p>如果对象原型链上的父类实现了 <code>Iterable</code> 接口，那这个对象也就实现了这个接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> fooArr = <span class="keyword">new</span> <span class="title class_">FooArray</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> fooArr) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(el); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 <code>API</code> 使用 <code>next()</code>方法 在可迭代对象中遍历数据。每次成功调用 <code>next()</code>，都会返回一个 <code>IteratorResult</code>对象，其中包含迭代器返回的下一个值。若不调用 <code>next()</code>，则无法知道迭代器的当前位置。</p><p><code>next()</code>方法返回的迭代器对象 <code>IteratorResult</code> 包含两个属性：<code>done</code> 和 <code>value</code>。<code>done</code> 是一个布尔值，表示是否还可以再次调用 <code>next()</code>取得下一个值；<code>value</code> 包含可迭代对象的下一个值（<code>done</code> 为 <code>false</code>），或者 <code>undefined</code>（<code>done</code> 为 <code>true</code>）。<code>done: true</code> 状态称为“耗尽”。可以通过以下简单的数组来演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter); <span class="comment">// ArrayIterator &#123;&#125; </span></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><p>这里通过创建迭代器并调用<code>next()</code>方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 <code>done: true</code> 状态， 后续调用 <code>next()</code>就一直返回同样的值了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><p><strong>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系</strong>，只会独立地遍历可迭代对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="keyword">let</span> iter2 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p><strong>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;baz&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><p><strong>需要注意的是，迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象</strong>。</p><p>“迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型。下面的例子比较了一个显式的迭代器实现和一个原生的迭代器实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类实现了可迭代接口（Iterable） </span></span><br><span class="line"><span class="comment">// 调用默认的迭代器工厂函数会返回</span></span><br><span class="line"><span class="comment">// 一个实现迭代器接口（Iterator）的迭代器对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">return</span> &#123; </span><br><span class="line"> <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="comment">// 打印出实现了迭代器接口的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// &#123; next: f() &#123;&#125; &#125; </span></span><br><span class="line"><span class="comment">// Array 类型实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用 Array 类型的默认迭代器工厂函数</span></span><br><span class="line"><span class="comment">// 会创建一个 ArrayIterator 的实例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"><span class="comment">// 打印出 ArrayIterator 的实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Array Iterator &#123;&#125; </span></span><br></pre></td></tr></table></figure><h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>与 <code>Iterable</code> 接口类似，任何实现 <code>Iterator</code> 接口的对象都可以作为迭代器使用。下面这个例子中 的 Counter 类只能被迭代一定的次数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123; </span><br><span class="line">     <span class="comment">// Counter 的实例应该迭代 limit 次</span></span><br><span class="line">     <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123; </span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>; </span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">limit</span> = limit; </span><br><span class="line">  &#125; </span><br><span class="line">     <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">         <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &lt;= <span class="variable language_">this</span>.<span class="property">limit</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++ &#125;; </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>这个类实现了 <code>Iterator</code> 接口，但不理想。<strong>因为它的每个实例只能被迭代一次</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// (nothing logged) </span></span><br></pre></td></tr></table></figure><p>为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此， 可以把计数器变量放到闭包里，然后通过闭包返回迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">limit</span> = limit; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">     <span class="keyword">let</span> count = <span class="number">1</span>, </span><br><span class="line">     limit = <span class="variable language_">this</span>.<span class="property">limit</span>; </span><br><span class="line">     <span class="keyword">return</span> &#123; </span><br><span class="line">         <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (count &lt;= limit) &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">             &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>每个以这种方式创建的迭代器也实现了 <code>Iterable</code> 接口。<code>Symbol.iterator</code> 属性引用的工厂函数会返回相同的迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="keyword">let</span> iter2 = iter1[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1 === iter2); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>因为每个迭代器也实现了 <code>Iterable</code> 接口，所以它们可以用在任何期待可迭代对象的地方，比如 <code>for-of</code> 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item); &#125; </span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iter ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item); &#125; </span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br></pre></td></tr></table></figure><h3 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h3><p>可选的 <code>return()</code>方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知 道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：</p><ol><li><code>for-of</code> 循环通过 <code>break</code>、<code>continue</code>、<code>return</code> 或 <code>throw</code> 提前退出；</li><li>解构操作并未消费所有值。</li></ol><p><code>return()</code>方法必须返回一个有效的 <code>IteratorResult</code> 对象。简单情况下，可以只返回<code>&#123; done: true &#125;</code>。 因为这个返回值只会用在生成器的上下文中，所以本章后面再讨论这种情况。</p><p>如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用 <code>return()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">limit</span> = limit; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">     <span class="keyword">let</span> count = <span class="number">1</span>, </span><br><span class="line">     limit = <span class="variable language_">this</span>.<span class="property">limit</span>; </span><br><span class="line">     <span class="keyword">return</span> &#123; </span><br><span class="line">         <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (count &lt;= limit) &#123; </span><br><span class="line">             <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">             <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; </span><br><span class="line">             &#125; </span><br><span class="line">         &#125;, </span><br><span class="line">         <span class="keyword">return</span>() &#123; </span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting early&#x27;</span>); </span><br><span class="line">             <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// Exiting early </span></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="string">&#x27;err&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// Exiting early </span></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3; </span><br><span class="line"><span class="comment">// Exiting early </span></span><br></pre></td></tr></table></figure><p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br></pre></td></tr></table></figure><p>因为 <code>return()</code>方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭， 可以测试这个迭代器实例的 <code>return</code> 属性是不是函数对象。<strong>不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的</strong>。这是因为调用 <code>return()</code>不会强制迭代器进入关闭状态。即便如此，<code> return()</code>方法还是会被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line">iter.<span class="property">return</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting early&#x27;</span>); </span><br><span class="line">     <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">     <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">     <span class="keyword">break</span> </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是 <code>ECMAScript 6</code> 新增的一个极为灵活的结构，<strong>拥有在一个函数块内暂停和恢复代码执行的能力</strong>。这种新能力具有深远的影响，比如，<strong>使用生成器可以自定义迭代器和实现协程</strong>。</p><h3 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h3><p><strong>生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器</strong>。只要是可以定义函数的地方，就可以定义生成器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="keyword">function</span>* () &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; </span><br><span class="line"> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line"> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识生成器函数的星号不受两侧空格的影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的生成器函数： </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFnA</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFnB</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFnC</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="comment">// 等价的生成器方法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line"> *<span class="title function_">generatorFnD</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"> * <span class="title function_">generatorFnE</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（<code>suspended</code>）的状态。<strong>与迭代器相似，生成器对象也实现了 <code>Iterator</code> 接口，因此具有 <code>next()</code>方法。调用这个方法会让生成器开始或恢复执行。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// f next() &#123; [native code] &#125; </span></span><br></pre></td></tr></table></figure><p><code>next()</code>方法的返回值类似于迭代器，有一个 <code>done</code> 属性和一个 <code>value</code> 属性。函数体为空的生成器函数中间不会停留，调用一次 <code>next()</code>就会让生成器到达 <code>done: true</code> 状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><p><code>value</code> 属性是生成器函数的返回值，默认值为 <code>undefined</code>，可以通过生成器函数的返回值指定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: &#x27;foo&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p><strong>生成器函数只会在初次调用 <code>next()</code>方法后开始执行</strong>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line">generatorObject.<span class="title function_">next</span>(); <span class="comment">// foobar</span></span><br></pre></td></tr></table></figure><p>生成器对象实现了<code>Iterable</code> 接口，它们默认的迭代器是自引用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorFn); </span><br><span class="line"><span class="comment">// f* generatorFn() &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]);</span><br><span class="line"><span class="comment">// f [Symbol.iterator]() &#123;native code&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()); </span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); </span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g === g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); </span><br><span class="line"><span class="comment">// true </span></span><br></pre></td></tr></table></figure><h3 id="通过yield中断执行"><a href="#通过yield中断执行" class="headerlink" title="通过yield中断执行"></a>通过yield中断执行</h3><p><code>yield</code> 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 <code>yield</code> 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 <code>next()</code>方法来恢复执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><p>此时的<code>yield</code> 关键字有点像函数的中间返回语句，它生成的值会出现在 <code>next()</code>方法返回的对象里。 <strong>通过 <code>yield</code> 关键字退出的生成器函数会处在 <code>done: false</code> 状态；通过 <code>return</code> 关键字退出的生成器函 数会处于 <code>done: true</code> 状态。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: &#x27;baz&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p><strong>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 <code>next()</code> 不会影响其他生成器</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject1 = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="keyword">let</span> generatorObject2 = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p><strong><code>yield</code> 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。</strong>类似函数的 <code>return</code> 关键字，<code>yield</code> 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">validGeneratorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">invalidGeneratorFnA</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">invalidGeneratorFnB</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">invalidGeneratorFnC</span>(<span class="params"></span>) &#123; </span><br><span class="line"> (<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125;)(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li><p>生成器对象作为可迭代对象</p><p>在生成器对象上显式调用 <code>next()</code>方法的用处并不大。其实，如果把生成器对象当成可迭代对象， 那么使用起来会更方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>在需要自定义迭代对象时，这样使用生成器对象会特别有用</strong>。比如，需要定义一个可迭代对象， 而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123; </span><br><span class="line">     <span class="keyword">while</span>(n--) &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// foo </span></span><br></pre></td></tr></table></figure><p><strong>传给生成器的函数可以控制迭代循环的次数。在 n 为 0 时，while 条件为假，循环退出，生成器函数返回。</strong></p></li><li><p>使用yield实现输入和输出</p><p>除了可以作为函数的中间返回语句使用，<code>yield</code> 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 <code>yield</code> 关键字会接收到传给 <code>next()</code>方法的第一个值。这里有个地方不太好理解—— 第一次调用 <code>next()</code>传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params">initial</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(initial); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// foo </span></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;baz&#x27;</span>); <span class="comment">// baz </span></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;qux&#x27;</span>); <span class="comment">// qux </span></span><br></pre></td></tr></table></figure><p><code>yield</code> 关键字可以同时用于输入和输出，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// &#123; done: true, value: &#x27;bar&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到 <code>yield</code>关键字时暂停执行并计算出要产生的值：”foo”。下一次调用 <code>next()</code>传入了”bar”，作为交给同一个 <code>yield</code> 的值。<strong>然后这个值被确定为本次生成器函数要返回的值</strong>。</p><p><code>yield</code> 关键字并非只能使用一次。比如，以下代码就定义了一个无穷计数生成器函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;;++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> i; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 5 </span></span><br><span class="line">... </span><br></pre></td></tr></table></figure><p>假设想定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个 新数组可以实现这个需求，但不用数组也可以实现同样的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> i; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>另外，使用 <code>while</code> 循环也可以，而且代码稍微简洁一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(n--) &#123; </span><br><span class="line"> <span class="keyword">yield</span> i++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>这样使用生成器也可以实现范围和填充数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">range</span>(<span class="params">start, end</span>) &#123; </span><br><span class="line"> <span class="keyword">while</span>(end &gt; start) &#123; </span><br><span class="line"> <span class="keyword">yield</span> start++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">4</span>, <span class="number">7</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">zeroes</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">while</span>(n--) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">zeroes</span>(<span class="number">8</span>))); <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure></li><li><p>产生可迭代对象</p><p>可以使用星号增强 <code>yield</code> 的行为，让它能够迭代一个<strong>可迭代对象</strong>，<strong>从而一次产出一个值</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的 generatorFn： </span></span><br><span class="line"><span class="comment">// function* generatorFn() &#123; </span></span><br><span class="line"><span class="comment">//  for (const x of [1, 2, 3]) &#123; </span></span><br><span class="line"><span class="comment">// yield x; </span></span><br><span class="line"><span class="comment">//  &#125; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>与生成器函数的星号类似，<code>yield</code> 星号两侧的空格不影响其行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]; </span><br><span class="line"> <span class="keyword">yield</span> *[<span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"> <span class="keyword">yield</span> * [<span class="number">5</span>, <span class="number">6</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br></pre></td></tr></table></figure><p><strong>因为 <code>yield*</code>实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把 <code>yield</code> 放到一个循环里没什么不同</strong>。下面两个生成器函数的行为是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFnA</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFnA</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFnB</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFnB</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>yield*</code>的值是关联迭代器返回 <code>done: true</code> 时的 <code>value</code> 属性。对于普通迭代器来说，这个值是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value: 1 </span></span><br><span class="line"><span class="comment">// value: 2 </span></span><br><span class="line"><span class="comment">// value: 3 </span></span><br><span class="line"><span class="comment">// iter value: undefined </span></span><br></pre></td></tr></table></figure><p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">innerGeneratorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outerGeneratorFn</span>(<span class="params">genObj</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* <span class="title function_">innerGeneratorFn</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">outerGeneratorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value: foo </span></span><br><span class="line"><span class="comment">// iter value: bar</span></span><br></pre></td></tr></table></figure></li><li><p>使用yield*实现递归算法</p><p><code>yield*</code>最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123; </span><br><span class="line">     <span class="keyword">yield</span>* <span class="title function_">nTimes</span>(n - <span class="number">1</span>); </span><br><span class="line">     <span class="keyword">yield</span> n - <span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p><strong>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。</strong></p></li></ol><h3 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h3><p><strong>因为生成器对象实现了 <code>Iterable</code> 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器， 所以生成器格外适合作为默认迭代器</strong>。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">values</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"> &#125;</span><br><span class="line"> * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">values</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> f) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>这里，<code>for-of </code>循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。 这个生成器对象是可迭代的，所以完全可以在迭代中使用。</p><h3 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h3><p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现 <code>Iterator</code> 接口的对象一定有 <code>next()</code> 方法，还有一个可选的 <code>return()</code>方法用于提前终止迭代器。<strong>生成器对象除了有这两个方法，还有第三个方法：<code>throw()</code>。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// f next() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">return</span>); <span class="comment">// f return() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">throw</span>); <span class="comment">// f throw() &#123; [native code] &#125; </span></span><br></pre></td></tr></table></figure><p><code>return()</code>和 <code>throw()</code>方法都可以用于强制生成器进入关闭状态。</p><ol><li><p>return()</p><p><code>return()</code>方法会强制生成器进入关闭状态。提供给 <code>return()</code>方法的值，就是终止迭代器对象的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125; </span></span><br></pre></td></tr></table></figure><p>与迭代器不同，所有生成器对象都有 <code>return()</code>方法，只要通过它进入关闭状态，就无法恢复了。 后续调用 <code>next()</code>会显示 <code>done: true</code> 状态，而提供的任何返回值都不会被存储或传播：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 1 &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><p><code>for-of</code> 循环等内置语言结构会忽略状态为 <code>done: true</code> 的 <code>IteratorObject</code> 内部返回的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> g) &#123; </span><br><span class="line"> <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123; </span><br><span class="line"> g.<span class="keyword">return</span>(<span class="number">4</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure></li><li><p>throw()</p><p><strong><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// foo </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125; </span></span><br></pre></td></tr></table></figure><p>不过，<strong>假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，因此在这个例子中会跳过一个值</strong>。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> x; </span><br><span class="line">     &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 1&#125; </span></span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 3&#125; </span></span><br></pre></td></tr></table></figure><p><strong>如果生成器对象还没有开始执行，那么调用 throw()抛出的错误不会在函数内部被捕获</strong>，因为这相当于在函数块外部抛出了错误。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。<strong>任何实现 <code>Iterable</code> 接口的对象都有一个 <code>Symbol.iterator</code> 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现 <code>Iterator</code> 接口的对象</strong>。</p><p>迭代器必须通过连续调用 <code>next()</code>方法才能连续取得值，这个方法返回一个 <code>IteratorObject</code>。这 个对象包含一个 <code>done</code> 属性和一个 <code>value</code> 属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用 <code>next()</code>方法来消费，也可以通过原生消费者，比如 <code>for-of</code> 循环来自动消费。</p><p><strong>生成器是一种特殊的函数，调用之后会返回一个生成器对象</strong>。<strong>生成器对象实现了 <code>Iterable </code>接口， 因此可用在任何消费可迭代对象的地方</strong>。生成器的独特之处在于支持 <code>yield</code> 关键字，这个关键字能够暂停执行生成器函数。<strong>使用 <code>yield</code> 关键字还可以通过 <code>next()</code>方法接收输入和产生输出。在加上星号之 后，&#96;yield 关键字可以将跟在它后面的可迭代对象序列化为一连串值</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件开发领域，“迭代” 的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。&lt;code&gt;ECMAScript 6&lt;/code&gt; 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。&lt;/p&gt;
&lt;h1 id=&quot;理解迭代&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(4)——集合引用类型</title>
    <link href="http://pvnk1u.github.io/2022/09/07/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://pvnk1u.github.io/2022/09/07/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-09-06T20:32:39.000Z</published>
    <updated>2023-11-27T15:34:23.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>到目前为止，大多数引用值的示例使用的是 <code>Object</code> 类型。<code>Object</code> 是 <code>ECMAScript</code> 中最常用的类型之一。虽然 <code>Object</code> 的实例没有多少功能，但很适合存储和在应用程序间交换数据。</p><p>显式地创建 <code>Object</code> 的实例有两种方式。第一种是使用 <code>new</code> 操作符和 <code>Object</code> 构造函数，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>; </span><br></pre></td></tr></table></figure><p>另一种方式是使用对象字面量（<code>object literal</code>）表示法。对象字面量是对象定义的简写形式，目的是 为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 <code>person</code> 对象，但使 用的是对象字面量表示法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; <span class="comment">// 与 new Object()相同</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>; </span><br></pre></td></tr></table></figure><p>虽然使用哪种方式创建 <code>Object</code> 实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这 是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给 函数传递大量可选参数的主要方式，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayInfo</span>(<span class="params">args</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> output = <span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.<span class="property">name</span> == <span class="string">&quot;string&quot;</span>)&#123; </span><br><span class="line"> output += <span class="string">&quot;Name: &quot;</span> + args.<span class="property">name</span> + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.<span class="property">age</span> == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line"> output += <span class="string">&quot;Age: &quot;</span> + args.<span class="property">age</span> + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">alert</span>(output); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">displayInfo</span>(&#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">displayInfo</span>(&#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Greg&quot;</span> </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&quot;name&quot;</span>]); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p>从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性， 就像下面这个例子中一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&quot;name&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[propertyName]); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字&#x2F;保留字时，也可以使用中 括号语法。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为”first name”中包含一个空格，所以不能使用点语法来访问。不过，属性名中是可以包含非 字母数字字符的，这时候只要用中括号语法存取它们就行了。</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>除了 <code>Object</code>，<code>Array</code> 应该就是 <code>ECMAScript</code> 中最常用的类型了。<code>ECMAScript</code> 数组跟其他编程语言 的数组有很大区别。跟其他语言中的数组一样，<code>ECMAScript</code> 数组也是一组有序的数据，但跟其他语言 不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素 是字符串，第二个元素是数值，第三个是对象。<code>ECMAScript</code> 数组也是动态大小的，会随着数据添加而自动增长。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>有几种基本的方式可以创建数组。一种是使用 <code>Array</code> 构造函数，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br></pre></td></tr></table></figure><p>如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 <code>length</code> 属性就会被自动创 建并设置为这个值。比如，下面的代码会创建一个初始 <code>length </code>为 20 的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>); </span><br></pre></td></tr></table></figure><p>也可以给 <code>Array</code> 构造函数传入要保存的元素。比如，下面的代码会创建一个包含 3 个字符串值的 数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>); </span><br></pre></td></tr></table></figure><p>在使用 Array 构造函数时，也可以省略 new 操作符。结果是一样的。</p><p>另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以 逗号分隔的元素列表，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 创建一个包含 2 个元素的数组</span></span><br></pre></td></tr></table></figure><p><code>Array</code> 构造函数还有两个 <code>ES6</code> 新增的用于创建数组的静态方法：<code>from()</code>和 <code>of()</code>。<code>from()</code>用于将 类数组结构转换为数组实例，而 <code>of()</code>用于将一组参数转换为数组实例。</p><p><code>Array.from()</code>的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 <code>length</code> 属性 和可索引元素的结构。这种方式可用于很多场合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] </span></span><br><span class="line"><span class="comment">// 可以使用 from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">1</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">2</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">3</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(m)); <span class="comment">// [[1, 2], [3, 4]] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(s)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="title function_">alert</span>(a1 === a2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123; </span><br><span class="line"> *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arguments 对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArgsArray</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getArgsArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; </span><br><span class="line"> <span class="number">0</span>: <span class="number">1</span>, </span><br><span class="line"> <span class="number">1</span>: <span class="number">2</span>, </span><br><span class="line"> <span class="number">2</span>: <span class="number">3</span>, </span><br><span class="line"> <span class="number">3</span>: <span class="number">4</span>, </span><br><span class="line"> <span class="attr">length</span>: <span class="number">4</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLikeObject)); <span class="comment">// [1, 2, 3, 4] </span></span><br></pre></td></tr></table></figure><p><code>Array.from()</code>还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像 调用 <code>Array.from().map()</code>那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函 数中 <code>this</code> 的值。但这个重写的 <code>this</code> 值在箭头函数中不适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x**<span class="variable language_">this</span>.<span class="property">exponent</span>&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 4, 9, 16] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3); <span class="comment">// [1, 4, 9, 16] </span></span><br></pre></td></tr></table></figure><p><code>Array.of()</code>可以把一组参数转换为数组。这个方法用于替代在 <code>ES6</code>之前常用的 <code>Array.prototype.slice.call(arguments)</code>，一种异常笨拙的将 <code>arguments</code> 对象转换为数组的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>一个经典的 <code>ECMAScript</code> 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 <code>instanceof</code> 操作符就足矣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123; </span><br><span class="line"> <span class="comment">// 操作数组</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用 <code>instanceof</code> 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两 个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。</p><p>为解决这个问题，<code>ECMAScript</code> 提供了 <code>Array.isArray()</code>方法。这个方法的目的就是确定一个值是 否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value))&#123; </span><br><span class="line"> <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h2><p>在 <code>ES6</code> 中，<code>Array</code> 的原型上暴露了 3 个用于检索数组内容的方法：<code>keys()</code>、<code>values()</code>和 <code>entries()</code>。<code>keys()</code>返回数组索引的迭代器，<code>values()</code>返回数组元素的迭代器，而 <code>entries()</code>返回 索引&#x2F;值对的迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过 Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">keys</span>()); </span><br><span class="line"><span class="keyword">const</span> aValues = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">values</span>()); </span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">entries</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys); <span class="comment">// [0, 1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues); <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aEntries); <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]] </span></span><br></pre></td></tr></table></figure><p>使用 <code>ES6</code> 的解构可以非常容易地在循环中拆分键&#x2F;值对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(idx); </span><br><span class="line"> <span class="title function_">alert</span>(element); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure><h2 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h2><p><code>ES6</code> 新增了两个方法：批量复制方法 <code>copyWithin()</code>，以及填充数组方法 <code>fill()</code>。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p><p>使用 <code>fill()</code>方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充 的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。 也可以将负索引想象成数组长度加上它得到的一个正索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 用 5 填充整个数组</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [5, 5, 5, 5, 5] </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">6</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 6, 6] </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1) </span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4) </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 8, 8, 8, 0]; </span></span><br><span class="line"><span class="title function_">fill</span>()静默忽略超出数组边界、零长度及方向相反的索引范围：</span><br><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];  </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 4, 4] </span></span><br></pre></td></tr></table></figure><p>与 <code>fill()</code>不同，<code>copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指 定索引开始的位置。开始索引和结束索引则与 <code>fill()</code>使用同样的计算方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] </span></span><br><span class="line"><span class="title function_">copyWithin</span>()静默忽略超出数组边界、零长度及方向相反的索引范围：</span><br><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, -<span class="number">15</span>, -<span class="number">12</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>() </span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引部分可用，复制、填充可用部分</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>) </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>前面提到过，所有对象都有 <code>toLocaleString()</code>、<code>toString()</code>和 <code>valueOf()</code>方法。其中，<code>valueOf()</code> 返回的还是数组本身。而 <code>toString()</code>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的 字符串。<strong>也就是说，对数组的每个值都会调用其 <code>toString()</code>方法，以得到最终的字符串</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toString</span>()); <span class="comment">// red,blue,green </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">valueOf</span>()); <span class="comment">// red,blue,green </span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// red,blue,green </span></span><br></pre></td></tr></table></figure><p>首先是被显式调用的 <code>toString()</code>和 <code>valueOf()</code>方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。最后一行代码直接用 <code>alert()</code>显示数组，因为 <code>alert()</code>期待字符串，所以会在后台调用数组的 <code>toString()</code>方法，从而得到跟前面一样的结果。</p><p><code>toLocaleString()</code>方法也可能返回跟<code>toString()</code>和 <code>valueOf()</code>相同的结果，但也不一定。在 调用数组的 <code>toLocaleString()</code>方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法 唯一的区别是，为了得到最终的字符串，会调用数组每个值的 <code>toLocaleString()</code>方法，而不是 <code>toString()</code>方法。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123; </span><br><span class="line"> <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person2 = &#123; </span><br><span class="line"> <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> people = [person1, person2]; </span><br><span class="line"><span class="title function_">alert</span>(people); <span class="comment">// Nicholas,Greg </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toString</span>()); <span class="comment">// Nicholas,Greg </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toLocaleString</span>()); <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure><p>这里定义了两个对象 <code>person1</code> 和 <code>person2</code>，它们都定义了 <code>toString()</code>和 <code>toLocaleString()</code>方 法，而且返回不同的值。然后又创建了一个包含这两个对象的数组 <code>people</code>。在将数组传给 <code>alert()</code>时， 输出的是”Nicholas,Greg”，这是因为会在数组每一项上调用 <code>toString()</code>方法（与下一行显式调用 <code>toString()</code>方法结果一样）。而在调用数组的 <code>toLocaleString()</code>方法时，结果变成了”Nikolaos,  Grigorios”，这是因为调用了数组每一项的 <code>toLocaleString()</code>方法。</p><p>继承的方法 <code>toLocaleString()</code>以及 <code>toString()</code>都返回数组值的逗号分隔的字符串。如果想使 用不同的分隔符，则可以使用 <code>join()</code>方法。<code>join()</code>方法接收一个参数，即字符串分隔符，返回包含所 有项的字符串。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>)); <span class="comment">// red,green,blue </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;||&quot;</span>)); <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure><p>这里在 colors 数组上调用了 join()方法，得到了与调用 <code>toString()</code>方法相同的结果。传入逗 号，结果就是逗号分隔的字符串。最后一行给 <code>join()</code> 传入了双竖线，得到了字符串 “red||green||blue”。如果不给 <code>join()</code>传入任何参数，或者传入 <code>undefined</code>，则仍然使用逗号作为分隔符。</p><p>如果数组中某一项是 <code>null</code> 或 <code>undefined</code>，则在 <code>join()</code>、<code>toLocaleString()</code>、 <code>toString()</code>和 <code>valueOf()</code>返回的结果中会以空字符串表示。</p><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p><code>ECMAScript</code> 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样， 也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就 是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个 地方发生，即栈顶。<code>ECMAScript</code> 数组提供了 <code>push()</code>和 <code>pop()</code>方法，以实现类似栈的行为。</p><p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。<code>pop()</code>方法则 用于删除数组的最后一项，同时减少数组的 <code>length</code> 值，返回被删除的项。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// black </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式 限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 <code>push() </code>方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 <code>shift()</code>，它会删除数 组的第一项并返回它，然后数组长度减 1。使用 <code>shift()</code>和 <code>push()</code>，可以把数组当成队列来使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// red </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p><code>ECMAScript</code> 也为数组提供了 <code>unshift()</code>方法。顾名思义，<code>unshift()</code>就是执行跟 <code>shift()</code>相反的 操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 <code>unshift()</code>和 <code>pop()</code>，可以在 相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// green </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>数组有两个方法可以用来对元素重新排序：<code>reverse()</code>和 <code>sort()</code>。顾名思义，<code>reverse()</code>方法就 是将数组元素反向排列。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">values.<span class="title function_">reverse</span>(); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1 </span></span><br></pre></td></tr></table></figure><p>这里，数组 values 的初始状态为[1,2,3,4,5]。通过调用 reverse()反向排序，得到了 [5,4,3,2,1]。这个方法很直观，但不够灵活，所以才有了 <code>sort()</code>方法。</p><p>默认情况下，<code>sort()</code>会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此， <code>sort()</code>会在每一项上调用 <code>String()</code>转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值， 也会先把数组转换为字符串再比较、排序。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure><p>一开始数组中数值的顺序是正确的，但调用 <code>sort()</code>会按照这些数值的字符串形式重新排序。因此， 即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情 况下都不是最合适的。为此，<code>sort()</code>方法可以接收一个比较函数，用于判断哪个值应该排在前面。</p><p>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相 等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一 个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 <code>sort()</code>方法，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(compare); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15 </span></span><br></pre></td></tr></table></figure><p>在给 <code>sort()</code>方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也可以产生降序效果，只要把返回值交换一下即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(compare); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 15,10,5,1,0 </span></span><br></pre></td></tr></table></figure><p>此外，这个比较函数还可简写为一个箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? <span class="number">1</span> : a &gt; b ? -<span class="number">1</span> : <span class="number">0</span>); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure><p><code>reverse()</code>和 <code>sort()</code>都返回调用它们的数组的引用。</p><p>如果数组的元素是数值，或者是其 <code>valueOf()</code>方法返回数值的对象（如 <code>Date</code> 对象），这个比较函 数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> value2 - value1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>比较函数就是要返回小于 0、0 和大于 0 的数值，因此减法操作完全可以满足要求。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>对于数组中的元素，有很多操作方法。比如，<code>concat()</code>方法可以在现有数组全部元素基础上 创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这 个新构建的数组。如果传入一个或多个数组，则 <code>concat()</code>会把这些数组的每一项都添加到结果数组。 如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure><p>这里先创建一个包含 3个值的数组 <code>colors</code>。然后 <code>colors</code> 调用 <code>concat()</code>方法，传入字符串”yellow” 和一个包含”black”和”brown”的数组。保存在 <code>colors2</code> 中的结果就是[“red”, “green”, “blue”,  “yellow”, “black”, “brown”]。原始数组 <code>colors</code> 保持不变。</p><p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcatSpreadable</code>。这个符号能够阻止 <code>concat()</code>打平参数数组。相反，把这个值设置为 true 可以强制打平 类数组对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">length</span>: <span class="number">2</span>, </span><br><span class="line"> <span class="number">0</span>: <span class="string">&quot;pink&quot;</span>, </span><br><span class="line"> <span class="number">1</span>: <span class="string">&quot;cyan&quot;</span> </span><br><span class="line">&#125;; </span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, newColors); </span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">concat</span>(moreNewColors); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;] </span></span><br></pre></td></tr></table></figure><p>接下来，方法 <code>slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。<code>slice()</code>方法可以 接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 <code>slice()</code>会返回该索引 到数组末尾的所有元素。如果有两个参数，则 <code>slice()</code>返回从开始索引到结束索引对应的所有元素，<strong>其中不包含结束索引对应的元素。记住，这个操作不影响原始数组</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line"><span class="title function_">alert</span>(colors2); <span class="comment">// green,blue,yellow,purple </span></span><br><span class="line"><span class="title function_">alert</span>(colors3); <span class="comment">// green,blue,yellow </span></span><br></pre></td></tr></table></figure><p>这里，<code>colors</code> 数组一开始有 5 个元素。调用 <code>slice()</code>传入 1 会得到包含 4 个元素的新数组。其中不包括”red”，这是因为拆分操作要从位置 1 开始，即从”green”开始。得到的 <code>colors2</code> 数组包含 “green”、”blue”、”yellow”和”purple”。<code>colors3</code> 数组是通过调用 <code>slice()</code>并传入 1 和 4 得到的， 即从位置 1 开始复制到位置 3。因此 <code>colors3</code> 包含”green”、”blue”和”yellow”。</p><p>如果 <code>slice()</code>的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比 如，在包含 5 个元素的数组上调用 slice(-2,-1)，就相当于调用 slice(3,4)。如果结 束位置小于开始位置，则返回空数组。</p><p>或许最强大的数组方法就属 <code>splice()</code>了，使用它的方式可以有很多种。<code>splice()</code>的主要目的是 在数组中间插入元素，但有 3 种不同的方式使用这个方法。</p><ol><li><p>删除</p><p>需要给 <code>splice()</code>传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从 数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。</p></li><li><p>插入</p><p>需要给 <code>splice()</code>传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多 个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串 “red”和”green”。</p></li><li><p>替换</p><p><code>splice()</code>在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位 置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量 一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始 向数组中插入”red”和”green”。</p></li></ol><p><code>splice()</code>方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返 回空数组）。以下示例展示了上述 3 种使用方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 在位置 1 插入两个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,yellow,orange,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,red,purple,orange,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h2 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h2><p><code>ECMAScript</code> 提供两类搜索数组的方法：按<strong>严格相等</strong>搜索和按<strong>断言函数</strong>搜索。</p><ol><li><p>严格相等</p><p><code>ECMAScript</code> 提供了 3 个严格相等的搜索方法：<code>indexOf()</code>、<code>lastIndexOf()</code>和 <code>includes()</code>。其中，前两个方法在所有版本中都可用，而第三个方法是 <code>ECMAScript</code> 7 新增的。这些方法都接收两个参 数：要查找的元素和一个可选的起始搜索位置。<code>indexOf()</code>和 <code>includes()</code>方法从数组前头（第一项） 开始向后搜索，而 <code>lastIndexOf()</code>从数组末尾（最后一项）开始向前搜索。</p><p><code>indexOf()</code>和 <code>lastIndexOf()</code>都返回要查找的元素在数组中的位置，如果没找到则返回-1。 <code>includes()</code>返回布尔值，表示是否至少找到一个与指定元素匹配的项。<strong>在比较第一个参数跟数组每一 项时，会使用全等（&#x3D;&#x3D;&#x3D;）比较，也就是说两项必须严格相等。</strong>下面来看一些例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>, <span class="number">7</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;]; </span><br><span class="line"><span class="keyword">let</span> morePeople = [person]; </span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">indexOf</span>(person)); <span class="comment">// -1 </span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">indexOf</span>(person)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">includes</span>(person)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">includes</span>(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>断言函数</p><p><code>ECMAScript</code> 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回 值决定了相应索引的元素是否被认为匹配。</p><p>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前 元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。 <code>find()</code>和 <code>findIndex()</code>方法使用了断言函数。这两个方法都从数组的最小索引开始。<code>find()</code>返回 第一个匹配的元素，<code>findIndex()</code>返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数， 用于指定断言函数内部 <code>this</code> 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [ </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line"> &#125; </span><br><span class="line">]; </span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125; </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p><strong>找到匹配项后，这两个方法都不再继续搜索。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]; </span><br><span class="line"><span class="comment">// 找到匹配后，永远不会检查数组的最后一个元素</span></span><br><span class="line">evens.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(element); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(index); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array); </span><br><span class="line"> <span class="keyword">return</span> element === <span class="number">4</span>; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// [2, 4, 6] </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// [2, 4, 6] </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p><code>ECMAScript</code> 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数， 以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影 响方法的返回值。数组的 5 个迭代方法如下。</p><ol><li><p>every()</p><p>对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</p></li><li><p>filter()</p><p>对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</p></li><li><p>forEach()</p><p>对数组每一项都运行传入的函数，没有返回值。</p></li><li><p>map()</p><p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</p></li><li><p>some()</p><p>对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</p></li></ol><p><strong>这些方法都不改变调用它们的数组。</strong></p><p>在这些方法中，<code>every()</code>和 <code>some()</code>是最相似的，都是从数组中搜索符合某个条件的元素。对 <code>every()</code> 来说，传入的函数必须对每一项都返回 true，它才会返回 true；否则，它就返回 false。而对 <code>some()</code> 来说，只要有一项让传入的函数返回 true，它就会返回 true。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(everyResult); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(someResult); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面再看一看 <code>filter()</code>方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(filterResult); <span class="comment">// 3,4,5,4,3 </span></span><br></pre></td></tr></table></figure><p>这里，调用 filter()返回的数组包含 3、4、5、4、3，因为只有对这些项传入的函数才返回 true。 这个方法非常适合从数组中筛选满足给定条件的元素。</p><p>接下来 <code>map()</code>方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传 入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(mapResult); <span class="comment">// 2,4,6,8,10,8,6,4,2 </span></span><br></pre></td></tr></table></figure><p>以上代码返回了一个数组，包含原始数组中每个值乘以 2 的结果。这个方法非常适合创建一个与原 始数组元素一一对应的新数组。</p><p>最后，再来看一看 <code>forEach()</code>方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，<code>forEach()</code>方法相当于使用 for 循环遍历数组。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 执行某些操作 </span></span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>数组的这些迭代方法通过执行不同操作方便了对数组的处理。</p><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p><code>ECMAScript</code> 为数组提供了两个归并方法：<code>reduce()</code>和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。<code>reduce()</code>方法从数组第一项开始遍历到最后一项。 而 <code>reduceRight()</code>从最后一项开始遍历至第一项。</p><p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。 传给 <code>reduce()</code>和 <code>reduceRight()</code>的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数 组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法 传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数 的第一个参数是数组的第一项，第二个参数是数组的第二项。</p><p>可以使用 <code>reduce()</code>函数执行累加数组中所有数值的操作，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur); </span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>第一次执行归并函数时，<code>prev</code> 是 1，<code>cur</code> 是 2。第二次执行时，<code>prev</code> 是 3（1 + 2），<code>cur</code> 是 3（数 组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。</p><p><code>reduceRight()</code>方法与之类似，只是方向相反。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduceRight</span>(<span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> prev + cur; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15 </span></span><br></pre></td></tr></table></figure><p>在这里，第一次调用归并函数时 <code>prev</code> 是 5，而 <code>cur</code> 是 4。当然，最终结果相同，因为归并操作都是简单的加法。</p><h1 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h1><p>定型数组（<code>typed array</code>）是 <code>ECMAScript</code> 新增的结构，目的是提升向原生库传输数据的效率。实际上，<code>JavaScript</code> 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。为理解如何使 用定型数组，有必要先了解一下它的用途。</p><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>随着浏览器的流行，不难想象人们会满怀期待地通过它来运行复杂的 3D 应用程序。早在 2006 年， Mozilla、Opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台， 无须安装任何插件。其目标是开发一套 <code>JavaScript API</code>，从而充分利用 3D 图形 API 和 GPU 加速，以便 在元素上渲染复杂的图形。</p><ol><li><p>WebGL</p><p>最后的 JavaScript API 是基于 OpenGL ES（OpenGL for Embedded Systems）2.0 规范的。OpenGL ES 是 OpenGL 专注于 2D 和 3D 计算机图形的子集。这个新 API 被命名为 WebGL（Web Graphics Library）， 于 2011 年发布 1.0 版。有了它，开发者就能够编写涉及复杂图形的应用程序，它会被兼容 WebGL 的浏 览器原生解释执行。</p><p>在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形 驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript 数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 绑定都需要在 目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费 很多时间。</p></li><li><p>定型数组</p><p>这当然是难以接受的，Mozilla 为解决这个问题而实现了 <code>CanvasFloatArray</code>。这是一个提供 JavaScript 接口的、C 语言风格的浮点值数组。<code>JavaScript</code> 运行时使用这个类型可以分配、读取和写入数组。 这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。最终，<code>CanvasFloatArray</code> 变成了 <code>Float32Array</code>，也就是今天定型数组中可用的第一个“类型”。</p></li></ol><h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p><code>Float32Array</code> 实际上是一种“视图”，可以允许 <code>JavaScript</code> 运行时访问一块名为 <code>ArrayBuffer</code> 的 预分配内存。<code>ArrayBuffer</code> 是所有定型数组及视图引用的基本单位。</p><p><code>ArrayBuffer()</code>是一个普通的 <code>JavaScript</code> 构造函数，可用于在内存中分配特定数量的字节空间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 在内存中分配 16 字节</span></span><br><span class="line"><span class="title function_">alert</span>(buf.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br></pre></td></tr></table></figure><p><code>ArrayBuffer</code> 一经创建就不能再调整大小。不过，可以使用 <code>slice()</code>复制其全部或部分到一个新实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); </span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">4</span>, <span class="number">12</span>); </span><br><span class="line"><span class="title function_">alert</span>(buf2.<span class="property">byteLength</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><code>ArrayBuffer</code> 某种程度上类似于 C++的 <code>malloc()</code>，但也有几个明显的区别。</p><ol><li>malloc()在分配失败时会返回一个 null 指针。ArrayBuffer 在分配失败时会抛出错误。</li><li>malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer 分配的内存不能超过 Number.MAX_SAFE_INTEGER（253  1）字节。</li><li>malloc()调用成功不会初始化实际的地址。声明 ArrayBuffer 则会将所有二进制位初始化 为 0</li><li>通过 malloc()分配的堆内存除非调用 free()或程序退出，否则系统不能再使用。而通过声明 ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。</li></ol><p>不能仅通过对 <code>ArrayBuffer</code> 的引用就读取或写入其内容。要读取或写入 <code>ArrayBuffer</code>，就必须 通过视图。视图有不同的类型，但引用的都是 <code>ArrayBuffer</code> 中存储的二进制数据。</p><h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>第一种允许读写 <code>ArrayBuffer</code> 的视图是 <code>DataView</code>。这个视图专为文件 I&#x2F;O 和网络 I&#x2F;O 设计，其 <code>API</code> 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。<code>DataView</code> 对缓冲内容没有任何预设，也不能迭代。</p><p>必须在对已有的<code>ArrayBuffer</code> 读取或写入时才能创建 <code>DataView</code> 实例。这个实例可以使用全部或 部分 <code>ArrayBuffer</code>，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); </span><br><span class="line"><span class="comment">// DataView 默认使用整个 ArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteOffset</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">buffer</span> === buf); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">// byteOffset=0 表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">// byteLength=8 限制视图为前 8 个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>); </span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteOffset</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">buffer</span> === buf); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 如果不指定，则 DataView 会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">// byteOffset=8 表示视图从缓冲的第 9 个字节开始</span></span><br><span class="line"><span class="comment">// byteLength 未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">8</span>); </span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">byteOffset</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">buffer</span> === buf); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要通过 <code>DataView</code> 读取缓冲，还需要几个组件。</p><ul><li><p>首先是要读或写的字节偏移量。可以看成 <code>DataView</code> 中的某种“地址”。</p></li><li><p><code>DataView</code> 应该使用 <code>ElementType</code> 来实现 <code>JavaScript</code> 的 <code>Number</code> 类型到缓冲内二进制格式的转换。</p></li><li><p>最后是内存中值的字节序。默认为大端字节序。</p></li></ul><ol><li><p>ElementType</p><p><code>DataView</code> 对存储在缓冲内的数据类型没有预设。它暴露的 <code>API</code> 强制开发者在读、写时指定一个 <code>ElementType</code>，然后 <code>DataView</code> 就会忠实地为读、写而完成相应的转换。</p><p><code>ECMAScript</code> 6 支持 8 种不同的 <code>ElementType</code>（见下表）。</p><table><thead><tr><th>ElementType</th><th>字节</th><th>说明</th><th>等价的C类型</th><th>值的范围</th></tr></thead><tbody><tr><td>Int8</td><td>1</td><td>8位有符号整数</td><td>signed char</td><td>-128-127</td></tr><tr><td>Uint8</td><td>1</td><td>8位无符号整数</td><td>unsigned char</td><td>0-255</td></tr><tr><td>Int16</td><td>2</td><td>16位有符号整数</td><td>short</td><td>-32768-32767</td></tr><tr><td>Uint16</td><td>2</td><td>16位无符号整数</td><td>unsigned short</td><td>0-65535</td></tr><tr><td>Int32</td><td>4</td><td>32位有符号整数</td><td>int</td><td>-2147483648-147483647</td></tr><tr><td>Uint32</td><td>4</td><td>32位无符号整数</td><td>unsigned int</td><td>0-4294967295</td></tr><tr><td>Float32</td><td>4</td><td>32位IEEE-754浮点数</td><td>float</td><td>-3.4e+38-+3.4e+38</td></tr><tr><td>Float64</td><td>8</td><td>64位IEEE-754浮点数</td><td>double</td><td>-1.7e+308-+1.7e+308</td></tr></tbody></table><p><code>DataView</code> 为上表中的每种类型都暴露了 <code>get</code> 和 <code>set</code> 方法，这些方法使用 <code>byteOffset</code>（字节偏移 量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 说明整个缓冲确实所有二进制位都是 0 </span></span><br><span class="line"><span class="comment">// 检查第一个和第二个字符</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">1</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 检查整个缓冲</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为 1 </span></span><br><span class="line"><span class="comment">// 255 的二进制表示是 11111111（2^8 - 1）</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">255</span>); </span><br><span class="line"><span class="comment">// DataView 会自动将数据转换为特定的 ElementType </span></span><br><span class="line"><span class="comment">// 255 的十六进制表示是 0xFF </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0xFF</span>); </span><br><span class="line"><span class="comment">// 现在，缓冲里都是 1 了</span></span><br><span class="line"><span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p>字节序</p><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约 定。<code>DataView</code> 只支持两种约定：<code>大端字节序</code>和<code>小端字节序</code>。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。</p><p><code>JavaScript</code> 运行时所在系统的原生字节序决定了如何读取或写入字节，但 <code>DataView</code> 并不遵守这 个约定。对一段内存而言，<code>DataView</code> 是一个中立接口，它会遵循你指定的字节序。<code>DataView</code> 的所 有 <code>API</code> 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 <code>true</code> 即可启用小端字节序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是 1 </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于 1 </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于 1 </span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x8 0x0 0x0 0x1 </span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001 </span></span><br><span class="line"><span class="comment">// 按大端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x80 是高字节，0x01 是低字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>)); <span class="comment">// 32769 </span></span><br><span class="line"><span class="comment">// 按小端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x01 是高字节，0x80 是低字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 384 </span></span><br><span class="line"><span class="comment">// 按大端字节序写入 Uint16 </span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0004</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x0 0x0 0x4 </span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 按小端字节序写入 Uint16 </span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x2 0x0 0x0 </span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>边界情形</p><p><code>DataView</code> 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 <code>RangeError</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">6</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">8</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">setInt32</span>(<span class="number">4</span>, <span class="number">123</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br></pre></td></tr></table></figure><p><code>DataView</code> 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则 抛出错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="number">1.5</span>); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 1 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, [<span class="number">4</span>]); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 4 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="title class_">Symbol</span>()); </span><br><span class="line"><span class="comment">// TypeError </span></span><br></pre></td></tr></table></figure></li><li><p>定型数组</p><p>定型数组是另一种形式的 <code>ArrayBuffer</code> 视图。虽然概念上与 <code>DataView</code> 接近，但定型数组的区别 在于，它特定于一种 <code>ElementType</code> 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的 <code>API</code> 和更高的性能。设计定型数组的目的就是提高与 <code>WebGL</code> 等原生库交换二进制数据的效率。由于定 型数组的二进制表示对操作系统而言是一种容易使用的格式，<code>JavaScript </code>引擎可以重度优化算术运算、 按位运算和其他对定型数组的常见操作，因此使用它们速度极快。</p><p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类 型的定型数组。另外，通过<code>.from()</code>和<code>.of()</code>也可以创建定型数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 12 字节的缓冲</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">12</span>); </span><br><span class="line"><span class="comment">// 创建一个引用该缓冲的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buf); </span><br><span class="line"><span class="comment">// 这个定型数组知道自己的每个元素需要 4 字节</span></span><br><span class="line"><span class="comment">// 因此长度为 3 </span></span><br><span class="line"><span class="title function_">alert</span>(ints.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 创建一个长度为 6 的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(<span class="number">6</span>); </span><br><span class="line"><span class="comment">// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节</span></span><br><span class="line"><span class="title function_">alert</span>(ints2.<span class="property">length</span>); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 类似 DataView，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line"><span class="title function_">alert</span>(ints2.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 24 </span></span><br><span class="line"><span class="comment">// 创建一个包含[2, 4, 6, 8]的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]); </span><br><span class="line"><span class="title function_">alert</span>(ints3.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints3.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br><span class="line"><span class="title function_">alert</span>(ints3[<span class="number">2</span>]); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 通过复制 ints3 的值创建一个 Int16Array </span></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(ints3); </span><br><span class="line"><span class="comment">// 这个新类型数组会分配自己的缓冲</span></span><br><span class="line"><span class="comment">// 对应索引的每个值会相应地转换为新格式</span></span><br><span class="line"><span class="title function_">alert</span>(ints4.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints4.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(ints4[<span class="number">2</span>]); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 基于普通数组来创建一个 Int16Array </span></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="title class_">Int16Array</span>.<span class="title function_">from</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]); </span><br><span class="line"><span class="title function_">alert</span>(ints5.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints5.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(ints5[<span class="number">2</span>]); <span class="comment">// 7 </span></span><br><span class="line"><span class="comment">// 基于传入的参数创建一个 Float32Array </span></span><br><span class="line"><span class="keyword">const</span> floats = <span class="title class_">Float32Array</span>.<span class="title function_">of</span>(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>); </span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 12 </span></span><br><span class="line"><span class="title function_">alert</span>(floats[<span class="number">2</span>]); <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure><p>定型数组的构造函数和实例都有一个 <code>BYTES_PER_ELEMENT</code> 属性，返回该类型数组中每个元素的大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">Int16Array</span>.<span class="property">BYTES_PER_ELEMENT</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Int32Array</span>.<span class="property">BYTES_PER_ELEMENT</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(<span class="number">1</span>), </span><br><span class="line">   floats = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(<span class="number">1</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints.<span class="property">BYTES_PER_ELEMENT</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">BYTES_PER_ELEMENT</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(<span class="number">4</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints[<span class="number">0</span>]); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(ints[<span class="number">1</span>]); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(ints[<span class="number">2</span>]); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(ints[<span class="number">3</span>]); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><ol><li><p>定型数组行为</p><p>从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：</p><ul><li>[]</li><li>copyWithin()</li><li>entries()</li><li>every()</li><li>fill()</li><li>filter()</li><li>find()</li><li>findIndex()</li><li>forEach()</li><li>indexOf()</li><li>join()</li><li>keys()</li><li>lastIndexOf()</li><li>length</li><li>map()</li><li>reduce()</li><li>reduceRight()</li><li>reverse()</li><li>slice()</li><li>some()</li><li>sort()</li><li>toLocaleString()</li><li>toString()</li><li>values()</li></ul><p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line"><span class="keyword">const</span> doubleints = ints.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span>*x); </span><br><span class="line"><span class="title function_">alert</span>(doubleints <span class="keyword">instanceof</span> <span class="title class_">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>定型数组有一个 <code>Symbol.iterator</code> 符号属性，因此可以通过 <code>for..of</code> 循环和扩展操作符来操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> int <span class="keyword">of</span> ints) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(int); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...ints)); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure></li><li><p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p><ul><li>concat()</li><li>pop()</li><li>push()</li><li>shift()</li><li>splice()</li><li>unshift()</li></ul><p>不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：<code>set()</code>和 <code>subarray()</code>。 <code>set()</code>从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建长度为 8 的 int16 数组</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(<span class="number">8</span>); </span><br><span class="line"><span class="comment">// 把定型数组复制为前 4 个值</span></span><br><span class="line"><span class="comment">// 偏移量默认为索引 0 </span></span><br><span class="line">container.<span class="title function_">set</span>(<span class="title class_">Int8Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(container); <span class="comment">// [1,2,3,4,0,0,0,0] </span></span><br><span class="line"><span class="comment">// 把普通数组复制为后 4 个值</span></span><br><span class="line"><span class="comment">// 偏移量 4 表示从索引 4 开始插入</span></span><br><span class="line">container.<span class="title function_">set</span>([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(container); <span class="comment">// [1,2,3,4,5,6,7,8] </span></span><br><span class="line"><span class="comment">// 溢出会抛出错误</span></span><br><span class="line">container.<span class="title function_">set</span>([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">7</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br></pre></td></tr></table></figure><p><code>subarray()</code>执行与 <code>set()</code>相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。 复制值时的开始索引和结束索引是可选的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="title class_">Int16Array</span>.<span class="title function_">of</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>); </span><br><span class="line"><span class="comment">// 把整个数组复制为一个同类型的新数组</span></span><br><span class="line"><span class="keyword">const</span> fullCopy = source.<span class="title function_">subarray</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullCopy); <span class="comment">// [2, 4, 6, 8] </span></span><br><span class="line"><span class="comment">// 从索引 2 开始复制数组</span></span><br><span class="line"><span class="keyword">const</span> halfCopy = source.<span class="title function_">subarray</span>(<span class="number">2</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(halfCopy); <span class="comment">// [6, 8] </span></span><br><span class="line"><span class="comment">// 从索引 1 开始复制到索引 3 </span></span><br><span class="line"><span class="keyword">const</span> partialCopy = source.<span class="title function_">subarray</span>(<span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(partialCopy); <span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>下溢与上溢</p><p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了 如何处理下溢和上溢：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为 2 的有符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个二补数形式的有符号整数</span></span><br><span class="line"><span class="comment">// 范围是-128（-1 * 2^7）~127（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 长度为 2 的无符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个无符号整数</span></span><br><span class="line"><span class="comment">// 范围是 0~255（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引</span></span><br><span class="line"><span class="comment">// 索引只取最低有效位上的 8 位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>; <span class="comment">// 0x100 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 0] </span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>; <span class="comment">// 0x1FF </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 255] </span></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line"><span class="comment">// 0xFF 是以二补数形式表示的-1（截取到 8 位）, </span></span><br><span class="line"><span class="comment">// 但 255 是一个无符号整数</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = -<span class="number">1</span> <span class="comment">// 0xFF (truncated to 8 bits) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 255] </span></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80 是无符号整数的 128，是二补数形式的-128 </span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>; <span class="comment">// 0x80 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, -128] </span></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF 是无符号整数的 255，是二补数形式的-1 </span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>; <span class="comment">// 0xFF </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, -1] </span></span><br></pre></td></tr></table></figure><p>除了 8 种元素类型，还有一种“夹板”数组类型：<code>Uint8ClampedArray</code>，不允许任何方向溢出。 超出最大值 <code>255</code> 的值会被向下舍入为 <code>255</code>，而小于最小值 0 的值会被向上舍入为 0。</p></li></ol></li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>ECMAScript</code> 6 以前，在 <code>JavaScript</code> 中实现“键&#x2F;值”式存储可以使用 <code>Object</code> 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此 <code>TC39</code> 委员会专门为 “键&#x2F;值”存储定义了一个规范。</p><p>作为 <code>ECMAScript</code> 6 的新增特性，<code>Map</code> 是一种新的集合类型，为这门语言带来了真正的键&#x2F;值存储机 制。<code>Map</code> 的大多数特性都可以通过 <code>Object</code> 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。</p><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><p>使用 <code>new</code> 关键字和 <code>Map</code> 构造函数可以创建一个空映射：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure><p>如果想在创建的同时初始化实例，可以给 <code>Map</code> 构造函数传入一个可迭代对象，需要包含键&#x2F;值对数 组。可迭代对象中的每个键&#x2F;值对都会按照迭代顺序插入到新映射实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(m1.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>(&#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>]; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(m2.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>([[]]); </span><br><span class="line"><span class="title function_">alert</span>(m3.<span class="title function_">has</span>(<span class="literal">undefined</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m3.<span class="title function_">get</span>(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>初始化之后，可以使用 <code>set()</code>方法再添加键&#x2F;值对。另外，可以使用 <code>get()</code>和 <code>has()</code>进行查询，可 以通过<code>size</code> 属性获取映射中的键&#x2F;值对的数量，还可以使用 <code>delete()</code>和 <code>clear()</code>删除值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// undefined </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 0 </span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 2 </span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&quot;firstName&quot;</span>); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">m.<span class="title function_">clear</span>(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p><code>set()</code>方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>与 <code>Object</code> 只能使用数值、字符串或符号作为键不同，<code>Map</code> 可以使用任何 <code>JavaScript</code> 数据类型作为 键。<code>Map</code> 内部使用 <code>SameValueZero</code> 比较操作（<code>ECMAScript</code> 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与 <code>Object</code> 类似，映射的值是没有限制的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">m.<span class="title function_">set</span>(functionKey, <span class="string">&quot;functionValue&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(symbolKey, <span class="string">&quot;symbolValue&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(objectKey, <span class="string">&quot;objectValue&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(functionKey)); <span class="comment">// functionValue </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(symbolKey)); <span class="comment">// symbolValue </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(objectKey)); <span class="comment">// objectValue </span></span><br><span class="line"><span class="comment">// SameValueZero 比较意味着独立实例不冲突</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;, </span><br><span class="line"> objVal = &#123;&#125;, </span><br><span class="line"> arrKey = [], </span><br><span class="line"> arrVal = []; </span><br><span class="line">m.<span class="title function_">set</span>(objKey, objVal); </span><br><span class="line">m.<span class="title function_">set</span>(arrKey, arrVal); </span><br><span class="line">objKey.<span class="property">foo</span> = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line">objVal.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrKey.<span class="title function_">push</span>(<span class="string">&quot;foo&quot;</span>); </span><br><span class="line">arrVal.<span class="title function_">push</span>(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure><p><code>SameValueZero</code>比较也可能导致意想不到的冲突：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN </span></span><br><span class="line"> b = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN </span></span><br><span class="line"> pz = +<span class="number">0</span>, </span><br><span class="line"> nz = -<span class="number">0</span>; </span><br><span class="line"><span class="title function_">alert</span>(a === b); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(pz === nz); <span class="comment">// true </span></span><br><span class="line">m.<span class="title function_">set</span>(a, <span class="string">&quot;foo&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(pz, <span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(b)); <span class="comment">// foo </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h2 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h2><p>与 <code>Object</code> 类型的一个主要差异是，<code>Map</code> 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。</p><p>映射实例可以提供一个迭代器（<code>Iterator</code>），能以插入顺序生成[key, value]形式的数组。可以 通过 <code>entries()</code>方法（或者 <code>Symbol.iterator</code> 属性，它引用 <code>entries()</code>）取得这个迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">entries</span> === m[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3] </span></span><br></pre></td></tr></table></figure><p>因为 <code>entries()</code>是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]] </span></span><br></pre></td></tr></table></figure><p>如果不使用迭代器，而是使用回调方式，则可以调用映射的 <code>forEach(callback, opt_thisArg)</code> 方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调 内部<code>this</code> 的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, key</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// key1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// key2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// key3 -&gt; val3 </span></span><br></pre></td></tr></table></figure><p><code>keys()</code>和 <code>values()</code>分别返回以插入顺序生成键和值的迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// key1 </span></span><br><span class="line"><span class="comment">// key2 </span></span><br><span class="line"><span class="comment">// key3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value1 </span></span><br><span class="line"><span class="comment">// value2 </span></span><br><span class="line"><span class="comment">// value3 </span></span><br></pre></td></tr></table></figure><p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> key = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(key); <span class="comment">// newKey </span></span><br><span class="line"> <span class="title function_">alert</span>(m1.<span class="title function_">get</span>(<span class="string">&quot;key1&quot;</span>)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [keyObj, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> key.<span class="property">id</span> = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(key); <span class="comment">// &#123;id: &quot;newKey&quot;&#125; </span></span><br><span class="line"> <span class="title function_">alert</span>(m.<span class="title function_">get</span>(keyObj)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(keyObj); <span class="comment">// &#123;id: &quot;newKey&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="选择-Object-还是-Map"><a href="#选择-Object-还是-Map" class="headerlink" title="选择 Object 还是 Map"></a>选择 Object 还是 Map</h2><p>对于多数 Web 开发任务来说，选择 <code>Object</code> 还是 <code>Map</code> 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p><ol><li><p>内存占用</p><p><code>Object</code> 和 <code>Map</code> 的工程级实现在不同浏览器间存在明显差异，但存储单个键&#x2F;值对所占用的内存数量 都会随键的数量线性增加。批量添加或删除键&#x2F;值对则取决于各浏览器对该类型内存分配的工程实现。 不同浏览器的情况不同，但给定固定大小的内存，<code>Map</code> 大约可以比 <code>Object</code> 多存储 50%的键&#x2F;值对。</p></li><li><p>插入性能</p><p>向 <code>Object</code> 和 <code>Map</code> 中插入新键&#x2F;值对的消耗大致相当，不过插入 <code>Map</code> 在所有浏览器中一般会稍微快 一点儿。对这两个类型来说，插入速度并不会随着键&#x2F;值对数量而线性增加。如果代码涉及大量插入操 作，那么显然 <code>Map</code> 的性能更佳。</p></li><li><p>查找速度</p><p>与插入不同，从大型 <code>Object</code> 和 <code>Map</code> 中查找键&#x2F;值对的性能差异极小，但如果只包含少量键&#x2F;值对， 则 <code>Object</code> 有时候速度更快。在把 <code>Object</code> 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 <code>Map</code> 来说是不可能的。对这两个类型而言， 查找速度不会随着键&#x2F;值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选 择 <code>Object</code> 更好一些。</p></li><li><p>删除性能</p><p>使用 <code>delete</code> 删除 <code>Object</code> 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此， 出现了一些伪删除对象属性的操作，包括把属性值设置为 <code>undefined</code> 或 <code>null</code>。但很多时候，这都是一 种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，<code>Map</code> 的 <code>delete()</code>操作都比插入和查找更快。 如果代码涉及大量删除操作，那么毫无疑问应该选择 <code>Map</code>。</p></li></ol><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><code>ECMAScript</code> 6 新增的“弱映射”（<code>WeakMap</code>）是一种新的集合类型，为这门语言带来了增强的键&#x2F; 值对存储机制。<code>WeakMap</code> 是 <code>Map</code> 的“兄弟”类型，其 <code>API</code> 也是 <code>Map</code> 的子集。<code>WeakMap</code> 中的“weak”（弱）， 描述的是 <code>JavaScript</code> 垃圾回收程序对待“弱映射”中键的方式。</p><h3 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h3><p>可以使用 new 关键字实例化一个空的 <code>WeakMap</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br></pre></td></tr></table></figure><p>弱映射中的键只能是 <code>Object</code> 或者继承自 <code>Object</code> 的类型，尝试使用非对象设置键会抛出 <code>TypeError</code>。值的类型没有限制。</p><p>如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键&#x2F;值对数组。 可迭代对象中的每个键&#x2F;值都会按照迭代顺序插入新实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 使用嵌套数组初始化弱映射</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [key2, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key1)); <span class="comment">// val1 </span></span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key2)); <span class="comment">// val2 </span></span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key3)); <span class="comment">// val3 </span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key </span></span><br><span class="line"><span class="keyword">typeof</span> wm2; </span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作键</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;key1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> stringKey, <span class="string">&quot;val1&quot;</span> </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(wm3.<span class="title function_">get</span>(stringKey)); <span class="comment">// &quot;val1&quot;</span></span><br></pre></td></tr></table></figure><p>初始化之后可以使用 <code>set()</code>再添加键&#x2F;值对，可以使用 <code>get()</code>和 <code>has()</code>查询，还可以使用 <code>delete()</code> 删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// undefined </span></span><br><span class="line">wm.<span class="title function_">set</span>(key1, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(key2, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// Matt </span></span><br><span class="line">wm.<span class="title function_">delete</span>(key1); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key2)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><code>set()</code>方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>().<span class="title function_">set</span>(key1, <span class="string">&quot;val1&quot;</span>); </span><br><span class="line">wm.<span class="title function_">set</span>(key2, <span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(key3, <span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// val1 </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key2)); <span class="comment">// val2 </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key3)); <span class="comment">// val3 </span></span><br></pre></td></tr></table></figure><h3 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h3><p><code>WeakMap</code> 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，<strong>这些键不属于正式的引用， 不会阻止垃圾回收</strong>。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键&#x2F;值 对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</p><p>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line">wm.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&quot;val&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>set()</code>方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用， 所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键&#x2F;值对就从弱映射中消失 了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键&#x2F;值被破坏以后，值本身 也会成为垃圾回收的目标。</p><p>再看一个稍微不同的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line"> <span class="attr">key</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">&quot;val&quot;</span>); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) &#123; </span><br><span class="line"> container.<span class="property">key</span> = <span class="literal">null</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这一次，<code>container</code> 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目 标。不过，如果调用了 <code>removeReference()</code>，就会摧毁键对象的最后一个引用，垃圾回收程序就可以 把这个键&#x2F;值对清理掉。</p><h3 id="不可迭代键"><a href="#不可迭代键" class="headerlink" title="不可迭代键"></a>不可迭代键</h3><p>因为 <code>WeakMap</code> 中的键&#x2F;值对任何时候都可能被销毁，所以没必要提供迭代其键&#x2F;值对的能力。当然， 也用不着像 <code>clear()</code>这样一次性销毁所有键&#x2F;值的方法。<code>WeakMap</code> 确实没有这个方法。因为不可能迭代， 所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问 <code>WeakMap</code> 实例，也没办法看到其中的内容。 </p><p><code>WeakMap</code> 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。</p><h3 id="使用弱映射"><a href="#使用弱映射" class="headerlink" title="使用弱映射"></a>使用弱映射</h3><p><code>WeakMap</code> 实例与现有 <code>JavaScript</code> 对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相关策略。</p><ol><li><p>私有变量</p><p>弱映射造就了在JavaScript中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。</p><p>下面是一个示例实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">setId</span>(id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> privateMembers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;; </span><br><span class="line"> privateMembers[property] = value; </span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property]; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">setId</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">getId</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123 </span></span><br><span class="line">user.<span class="title function_">setId</span>(<span class="number">456</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// 并不是真正私有的</span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(user)[user.<span class="property">idProperty</span>]); <span class="comment">// 456 </span></span><br></pre></td></tr></table></figure><p>慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以 取得“私有”变量了。为了避免这种访问，可以用一个闭包把 <code>WeakMap</code> 包装起来，这样就可以把弱映射与外界完全隔离开了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = (<span class="function">() =&gt;</span> &#123; </span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setId</span>(id); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123; </span><br><span class="line">            <span class="keyword">const</span> privateMembers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;; </span><br><span class="line">            privateMembers[property] = value; </span><br><span class="line">            wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property]; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_">setId</span>(<span class="params">id</span>) &#123; </span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_">getId</span>(<span class="params">id</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>); </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">User</span>; </span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123 </span></span><br><span class="line">user.<span class="title function_">setId</span>(<span class="number">456</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure><p>这样，拿不到弱映射中的键，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但 整个代码也完全陷入了 <code>ES6</code> 之前的闭包私有变量模式。</p></li><li><p>因为 <code>WeakMap</code> 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中 使用了常规的 <code>Map</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>); </span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">m.<span class="title function_">set</span>(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;); </span><br></pre></td></tr></table></figure><p>假设在上面的代码执行后，页面被 <code>JavaScript</code> 改变了，原来的登录按钮从 <code>DOM</code> 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍然会逗留在内存中，除非明确将其从映射中 删除或者等到映射本身被销毁。 如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>); </span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.<span class="title function_">set</span>(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>ECMAScript</code> 6 新增的 <code>Set</code> 是一种新集合类型，为这门语言带来集合数据结构。<code>Set</code> 在很多方面都像是加强的 Map，这是因为它们的大多数 <code>API</code> 和行为都是共有的。</p><h2 id="基本API-2"><a href="#基本API-2" class="headerlink" title="基本API"></a>基本API</h2><p>使用 <code>new</code> 关键字和 <code>Set</code> 构造函数可以创建一个空集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></table></figure><p>如果想在创建的同时初始化实例，则可以给 Set 构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组初始化集合 </span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="title function_">alert</span>(s1.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(&#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(s2.<span class="property">size</span>); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>初始化之后，可以使用 <code>add()</code>增加值，使用 <code>has()</code>查询，通过 <code>size</code> 取得元素数量，以及使用 <code>delete()</code> 和 <code>clear()</code>删除元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 0 </span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 2 </span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="string">&quot;Matt&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">s.<span class="title function_">clear</span>(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p><code>add()</code>返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&quot;val1&quot;</span>); </span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>与 <code>Map</code> 类似，<code>Set</code> 可以包含任何 <code>JavaScript</code> 数据类型作为值。集合也使用 <code>SameValueZero</code> 操作 （<code>ECMAScript</code> 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">s.<span class="title function_">add</span>(functionVal); </span><br><span class="line">s.<span class="title function_">add</span>(symbolVal); </span><br><span class="line">s.<span class="title function_">add</span>(objectVal); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(functionVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(symbolVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(objectVal)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// SameValueZero 检查意味着独立的实例不会冲突</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;, </span><br><span class="line"> arrVal = []; </span><br><span class="line">s.<span class="title function_">add</span>(objVal); </span><br><span class="line">s.<span class="title function_">add</span>(arrVal); </span><br><span class="line">objVal.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrVal.<span class="title function_">push</span>(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(objVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(arrVal)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><code>add()</code>和 <code>delete()</code>操作是幂等的。<code>delete()</code>返回一个布尔值，表示集合中是否存在要删除的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h2 id="顺序与迭代-1"><a href="#顺序与迭代-1" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h2><p><code>Set</code> 会维护值插入时的顺序，因此支持按顺序迭代。 </p><p>集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 <code>values()</code>方法及其别名方法 <code>keys()</code>（或者 <code>Symbol.iterator</code> 属性，它引用 <code>values()</code>）取得这个迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">values</span> === s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">keys</span> === s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3 </span></span><br></pre></td></tr></table></figure><p>因为 <code>values()</code>是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...s]); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure><p>集合的 <code>entries()</code>方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;] </span></span><br></pre></td></tr></table></figure><p>如果不使用迭代器，而是使用回调方式，则可以调用集合的 <code>forEach()</code>方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 <code>this</code>的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// val1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// val2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure><p>修改集合中值的属性不会影响其作为集合值的身份：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>]); </span><br><span class="line"><span class="comment">// 字符串原始值作为值不会被修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> value = <span class="string">&quot;newVal&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(value); <span class="comment">// newVal </span></span><br><span class="line"> <span class="title function_">alert</span>(s1.<span class="title function_">has</span>(<span class="string">&quot;val1&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> valObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([valObj]); </span><br><span class="line"><span class="comment">// 修改值对象的属性，但对象仍然存在于集合中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s2.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> value.<span class="property">id</span> = <span class="string">&quot;newVal&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(value); <span class="comment">// &#123;id: &quot;newVal&quot;&#125; </span></span><br><span class="line"> <span class="title function_">alert</span>(s2.<span class="title function_">has</span>(valObj)); <span class="comment">// true </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(valObj); <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="定义正式集合操作"><a href="#定义正式集合操作" class="headerlink" title="定义正式集合操作"></a>定义正式集合操作</h2><p>从各方面来看，<code>Set</code> 跟 <code>Map</code> 都很相似，只是 <code>API</code> 稍有调整。唯一需要强调的就是集合的 <code>API</code>对自 身的简单操作。很多开发者都喜欢使用 <code>Set</code> 操作，但需要手动实现：或者是子类化 <code>Set</code>，或者是定义一 个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态 方法。在实现这些操作时，需要考虑几个地方。</p><ol><li>某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</li><li>Set 保留插入顺序，所有方法返回的集合必须保证顺序。</li><li>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能 够节省对象初始化成本。</li><li>不要修改已有的集合实例。union(a, b)或 a.union(b)应该返回包含结果的新集合实例。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Set</span> &#123; </span><br><span class="line"> <span class="title function_">union</span>(<span class="params">...sets</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">union</span>(<span class="variable language_">this</span>, ...sets) </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">intersection</span>(<span class="params">...sets</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">intersection</span>(<span class="variable language_">this</span>, ...sets); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">difference</span>(<span class="params">set</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">difference</span>(<span class="variable language_">this</span>, set); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">symmetricDifference</span>(<span class="params">set</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">symmetricDifference</span>(<span class="variable language_">this</span>, set); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">cartesianProduct</span>(<span class="params">set</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">cartesianProduct</span>(<span class="variable language_">this</span>, set); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">powerSet</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">powerSet</span>(<span class="variable language_">this</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">union</span>(<span class="params">a, ...bSets</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123; </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123; </span><br><span class="line">         unionSet.<span class="title function_">add</span>(bValue); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> unionSet; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">intersection</span>(<span class="params">a, ...bSets</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123; </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123; </span><br><span class="line">             <span class="keyword">if</span> (!b.<span class="title function_">has</span>(aValue)) &#123; </span><br><span class="line">             intersectionSet.<span class="title function_">delete</span>(aValue); </span><br><span class="line">          &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> intersectionSet; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 返回两个集合的差集</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">difference</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123; </span><br><span class="line">         <span class="keyword">if</span> (a.<span class="title function_">has</span>(bValue)) &#123; </span><br><span class="line">         differenceSet.<span class="title function_">delete</span>(bValue); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> differenceSet; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">symmetricDifference</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line">     <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">     <span class="keyword">return</span> a.<span class="title function_">union</span>(b).<span class="title function_">difference</span>(a.<span class="title function_">intersection</span>(b)); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line"> <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">cartesianProduct</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123; </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123; </span><br><span class="line">            cartesianProductSet.<span class="title function_">add</span>([aValue, bValue]); </span><br><span class="line">         &#125; </span><br><span class="line">  &#125; </span><br><span class="line">     <span class="keyword">return</span> cartesianProductSet; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">powerSet</span>(<span class="params">a</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> powerSet = <span class="keyword">new</span> <span class="title class_">XSet</span>().<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">XSet</span>()); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">const</span> set <span class="keyword">of</span> <span class="keyword">new</span> <span class="title class_">XSet</span>(powerSet)) &#123; </span><br><span class="line">         powerSet.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">XSet</span>(set).<span class="title function_">add</span>(aValue)); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> powerSet; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p><code>ES6</code>新增的“弱集合”（WeakSet）是一种新的集合类型，为这门语言带来了集合数据结构。WeakSet是Set的“兄弟”类型，其API也是Set的子集。WeakSet中的“weak”，描述的是JavaScript垃圾回收程序对待“弱集合”中值的方式。</p><h3 id="基本API-3"><a href="#基本API-3" class="headerlink" title="基本API"></a>基本API</h3><p>可以使用new关键字实例化一个空的<code>WeakSet</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure><p> 弱集合中的值只能是Object或者继承自Object的类型，尝试使用非对象设置值会抛出TypeError。</p><p>如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 使用数组初始化弱集合</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([val1, val2, val3]); </span><br><span class="line"><span class="title function_">alert</span>(ws1.<span class="title function_">has</span>(val1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws1.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws1.<span class="title function_">has</span>(val3)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([val1, <span class="string">&quot;BADVAL&quot;</span>, val3]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet </span></span><br><span class="line"><span class="keyword">typeof</span> ws2; </span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作值</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;val1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> ws3 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([stringVal]); </span><br><span class="line"><span class="title function_">alert</span>(ws3.<span class="title function_">has</span>(stringVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>初始化之后可以使用add()再添加新值，可以使用 has()查询，还可以使用 delete()删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// false </span></span><br><span class="line">ws.<span class="title function_">add</span>(val1) </span><br><span class="line"> .<span class="title function_">add</span>(val2); </span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br><span class="line">ws.<span class="title function_">delete</span>(val1); <span class="comment">// 只删除这一个值</span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>add()方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>().<span class="title function_">add</span>(val1); </span><br><span class="line">ws.<span class="title function_">add</span>(val2) </span><br><span class="line"> .<span class="title function_">add</span>(val3); </span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val3)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="弱值"><a href="#弱值" class="headerlink" title="弱值"></a>弱值</h3><p>WeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，<strong>这些值不属于正式的引用， 不会阻止垃圾回收</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line">ws.<span class="title function_">add</span>(&#123;&#125;); </span><br></pre></td></tr></table></figure><p><code>add()</code>方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当 这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为 一个空集合。</p><p>再看一个稍微不同的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line"> <span class="attr">val</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">ws.<span class="title function_">add</span>(container.<span class="property">val</span>); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) &#123; </span><br><span class="line"> container.<span class="property">val</span> = <span class="literal">null</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这一次，<code>container</code> 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标。不过，如果调用了 <code>removeReference()</code>，就会摧毁值对象的最后一个引用，垃圾回收程序就可以把这个值清理掉。</p><h3 id="不可迭代值"><a href="#不可迭代值" class="headerlink" title="不可迭代值"></a>不可迭代值</h3><p>因为 WeakSet 中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着 像 <code>clear()</code>这样一次性销毁所有值的方法。WeakSet 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱集合中取得值。即便代码可以访问 WeakSet 实例，也没办法看到其中的内容。 </p><p><strong>WeakSet 之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了</strong>。</p><h3 id="使用弱集合"><a href="#使用弱集合" class="headerlink" title="使用弱集合"></a>使用弱集合</h3><p>相比于 WeakMap 实例，WeakSet 实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。</p><p>来看下面的例子，这里使用了一个普通 Set：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>); </span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.<span class="title function_">add</span>(loginButton); </span><br></pre></td></tr></table></figure><p>这样，通过查询元素在不在 <code>disabledElements</code> 中，就可以知道它是不是被禁用了。不过，假如 元素从 DOM 树中被删除了，它的引用却仍然保存在 Set 中，因此垃圾回收程序也不能回收它。</p><p>为了让垃圾回收程序回收元素的内存，可以在这里使用 WeakSet：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.<span class="title function_">add</span>(loginButton);</span><br></pre></td></tr></table></figure><p>这样，只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。</p><h2 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h2><p>ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。</p><p>有 4 种原生集合类型定义了默认迭代器：</p><ol><li>Array</li><li>所有定型数组</li><li>Map</li><li>Set</li></ol><p>很简单，这意味着上述所有类型都支持顺序迭代，都可以传入 for-of 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [ </span><br><span class="line"> <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>), </span><br><span class="line"> typedArr = <span class="title class_">Int16Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">4</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">9</span>, <span class="number">10</span>]) </span><br><span class="line">]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// [5, 6] </span></span><br><span class="line"><span class="comment">// [7, 8] </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 10 </span></span><br></pre></td></tr></table></figure><p>这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用， 只需简单的语法就可以复制整个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1 === arr2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]); </span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(map1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure><p>当然，也可以构建数组的部分元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">0</span>, ...arr1, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>浅复制意味着只会复制对象引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;]; </span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1]; </span><br><span class="line">arr1[<span class="number">0</span>].<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: &#x27;bar&#x27; &#125; </span></span><br></pre></td></tr></table></figure><p>上面的这些类型都支持多种构建方法，比如 <code>Array.of()</code>和 <code>Array.from()</code>静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">// 把数组复制到定型数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="title class_">Int16Array</span>.<span class="title function_">of</span>(...arr1); </span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="title class_">Int16Array</span>.<span class="title function_">from</span>(arr1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArr1); <span class="comment">// Int16Array [1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArr2); <span class="comment">// Int16Array [1, 2, 3] </span></span><br><span class="line"><span class="comment">// 把数组复制到映射</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(arr1.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, <span class="string">&#x27;val&#x27;</span> + x])); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map &#123;1 =&gt; &#x27;val 1&#x27;, 2 =&gt; &#x27;val 2&#x27;, 3 =&gt; &#x27;val 3&#x27;&#125; </span></span><br><span class="line"><span class="comment">// 把数组复制到集合</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(typedArr2); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set &#123;1, 2, 3&#125; </span></span><br><span class="line"><span class="comment">// 把集合复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [1, 2, 3] </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h1&gt;&lt;p&gt;到目前为止，大多数引用值的示例使用的是 &lt;code&gt;Object&lt;/code&gt; 类型。&lt;code&gt;Objec</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计读书笔记(3)——基本引用类型</title>
    <link href="http://pvnk1u.github.io/2022/08/18/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://pvnk1u.github.io/2022/08/18/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-08-17T20:32:39.000Z</published>
    <updated>2023-11-27T15:34:23.880Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引用值（或者对象）是某个特定引用类型的实例</strong>。在<code>ECMAScript</code>中，<strong>引用类型是把数据和功能组织到一起的结构</strong>，经常被人错误地称作“类”。虽然从技术上讲 <code>JavaScript</code> 是一门面向对象语言，但<code>ECMAScript</code> 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p>引用类型虽然有点像类，但跟类并不是一个概念。</p><p>对象被认为是某个特定引用类型的实例。新对象通过使用<code>new</code> 操作符后跟一个构造函数（<code>constructor</code>）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><p>这行代码创建了引用类型 <code>Date</code> 的一个新实例，并将它保存在变量 <code>now</code> 中。<code>Date()</code>在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。<code>ECMAScript</code> 提供了很多像 <code>Date</code> 这样的原生引用类型，帮助开发者实现常见的任务。</p><p>函数也是一种引用类型。</p><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p><code>ECMAScript</code> 的<code>Date</code> 类型参考了<code>Java</code> 早期版本中的<code>java.util.Date</code>。为此，<code>Date</code> 类型将日期保存为自协调世界时（<code>UTC</code>，<code>Universal  Time  Coordinated</code>）时间1970 年1 月1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，<code>Date</code> 类型可以精确表示1970 年1 月1 日之前及之后285 616 年的日期。</p><p>要创建日期对象，就使用<code>new</code> 操作符来调用<code>Date</code> 构造函数：</p><p>在不给<code>Date</code> 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（<code>UNIX</code> 纪元1970 年1 月1 日午夜之后的毫秒数）。<code>ECMAScript</code>为此提供了两个辅助方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。</p><p><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。<code>ECMA-262</code> 第5 版定义了<code>Date.parse()</code>应该支持的日期格式，填充了第3 版遗留的空白。所有实现都必须支持下列日期格式：</p><ul><li>“月&#x2F;日&#x2F;年”，如”5&#x2F;23&#x2F;2019”；</li><li>“月名 日, 年”，如”May 23, 2019”；</li><li>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”； </li><li>ISO  8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容ES5 的实现）。</li></ul><p>比如，要创建一个表示“2019 年5 月23 日”的日期对象，可以使用以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&quot;May 23, 2019&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法会返回<code>NaN</code>。如果直接把表示日期的字符串传给<code>Date</code> 构造函数，那么<code>Date</code> 会在后台调用<code>Date.parse()</code>。换句话说，下面这行代码跟前面那行代码是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>);</span><br></pre></td></tr></table></figure><p>这两行代码得到的日期对象相同。</p><p><code>Date.UTC()</code>方法也返回日期的毫秒表示，但使用的是跟<code>Date.parse()</code>不同的信息来生成这个值。传给<code>Date.UTC()</code>的参数是年、零起点月数（1 月是0，2 月是1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1 日。其他参数的默认值都是0。下面是使用<code>Date.UTC()</code>的两个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT 时间2000 年1 月1 日零点 </span></span><br><span class="line"><span class="keyword">let</span> y2k = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2000</span>, <span class="number">0</span>)); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// GMT 时间2005 年5 月5 日下午5 点55 分55 秒 </span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure><p>这个例子创建了两个日期 。第一个日期是2000 年1 月1 日零点（GMT），2000 代表年，0 代表月（1 月）。因为没有其他参数（日取1，其他取 0），所以结果就是该月第1 天零点。第二个日期表示2005年5 月5 日下午5 点55 分55 秒（GMT）。虽然日期里面涉及的都是5，但月数必须用4，因为月数是零起点的。小时也必须是17，因为这里采用的是24 小时制，即取值范围是0~23。其他参数就都很直观了。</p><p>与 <code>Date.parse()</code>一样，<code>Date.UTC()</code>也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 <code>GMT</code> 日期。不过 <code>Date</code> 构造函数跟 <code>Date.UTC()</code>接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地时间2000 年1 月1 日零点 </span></span><br><span class="line">let y2k = new Date(<span class="number">2000</span><span class="punctuation">,</span> <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地时间2005 年5 月5 日下午5 点55 分55 秒 </span></span><br><span class="line">let allFives = new Date(<span class="number">2005</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">17</span><span class="punctuation">,</span> <span class="number">55</span><span class="punctuation">,</span> <span class="number">55</span>);</span><br></pre></td></tr></table></figure><p>以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。</p><p><code>ECMAScript</code> 还提供了 <code>Date.now()</code>方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始时间 </span></span><br><span class="line"><span class="keyword">let</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数 </span></span><br><span class="line"><span class="title function_">doSomething</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 结束时间 </span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="title class_">Date</span>.<span class="title function_">now</span>(), </span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure><h2 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>与其他类型一样，<code>Date</code> 类型重写了<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。但与其他类型不同，重写后这些方法的返回值不一样。<code>Date</code> 类型的<code>toLocaleString()</code>方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。<code>toString()</code>方法通常返回带时区信息的日期和时间，而时间也是以24 小时制（0~23）表示的。下面给出了<code>toLocaleString()</code>和<code>toString()</code>返回的2019 年2 月1 日零点的示例（地区为”en-US”的PST，即Pacific Standard Time，太平洋标准时间）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toLocaleString</span>() - <span class="number">2</span>/<span class="number">1</span>/<span class="number">2019</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">AM</span> </span><br><span class="line"></span><br><span class="line"><span class="title function_">toString</span>() - <span class="title class_">Thu</span> <span class="title class_">Feb</span> <span class="number">1</span> <span class="number">2019</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">GMT</span>-<span class="number">0800</span> (<span class="title class_">Pacific</span> <span class="title class_">Standard</span> <span class="title class_">Time</span>) </span><br></pre></td></tr></table></figure><p><code>Date</code> 类型的<code>valueOf()</code>方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 2019 年1 月1 日 </span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// 2019 年2 月1 日 </span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1 &lt; date2); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1 &gt; date2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>日期2019 年1 月1 日在2019 年2 月1 日之前，所以说前者小于后者没问题。因为2019 年1 月1 日的毫秒表示小于2019 年2 月1 日的毫秒表示，所以用小于号比较这两个日期时会返回true。这也是确保日期先后的一个简单方式。</p><h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><p><code>Date</code> 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ul><li><code>toDateString()</code>显示日期中的周几、月、日、年（格式特定于实现）； </li><li><code>toTimeString()</code>显示日期中的时、分、秒和时区（格式特定于实现）； </li><li><code>toLocaleDateString()</code>显示日期中的周几、月、日、年（格式特定于实现和地区）； </li><li><code>toLocaleTimeString()</code>显示日期中的时、分、秒（格式特定于实现和地区）； </li><li><code>toUTCString()</code>显示完整的<code>UTC</code> 日期（格式特定于实现）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toDateString</span>()</span><br><span class="line"><span class="string">&#x27;Mon Aug 22 2022&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toTimeString</span>()</span><br><span class="line"><span class="string">&#x27;12:37:11 GMT+0800 (中国标准时间)&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toLocaleDateString</span>()</span><br><span class="line"><span class="string">&#x27;2022/8/22&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line"><span class="string">&#x27;12:37:11&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toUTCString</span>()</span><br><span class="line"><span class="string">&#x27;Mon, 22 Aug 2022 04:37:11 GMT&#x27;</span></span><br></pre></td></tr></table></figure><p>这些方法的输出与 <code>toLocaleString()</code>和 <code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p><h2 id="日期-x2F-时间组件方法"><a href="#日期-x2F-时间组件方法" class="headerlink" title="日期&#x2F;时间组件方法"></a>日期&#x2F;时间组件方法</h2><p><code>Date</code> 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为<code>GMT</code>）时的日期。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getTime()</td><td>返回日期的毫秒表示；与valueOf()相同</td></tr><tr><td>setTime(milliseconds)</td><td>设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td>getFullYear()</td><td>返回4 位数年（即2019 而不是19）</td></tr><tr><td>getUTCFullYear()</td><td>返回UTC 日期的4 位数年</td></tr><tr><td>setFullYear(year)</td><td>设置日期的年（year 必须是4 位数）</td></tr><tr><td>setUTCFullYear(year)</td><td>设置UTC 日期的年（year 必须是4 位数）</td></tr><tr><td>getMonth()</td><td>返回日期的月（0 表示1 月，11 表示12 月）</td></tr><tr><td>getUTCMonth()</td><td>返回UTC 日期的月（0 表示1 月，11 表示12 月）</td></tr><tr><td>setMonth(month)</td><td>设置日期的月（month 为大于0 的数值，大于11 加年）</td></tr><tr><td>setUTCMonth(month)</td><td>设置UTC 日期的月（month 为大于0 的数值，大于11 加年）</td></tr><tr><td>getDate()</td><td>返回日期中的日（1~31）</td></tr><tr><td>getUTCDate()</td><td>返回UTC 日期中的日（1~31）</td></tr><tr><td>setDate(date)</td><td>设置日期中的日（如果date 大于该月天数，则加月）</td></tr><tr><td>setUTCDate(date)</td><td>设置UTC 日期中的日（如果date 大于该月天数，则加月）</td></tr><tr><td>getDay()</td><td>返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td>getUTCDay()</td><td>返回UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td>getHours()</td><td>返回日期中的时（0~23）</td></tr><tr><td>getUTCHours()</td><td>返回UTC 日期中的时（0~23）</td></tr><tr><td>setHours(hours)</td><td>设置日期中的时（如果hours 大于23，则加日）</td></tr><tr><td>setUTCHours(hours)</td><td>设置UTC 日期中的时（如果hours 大于23，则加日）</td></tr><tr><td>getMinutes()</td><td>返回日期中的分（0~59）</td></tr><tr><td>getUTCMinutes()</td><td>返回UTC 日期中的分（0~59）</td></tr><tr><td>setMinutes(minutes)</td><td>设置日期中的分（如果minutes 大于59，则加时）</td></tr><tr><td>setUTCMinutes(minutes)</td><td>设置UTC 日期中的分（如果minutes 大于59，则加时）</td></tr><tr><td>getSeconds()</td><td>返回日期中的秒（0~59）</td></tr><tr><td>getUTCSeconds()</td><td>返回UTC 日期中的秒（0~59）</td></tr><tr><td>setSeconds(seconds)</td><td>设置日期中的秒（如果seconds 大于59，则加分）</td></tr><tr><td>setUTCSeconds(seconds)</td><td>设置UTC 日期中的秒（如果seconds 大于59，则加分）</td></tr><tr><td>getMilliseconds()</td><td>返回日期中的毫秒</td></tr><tr><td>getUTCMilliseconds()</td><td>返回UTC 日期中的毫秒</td></tr><tr><td>setMilliseconds(milliseconds)</td><td>设置日期中的毫秒</td></tr><tr><td>setUTCMilliseconds(milliseconds)</td><td>设置UTC 日期中的毫秒</td></tr><tr><td>getTimezoneOffset()</td><td>返回以分钟计的UTC 与本地时区的偏移量（如美国EST 即“东部标准时间”返回300，进入夏令时的地区可能有所差异）</td></tr></tbody></table><h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><p><code>ECMAScript</code> 通过<code>RegExp</code> 类型支持正则表达式。正则表达式使用类似<code>Perl</code> 的简洁语法来创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure><h1 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h1><p>为了方便操作原始值，<code>ECMAScript</code> 提供了3 种特殊的引用类型：<code>Boolean</code>、<code>Number</code> 和<code>String</code>。</p><p>这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。<strong>每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在这里，<code>s1</code> 是一个包含字符串的变量，它是一个原始值。第二行紧接着在<code>s1</code> 上调用了<code>substring()</code>方法，并把结果保存在<code>s2</code> 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问<code>s1</code> 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3 步：</p><ol><li>创建一个<code>String</code> 类型的实例；</li><li>调用实例上的特定方法；</li><li>销毁实例。</li></ol><p>可以把这3 步想象成执行了如下3 行<code>ECMAScript</code> 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">s1 = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3 步也会在后台发生，只不过使用的是<code>Boolean</code> 和<code>Number</code> 包装类型而已。 </p><p><strong>引用类型与原始值包装类型的主要区别在于对象的生命周期</strong>。在通过<code>new</code> 实例化引用类型后，得到的实例会在离开作用域时被销毁。</p><p><code>Object</code> 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">String</span>);  <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>如果传给<code>Object</code> 的是字符串，则会创建一个<code>String</code> 的实例。如果是数值，则会创建<code>Number</code> 的实例。布尔值则会得到<code>Boolean</code> 的实例。</p><p>注意，使用<code>new</code> 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> number = <span class="title class_">Number</span>(value);    <span class="comment">// 转型函数 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> number);    <span class="comment">// &quot;number&quot; </span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Number</span>(value);   <span class="comment">// 构造函数 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj);       <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>number</code> 中保存的是一个值为 25 的<strong>原始数值</strong>，而变量 <code>obj</code> 中保存的是一个<code>Number</code> 的实例。</p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p><code>Boolean</code> 是对应布尔值的引用类型。要创建一个<code>Boolean</code> 对象，就使用<code>Boolean</code> 构造函数并传入<code>true</code> 或<code>false</code>，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><p><code>Boolean</code> 的实例会重写<code>valueOf()</code>方法，返回一个原始值<code>true</code> 或<code>false</code>。<code>toString()</code>方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，<code>Boolean</code> 对象在 <code>ECMAScript</code> 中用得很少。<strong>不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用<code>Boolean</code> 对象时</strong>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true </span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们创建一个值为<code>false</code> 的<code>Boolean</code> 对象。然后，在一个布尔表达式中通过<code>&amp;&amp;</code>操作将这个对象与一个原始值<code>true</code> 组合起来。在布尔算术中，<code>false &amp;&amp; true</code> 等于<code>false</code>。可是，这个表达式是对 <code>falseObject</code> 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为<code>true</code>，因此 <code>falseObject</code>在这个表达式里实际上表示一个<code>true</code> 值。那么<code>true &amp;&amp; true</code> 当然是<code>true</code>。</p><p>除此之外，原始值和引用值（<code>Boolean</code> 对象）还有几个区别。首先，<code>typeof</code> 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，<code>Boolean</code> 对象是 <code>Boolean</code> 类型的实例，在使用<code>instaceof</code> 操作符时返回<code>true</code>，但对原始值则返回<code>false</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> falseObject);             <span class="comment">// object </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> falseValue);              <span class="comment">// boolean </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(falseObject <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(falseValue <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);  <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>理解原始布尔值和<code>Boolean</code> 对象之间的区别非常重要，<strong>强烈建议永远不要使用后者</strong>。</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p><code>Number</code> 是对应数值的引用类型。要创建一个 <code>Number</code> 对象，就使用 <code>Number</code> 构造函数并传入一个 数值，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>); </span><br></pre></td></tr></table></figure><p>与 <code>Boolean</code> 类型一样，<code>Number</code> 类型重写了 <code>valueOf()</code>、<code>toLocaleString()</code>和 <code>toString()</code>方 法。valueOf()方法返回<code>Number</code> 对象表示的原始数值，另外两个方法返回数值字符串。<code>toString()</code> 方法可选地接收一个表示基数的参数并返回相应基数形式的数值字符串，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>()); <span class="comment">// &quot;10&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">8</span>)); <span class="comment">// &quot;12&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">10</span>)); <span class="comment">// &quot;10&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>)); <span class="comment">// &quot;a&quot; </span></span><br></pre></td></tr></table></figure><p>除了继承的方法，<code>Number</code> 类型还提供了几个用于将数值格式化为字符串的方法。</p><p><code>toFixed()</code>方法返回包含指定小数点位数的数值字符串，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// &quot;10.00&quot; </span></span><br></pre></td></tr></table></figure><p>这里的 <code>toFixed()</code>方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为 “10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// &quot;10.01&quot; </span></span><br></pre></td></tr></table></figure><p><code>toFixed()</code>自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定 得到精确的结果。比如，0.1 + 0.2 &#x3D; 0.30000000000000004。</p><p>另一个用于格式化数值的方法是 <code>toExponential()</code>，返回以科学记数法（也称为指数记数法）表 示的数值字符串。与 <code>toFixed()</code>一样，<code>toExponential()</code>也接收一个参数，表示结果中小数的位数。 来看下面的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toExponential</span>(<span class="number">1</span>)); <span class="comment">// &quot;1.0e+1&quot;</span></span><br></pre></td></tr></table></figure><p>与 <code>Boolean</code> 对象类似，<code>Number</code> 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 <code>Number</code> 对象。在处理原始数值和引用数值时，<code>typeof</code> 和 <code>instacnceof</code> 操作符会返回不同的结果，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> numberObject); <span class="comment">// &quot;object&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> numberValue); <span class="comment">// &quot;number&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberObject <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberValue <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>原始数值在调用 <code>typeof</code> 时始终返回”number”，而 <code>Number</code> 对象则返回”object”。类似地，<code>Number</code> 对象是 <code>Number</code> 类型的实例，而原始数值不是。</p><p><code>isInteger()</code>方法与安全整数</p><p><code>ES6</code> 新增了 <code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0 可能会让人误以为数值是一个浮点值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1.00</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1.01</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p><code>IEEE 754</code> 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值 范围从 <code>Number.MIN_SAFE_INTEGER</code>（-2<sup>53</sup>+ 1）到 <code>Number.MAX_SAFE_INTEGER</code>（2<sup>53</sup> - 1）。对超出这 个范围的数值，即使尝试保存为整数，<code>IEEE 754</code> 编码格式也意味着二进制值可能会表示一个完全不同的 数值。为了鉴别整数是否在这个范围内，可以使用 <code>Number.isSafeInteger()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(-<span class="number">1</span> * (<span class="number">2</span> ** <span class="number">53</span>))); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(-<span class="number">1</span> * (<span class="number">2</span> ** <span class="number">53</span>) + <span class="number">1</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(<span class="number">2</span> ** <span class="number">53</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><code>String</code> 是对应字符串的引用类型。要创建一个 <code>String</code> 对象，使用 <code>String</code>构造函数并传入一个 数值，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>String</code> 对象的方法可以在所有字符串原始值上调用。3个继承的方法 <code>valueOf()</code>、<code>toLocaleString()</code> 和 <code>toString()</code>都返回对象的原始字符串值。</p><p>每个 <code>String</code> 对象都有一个 <code>length</code> 属性，表示字符串中字符的数量。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="property">length</span>); <span class="comment">// &quot;11&quot; </span></span><br></pre></td></tr></table></figure><p>注意，即使字符串中包含双字节 字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数。</p><ol><li><p>JavaScript字符</p><p><code>JavaScript</code>  字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 <code>length</code> 属性表示字符串包含多少 16 位码元。</p><p>此外，<code>charAt()</code>方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &quot;c&quot; </span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 字符串使用了两种 <code>Unicode</code> 编码混合的策略：<code>UCS-2</code> 和 <code>UTF-16</code>。对于可以采用 16 位编码 的字符（U+0000~U+FFFF），这两种编码实际上是一样的。</p><p>使用 <code>charCodeAt()</code>方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索 引以整数指定。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>)); <span class="comment">// 99 </span></span><br><span class="line"><span class="comment">// 十进制 99 等于十六进制 63 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">99</span> === <span class="number">0x63</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>字符串操作方法</p><p>首先是 <code>concat()</code>，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>对 <code>stringValue</code> 调 用 <code>concat()</code>方法的结果是得到”hello world”， 但 <code>stringValue</code> 的值保持不变。<code>concat()</code>方法可以接收任意多个参数，因此可以一次性拼接多个字符串， 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world!&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot; </span></span><br></pre></td></tr></table></figure><p>虽然 <code>concat()</code>方法可以拼接 字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。</p><p><code>ECMAScript</code> 提供了 3 个从字符串中提取子字符串的方法：<code>slice()</code>、<code>substr()</code>和 <code>substring()</code>。3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。<strong>第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置</strong>。对 <code>slice()</code>和 <code>substring()</code>而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对 <code>substr()</code>而言，第二个参数表示返回的子字符串数量。 <strong>任何情况下，省略第二个参数都意味着提取到字符串末尾</strong>。与 <code>concat()</code>方法一样，<code>slice()</code>、<code>substr()</code> 和 <code>substring()</code>也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot; </span></span><br></pre></td></tr></table></figure><p>当某个参数是负值时，这 3 个方法的行为又有不同。比如，<code>slice()</code>方法将所有负值参数都当成字符串长度加上负参数值。而 <code>substr()</code>方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。 substring()方法会将所有负参数值都转换为 0。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(-<span class="number">3</span>)); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;hel&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;&quot; (empty string) </span></span><br></pre></td></tr></table></figure></li><li><p>字符串位置方法</p><p>有两个方法用于在字符串中定位子字符串：<code>indexOf()</code>和 <code>lastIndexOf()</code>。这两个方法从字符 串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，<code>indexOf()</code>方法<strong>从字符串开头开始查找子字符串</strong>，而 <code>lastIndexOf()</code>方法<strong>从字符串末尾开始查找子字符串</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7 </span></span><br></pre></td></tr></table></figure><p><strong>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置</strong>。这意味着，<code>indexOf()</code>会从这个 参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；<code>lastIndexOf()</code>则会从这个参数指的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。下面看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 7 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4 </span></span><br></pre></td></tr></table></figure><p>像这样使用第二个参数并循环调用 <code>indexOf()</code>或 <code>lastIndexOf()</code>，就可以在字符串中找到所有的目标子字符串，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> positions = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"><span class="keyword">let</span> pos = stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;e&quot;</span>); </span><br><span class="line"><span class="keyword">while</span>(pos &gt; -<span class="number">1</span>) &#123; </span><br><span class="line">  positions.<span class="title function_">push</span>(pos); </span><br><span class="line">  pos = stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;e&quot;</span>, pos + <span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(positions); <span class="comment">// [3,24,32,35,52] </span></span><br></pre></td></tr></table></figure></li><li><p>字符串包含方法</p><p><code>ECMAScript</code> 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code>、 <code>endsWith()</code>和 <code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含 的布尔值。它们的区别在于，<code>startsWith()</code>检查开始于索引 0 的匹配项，<code>endsWith()</code>检查开始于索 引(<code>string.length</code> - <code>substring.length</code>)的匹配项，而 <code>includes()</code>检查整个字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>startsWith()</code>和 <code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。</p><p><code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>));     <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>trim()方法</p><p><code>ECMAScript</code> 在所有字符串上都提供了trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;  hello world  &quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue);         <span class="comment">// &quot;  hello world &quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue);  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>由于<code>trim()</code>返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。 另外，<code>trimLeft()</code>和<code>trimRight()</code>方法分别用于从字符串开始和末尾清理空格符。</p></li><li><p>repeat()方法 </p><p><code>ECMAScript</code> 在所有字符串上都提供了 <code>repeat()</code>方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">repeat</span>(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>); </span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure></li><li><p>padStart()和padEnd()方法</p><p><code>padStart()</code>和 <code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">6</span>));       <span class="comment">// &quot;   foo&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));  <span class="comment">// &quot;......foo&quot; </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">6</span>));         <span class="comment">// &quot;foo   &quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));    <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">2</span>));        <span class="comment">// &quot;foo&quot; </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>));   <span class="comment">// &quot;foobarba&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">2</span>));          <span class="comment">// &quot;foo&quot; </span></span><br></pre></td></tr></table></figure></li><li><p>字符串迭代与解构</p><p>字符串的原型上暴露了一个<code>@@iterator</code> 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>for-of</code> 循环中可以通过这个迭代器按序访问每个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// b </span></span><br><span class="line"><span class="comment">// c </span></span><br><span class="line"><span class="comment">// d </span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...message]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串大小写转换 </p><p>下一组方法涉及大小写转换，包括 4 个方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>。<code>toLowerCase()</code>和<code>toUpperCase()</code>方法是原来就有的方法，与<code>java.lang.String</code> 中的方法同名。<code>toLocaleLowerCase()</code>和<code>toLocaleUpperCase()</code>方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），<code>Unicode</code> 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。下面是几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLocaleUpperCase</span>());  <span class="comment">// &quot;HELLO WORLD&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toUpperCase</span>());        <span class="comment">// &quot;HELLO WORLD&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLocaleLowerCase</span>());  <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLowerCase</span>());        <span class="comment">// &quot;hello world&quot; </span></span><br></pre></td></tr></table></figure></li><li><p>字符串模式匹配方法</p><p><code>String</code> 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是<code>match()</code>方法，这个方法本质上跟<code>RegExp</code> 对象的 <code>exec()</code>方法相同。<code>match()</code>方法接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code> 对象。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);      <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);         <span class="comment">// &quot;cat&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>另一个查找模式的字符串方法是<code>search()</code>。这个方法唯一的参数与<code>match()</code>方法一样：正则表达式字符串或<code>RegExp</code> 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。<code>search()</code>始终从字符串开头向后匹配模式。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pos = text.<span class="title function_">search</span>(<span class="regexp">/at/</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pos);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这里，<code>search(/at/)</code>返回1，即”at”的第一个字符在字符串中的位置。</p><p>为简化子字符串替换操作，<code>ECMAScript</code> 提供了<code>replace()</code>方法。这个方法接收两个参数，第一个参数可以是一个 <code>RegExp</code> 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);  <span class="comment">// &quot;cond, bat, sat, fat&quot; </span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);  <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>localeCompare()方法 </p><p>最后一个方法是<code>localeCompare()</code>，这个方法比较两个字符串，返回如下3 个值中的一个。</p><ol><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。） </li><li>如果字符串与字符串参数相等，则返回0。 </li><li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;brick&quot;</span>));  <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;zoo&quot;</span>));    <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p><code>localeCompare()</code>的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是<code>ECMAScript</code> 实现的标准语言，<code>localeCompare()</code>区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。</p></li></ol><h1 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h1><p><code>ECMA-262</code> 对内置对象的定义是“任何由<code>ECMAScript</code> 实现提供、与宿主环境无关，并在<code>ECMAScript</code>程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括<code>Object</code>、<code>Array</code> 和<code>String</code>。本节介绍<code>ECMA-262</code>定义的另外两个单例内置对象：<code>Global</code> 和<code>Math</code>。</p><h2 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h2><p><code>Global</code> 对象是<code>ECMAScript</code> 中最特别的对象，因为代码不会显式地访问它。<code>ECMA-262</code> 规定<code>Global</code>对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，<strong>不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成<code>Global</code> 对象的属性</strong> 。前面介绍的函数，包括<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和<code>parseFloat()</code>，实际上都是<code>Global</code> 对象的方法。除了这些，<code>Global</code> 对象上还有另外一些方法。</p><ol><li><p>URL编码方法</p><p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI 不能包含某些字符，比如空格。使用URI 编码方法来编码URI 可以让浏览器能够理解它们，同时又以特殊的<code>UTF-8</code> 编码替换掉所有无效字符。</p><p><code>ecnodeURI()</code>方法用于对整个 URI 进行编码，比如”<a href="http://www.wrox.com/illegal">www.wrox.com/illegal</a> value.js”。而<code>encodeURIComponent()</code>方法用于编码URI 中单独的组件，比如前面URL 中的”illegal value.js”。</p><p>这两个方法的主要区别是，<code>encodeURI()</code>不会编码属于URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而<code>encodeURIComponent()</code>会编码它发现的所有非标准字符。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURI</span>(uri)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURIComponent</span>(uri)); </span><br></pre></td></tr></table></figure><p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>相对的是<code>decodeURI()</code>和<code>decodeURIComponent()</code>。<code>decodeURI()</code>只对使用<code>encodeURI()</code>编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由<code>encodeURI()</code>替换的。类似地，<code>decodeURIComponent()</code>解码所有被<code>encodeURIComponent()</code>编码的字符，基本上就是解码所有特殊值。</p></li><li><p>eval()方法</p><p>最后一个方法可能是整个 <code>ECMAScript</code> 语言中最强大的了，它就是 <code>eval()</code>。这个方法就是一个完整的 <code>ECMAScript</code> 解释器，它接收一个参数，即一个要执行的 <code>ECMAScript</code>（<code>JavaScript</code>）字符串。来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码的功能与下一行等价：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure><p>当解释器发现<code>eval()</code>调用时，会将参数解释为实际的<code>ECMAScript</code> 语句，然后将其插入到该位置。通过 <code>eval()</code>执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在<code>eval()</code>调用内部被引用，比如下面这个例子： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>);  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>类似地，可以在<code>eval()</code>内部定义一个函数或变量，然后在外部代码中引用，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;</span>); </span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure><p>通过 <code>eval()</code>定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在<code>eval()</code>执行的时候才会被创建。</p><p>在严格模式下，在 <code>eval()</code>内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报错。同样，在严格模式下，赋值给<code>eval</code> 也会导致错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; </span><br><span class="line"><span class="built_in">eval</span> = <span class="string">&quot;hi&quot;</span>;  <span class="comment">// 导致错误</span></span><br></pre></td></tr></table></figure></li><li><p>windows对象</p><p>虽然<code>ECMA-262</code>没有规定直接访问<code>Global</code> 对象的方式，但浏览器将<code>window</code> 对象实现为<code>Global</code>对象的代理。因此，所有全局作用域中声明的变量和函数都变成了<code>window</code> 的属性。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayColor</span>(); <span class="comment">// &quot;red&quot; </span></span><br></pre></td></tr></table></figure><p>这里定义了一个名为color的全局变量和一个名为<code>sayColor()</code>的全局函数。在<code>sayColor()</code>内部，通过<code>window.color</code> 访问了<code>color</code> 变量，说明全局变量变成了<code>window</code> 的属性。接着，又通过<code>window</code>对象直接调用了<code>window.sayColor()</code>函数，从而输出字符串。 </p><p>另一种获取Global 对象的方式是使用如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">global</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;  </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这段代码创建一个立即调用的函数表达式，返回了<code>this</code> 的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过<code>call()/apply()）</code>指定<code>this</code> 值的情况下执行时，<code>this</code> 值等于<code>Global</code> 对象。因此，调用一个简单返回<code>this</code> 的函数是在任何执行上下文中获取<code>Global</code> 对象的通用方式。</p></li></ol><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><code>ECMAScript</code> 提供了 <code>Math</code> 对象作为保存数学公式、信息和计算的地方。<code>Math</code> 对象提供了一些辅助计算的属性和方法。</p><ol><li><p>min()和 max()方法</p><p><code>Math</code> 对象提供了很多辅助执行简单或复杂数学计算的方法。 <code>min()</code>和 <code>max()</code>方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let max = Math.max(<span class="number">3</span><span class="punctuation">,</span> <span class="number">54</span><span class="punctuation">,</span> <span class="number">32</span><span class="punctuation">,</span> <span class="number">16</span>); </span><br><span class="line">console.log(max); <span class="comment">// 54 </span></span><br><span class="line">let min = Math.min(<span class="number">3</span><span class="punctuation">,</span> <span class="number">54</span><span class="punctuation">,</span> <span class="number">32</span><span class="punctuation">,</span> <span class="number">16</span>); </span><br><span class="line">console.log(min); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]; </span><br><span class="line"><span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...val);</span><br></pre></td></tr></table></figure></li><li><p>舍入方法</p><p>接下来是用于把小数值舍入为整数的 4 个方法：<code>Math.ceil()</code>、<code>Math.floor()</code>、<code>Math.round() </code>和 <code>Math.fround()</code>。这几个方法处理舍入的方式如下所述。</p><ul><li><code>Math.ceil()</code>方法始终向上舍入为最接近的整数。</li><li><code>Math.floor()</code>方法始终向下舍入为最接近的整数。</li><li><code>Math.round()</code>方法执行四舍五入。</li><li><code>Math.fround()</code>方法返回数值最接近的单精度（32 位）浮点值表示。</li></ul></li><li><p>random()方法</p><p><code>Math.random()</code>方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用 <code>Math.random()</code>从一组整数中随机选择一个数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * total_number_of_choices + first_possible_value) </span><br></pre></td></tr></table></figure><p>这里使用了 <code>Math.floor()</code>方法，因为 <code>Math.random()</code>始终返回小数，即便乘以一个数再加上一 个数也是小数。因此，如果想从 1~10 范围内随机选择一个数，代码就是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样就有 10 个可能的值（1<del>10），其中最小的值是 1。如果想选择一个 2</del>10 范围内的值，则代码就要写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">9</span> + <span class="number">2</span>); </span><br></pre></td></tr></table></figure><p>2~10 只有 9 个数，所以可选总数（total_number_of_choices）是 9，而最小可能的值 （first_possible_value）是 2。很多时候，通过函数来算出可选总数和最小可能的值可能更方便， 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> choices = upperValue - lowerValue + <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * choices + lowerValue); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">selectFrom</span>(<span class="number">2</span>,<span class="number">10</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 2~10 范围内的值，其中包含 2 和 10</span></span><br></pre></td></tr></table></figure><p>这里的函数 <code>selectFrom()</code>接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加 1 得到可选总数，然后再套用上面的公式。于是，调用 <code>selectFrom(2,10)</code>就可以从 2~10（包含） 范围内选择一个值了。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;引用值（或者对象）是某个特定引用类型的实例&lt;/strong&gt;。在&lt;code&gt;ECMAScript&lt;/code&gt;中，&lt;strong&gt;引用类型是把数据和功能组织到一起的结构&lt;/strong&gt;，经常被人错误地称作“类”。虽然从技术上讲 &lt;code&gt;JavaScri</summary>
      
    
    
    
    <category term="web" scheme="http://pvnk1u.github.io/categories/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/categories/web/javascript/"/>
    
    
    <category term="web" scheme="http://pvnk1u.github.io/tags/web/"/>
    
    <category term="javascript" scheme="http://pvnk1u.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
