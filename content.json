{"meta":{"title":"YOLO","subtitle":"","description":"","author":"pvnk1u","url":"http://pvnk1u.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-11-27T15:34:23.875Z","updated":"2023-11-27T15:34:23.875Z","comments":false,"path":"/404.html","permalink":"http://pvnk1u.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-27T15:34:23.981Z","updated":"2023-11-27T15:34:23.981Z","comments":false,"path":"tags/index.html","permalink":"http://pvnk1u.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-27T15:34:23.981Z","updated":"2023-11-27T15:34:23.981Z","comments":false,"path":"repository/index.html","permalink":"http://pvnk1u.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-27T15:34:23.888Z","updated":"2023-11-27T15:34:23.888Z","comments":false,"path":"categories/index.html","permalink":"http://pvnk1u.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"UdemyHtmlCss学习笔记——代码","slug":"UdemyHtmlCss学习笔记——代码与设计","date":"2023-11-21T07:32:39.000Z","updated":"2024-01-18T16:01:09.230Z","comments":true,"path":"2023/11/21/UdemyHtmlCss学习笔记——代码与设计/","link":"","permalink":"http://pvnk1u.github.io/2023/11/21/UdemyHtmlCss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"H5 使用strong元素取代b元素进行加粗显示 使用em元素取代i元素进行斜体显示 语义化元素 header nav section article aside figcaption figure footer CSS默认样式很多HTML元素本身都带有默认样式，默认样式定义在用户代理样式表(user agent stylesheet)中。 字体font-family为sans-serif代表无衬线字体，serif代表有衬线字体，有无沉陷的区别体现在文字的边角上是否有相应多出来的边缘线。无衬线字体更加简洁现代。 CSS选择器 后代选择器 123header p&#123; &#125; Id、Class选择器 1234567#name&#123; &#125;.class&#123; &#125; 元素选择器 1234567p&#123; &#125;a&#123;&#125; 通用选择器 123456/**通用选择器*/*&#123;&#125; 实际上，通用选择器是非常有用的，因为很多HTML元素都具有默认样式，如margin、padding等属性都有默认值。此时，为了方便对页面元素进行排版，便可以使用通用选择器直接指定所有元素的margin、padding值为0，这样后续开发时，HTML元素便不会受到默认样式的影响，因为通用选择器的优先级很低，可以很容易地被其他选择器设置的样式覆盖。 尺寸在CSS中可以通过height和width设置元素的高度和宽度。 对图像设置尺寸时，需要注意宽高度需要和原图片的宽高度保持一致，否则图片将会失真，可以在对宽高度中的其中一个进行了设置后，对另外一个属性使用auto属性自动适应。另外，如果使用百分比(如50%)设置元素宽度时，意味着元素的宽度将会是元素所在父元素的一半宽度，这对于响应式非常有用。 颜色RGB每种颜色都可以通过RED、GREEN、BLUE三种颜色的组合来呈现，这就是RGB颜色表示法。这三种基础颜色的取值范围可以从0~255不等，也就是说可以通过这三种基础颜色的组合呈现出一千六百多万种颜色。 当RED、GREEN、BLUE三种颜色中的的某一个值分别为最大值，而另外两个值为0时，则呈现出纯粹的对应颜色。 CSS颜色表示法在CSS中有两种颜色表示法： RGB&#x2F;RGBA表示法 通过使用RGB函数指定颜色，例如rgb(0,255,255)。 当需要指定颜色透明度的时候可以使用RGBA,A代表Alpha，例如rgba(0,255,255,0.3)，第四位值取值范围为0~1，取值越小则越透明，越大则越明显。 十六进制表示法 十六进制表示法不使用RGB的0255的表示法，而是使用0FF的表示法，FF和255一样。例如#00ffff，当十六进制表示法中的某两位相同时，可以使用速记法表示，例如#00ffff可以表示为#0ff。 实践中大多使用十六进制表示法，如果需要透明度，则使用RGBA表示法。 灰色在RGB表示法中，当光谱中的三个颜色相同时，将会得到灰色。当三个光谱值为最大值255时，得到白色，当三个值为最小值0时，得到黑色。也就是说正好有256种灰色值可以选择。 伪类 first-child 1234567/** 当一个li元素所在父元素下的第一个子元素是li元素时，这个第一个子元素(li元素)将被选中。如果一个li元素所在父元素下的第一个子元素不是li元素时，则这个li元素所在父元素下的子li元素都将不会被选中*/li:first-child&#123; &#125; last-child 1234567/** 当一个li元素所在父元素下的最后一个子元素是li元素时，这个第一个子元素(li元素)将被选中。如果一个li元素所在父元素下的第一个子元素不是li元素时，则这个li元素所在父元素下的子li元素都将不会被选中*/li:last-child&#123; &#125; nth-child() 123456/**当一个li元素所在父元素下的第偶数个元素是li元素时，这个元素将会被选中，如果第偶数个元素不是li元素则不会被选中*/li:nth-child(even)&#123; &#125; 更多用法参考 MDN nth-child() 链接伪类 a:link 选中所有具有href属性的a元素，如果没有href属性代表不是真正的链接，所以不算是link，a:link&#123;&#125;中的css规则如果与a&#123;&#125;中设置的规则相同时，生效的将是a:link&#123;&#125;中设置的规则。 a:visited 设置访问过的链接的样式，大多数现实情况下与a:link&#123;&#125;中的样式相同。 a:hover 设置鼠标在a链接上悬停时的样式， a:active 设置实际点击a链接时的链接的样式 需要特别注意的是，在实际使用时，总是应该按照这个顺序定义链接在不同情况下的样式，即L V H A。 在浏览器的开发者工具中，可以手动选中链接伪类以进行链接样式调试。 CSS三大特性CSS选择器优先级当一个元素被多个选择器共同指定样式规则时，其中的所有样式都将被应用，但是可能会存在一个元素对应的多个选择器中存在相同CSS属性的情况，如下所示： 123&lt;p id=&quot;author-text&quot; class=&quot;author&quot;&gt; Some Text&lt;/p&gt; 123456789101112131415.author&#123; font-style: italic; font-size: 18px;&#125;#author-text&#123; font-size: 20px;&#125;p,li&#123; font-family: sans-serif; color: #444; font-size: 22px;&#125; 在这段代码中，都对指定的p元素设置了font-size属性，这种情况下会根据CSS选择器的优先级来确定哪个选择器中的样式得到应用，优先级顺序如下（从高到低）： !important 使用!important声明的样式具有最高优先级，但是通常不应该使用，只应该在必要时作为最后的手段用来解决CSS中的冲突。 内联样式（不应该使用） 123&lt;p style=&quot;font-size:18px&quot;&gt; Some Text&lt;/p&gt; ID选择器(#) 如果有多个ID选择器对同一个元素设置了样式，则最后被定义的选择器生效 Class&#x2F;伪类选择器 同样的，当有多个class选择器时，最后被定义的选择器生效 元素选择器 同样的，当有多个元素选择器时，最后被定义的选择器生效 通用选择器（优先级最低） 123456/**通用选择器*/*&#123;&#125; VS Code中当鼠标悬浮在CSS选择器上时，VS Code会自动计算并显示出对应选择器的生效优先级权重Selector Specificity，其存在三个值，例如(1,0,0)，值越大的选择器，其定义的样式生效的优先级越高。 在实际开发中，应尽量避免某个元素的相同属性被定义在其多个选择器中，这样会使选择器及其中定义的样式变得非常混乱难以理解。 继承性给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。 并不是所有的属性都可以继承, 只有以color&#x2F;font-&#x2F;text-&#x2F;line-&#x2F;letter-&#x2F;list-开头的文本属性才可以继承。 在CSS的继承中不仅仅是直接子元素可以继承, 只要是后代都可以继承 继承性中的特殊性 a标签的文字颜色和下划线是不能继承的 h标签的文字大小是不能继承的 元素继承来的样式是优先级最低的。 可以通过通用选择器来为所有元素设置统一的不会被继承的样式： 123*&#123; &#125; CSS盒子模型盒子模型组成盒子模型是CSS最基本的模型，盒子模型定义了元素如何显示在网页上以及元素的大小。每个页面元素都可以看作是一个矩形框，每个框都可以有内容（content）、内部的填充（padding）、内部的边框（border）、外部的边界（margin）等部分。 内容（content） 这是页面元素的实际内容，它可以是文本&#x2F;图像&#x2F;表格&#x2F;视频等各种内容，CSS属性中的高度height、宽度width属性所指的宽高度就是指的内容区的宽高度。 边框（border） 在元素内容之外的区域内，可以指定元素的边框（包括宽度、样式、杨色等样式），需要注意的是，边框依然属性元素内的区域。 填充（padding） 在元素内容向外、边框向内的区域，是元素的填充，填充围绕着元素内容。和边框（border）一样，padding也依然是在元素内部。 填充（padding）本质上是可以在元素内部创建的独立于元素内容之外的空白空间。 外边距（margin） 在边框（border）之外的区域就是外边距 （margin），和填充（padding）不同的是，外边距（margin）已经不是在元素内部了，外边距描述的是多个元素之间的空间。 对于页面元素的这四个部分来说，其中前三个部分内容（content）、边框（border）、填充（padding）加起来的区域是元素的可见部分（也可称为填充区域）。需要特别注意的是，虽然元素的实际内容（文字、图像、视频等）只会显示在内容（content）区域中，但是如果元素设置了background、background-color等背景属性时，这些背景属性所应用的范围并不是内容（content）区域，而是整个元素的可见部分（填充区域）。 对于边框（border）、填充（padding）、外边距（margin）可以有多种方式指定上下左右四个方向的值，比如： 12345678910111213141516171819202122232425262728293031323334/**指定元素的上下左右的填充都是20个像素*/.class&#123; padding: 20px;&#125;/**指定元素的上下填充都是20个像素、左右的填充是40个像素*/.class&#123; padding: 20px 40px;&#125;/**指定元素的 上填充为25px 右填充为50px 下填充为75px 左填充为100px*/.class&#123; padding:25px 50px 75px 100px;&#125;/**指定元素的 上填充为25px 左右填充为50px 下填充为75px*/.class&#123; padding:25px 50px 75px;&#125; 对于margin属性，特别需要注意的一点是：如果两个相邻元素均设置了彼此对向方向上的margin属性值，则这两个相邻元素的外边距值不是其分别设置的外边距值之和，而是两个外边距值中的最大值。这种现象被称为边缘坍陷。 盒子模型计算默认盒子模型下，元素在页面上实际显示时所占用的宽度和高度计算方式由内容区域（content）、填充（padding）、边框（border）三部分得出，元素内容（content）的高度和宽度可以通过height和width属性指定，如果不指定的话，浏览器将根据实际内容自动计算得出，但是这个内容区域的高度和宽度并不是元素最终在页面上显示时的高度和宽度，真正的宽高度计算方式如下： 真正的元素宽度 左边框(left border) + 左填充（left padding） + 元素内容区域宽度（width） + 右填充（right padding） + 右边框（right border） 真正的元素高度 顶部边框(top border) + 顶部填充（top padding） + 元素内容区域高度（height） + 下填充（bottom padding） + 底部边框（bottom border） 盒子模型类型默认的盒子模型为box-sizing: content-box;，但是在这种默认的盒子模型下，height、width属性的应用范围是内容本身，此时元素盒子的实际高度和实际宽度的计算是比较复杂的，因为需要将内容本身的宽高度再加上填充长度再加上边框宽度才是盒子模型最后的宽度，所以可以将box-sizing属性的值修改为border-box。在border-box下，height、width属性应用的范围是包含border、padding、内容在内的全部范围。此时，就不需要再手动计算元素盒子的实际宽度和高度了，直接使用width、height即可。需要注意的是，在box-sizing:border-box下，再指定元素的padding、border值时，这部分的值将会从实际内容区域中扣减掉（即实际内容区域将会减小）。 可以使用全局选择器指定所有元素的盒子模型都是border-box，同时指定所有元素的默认填充padding、边距margin的值都是0，方便开发调试。 12345*&#123; margin: 0; padding:0 ; box-sizing: border-box;&#125; 元素类型HTML元素根据默认布局方式的不同，分为块级元素、内联元素（也叫行内元素）、内联块元素三种。 块级元素常用的标签如：div、p、ul、li、h1~h6、dl、dt、dd等等都是块元素，它在布局中的行为： 支持全部的样式 如果没有设置宽度，默认的宽度为父级宽度100% 默认情况下，块级元素总是单独占据一行、即使设置了宽度 通过display:block可以将其他类型的元素转换为块级元素。 内联元素内联元素也叫行内元素，常见的内联元素有strong、em、a、img、button元素等。它在布局中的行为： 支持部分样式 宽高由实际内容决定 不同的内联元素并在同一行里，不会换行 使用CSS代码强制换行，盒子之间会产生间距 子元素是内联元素时，父元素可以用text-align属性设置子元素水平对齐方式。 通过display:inline可以把其他类型的元素转换为内联元素。 需要特别注意的是，对于内联元素，宽度和高度是没有效果的，填充(padding)和外边距(margin)也只会在水平方向上起作用。 内联块元素内联块元素，也叫行内块元素，是新增的元素类型，现有元素没有归于此类别的，img和input元素的行为类似这种元素，但是也归类于内联元素，可以用display属性将块元素或者内联元素转化成这种元素。它们在布局中表现的行为： 支持全部样式 如果没有设置宽高，宽高由内容决定 只占用需要的空间，会和其他内联块元素和内联元素并在一行 代码换行，盒子会产生间距 子元素是内联块元素，父元素可以用text-align属性设置子元素水平对齐方式。 总结一下就是，内联块元素在外部表现得像内联元素（所以它们会并在同一行内显示），但是在内部表现得像是块级元素（所以可以设置宽度和高度）。 可以使用display:inline-block来将其他类型的元素转换为内联块元素。实际开发时，可以灵活地将内联元素转换为内联块元素来应用相应的样式。 CSS定位CSS中有几种几种不同的定位模式，可以通过position属性进行设置，该属性的可选值： static 元素的默认定位模式，没有定位，元素出现在正常的文档流中 relative 该关键字下，元素默认先被放置在未添加定位时的默认位置，再使用left、top、right、bottom属性相对于默认位置调整定位（此时，相对定位元素会相对原默认位置出现偏移，原默认位置会变为空白）。 如果想要让一个父元素的某个子元素（可以不是直接子元素）相对于父元素进行绝对定位，则父元素需要是relative相对定位的。 fixed 元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform、perspective、filter 或 backdrop-filter 属性非 none 时，容器由视口改为该祖先。 absolute 可以将任何元素绝对定位于页面上的任何位置，这种绝对定位模式会使对应的元素脱离原有文档流，并使其完全失去对周围其他元素的任何影响（甚至会与其他元素重叠）。而且这种定位将是相对于一个相对定位的父容器而言的；也就是说，如果想要对某个元素设置绝对定位，则这个元素的某一个父级元素（不需要必须是父元素）需要是相对（relative）定位的。绝对元素定位的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行定位，最终定位位置是相对于其第一个relative的父级元素（不需要必须是父元素）而言的。如果绝对定位元素的父元素是body且body未设置relative相对定位的话，则绝对定位元素的位置是相对于视口viewport而言的，也就是相对于浏览器当前窗口范围内进行绝对定位。 未通过left、top、right、bottom属性设置绝对定位元素的位置时，默认情况下，绝对定位元素的位置将出现在其第一个父级元素的左上角（即top和left都是0）。 sticky 元素根据正常文档流进行定位，但是在页面滚动时，该元素不会跟随页面一起滚动（显示&#x2F;消失），而是始终位于其默认相对于视口viewport的位置。相当于是相对定位和固定定位的结合，既有相对定位的保留自己原来位置的特点又有固定定位相对于可视窗口定位的特点。 伪元素伪元素本质上是HTML中不存在的，但是仍然可以在CSS中选择并设置样式的元素。 伪元素在CSS中以两个冒号(::)表示。 常用伪元素 first-letter 1234h1::first-letter&#123; font-style: normal; margin-right: 5px;&#125; 选中h1元素的第一个字符 first-line 123p::first-line&#123; color: red;&#125; 选择p元素中的第一行内容。 123h3 + p::first-line&#123; color: red;&#125; 相邻兄弟选择器。选中紧跟h3标题后的兄弟p元素的第一行。 after&#x2F;before 123456789101112131415h2::after&#123; /** 设置伪元素内容,即使伪元素没有实际内容，仍然需要定义content属性 */ content: &quot;TOP&quot;; background-color: #ffe70e; color: #000; font-size: 16px; font-weight: bold; display: inline-block; padding: 5px 10px; position: absolute; top: -10px; right: -25px;&#125; after&#x2F;before伪元素可用于设置指定元素的最后一个&#x2F;第一个子元素。after&#x2F;before伪元素对于不想创建真实HTML元素但是又想设置样式的装饰元素的场景(比如页面上的一个标识符)非常有帮助。 需要特别注意的是，after/before创建的伪元素默认元素类型是内联元素。 布局Float浮动布局这是使用float属性实现布局的老方式，目前已经基本上不会在新项目中使用。 例如：**float: left; 将页面元素设置为向左浮动后，元素将会像绝对定位一样脱离正常文档流。**浮动元素周围的元素都将会在它周围漂浮(这一点在周围的文本元素特别多时表现得更加明显)。 假如先后有两个块级元素 A、B，如果把 A 设置为 float: left 但是不设置 B 元素为浮动，此时 B 元素将会在 A 元素的右侧紧贴着 A 元素漂浮显示，但是此时 B 元素的左填充、左边距并不是相较于 A 元素的最右侧计算的，其依然是相较于 A 元素的最左侧计算，因为此时只有 A 元素脱离了文档流，B 元素并没有，所以虽然视觉效果上看起来 B 元素是在 A 元素右侧紧贴着 A 元素的，其计算时依然是参照文档流中的位置进行计算。但是如果把 A、B 元素均设置为浮动，此时 B 元素仍然紧贴着 A 元素的右侧，但是其计算左填充、左外边距的时候就变成根据 A 元素的右侧进行计算了，因为此时 A、B 元素都已脱离文档流，再次处于同一区域中。 设置了浮动的元素依然可以设置 margin 值来调整浮动元素与页面上其他仍处在文档流中的元素的外边距。 还有一条有关浮动需要注意的是当一个块级元素没有设置高度 height 值（高度自动扩展）时，如果这个块级元素内部的元素都变成了浮动元素，即其内部的元素都脱离了文档流，则这个父块级元素的高度将会失去高度，这就是”折叠元素”（元素的高度已经被折叠了），因为其内部已经没有实际上可以显示在文档流中的元素了，所以其高度变成了 0。避免这种副作用最好的方式就是使用 clear 来设置不想被浮动元素影响的元素（清除其围绕浮动元素漂浮的效果），可以使用 .container::after{content: ‘’;display: block;clear:both}来实现，这样就不需要手动在容器最后添加一个 HTML 元素来清除浮动了。元素被清除浮动之后，其将不会再围绕着浮动元素漂浮，而是依然在其原本的位置中。使用这个特性可以灵活的用来实现多个块级元素的并排、并列布局。如果想让浮动元素相邻的元素不要跟随在浮动元素周围漂浮显示的话，也可以对相应的元素使用clear属性清除浮动。 当在一行中有两个浮动元素，一个向左浮动，一个向右浮动且这两个元素的宽度之和不等于其父元素的宽度之和时，这两个元素中间会自动露出相应的空白区域，这一点可以非常方便的用于页面布局美化。 浮动和绝对定位的都会使元素脱离文档流，不同之处在于浮动元素会影响其周围的其他元素，使其他元素漂浮在它周围，而绝对定位与其周围的元素之间不会有任何影响。 FlexboxFlexbox 是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间。 长久以来，CSS 布局中唯一可靠且跨浏览器兼容的创建工具只有 float 和 position。这两个工具大部分情况下都很好使，但是在某些方面它们具有一定的局限性，让人难以完成任务。以下简单的布局需求是难以或不可能用这样的工具（float 和 position）方便且灵活的实现的： 在父内容里面垂直居中一个块内容。 使容器的所有子项占用等量的可用宽度&#x2F;高度，而不管有多少宽度&#x2F;高度可用。 使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。 Flexbox 使得这些布局任务变得更加容易。 要使用 flexbox，首先要创建弹性容器，可以通过在容器上添加 display: flex实现。这样弹性容器的所有直接子元素都将变为弹性元素。这些弹性元素的布局方向称为主轴。另外一个轴称为辅轴。主轴和辅轴可以通过设置属性调换。 对于弹性容器，有以下几个需要记住的属性： gap 可以在不使用 margin 外边距的情况下在各元素之间创建间隔。 justify-content 沿主轴对齐项目（默认情况下水平对齐）的方式 可选值有：flex-start | flex-end | center | space-between | space-around | space-evenly space-between 可以实现均分排满主轴的效果，经常拿来实现分别在最左侧和最右侧展示两个元素的效果。 align-items 沿辅轴对齐项目（默认情况下垂直对齐）的方式 stretch | flex-start | flex-end | center | baseline flex-direction 定义哪个是主轴 row | row-reverse | column | column-reverse flex-wrap 设置在项目太大的时候是否可以换行 nowrap | wrap | wrap-reverse align-content 在元素有多行时适用 stretch | flex-start | flex-end | center | space-between | space-around 对于弹性容器内部的容器元素，也有几个需要记住的属性： align-self 重新设置单个弹性容器元素的对齐属性（而不是适用弹性容器设置的的默认对齐方式） 可选值有: auto | stretch | flex-start | flex-end | center | baseline flex-grow flex-grow的默认值为0。这个属性可以允许弹性元素自动扩大以占据多余的空白空间，如果对一个弹性容器内的所有弹性元素均设置一个相同的 flex-grow 非零 值，则所有弹性元素将均分剩余空白空间，如果只对其中的指定某几项弹性元素设置，则将由这几项分别具有响应的空间，具体分得的空间将由每一项的 flex-grow 值占总值的比例计算得出。 flex-shrink 设置当空间不够时弹性元素的伸缩方式，默认值为 1（即允许伸缩），如果将其设置为 0，则将不允许收缩（如果此时设置了 flex-basis 的值，则将以 flex-basis 的值作为统一大小，但是此时因为不允许收缩，所以可能会出现元素显示范围超出容器的情况）。 flex-basis flex-basis的默认值为auto， 作用与 width 相同，用于设置一个弹性元素的基本宽度，但是并不代表设置了这个值后，所有元素的大小都是这个值，弹性容器允许弹性元素根据其需要的空间自动调整大小（即 flex-shrink 默认为 1），因此，flex-basis 更像是一个基准值。在弹性容器中，应该使用 flex-basis 替代 width 设置元素宽度。 flex: 0 1 auto 简写法，共有三个值，分别表示 flex-grow，-shrink、basis order 不需要改变弹性元素在代码中的顺序即可定义真正显示时的先后顺序，弹性元素的默认order为0，默认按照升序排列。 可以使用flex: flex-grow flex-shrink flex-basis的速记表示法一次性表示flex-grow、flex-shrink、flex-basis三个属性。 对于需要明确指定宽度的弹性元素，需要通过flex-basis指定最佳宽度，对于其他的没有那么需要明确指定宽度的弹性元素，可以将其flex-grow设置为1（根据其他弹性元素的宽度自动调节自身宽度），这样就只需要在个别的弹性元素上指定宽度及指定弹性容器的gap间隙值即可实现弹性元素宽度自动计算的效果。省去了手动计算元素宽度并逐个指定的步骤。 使用 flexbox 的一个很明显的好处在于，对弹性容器素中的多个弹性元素，只需要设置好其中的部分元素，并且设置好其他元素的 flex 值后（比如 flex: 1 代表这个弹性元素将尽可能地占据剩余的空间），浏览器会自动计算出所有元素应该占据地空间。 GridGrid可以实现构建完整的二维布局，这使得它非常适合实现页面整体布局。CSS Grid 使用方式： 通过设置容器 display: grid 来实现 grid。 对于 CSS Grid 容器有如下重要属性： 容器内部的多个元素将按照指定的列数来挨个排列，比如总共有 8 个元素，通过 grid-template-columns: 200px 200px 100px 100px;设置了 grid 具有四列元素，且前两列的宽度是 200 像素，后两列的宽度是 100 像素。那么这 8 个元素将通过第一行 4 个，第二行 4 个的排列方式展现在页面上。 除了可以通过在 CSS Grid 容器上 grid-template-columns 设置列的宽度，也可以通过 grid-template-rows 以同样的方式设置行的高度。如果设置的高度过高，那么实际高度没有达到这个高度的元素将会以其实际高度展示而不是被拉长。 可以通过 gap 属性设置 grid 容器中的间距，gap 属性设置的间距不仅适用于列之间，也适用于行之间，如果想单独设置列间距和行间距，可以通过 column-gap 和 row-gap来分别设置。 与 flexbox 相似，CSS Grid容器 也具有 justify-items 和 align-items 属性，分别代表行排列方式和列排列方式。 justify-items: stretch | start | center | end align-items: stretch | start | center | end 这两个属性和在 flexbox 中的用法及作用一致，是用来指定实际内容在其对应的单元格内的排列方式的 在 CSS Grid 容器 上还有两个属性是 justify-content 和 align-content。 justify-content: stretch | start | center | end align-content: stretch | start | center | end 。 需要与 justify-items 和 align-items 注意区分的是，这两个内容对齐属性指定的是网格的行、列两个轨道在其父 Grid 容器中的排列方式（因为网格容器的大小肯定大于等于网格的大小）。 对于这两组属性的区分，只需要记住 justify-items 和 align-items指定的是实际内容在其所在的 grid 内的单元格中的排列方式，而 justify-content 和 align-content 指定的则是 grid 中的单元格在 grid 容器中的排列方式。 对于 CSS Grid 容器中的网格项目，有如下属性： 网格列、网格行 grid-column: &#x2F; | span grid-row: &#x2F; | span 网格列和网格行对于放置网格项目进入特定的单元格（而不是按照默认的顺序放入对应的单元格）非常重要。 例如grid-column: 2 / 3就是将指定的单元格放入第2列，同理，grid-row: 2 / 3就是将指定的单元格放入第2行，像这种只占据一行&#x2F;列的（第二个值只比第一个值大1的）可以只写第一个值，例如grid-column: 2。当然，这个属性也可以指定网格跨越多列&#x2F;多行显示，例如grid-column: 2 / 4就是设置网格占据第二列~第三列的两列位置显示。为了不用进行计算，也可以使用grid-column: 2 / span 2设置跨越两列显示，不需要再进行计算。也可以设置grid-column: 1 / -1直接使元素占据整行。（因为grid分割线里最右边和最下方的值都是-1） justify-self: stretch | start | center | end align-self: stretch | start | center | end 用于覆盖对齐项，当其所在的 grid 容器被指定了 justify-items 和 align-items 属性，但是又想让特殊项使用个性化项目对齐样式替代 grid 容器的元素对齐样式时，就可以使用 justify-self 和 align-self 来代替父 grid 容器中的 justify-items 和 align-items 设置的样式。 在 CSS grid 中，可以在 grid-template-columns 和 grid-template-rows 中使用 fr(比如 1fr) 单位替代 px 单位指定大小。这样可以使对应的列或行填满 CSS Grid 容器中在指定方向上的所有剩余空间。如果对所有网格都使用了 fr 单位来指定大小，则这些网格将根据 fr 单位的大小按照 fr 单位的比例瓜分占满容器在这个方向上的空间。如果各网格的值都相同（1fr），则将均分容器在这个方向上的空间。 如果在 grid-template-colums 和 grid-template-rows 中的某一列或某一行上使用了 auto，则这一列（行）将只占据其实际需要占据的空间，除去这个 auto 大小元素之后的空间再被其他的设置了相应 px 像素或者 fr 单位的列（行）瓜分。 如果想快速均匀设置四列元素的 grid 布局，只需要简写为 grid-template-columns: repeat(4,1fr)，而不用写上四遍 1fr。 如果没有手动设置容器的高度，则每一行网格的实际高度由这一行中高度最高的一个网格的高度确定。如果通过 grid-template-rows 设置了每一行的高度相同，则所有行的高度都由其中高度最高的一个网格确定。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"html","slug":"web/html","permalink":"http://pvnk1u.github.io/categories/web/html/"},{"name":"css","slug":"web/html/css","permalink":"http://pvnk1u.github.io/categories/web/html/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"http://pvnk1u.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(6)——内容布局","slug":"精通CSS读书笔记(7)——页面布局与网格","date":"2023-07-01T07:28:39.000Z","updated":"2023-11-27T15:34:23.888Z","comments":true,"path":"2023/07/01/精通CSS读书笔记(7)——页面布局与网格/","link":"","permalink":"http://pvnk1u.github.io/2023/07/01/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BD%91%E6%A0%BC/","excerpt":"","text":"本章介绍布局的系统性方法。上一章探讨的是个别页面组件的布局方式。了解页面布局最好先从个别组件开始。但与此同时，会发现总体结构中有重复出现的模式。本章主要讨论如何以可重用的方式实现这些结构，也就是能够盛放内容的容器。 创建容器的时候，一般都需要一个包含预置尺寸和比例的网格系统。首先会介绍相对传统的创建网格系统的方法，然后演进到使用Flexbox。后半章还会涉及到面向未来的CSS Grid Layout规范。 在把设计方案转换成模板时，很多时候想都不想，就开始写HTML和写CSS。这样写着写着，很快就会发现没有了任何回旋余地。如果能在事前稍微作一番规划，将来很可能就避免了大量的无用功。规划阶段的关键就在于从设计方案中找出重复的模式，并识别出一些本质的东西。 网格说到一个网站的整体布局，经常会想到网格系统。网格系统是设计师在切分布局时作为参照的一组行和列。行和列之间的空白叫作空距。网格系统是页面布局常用的参考系。 布局辅助类类名用于为布局添加样式。对于简单的网站，几个类名就够用了。比如，用于控制两栏博客布局的类名大概这样就可以了： 12.main-content&#123;&#125;.secondary-content&#123;&#125; 随着网站的复杂度提高，会发现一些规律：由于某些部分从属于特定的内容层级，类名无法清晰地传达其意图。这时候类名重用就成了一个问题。为了让样式可以重用，很多人尝试“可视化”的命名方式，比如： 123.column&#123; /* 一般列的样式 */&#125;.column-half&#123;/* 占行宽的一半 */&#125;.row&#123;/*一般行的样式 */&#125; 这几个类名严格来说是表现性的，也就是在HTML中要加入表现性信息。另外，这样命名一目了然，方便重用，可以一次到位地解决布局问题。 另一种做法是把具有共用样式的选择符集中到一起： 123456.thing,.other-thing,.third-thing,.fourth-thing&#123; /* 共用的样式 */&#125; 这样做的好处是不必为了应用这些样式而专门搞一个类名，只需要在这一个地方添加或删除即可。但如此一来，选择符可能会越来越多，变得难以维护。这也会给代码组织带来问题。而且像这样根据共用样式而非可重用组件来分割样式，还会让修改网站中特定部分的样式变得非常麻烦，因为不得不在很多样式块之间跳来跳去。 命名规范是高质量代码的重要组成部分，把表现与标记混在一起也是权衡的结果。本章将走一条中间路线，一方面会使用一些辅助类，另一方面会尽可能少地与表现绑定起来。这是创建布局系统的简便方式，可以快速实现原型，同时还能保持样式的一致性。 固定、流动还是弹性“固定布局”、“流动布局”、“弹性布局”的说法指的是在某种布局下如何约束元素的尺寸。 固定布局 指页面具有特定的宽度，比如960像素。固定布局已经流行很长时间了，因为这样设计师和开发者会轻松很多。但是，有人会质疑到底什么尺寸是最好的：现在用户屏幕的主流宽度是1024像素，还是1280像素呢？ 弹性布局 指布局元素的尺寸使用em单位。这样，即使用户缩放文本大小，布局的比例也不会变。再与最小和最大宽度结合使用，还能使页面更好地适应屏幕大小。虽然弹性布局有点过时了，但其利用最大宽度限制em单位的思想是创建流动布局的关键。 流动布局 也称为“流式布局”，指页面元素会按比例缩放，但元素与元素之间的比率（有时候连元素之间的距离也）保持不变。这其实是Web的默认模式，即块级元素没有预置的宽度，其尺寸会随可用空间大小而变化。 建议尽量不要使用固定布局，最好使用流式布局，使其适应不同的设备。这种让设计能响应环境的设计方法叫作响应表WEB设计。 创建灵活的页面布局本节会介绍几种实用的布局方法，可以用来创建可靠、灵活、可重用的页面布局。 接下来会创建一个如下图所示的页面布局，这个布局会随屏幕大小而展示不同的列数，同时水平的分节也会变化。 把这个页面的布局简化成线框图，可以得到如下图所示的样子： 这个线框图没有表现出布局整体是居中的，有一个最大宽度限制。接下来就从这个限制宽度包装元素开始。 包装元素包装元素是页面布局中常用的一个盛放内容的元素，比如： 123456&lt;body&gt; &lt;!-- Some temporary style attributes added, just to see the effects of the wrapper. --&gt; &lt;div class=&quot;wrapper&quot; style=&quot;background-color: #ccc; min-height: 300px;&quot;&gt; &lt;h1 style=&quot;margin: 0&quot;&gt;My page&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt; 下面为这个包装元素添加一些样式。这些样式通过自动外边距，将包装元素设置为在页面上居中，同时使用了最大宽度。对于流动布局而言，适应百分比来设置一个稍微小于100%的宽度是很常见的。最大宽度则相对于文本大小来设置，单位是em。 12345.wrapper&#123; width: 95%; max-width: 76em; margin: 0 auto;&#125; body元素默认是有外边距的，为避免不必要的困扰，这里需要去掉它。简单地去掉body的外边距： 123body&#123; margin: 0;&#125; 下图所示的结果就是布局的起点了。以上寥寥几行CSS样式反映了如下几个布局选择。 主包装元素正常情况下应该是视口宽度的95%。 通过简写的margin: 0 auto，我们去掉了它的上下外边距，然后将水平剩余空间平均分配给左、右外边距（每一侧是2.5%），这样就让它在页面上居中了。 但是，这个包装元素最宽不会超过76em。按照每em默认为16像素计算，相当于1216像素。不过，如果用户通过浏览器缩放文本大小，包装元素的宽度也会同比例缩放。76em不是谁规定的，只是觉得它比较适合当前的布局。 这里屏蔽了一些不可控因素，比如屏幕大小及用户的字体设置，因为不希望布局的宽度值固定。 但一个居中的布局两侧应该留出一些空白区域，这跟屏幕大小无关。我们希望布局的宽度有一个上限，以防止文本行的长度超出可读范围。假如用户的浏览器有不同的默认文本大小，那么布局的最大宽度应该也能自动缩放。 由于设计不同，选择的度量方式也可能不同，但原理都是一样的：首先大体上确定内容包装元素的限制条件，但又不能把它们的值写死。要让布局能随机应变。 “随机应变”是软件设计的各种领域中经常能听到的一句话。在整体布局时不使用特定的像素值，就可以实现这一点。而这些样式一旦写完，就可以应用给任何包装元素，只要给它们添加相应的类即可。 换句话说，现在只要应用wrapper类就行了。以下代码中有3个地方应用这个类。首先是页头部分，然后是导航条。这两个元素本身是与浏览器视口一样宽的，但通过在它们内部包含一个包装元素，就可以实现内容在布局层面上居中。这两个块之后的main元素也是包装元素，用于盛放特定于页面的内容。 123456789101112131415161718&lt;header class=&quot;masthead&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;h1&gt;Important News&lt;/h1&gt; &lt;/div&gt;&lt;/header&gt;&lt;nav role=&quot;navigation&quot; class=&quot;navbar&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;navlist&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;World&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Local&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Sports&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt;&lt;main class=&quot;wrapper&quot;&gt; &lt;!-- 这里是主体内容 --&gt;&lt;/main&gt; 相关CSS代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* here&#x27;s our wrapper */.wrapper &#123; width: 95%; max-width: 76em; margin: 0 auto;&#125;/* masthead styling */.masthead &#123; background-color: #8E3339;&#125;.masthead h1 &#123; margin: 0; padding: 0.5em 0; color: #fff; text-shadow: -.1em .1em 0 rgba(0,0,0,0.3);&#125;/* navbar styling */.navbar &#123; background-color: #5E2126; margin-bottom: 1.375em;&#125;nav &#123; display: block;&#125;.navbar ul &#123; font-family: &#x27;Avenir Next&#x27;, Avenir, Corbel, &#x27;Franklin Gothic&#x27;, &#x27;Century Gothic&#x27;, CenturyGothic, AppleGothic, sans-serif; list-style: none; padding: 0; margin: 0; background-color: #752A2F; display: flex; overflow: hidden;&#125;.navbar li &#123; float: left; text-transform: uppercase; text-align: center; box-sizing: border-box; flex: 1 1 auto; border-left: 1px solid #8E3339;&#125;.navbar li:first-child &#123; border-left: 0;&#125;.navbar li a &#123; display: block; text-decoration: none; line-height: 1.75em; padding: 1em 2em; color: #fff;&#125; 效果如下图所示： 创建行容器和列创建好了头部菜单之后，再来实现“内容“部分在水平方向上的分组。效果如下图所示： 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Finished column layout sketch&lt;/title&gt; &lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/grid-base.css&quot;&gt;&lt;!-- the HTML5 shiv, to help older browsers understand styling on newer HTML5 elements: --&gt; &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /* our grid styles: */ .row:after &#123; content: &#x27;&#x27;; display: block; clear: both; &#125; .row-quartet &gt; * &#123; width: 25%; &#125; .row-trio &gt; * &#123; width: 33.3333%; &#125; .col &#123; float: left; -moz-box-sizing: border-box; box-sizing: border-box; min-height: 100px; outline: 1px solid #666; &#125; .subcategory-featured &#123; width: 50%; &#125; .subcategory-content &#123; width: 80%; &#125; .subcategory-header &#123; width: 20%; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;masthead&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;h1&gt;Important News&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;nav role=&quot;navigation&quot; class=&quot;navbar&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;navlist&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;World&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Local&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Sports&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;main class=&quot;wrapper&quot;&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Sub-section 1&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col subcategory-featured&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Sub-section 1&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-trio&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/main&gt; &lt;/body&gt;&lt;/html&gt; 引用的grid-base.css中的样式表代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970body &#123; margin: 0; line-height: 1.375; font-family: Georgia, Times New Roman, Times, serif;&#125;h1,h2,h3,h4,h5,h6 &#123; font-family: Avenir Next, Avenir, Franklin Gothic, Trebuchet MS, Arial, sans-serif; margin-top: 0;&#125;a &#123; color: #8E3339; text-decoration: none;&#125;a:hover,a:focus &#123; text-decoration: underline;&#125;/* here&#x27;s our wrapper */.wrapper &#123; width: 95%; max-width: 76em; margin: 0 auto;&#125;/* masthead styling */.masthead &#123; background-color: #8E3339;&#125;.masthead h1 &#123; margin: 0; padding: 0.5em 0; color: #fff; text-shadow: -.1em .1em 0 rgba(0,0,0,0.3);&#125;/* navbar styling */.navbar &#123; background-color: #5E2126; margin-bottom: 1.375em;&#125;nav &#123; display: block;&#125;.navbar ul &#123; font-family: &#x27;Avenir Next&#x27;, Avenir, Corbel, &#x27;Franklin Gothic&#x27;, &#x27;Century Gothic&#x27;, CenturyGothic, AppleGothic, sans-serif; list-style: none; padding: 0; margin: 0; background-color: #752A2F; display: flex; overflow: hidden;&#125;.navbar li &#123; float: left; text-transform: uppercase; text-align: center; box-sizing: border-box; flex: 1 1 auto; border-left: 1px solid #8E3339;&#125;.navbar li:first-child &#123; border-left: 0;&#125;.navbar li a &#123; display: block; text-decoration: none; line-height: 1.75em; padding: 1em 2em; color: #fff;&#125; 接下来分析这份代码，在这段代码中，首先创建了行容器（class名为row）及行容器中的多列内容。首先定义HTML元素及类名（行为row，列为col），然后实现了内容在水平方向上的分组。 123456.row:after&#123; content: &#x27;&#x27;, display: block; clear: both; height: 0;&#125; 这里使用伪类和clear:both实现.row行元素分别各占一行的效果。 实现了行元素之后，再来实现创建列的效果。上一章的几种水平布局方法中，浮动是最常用的，也是浏览器支持最好的技术。因此，这里用浮动创建列。对于从左向右书写的语言，默认的向左浮动应该是最佳选择。 考虑到将来可能会在不影响列宽度的前提下，直接给列容器添加边框和内边距，还应该把box-sizing属性设置为border-box。 123456.col&#123; float: left; box-sizing: border-box; min-height: 100px; outline: 1px solid #666;&#125; 其中的min-height是为列指定了最低高度。outline则是指定了列的轮廓线（因为不影响元素尺寸，所以轮廓线适用于元素可视化布局和调试布局）。 接下来需要给列设置列宽。很多CSS库都使用直接表示宽度的类来指定列宽，比如： 123456.col-1of4&#123; width: 25%;&#125;.col-1of2&#123; width: 50%;&#125; 这种方式非常适合面向台式电脑或笔记本电脑的快速原型。根据前面定义的规则，很容易在HTML中定义一个3列的、最左列占一半宽度的布局。 12345&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col col-1of2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col col-1of4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col col-1of4&quot;&gt;&lt;/div&gt;&lt;/div&gt; 这种方式的缺点是过分强调某种布局。如果将来需要根据屏幕大小动态调整布局，这种命名方式就不太合适了。 如果想通过可重用的类名来控制尺寸，就必须让HTML标记与CSS表现有一个结合点。可以给这个结合点换个名字，不使用特定的宽度或者比率，让它更为普适。用音乐来比喻的话，可以创建一条规则，让行容器在正常情况下包含4个宽度相等的部分（quartet，四重奏）。 123.row-quartet &gt; * &#123; width: 25%;&#125; 然后使用通用选择符，直接针对行容器的子元素，同时可以降低这条通用规则的特殊性。因为通用选择符的特殊性为0，所以后面可以用一个特殊的类名来覆盖这个宽度。此时通过以下标记就可以创建一个包含4个等宽列的行： 123456&lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;&lt;/div&gt; 这样，.row-quartet中的列如果想改变宽度，就可以应用覆盖宽度的一个类名，但这个类名并不与布局相关。于是前面的3列布局就可以这样写： 12345&lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col my-special-column&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123.my-special-column&#123; width: 50%;&#125; 除了四重奏，当然还应该有三重奏： 123456.row-quartet &gt; *&#123; width: 25%;&#125;.row-trio &gt; *&#123; width: 33.3333%;&#125; 在前面的效果图中，两个子分类都有一个标题区，占整个布局区（包含标题区和内容区两块）的五分之一，右侧的内容区占剩下的五分之四。而在第一个子分类中，还有一个更大的文章列，占内容区的50%。相关代码如下： 1234567891011.subcategory-featured &#123; width: 50%;&#125;.subcategory-content &#123; width: 80%;&#125;.subcategory-header &#123; width: 20%;&#125; HTML代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Sub-section 1&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col subcategory-featured&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;&lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Sub-section 1&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-trio&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;h3&gt;Story&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 至此便实现了图中的效果。在这些定义好的网格类基础上，很容易组合和扩展出更复杂的布局模式。下面在每个容器中添加一些示例内容，以充实细节。 以下是带图片文章的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Float grid with dummy content&lt;/title&gt; &lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/grid-base.css&quot;&gt;&lt;!-- the HTML5 shiv, to help older browsers understand styling on newer HTML5 elements: --&gt; &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /* grid styling */ .row &#123; padding: 0; list-style: none; &#125; .row:after &#123; content: &#x27;&#x27;; display: block; clear: both; &#125; .col &#123; float: left; -moz-box-sizing: border-box; box-sizing: border-box; &#125; .col:last-child &#123; float: right; &#125; .row-quartet &gt; * &#123; width: 25%; &#125; .row-trio &gt; * &#123; width: 33.33333%; &#125; /* content styling */ .subcategory &#123; margin-top: 1.5em; border-bottom: 1px solid #8e3339; &#125; .subcategory-featured &#123; width: 50%; &#125; .subcategory-content &#123; width: 80%; &#125; .subcategory-header &#123; width: 20%; &#125; .story &#123; padding: .6875em; background-color: #eee; &#125; .story img &#123; width: 100%; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;masthead&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;h1&gt;Important News&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;nav role=&quot;navigation&quot; class=&quot;navbar&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;navlist&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;World&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Local&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Sports&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;main class=&quot;wrapper&quot;&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Lorem ipsum&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col subcategory-featured&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Cras suscipit nec leo id.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Autem repudiandae aliquid tempora quos reprehenderit architecto, sequi repellat.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Curabitur mattis purus nec velit.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam mattis eros id posuere.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Proin leo felis, semper nec&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam vitae risus tortor. Sed!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Dolor sit amet&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-trio&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Ut sit amet mi massa&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Nunc mollis sit amet nunc&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Duis sed ante enim. Cras&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Animi, explicabo, ipsum&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/main&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下所示： 在列容器（类名为col的元素）中，使用了带story类名的article元素。这个额外的元素将布局与内容隔离开来，避免因加重包装元素的负担而导致其过载。 这里需要注意的是以下有关.story的CSS代码： 12345678.story &#123; padding: .6875em; background-color: #eee;&#125;.story img &#123; width: 100%;&#125; 这里指定了.story元素的padding内边距的值及背景颜色，使内容区更加美观，随后设置.story的子img图片元素的宽度为100%。这里需要注意的是，例子中用的是同样一张图片，但是因为img的父元素.story的宽度不同，所以展示出的图片大小也不同，第一张图片的story的宽度是其他story元素的2倍，所以图片大小也是其他图片的两倍。 流式空距现在需要给列间添加一些空白了，这样布局才不会看起来紧绷绷的。 在流动布局中，空距可以是百分比，也可以是相对于字体大小的固定宽度。不管采用哪种方式，列元素两边的宽度都应该相等。换句话说，每一边的空距宽度都应该是空距宽度的一半。 不管怎么样，都应该知道如何计算百分比外边距的实际值，这样才能保证空距与列宽相协调。在前面的例子中，文本大小为16像素，行高为1.375em，即22像素。假设我们希望在一般的屏幕尺寸中，空距等于文本的行高，从而将排版与布局联系起来。先从布局的最宽点开始，即76em或1216像素。 因为外边距相对包含块来计算，所以计算空距与总宽度的比例与计算相对文本大小是一样的：预期的宽度除以总宽度。22除以1216等于0.018092105。也就是说，一个空距大约是总宽度的1.8%。最后，这个百分比再除以2，就是每一列的每侧的外边距，即0.9%。 123.col&#123; margin: 0 0.9% 1.375em;&#125; 这里也添加了一个下外边距，让两个内容行之间的距离等于行高。注意这里的垂直空间用em设置，而不是百分比。这是因为行高和屏幕尺寸无关，既然以行高为依据，就应该沿用计算行高的参照物（即文本大小）。 此时看一下布局，会发现它乱了（如下图）。这是给列设置了外边距所导致的。就算设置了box-sizing: border-box，对外边距也是无能为力。此时所有列的总宽度超过了100%。因此，接下来需要重新定义列宽。 因为给每一列加了1.8%的空距，所以只要从原先的列宽中减去它就可以了。 12345678910111213141516171819.row-trio &gt; *&#123; width: 31.53333%;&#125;.row-quartet &gt; *&#123; width: 23.2%;&#125;.subcategory-featured&#123; width: 48.2%;&#125;.subcategory-header&#123; width: 18.2%;&#125;.subcategory-content&#123; width: 78.2%;&#125; 减去之后的效果就变得正常了，而且稍微拖窄一点浏览器窗口可以发现空距也会随之缩小。 抵消最外侧的空距 现在，我们有了一个网格系统，可以表示行、流动的列和流式空距。接下来要做的是处理细节，尽量避免视觉效果冲突。 首先，用于创建空距的外边距导致了外层容器左边和右边额外的缩进，这不是我们想要的。在内部行中嵌套的列也出现了同样的问题（如下图所示）。我们应该去掉第一项的左外边距和最后一项的右外边距。但这样会导致列宽和空距的计算复杂化。 对于没有特定宽度的非浮动块级元素，会在左、右负外边距都设置的情况下扩展其宽度。由于我们使用了一个独立的元素作为行来分隔内容（而不是让列元素也充当行再去嵌套列），此时正好可以利用这一点来应用我们的技巧，那就是给每一行的左、右两侧都应用一个等于空距一半宽度的负外边距。 123.row&#123; margin: 0 -.9%;&#125; 设置空距的替代方案 要想进一步简化列宽的计算，可以利用box-sizing属性，并使用内边距来设置空距。 如果想继续使用流式空距，那么只要把外边距改成内边距即可。这样就可以重新以整个宽度的适当百分比来表示列宽，而不必考虑空距了。 123456789101112131415.col&#123; float: left; box-sizing: border-box; padding: 0 .9% 1.375em;&#125;.row-trio &gt; *&#123; width: 33.3333%;&#125;.subcategory-featured&#123; width: 50%;&#125; 这样一来就可以使用排版的基准来设置空距了。换句话说，可以使用em来设置空距，而不用基于网格宽度的百分比。在下面的例子中，空距大小与行高相同，在列之间创建了相同的垂直与水平间距，而这与网格的宽度无关。 12345.col&#123; float: left; box-sizing: border-box; padding: 0 .6875em .1375em;&#125; 完整代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Float grid with elastic gutters&lt;/title&gt; &lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/grid-base.css&quot;&gt;&lt;!-- the HTML5 shiv, to help older browsers understand styling on newer HTML5 elements: --&gt; &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /* grid styling */ .row &#123; margin: 0 -.6875em; padding: 0; list-style: none; &#125; .row:after &#123; content: &#x27;&#x27;; display: block; clear: both; &#125; .row-quartet &gt; * &#123; width: 25%; &#125; .row-trio &gt; * &#123; width: 33.3333%; &#125; .col &#123; float: left; -moz-box-sizing: border-box; box-sizing: border-box; padding: 0 .6875em 1.375em; &#125; .col:last-child &#123; float: right; &#125; /* content styling */ .subcategory &#123; margin-top: 1.5em; border-bottom: 1px solid #8e3339; &#125; .subcategory-featured &#123; width: 50%; &#125; .subcategory-content &#123; width: 80%; &#125; .subcategory-header &#123; width: 20%; &#125; .story &#123; padding: .6875em; background-color: #eee; &#125; .story + .story &#123; margin-top: 1.375em; &#125; .story img &#123; width: 100%; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;masthead&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;h1&gt;Important News&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;nav role=&quot;navigation&quot; class=&quot;navbar&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;navlist&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;World&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Local&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Sports&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;main class=&quot;wrapper&quot;&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Lorem ipsum&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col subcategory-featured&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Cras suscipit nec leo id.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Autem repudiandae aliquid tempora quos reprehenderit architecto, sequi repellat.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Curabitur mattis purus nec velit.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam mattis eros id posuere.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Proin leo felis, semper nec&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam vitae risus tortor. Sed!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Dolor sit amet&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-trio&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Ut sit amet mi massa&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Nunc mollis sit amet nunc&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Duis sed ante enim. Cras&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Animi, explicabo, ipsum&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/main&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示，通过设置相对于文本大小的“弹性”空距，空距就跟内容宽度无关了。 增强列：包装与等高前面创建布局主要使用了浮动。除了浮动以外，还有很多其他布局方案可以实现同样布局的例子。掌握这些方法以后，可创造出更灵活的布局。 用行内块包装行和列 有时会有如下图这样的两行或更多行标题的HTML区域，使用浮动块来包装这些行可能会有问题。比如，某个新闻的标题很长，导致该列非常高，就会出现非常难看的“锯齿”效果。 为此，可以创建一个通用的类名，预期的应用场景就是包装多行。对添加了这个类名的容器，应用基于文本大小技术的inline-block。此时，由于font-size是0，在设置行容器的负外边距时要使用rem单位。考虑到向后兼容，这里还添加了像素单位的后备规则： 12345678910111213.row-wrapping&#123; font-size: 0; margin: 0 -11px; margin: 0 -.6875rem;&#125;.row-wrapping &gt; * &#123; float: none; vertical-align: top; display: inline-block; font-size: 16px; font-size: 1rem;&#125; 有了这两条规则，就可以添加任意多个新闻预览，这些新闻预览会在填满一行四列后自动折行。在验证结果之前，先用Flexbox再打磨一下细节。 使用Flexbox实现等高的列 之前介绍过，Flexbox可以用来创建等高的列。在创建一整套布局时，我们希望有些规则只在浏览器支持Flexbox时应用。 为检测浏览器是否支持Flexbox，要在页面上方引入一小段脚本。这里使用Modernizr，这个库会根据浏览器支持的特性，给HTML元素添加相应的类。访问https://modernizr.com/，可以在上面定制需要的检测脚本。本例所需的定制脚本只包含检测Flexbox特性的代码，以保持其最小化。 创建完检测脚本，把它复制到一个JavaScript文件里，然后引入即可，但次序一定要先于引入CSS文件的元素。然后就可以基于带前缀的类名来编写样式了。只有支持Flexbox的浏览器才会解析它们。flexbox类表示浏览器支持Flexbox，而flexwrap表示可伸缩项会折成多行或多列。 在完整的代码证还能看到使用了flexboxweener类，这个类表示浏览器支持IE10中的Flexbox。 首先，把标准行转换成Flexbox行： 123.flexbox .row&#123; display: flex;&#125; 这样就已经创建了等高的列，这也是可伸缩项会拉伸以填充父元素的默认行为。 因为针对每一列的内容都使用了包装元素，所以需要对这些列应用更多的Flexbox属性，使其中的内容能均匀地填充这些列。这里每一列都会变身为一个列状的可伸缩容器，其子元素按照规则会均匀填充可分配的剩余空间。 12345678.flexbox .col&#123; display: flex; flex-direction: column;&#125;.flexbox .col &gt; *&#123; flex: 1;&#125; 简写的flexbox: 1代表flex-grow: 1、flex-shrink: 1、flex-basis: 0。 最后，再对包装行进行增强，让它们也能利用Flexbox的等高机制。 1234.flexwrap .row-wrapping&#123; display: flex; flex-wrap: wrap;&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Using flexbox to create equal-height columns&lt;/title&gt; &lt;!-- the base styles and &quot;housekeeping&quot; styles are in here: --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/grid-base.css&quot;&gt;&lt;!-- Modernizr script to detect flexbox support, which also includes HTML5 shiv, to help older browsers understand styling on newer HTML5 elements: --&gt; &lt;script src=&quot;js/modernizr.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /* grid styling */ .row &#123; list-style: none; padding: 0; margin: 0 -.6875em; &#125; .flexbox .row, .flexboxtweener .row &#123; display: -webkit-flex; display: -ms-flexbox; display: flex; &#125; .row:after &#123; content: &#x27;&#x27;; display: block; clear: both; &#125; .row-quartet &gt; * &#123; width: 25%; &#125; .row-trio &gt; * &#123; width: 33.3333%; &#125; .row-wrapping &#123; font-size: 0; margin: 0 -11px; margin: 0 -.6875rem; &#125; .flexwrap .row-wrapping &#123; display: -webkit-flex; display: -ms-flexbox; display: flex; -webkit-flex-wrap: wrap; -ms-flex-wrap: wrap; flex-wrap: wrap; &#125; .row-wrapping &gt; .col &#123; float: none; vertical-align: top; display: inline-block; font-size: 16px; font-size: 1rem; &#125; .col &#123; float: left; -moz-box-sizing: border-box; box-sizing: border-box; padding: 0 .6875em 1.375em; &#125; .flexbox .col, .flexboxtweener .col &#123; display: -webkit-flex; display: -ms-flexbox; display: flex; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; &#125; .flexbox .col &gt; *, .flexboxtweener .col &gt; * &#123; -webkit-flex: 1; -ms-flex: 1 0 auto; flex: 1; &#125; .col:last-child &#123; float: right; &#125; /* content styling */ .subcategory &#123; margin-top: 1.5em; border-bottom: 1px solid #8e3339; &#125; .subcategory-featured &#123; width: 50%; &#125; .subcategory-content &#123; width: 80%; &#125; .subcategory-header &#123; width: 20%; &#125; .story &#123; padding: .6875em; background-color: #eee; &#125; .story + .story &#123; margin-top: 1.375em; &#125; .story img &#123; width: 100%; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header class=&quot;masthead&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;h1&gt;Important News&lt;/h1&gt; &lt;/div&gt;&lt;/header&gt;&lt;nav role=&quot;navigation&quot; class=&quot;navbar&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;navlist&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;World&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Local&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Sports&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt;&lt;main class=&quot;wrapper&quot;&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Lorem ipsum&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-quartet&quot;&gt; &lt;div class=&quot;col subcategory-featured&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Cras suscipit nec leo id.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Autem repudiandae aliquid tempora quos reprehenderit architecto, sequi repellat.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam!&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Curabitur mattis purus nec velit.&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;row row-quartet row-wrapping&quot;&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam! Dolor sit amet consectetur&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam mattis eros id posuere.&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Proin leo felis, semper nec&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam vitae risus tortor. Sed!&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Perferendis, ipsam!&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam mattis eros id posuere.&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Proin leo felis, semper nec&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;col&quot;&gt; &lt;div class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Aliquam vitae risus tortor. Sed!&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;subcategory&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;header class=&quot;col subcategory-header&quot;&gt; &lt;h2&gt;Dolor sit amet&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;col subcategory-content&quot;&gt; &lt;div class=&quot;row row-trio&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Ut sit amet mi massa&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Nunc mollis sit amet nunc&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;story&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Duis sed ante enim. Cras&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;article class=&quot;story&quot;&gt; &lt;img src=&quot;http://placehold.it/600x300&quot; alt=&quot;Dummy image&quot;&gt; &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Animi, explicabo, ipsum&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;Neque magnam vero obcaecati facere nobis sint dolore accusamus vitae consequuntur ad necessitatibus, laborum molestiae.&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/main&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(6)——内容布局","slug":"精通CSS读书笔记(6)——内容布局","date":"2023-06-05T07:28:39.000Z","updated":"2023-11-27T15:34:23.887Z","comments":true,"path":"2023/06/05/精通CSS读书笔记(6)——内容布局/","link":"","permalink":"http://pvnk1u.github.io/2023/06/05/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80/","excerpt":"","text":"网页是由不同内容块构成的：标题、段落、链接、列表、图片、视频等等。这些元素可以按照主题组织起来，比如一个标题，几段文本，外加一张图片就是一篇新闻报道。通过控制每个组件内部元素的位置、大小、顺序，就可以更好地传达它们的功能与含义。 所有内容块会进一步组织成整个页面的布局。下一章将会讲到如何系统化地布局页面。本章仍然聚焦于个别的内容块，从而深入理解如何对每个内容块进行布局。 之前大致讲过使用定位和浮动来实现布局，这两种手段各有千秋。此外，也可以使用表格显示模式和行内块来实现布局，当然也各有各的优缺点。CSS新增的Flexible Box Layout Module（或Flexbox）为内容块提供了一大批顺序、方向、对齐及尺寸相关的属性。Flex是非常强大的布局功能，本章会详细介绍。 定位定位并不适合于总体布局，因为它会把元素拉出页面的正常流。反过来看，这也正是定位在CSS中之所以重要的原因，接下来将简单探讨一下定位在哪些情况下最合适。 以下是对定位内容的简单总结： 元素的初始定位方式是静态定位（static），意思是块级元素垂直堆叠。 可以把元素设置为相对定位（relative），然后可以相对于其原始位置控制该元素的偏移量，同时又不影响其周围的元素。与此同时，这也为该元素的后代元素创造了定位上下文。这一点也是相对定位真正的用处。以前，在一些古老的布局技巧中，经常要偏移元素，当然现在已经很少这样了。 绝对定位（absolute）支持精确定位元素，相对于其最近的定位上下文：或者是其非静态定位的祖先元素，或者是HTML元素。绝对定位的元素会脱离页面流，然后再相对于其定位上下文进行定位。默认情况下，它们会被浏览器定位于之前静态定位时所处的位置但不会影响周围的元素。然后，可以相对于定位上下文来改变它们的位置。 固定定位（fixed）与绝对定位基本类似，只不过定位上下文被自动设置为浏览器视口。 绝对定位的应用场景绝对定位非常适合创建弹出层、提示和对话框这类覆盖于其他内容之上的组件。它们的位置可以通过top、right、bottom和left属性控制。关于绝对定位，了结以下知识可以写出更高效的代码。 利用初始位置 比如有一篇介绍太空飞船的文章，想在文章上添加一些行内的评注。这些评注最好以气泡图的样式显示在文章外部的空白区域，如下图所示。 每个评注组件都是一个aside组件，实际位置在它们指向的段落后面： 123&lt;p&gt;This is a fake article[...]&lt;/p&gt;&lt;aside class=&quot;comment&quot;&gt;I`ve never done this. Is that really true?&lt;/aside&gt;&lt;p&gt;You may think[...]&lt;/p&gt; 为了让评注显示在段落之后，需要使其绝对定位。而我们不必为了在垂直方向上准确的定位它们而给出确切的上偏移量。 绝对定位的元素默认会待在自己静态定位时的地方，因此第一步是让评注显示在其初始位置。 123.comment&#123; position: absolute;&#125; 添加这段CSS代码之后，aside元素将会变成绝对定位，即脱离页面流。这样一来，原本会跟在p元素文本段落之后看起来像是单独段落的aside内的内容将会出现在再往后的第二段p元素的上方，导致显示重叠。 接下来需要把评注向左和向上偏移，把它定位到之前段落的旁边。这听起来像是要使用相对定位，但元素不能同时既是绝对定位又是相对定位。如果此时使用方向性偏移属性（top、right、left和bottom），那就既要用到定位上下文，又要设置确定的偏移量。好在不用这么麻烦，在这里完全可以通过负外边距来移动元素： 123456.comment&#123; position: absolute; width: 7em; margin-left: -9.5em; margin-top: -2.5em;&#125; 在CSS中，负外边距是完全有效的，它们有如下有趣的行为。 左边或上边的负外边距会把元素向左或向上拉，盖住其旁边的元素。 右边或下边的负外边距会把相邻元素向左或向上拉，盖住设置了负外边距的元素。 在浮动的元素上，与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动的元素。而与浮动方向相同的负外边距会在该方向上把浮动的元素向外拉。 给未声明宽度的非浮动元素应用负外边距时，左、右负外边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。 对评注气泡组件而言，使用左和上负外边距把元素拉到位的做法，与使用相对定位很相似。 创建三角形 在评注气泡组件中，指向前面段落的小三角形又相对于评注气泡进行了绝对定位。它是通过伪元素创建的，使用了一种很古老的基于边框的技巧。 相关代码如下： 12345678910111213.comment:after &#123; position: absolute; content: &#x27;&#x27;; display: block; width: 0; height: 0; border: .5em solid #dcf0ff; border-bottom-color: transparent; border-right-color: transparent; position: absolute; right: -1em; top: .5em;&#125; 这里创建了一个0像素的块，其边框是0.5em，而且边框也只显示左、上边框。结果浏览器就只渲染出一个三角形。不用图片一样可以创造出三角形来！然后再把三角形定位到评估气泡的右上角位置。这里通过将border-bottom-color和border-right-color的值设置为transparent透明进而实现右半下角透明的效果（进而只剩下左上半角的图形）。 利用偏移实现自动大小 从另一个角度看，有必要知道：在绝对定位的情况下，如果声明了多个或所有偏移值，那么结果会怎么样。如果没有显式声明元素大小，那么绝对定位元素的大小由自身包含内容的多少来决定。如果相对于定位上下文的各个边声明偏移值，那么元素会被拉伸以满足设定的规则。 比如，如果希望让某元素总是与其外部元素保持一定距离，但又不给任何元素设定大小。如下图所示，一张图片上有一个包含文本的元素。 12345678&lt;header class=&quot;photo-header&quot;&gt; &lt;img src=&quot;images/big_spaceship.jpg&quot; alt=&quot;An artist`s mockup of the &quot;Dragon&quot; spaceship&quot;&gt; &lt;div class=&quot;photo-header-plate&quot;&gt; &lt;h1&gt;SpaceX unveil the Crew Dragon&lt;/h1&gt; &lt;p&gt;Photo from SpaceX on &lt;a href=&quot;https://www.flickr.com/photos/spacexphotos/16787988882/&quot; &gt; Flickr&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/header&gt; 假设不想给这个包含标题的盒子设定明确的宽度，那么可以只指定其右、下、左边的偏移，让它自己去计算上空距离： 12345678910111213.photo-header&#123; position: relative;&#125;.photo-header-plate&#123; position: absolute; right: 4em; bottom: 4em; left: 4em; background-color: #fff; background-color: rgba(255,255,255,0.7); padding: 2em;&#125; 无论图片多大，标题区始终都会位于距离底边及左、右两边4em的地方，而且会在标题折行的情况下自动调整高度，从而适应不同的屏幕大小。 定位与z-index：堆叠内容的陷阱要用好定位，还有一个重点技术必须掌握，那就是z-index，也就是堆叠元素的次序。基本原理：静态定位（static）以外的元素会根据它们在代码树中的深度依次叠放，就像打扑克牌一样，后发的牌会压在先发的牌上面。它们的次序可以通过z-index来调整。 设置了z-index的元素，只要值是正值，就会出现在没有设置z-index的元素上方。尚未设置z-inde的元素在z-index值为负的元素上方。 除了z-index，还有其他影响元素堆叠次序的因素。这里也有一个概念，叫堆叠上下文。就像一盒扑克牌，每张牌本身也是一个上下文（牌盒），而牌只能相对于当前的牌盒排定次序。有一个根堆叠上下文，所有z-index不是auto的定位元素都会在这个上下文中排序。随着其他上下文的建立，就会出现堆叠层级。 堆叠上下文是由特定属性和值创建的。比如，任何设定了position: absolute及值不是auto的z-index属性的元素，都会创建一个自己后代元素的堆叠上下文。 在一个堆叠上下文内部，无论z-index值多大或多小，都不会影响其他堆叠上下文，毕竟不能相对于别的堆叠上下文重新排序。 如下图所示： 容器A、B、C和D都是绝对定位的，其中C是B的子元素。容器C和D设置了z-index，但由于容器B的opacity值小于1，所以它又创建了一个新的独立的堆叠上下文。于是，就算C的z-index的值再大，它也不会跑到D的上方。 设置小于1的opacity值也可以创建新的堆叠上下文。opacity小于1的元素需要独立渲染（包括它的所有后代元素），然后再放到页面上。这样就可以保证在把它们放到页面上时，原有的元素不会与半透明的元素发生交错。后面会有这个例子及其他类似的例子，比如transform和filter属性，也会触发创建新的堆叠上下文。 水平布局通常，页面会随内容增加沿垂直方向扩展。后来添加的任何块容器（div、article、h1-h6等等）都会垂直堆放起来，因为块级元素的宽度是自动计算的。因此，在需要给内容块设置明确宽度，并让它们水平排列时，就需要特殊处理。 使用浮动来实现小型“媒体组件”布局是一种基础的组件模式，即组件一边是图片（或其他媒体），另一边是文本，“左边是这个，右边是那个，二者相互关联“。很多网站都在使用这种模式。如下图所示： 除此之外，还有很多通用模式的组件，可见于各类网站。其中很多都涉及水平布局。为此，CSS引入了Flexbox来专门解决水平布局问题（以及其他问题），但在得到浏览器完全支持之前，可能还要借助浮动、inline-block显示，或者表格显示模式，才能完美实现水平布局。 使用浮动在太空飞船的例子中，有一个使用浮动的例子。figure浮动到了右侧，让行盒子对其四周环绕。同时通过margin-right的负外边距把图片向外推出去一点，以便与文本保持一些间距。 123456789101112131415161718&lt;style&gt; figure&#123; background-color: #eee; margin: 0; padding: 1em; float: right; max-width: 17em; margin-right: -8em; /* 向右推出 */ margin-left: 1em; &#125;&lt;/style&gt;&lt;p&gt;You may think[...]&lt;/p&gt; &lt;figure&gt; &lt;img src=&quot;images/spaceship.jpg&quot; alt=&quot;The Dragon spaceship in orbit around Earth.&quot;&gt; &lt;figcaption&gt;The &quot;Dragon&quot; spaceship,created by SpaceX.Image from &lt;a href=&quot;https://www.flickr.com/photos/spacexphotos/16787988882/&quot;&gt;Flickr.com&lt;/a&gt;&lt;/figuration&gt; &lt;/figure&gt;&lt;p&gt;There`s various[...]&lt;/p&gt; 下面的代码中，删除了这个负外边距，并把插图宽度设置为文章宽度的一半，而且还增加了第二幅插图。此时，两幅插图并肩而立。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Two floated images side by side&lt;/title&gt; &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; font-family: Georgia, Times New Roman, serif; line-height: 1.5; padding: 2em 8em; max-width: 35em; margin: 0 auto; &#125; h1 &#123; font-family: Avenir, Franklin Gothic, sans-serif; &#125; figure &#123; background-color: #eee; margin: 0; padding: 1em; box-sizing: border-box; float: right; max-width: 50%; &#125; figure img &#123; width: 100%; display: block; margin-bottom: .5em; &#125; figcaption &#123; font-style: italic; font-size: .875em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;A fake article about spaceships&lt;/h1&gt; &lt;p&gt;This is a fake article about spaceships. Remember when you did presentations in middle school, and you told the class about what your assignment was about, then read aloud from the paper you had written, including the title? ”My assignment is about spaceships. Spaceships. Spaceships are very large, and fly in space...”.&lt;/p&gt; &lt;p&gt;You may think that spaceships are fake, like this article, but they’re not. There are actual spaceships, flying in space right now, probably. For example, there’s the International Space Station, which is a spaceship of sorts. Well, actually it’s a space station, which is even cooler!&lt;/p&gt; &lt;figure&gt; &lt;img src=&quot;images/spaceship.jpg&quot; alt=&quot;The Dragon spaceship in orbit around Earth.&quot;&gt; &lt;figcaption&gt;The ”Dragon” spaceship, created by SpaceX. Image from &lt;a href=&quot;https://www.flickr.com/photos/spacexphotos/16787988882/&quot;&gt;Flickr.com&lt;/a&gt;&lt;/figcaption&gt; &lt;/figure&gt; &lt;figure&gt; &lt;img src=&quot;images/spaceship2.jpg&quot; alt=&quot;The Dragon spaceship landing on Mars.&quot;&gt; &lt;figcaption&gt;Artist mockup of Mars landing. Image from &lt;a href=&quot;https://www.flickr.com/photos/spacexphotos/21424800115&quot;&gt;Flickr.com&lt;/a&gt;&lt;/figcaption&gt; &lt;/figure&gt; &lt;p&gt;There’s various government organizations and companies that are building spaceships. One of them is SpaceX. An image of one of their spaceships appears on this very page.&lt;/p&gt; &lt;p&gt;I can&#x27;t be bothered to write any more about spaceships so the rest of the text will just be nonsense. This isn’t a school assignment after all.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sequi saepe harum, excepturi dolorum voluptatem hic amet nemo. Incidunt tenetur dignissimos laborum molestiae reiciendis ipsum quas temporibus nisi dolor, ea libero!&lt;/p&gt; &lt;p&gt;A assumenda, et eius odit, rerum delectus placeat dolores eveniet quis. Iure neque deserunt mollitia impedit illo corporis odio quod, velit ducimus!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 可以看到从第一个figure元素开始排在最右边，后面的第二个figure元素依次向左排列。 这种布局方式是很多CSS布局会用到的一种基本技术，即让浮动的元素构成一行中的列。但正如之前讨论过的，浮动也会有一些问题。浮动的元素并不在页面流中，因此需要一个元素来包含浮动元素。为此，可以给容器内部的一个（伪）元素应用clear，也可以通过规则让容器成为一个新的块级格式化上下文（BFC，blocking formating context）。必要时，浮动也可以包含多行，但如果上面的行有浮动元素，也可能会被卡住。 浮动也可以对有限的水平内容进行独立于源码次序的排序。比如，通过分别向左或向右浮动两个元素，可以调整两幅插图的次序。将上面代码示例中的float的值由right改为left即可实现两幅图片位置调换的效果。 因为浏览器对浮动的支持极为普遍，所以浮动也成为了各种水平布局中的常用技术。除了浮动，实际上还有其他技术可以用来创建水平布局，虽然这些技术各有利弊。 行内块布局文本行自身就是水平布局时，至少在从左往右和从右往左书写的语言中是如此。使用行内元素（如span、time或a）时，它们会与文本沿相同方向水平对齐。也可以把行内块加入到文本流中，创造出水平对齐的元素，从视觉上看又是一个块。 比如，为太空飞船的文章末尾添加一些元数据，包括作者姓名、照片和电子邮件地址。为了添加样式，还使用了两个额外的span元素： 1234567&lt;p class=&quot;author-meta&quot;&gt; &lt;img class=&quot;author-image&quot; src=&quot;images/author.jpg&quot; alt=&quot;Arthur C. Lark&quot;&gt; &lt;span class=&quot;author-info&quot;&gt; &lt;span class=&quot;author-name&quot;&gt;Written by Arthur C. Lark&lt;/span&gt; &lt;a class=&quot;author-email&quot; href=&quot;mailto:arthur.c.lark@example.com&lt;/a&gt;&quot;&gt;arthur.c.lark@example.com&lt;/a&gt; &lt;/span&gt;&lt;/p&gt; 现在，.author-meta段落的底部会与图片底部及文本基线对齐。段落中的所有空白字符，包括图片和作者信息之间的换行符都被渲染为空格。这些空格的宽度取决于字体及其大小。 接下来，把图片和作者信息转换为行内块： 1234.author-image,.author-info&#123; display: inline-block;&#125; 渲染之后，其实并没有什么可见的差别。差别只在于现在图片和作者信息都是块了。比如，可以把作者信息中包含的姓名和电子邮件地址分别列为两行，只要把它们修改为块级元素即可： 1234.author-name,.author-email&#123; display: block;&#125; 现在已经比较接近想要的水平布局了：左边是浮动的图片，右边是一个文本块。但还有一点，此时作者信息块最后一行的基线与图片底部是对齐的。下图展示了此时的状况： 现在可以通过vertical-align属性相对于图片来对齐作者信息。下图展示了在对齐关键字设置为top时，作者信息块的顶部与图片顶部对齐的效果： 行内块的垂直居中 假设想要的设计是让作者信息块相对于图片垂直居中。可能会这么写： 123.author-info&#123; vertical-align: middle;&#125; 然而，结果可能并非是垂直居中，如下图所示： 这是因为，关键字middle在应用给行内块时，其含义是“将这个行内块的垂直中心点与这行文本x高度的中心点对齐”。这个例子中没有行内文本，（行内最高的）图片就成为行盒子高度以及基线位置的元素。而此时x高度的中心点就在图片底部（基线）靠上一点。要想将作者信息与图片一起垂直居中，需要让这两个元素都参照同一个“中心点”： 1234.author-image,.author-info&#123; vertical-align: middle;&#125; 因为图片此时也是行内块，所以它就与作者信息在同一个垂直点上居中对齐了，从而得到了想要的布局，如下图所示： 如何确定行盒子的基线，以及这些规则如何影响行内及行内块元素是比较复杂的。对于利用行内块创建水平布局而言，如果需要垂直对齐，有以下两个要点： 要让行内块沿上方对齐（很像浮动），设置：vertical-align: top; 要让两个元素的内容垂直对齐，先把它们都转化成行内块，再对它们应用vertical-align: middle。 在容器元素中垂直居中 前面的两个要点的第二个告诉我们：可以在任意高度的容器内垂直居中内容。其实也不完全对。唯一的前提是把容器的高度设置为确切的高度。 比如，假设想把作者元数据块设置为10em高，然后在其中居中放置作者图片和信息。首先，给.author-meta块应用这个高度。为清晰起见，也添加了一个边框。如下图： 1234.author-meta&#123; height: 10em; border: 1px solid #ccc;&#125; 但作者信息和图片并没有相对于容器块垂直居中对齐，而是仍然沿原来那条假想的文本行对齐。为了实现与容器垂直对齐，还需要增加一个行内块元素，让它占据100%的容器高度。这个元素会让middle关键字认为容器的垂直中点是对齐点。为此，可以借助伪元素。如下图所示，在引入了这个“幽灵元素”后，假想的基线就以它为准了。 123456.author-meta:before&#123; content: &#x27;&#x27;, display: inline-block; vertical-align: middle; height: 100%;&#125; 如图所示，利用高度为100%的伪元素，让middle关键字代表容器的垂直中心点。此时，就好像整个.author-meta容器中只有一行文本，且高度与容器高度相同。因为这个伪元素是一个行内块，且其垂直对齐方式设置为middle，所以其他行内块也就与容器的中心垂直对齐了。接下来要做的就是水平居中内容。因为行内块像文本一样对齐，所以这里使用text-align。 123456789.author-meta&#123; height: 10em; text-align: center; border: 1px solid #ccc;&#125;.author-info&#123; text-align: left;&#125; 结果就是.author-meta既水平居中又垂直居中，如下图所示： 确切地讲，这里的水平居中并不准确。这是因为行盒子内的任何空白符都会被渲染为一个空格。伪元素就会创建这么一个空格，导致内容向右偏移几个像素。通过给伪元素应用负外边距，可以抵消空格的宽度。 123.author-info:before&#123; margin-right: -.25em;&#125; 追究细节：与空白战斗到底 对于每个块都占据确切宽度的水平布局而言，空白是个突出的问题。下面以另一个常见的组件为例，介绍在使用行内块的情况下如何解决这个问题，尽量不使用具体数值。 创建一个导航条，包含4个链接项，每一项都占据宽度的四分之一。标记如下： 12345678&lt;nav class=&quot;navbar&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/spaceships&quot;&gt;Spaceships&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/planets&quot;&gt;Planets&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/stars&quot;&gt;Stars&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 以下CSS标记为导航条添加了基本的颜色及字体样式，并通过轮廓线突出了链接项的边界。这里将每一项设置为占据25%的宽度，4项正好占据全部宽度。 1234567891011121314151617181920212223242526272829nav &#123; display: block;&#125;.navbar ul &#123; font-family: &#x27;Avenir Next&#x27;, Avenir, Corbel, &#x27;Franklin Gothic&#x27;, &#x27;Century Gothic&#x27;, CenturyGothic, AppleGothic, sans-serif; list-style: none; padding: 0; background-color: #486a8e;&#125;.navbar li &#123; text-transform: uppercase; display: inline-block; text-align: center; width: 25%; -moz-box-sizing: border-box; box-sizing: border-box; background-color: #12459e; outline: 1px solid #fff;&#125;.navbar li a &#123; display: block; text-decoration: none; line-height: 1.75em; padding: 1em; color: #fff;&#125; 通过使用box-sizing: border-box确保每一项的边框及内边距都包含在各自25%的宽度以内。导航条本身的背景颜色是蓝灰色，链接项的颜色是深蓝色，链接文本颜色是白色。 HTML源代码中的换行符被渲染成了空白符，再加上每一项25%的宽度，就导致了折行。要消灭这些空白符，可以尝试把所有li标签都排到一行，但这种要求显示不友好。 解决问题的方法也很简单粗暴，就是把包含元素ul的font-size设置为0（从而让每个空格的宽度为0），然后在每一项上重新设置大小： 12345678.navbar ul&#123; font-size: 0;&#125;.navbar li&#123; font-size: 16px; font-size: 1rem;&#125; 这样就如期解决了空白问题，每一项都相互靠拢，只占据了一行。但这个技术也有缺点。首先与可以继承的font-size有关。假设在导航条上设置的是16像素的font-size，那么就不能再使用em单位或比例，让每一项继承一个可伸缩的大小了。它会变成与0相乘。不过，可以使用rem单位，相对于根字体大小来保持可伸缩性。 使用表格显示属性实现布局表格中的行恰好具有导航条例子中我们想要的特质：一组单元格恰好占满一行，而且永远不会折行。这也正是HTML表格在WEB发展早期成为页面布局垄断技术的缘由。可以通过CSS来借用表格的显示模式，不必求诸HTML表格标记。 如果将前面导航条的例子改为对ul元素使用的一种表格显示模式，并将其中的每一项设置为表格单元，那么也会得到与使用行内块一样的效果： 12345678910.navbar ul&#123; width: 100%; display: table; table-layout: fixed;&#125;.navbar li&#123; width: 25%; display: table-cell;&#125; 这样可以得到相同的布局效果。 注意这里将ul元素的宽度设置为100，是为了保证导航条能扩展到与父元素同宽。与常规块不同，不设置宽度的表格会“收缩适应”内容宽度，除非包含内容的单元把它撑开，让它的宽度足以填充父容器。 表格行中每一列的宽度有两种算法。默认情况下，浏览器会使用“自动”算法。这是一种没有明确规定，但某种程度上又是事实标准的算法，基本上就是根据自身单元格内容所需的宽度来决定整个表格的宽度。 另一种算法是“固定”表格布局，即使用table-layout: fixed。这种算法下的列宽由表格第一行的列决定。第一行中声明的列宽具有决定性，后续行如果遇到内容较多的情况，只能折行或者溢出。 在利用表格显示模式来创建布局时，必须清楚这样也会引入表格的问题。比如，渲染为表格单元的元素无法应用外边距，给表格单元应用定位时的行为也无法预料。 表格单元格中的垂直对齐 使用表格显示模式时，表格单元格中的垂直对齐效果无须借助任何额外的技术。只要给显示为table-cell的元素应用vertical-align: middle，就可以令其中的内容在单元格中垂直居中。 FlexboxFlexbox，也就是Flexible Box Layout模块，是CSS提供的用于布局的一套新属性。这套属性包含针对容器（弹性容器，flex container）和针对其直接子元素（弹性项，flex item）的两类属性。Flexbox可以控制弹性项的如下方面： 大小 流动方向，水平还是垂直，正向还是反向 两个轴向上的对齐与分布 顺序，与源代码中的顺序无关 Flexbox就是为了解决行内块、浮动和表格格式对应的棘手问题而生的。 浏览器支持与语法Flexbox已经得到主流浏览器较新版本的广泛支持。对于某些需要兼容的旧版本浏览器，只要调整一下语法或提供商前缀，基本上也没问题。 理解Flex方向：主轴与辅轴Flexbox可以针对页面中某一区域，控制其中元素的顺序、大小、分布及对齐。这个区域内的盒子可以沿两个方向排列：默认水平排列（成一行），也可以垂直排列（成一列），这个排列方式称为主轴。 与主轴垂直的方向称为辅轴，区域内的盒子可以沿辅轴发生位移或伸缩，如下图所示。通常，Flexbox布局中最重要的尺寸就是主轴方向的尺寸：水平布局时的宽度或垂直布局时的高度。主轴方向的这个尺寸为主尺寸。 回头再看看之前的导航条（包含链接的无序列表和容器），它很容易转换成Flex容器。假设其他样式（颜色、字体、链接、边框）都一样，那么只要一行CSS代码即可。至于列表项，无须声明任何属性，而且也不必给每一项指明宽度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Navbar using flexbox, no width&lt;/title&gt; &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; nav &#123; display: block; &#125; .navbar ul &#123; display: -webkit-flex; display: -ms-flexbox; display: -webkit-box; display: -moz-box; display: flex; font-family: &#x27;Avenir Next&#x27;, Avenir, Corbel, &#x27;Franklin Gothic&#x27;, &#x27;Century Gothic&#x27;, CenturyGothic, AppleGothic, sans-serif; list-style: none; padding: 0; background-color: #486a8e; &#125; .navbar li &#123; text-transform: uppercase; text-align: center; -moz-box-sizing: border-box; box-sizing: border-box; background-color: #12459e; outline: 1px solid #fff; &#125; .navbar li a &#123; display: block; text-decoration: none; line-height: 1.75em; padding: 1em; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=&quot;navbar&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/spaceships&quot;&gt;Spaceships&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/planets&quot;&gt;Planets&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/stars&quot;&gt;Stars&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 从上图中可以看到，链接项是水平排列的，而且根据各自的内容进行了收缩适应。结果就好像是块级文档流被旋转了90度一样。所有链接项集中在左侧，是从左到右书写的语言环境下的默认行为。如果把flex-direction改成row-inverse，那么所有链接就会集中到右侧，而且变成从右向左排列。 如果不指定大小，Flex容器内的项目会自动收缩。也就是说，一行中的各项会收缩到各自的最小宽度，或者一列中的各项会收缩到各自的最小高度，以恰好可以容纳自身内容为限。 对齐与空间Flexbox对子项的排列有多种方式。沿主轴的排列叫排布，沿辅轴的排列叫对齐。 用于指定排布格式的属性叫justify-content，其默认值是flex-start，表示按照当前文本方向排布（也就是向左对齐）。如果改成flex-end，所有项就都会挤到右侧（变成向右对齐），但顺序不变。下面的四个图分别展示了flex-end以及另外三个关键字center、space-between和space-around的效果。 Flexbox不允许通过以上这些关键字指定个别项的排布方式。然而，对Flexbox的子项指定值为auto的外边距在这里却有不同的含义。因此，可以利用这一点。具体来说，如果指定某项一侧的外边距值为auto，而且在容器里那一侧还有空间，那么该外边距就会扩展占据可用空间。利用这一点，可以创造让一项位于一侧，其他项位于另一侧的布局。下图展示了第一项在左侧，其他项在右侧的布局。 123.navbar li:first-child&#123; margin-right: auto;&#125; 本质上来说，像这样使用自动外边距抵消了其他项的排布效果，因为之后就没有多余空间可分了。尽管如此，对其他项仍然可以应用外边距。 辅轴对齐 前面通过Flexbox轻松解决了水平布局的问题。实际上，Flexbox还支持对另一轴向的控制。如果增加Flex容器自身或其中一项的高度，会发现控制另一轴向属性的默认值会产生下图这种有趣的效果。 123.navbar ul&#123; min-height: 100px;&#125; 如图所示，默认情况下，Flex子项会沿辅轴方向填满Flex容器。好像这些子项被拉高了。实际上，控制辅轴对齐的属性align-items，其默认值是stretch（拉伸）。也就是说，子项默认拉伸，以填满可用空间。其他的关键字还有flex-start、center和flex-end，效果分别如下图所示。这3个关键字都会把子项收缩成原有大小，然后再沿辅轴进行上、中、下对齐。 最后，还可以使用baseline关键字，将子项中文本的基线与容器基线对齐，效果与行内块的默认行为类似。如果子项大小不一，而又希望它们在辅轴上虽然位置不同，但本身对齐，那么就可以采用这种方法。 在下图中，添加了一个类名表示当前活动的项： 123456&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;navbar-active&quot;&gt;&lt;a href=&quot;/spaceships&quot;&gt;Spaceships&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;planets&quot;&gt;Planets&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/stars&quot;&gt;Stars&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 这个活动项的font-size稍大一点，而且z-index值为1. 123.navbar .navbar-active&#123; font-size: 1.25em;&#125; 现在，容器的基线由较大活动项的基线决定，其他项都自动与之对齐。 对齐个别项 除了同时对齐所有项，还可以在辅轴上指定个别项的对齐方式。比如，可以让“HOME”项对齐到左上角，让其他项对齐到右下角。 123456789.navbar ul&#123; min-height: 100px; align-items; flex-end;&#125;.navbar li:first-child&#123; align-self: flex-start; margin-right: auto;&#125; Flexbox中的垂直对齐 终于，Flex使得可以轻松解决垂直对齐问题了。在容器里面只有一个元素时，只要将容器设置为flex，再将需要居中的元素的外边距设置为auto就行了。这是因为Flexbox中各项的自动外边距会扩展“填充”相应方向的空间。 123456&lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;flex-item&quot;&gt; &lt;h2&gt;Not so lost in space&lt;/h2&gt; &lt;p&gt;This item sits right in the middle of its container...&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 无论容器或其中元素有多大，仅需以下代码，即可实现水平垂直居中.flex-item。在这个例子中，让容器与视口一样高（在html、body和.flex-container元素上都设置了height: 100%），就是为了让效果更明显。 123456789101112html,body&#123; height: 100%;&#125;.flex-container&#123; height: 100%; display: flex;&#125;.flex-item&#123; margin: auto;&#125; 如果Flex容器中有多个元素，就像前面作者元素数据的例子一样，那么可以使用对齐属性把它们聚拢到水平和垂直中心上。为此，把排布和对齐都设置为center（当然，这也适用于单个元素的情况，只不过margin: auto的代码更少）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vertical centering using flexbox&lt;/title&gt; &lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; font-family: Georgia, Times New Roman, serif; line-height: 1.5; padding: 2em 8em; max-width: 35em; margin: 0 auto; &#125; .author-meta &#123; border: 1px solid #ccc; height: 160px; display: -webkit-box; display: -webkit-flex; display: -moz-box; display: -ms-flexbox; display: flex; /* [1] */ -webkit-box-align: center; -webkit-align-items: center; -moz-box-align: center; -ms-flex-align: center; align-items: center; /* [2] */ -webkit-box-pack: center; -webkit-justify-content: center; -moz-box-pack: center; -ms-flex-pack: center; justify-content: center; /* [3] */ &#125; .author-info &#123; margin-left: 0.5em; &#125; .author-name, .author-email &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;author-meta&quot;&gt; &lt;img class=&quot;author-image&quot; src=&quot;images/author.jpg&quot; alt=&quot;Arthur C. Lark&quot;&gt; &lt;span class=&quot;author-info&quot;&gt; &lt;span class=&quot;author-name&quot;&gt;Written by Arthur C. Lark&lt;/span&gt; &lt;a class=&quot;author-email&quot; href=&quot;mailto:arthur.c.lark@example.com&quot;&gt;arthur.c.lark@example.com&lt;/a&gt; &lt;/span&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在这里，使用flex-direction将author-meta内的元素排列为垂直显示，就像一列一样。所以排在行内元素img之后的文本元素author-info中的两个行内元素便被垂直排布了。 可伸缩的尺寸Flexbox支持对元素大小的灵活控制。这一点是实现精确内容布局的关键。 相关属性 Flex的意思是“可伸缩”，这体现在以下3个容器中：flex-basis、flex-grow和flex-shrink。这3个属性应用给每个可伸缩项，而不是容器。 flex-basis 控制项目在主轴方向上、经过修正之前的“首选”大小（width或height）。可以是长度值（如18em）、百分比（相对于容器的主轴而言），也可以是关键字auto（默认值）。 关键字auto的意思好像是把width或height设置为自动，但实际上并不是那么回事。这里auto值的意思是这个项目可以从对应的属性（width或height）那里获得主尺寸——如果设置了相应属性的话。如果没有设置主尺寸，那么该项目就根据其内容确定大小，有点类似浮动元素或行内块。 也可以设置content值，意思也是根据项目内容确定大小，但是会忽略通过width或height设置的主轴尺寸（与auto不同了）。注意，content关键字是后来才加入Flexbox的，支持程度可能不一致。 flex-grow 一个弹性系数。在通过flex-basis为每一项设置了首选大小之后，如果还有剩余空间，该系数表示该怎么处理。其值是一个数值，表示剩余空间的一个比值。这个比值的默认值是0，表示从flex-basis取得尺寸后就不再扩展。 flex-shrink 也是一个弹性系数，与flex-grow类似，但作用相反。换句话说，如果空间不够，该项如何收缩？增加了flex-shrink这个因素之后，计算过程更加复杂了。默认值是1，表示如果空间不够，所有项都会以自己的首选尺寸为基准等比例收缩。 要理解flex-basis与flex-grow以及flex-shrink的关系并不容易。Flexbox使用了相当复杂的算法来计算各伸缩项的大小。但是，如果将计算过程简化为以下两个步骤，那么理解起来就容易多了。 检查flex-basis，确定假想的主尺寸。 确定实际的主尺寸。如果按照假想的主尺寸把各项排布好之后，容器内还有剩余空间，那么它们可以伸展。伸展多少由flex-grow系数决定。相应地，如果容器装不下那么多项，则根据flex-shrink系数决定各项如何收缩。 举一个例子来更好地理解这些属性。在这个例子中，假设容器宽度是1000像素。标记中，这个容器包含两个子元素。其中一个包含一个短单词（用“Short”表示），另一个包含一个长单词（用“Looooooong”表示）。因此，前者要占据200像素宽度，后者要占据400像素宽度。此时项目还没有放到容器中。 如果这两项的flex-basis值都是默认的auto，而且都没有设置width属性，那么当它们放到容器中时，它们会各自依据自身内容确定宽度（如下图），因此一共会占据600像素。这是flex-basis默认值的结果，与前面导航条中的例子一致。 123.navbar li&#123; flex-basis: auto; /* 默认值 */&#125; 因为有剩余空间可分配，所以可以考虑flex-grow了。默认情况下，flex-grow的值为0，对各项的大小没有影响。假设此时把flex-flow的值设置为1会怎么样呢？ 1234.navbar li&#123; flex-basis: auto; flex-grow: 1;&#125; 默认的0和现在的1都代表什么？它们并不表示特定的大小，而表示具体的”几份“。 这个例子里有两项，结果是两项会伸展相同的距离。它们的1份表示各自分得剩余空间的一半，也就是200像素。换句话说第一项最终的宽度是400像素，第二项最终的宽度是600像素。加在一起，正好是容器的宽度，如下图所示。 假如给它们分别设置不同的flex-grow，类似这样： 1234567.navbar li:first-child&#123; flex-grow: 3;&#125;.navbar li:last-child&#123; flex-grow: 1;&#125; 这会导致第一项分得剩余空间的四分之三，第二项分得四分之一。结果就是，两项各占500像素的宽度！ 此例中的两项最终恰好平分秋色。如果希望各项能够按比例占据整个空间而不考虑各自内容，那么还有更合适的Flexbox技术，后面会介绍。 纯粹按伸缩系数计算大小 在上一节用到的“简化版Flexbox布局算法”的第一个步骤中，是根据内容宽度来确定项目宽度的，因为flex-basis的值是默认的auto，而且也没有给项目设定明确的宽度。假如第一步中flex-basis的值是0，那在这一步就不会给项目分配空间了。这种情况下，容器内部的全部空间都会留到第二步再分配，就是根据伸缩系数切分，然后将最终尺寸指定给具体的项目。 在下图中，两个项目的flex-basis值为0，flex-grow的值为1。这意味着容器的全部空间要分为两部分，从而每个项目恰好占据可分配空间的一半。这个效果很接近使用百分比计算的布局，但好在无论有多少项目，Flexbox都会自动伸缩以适应整个宽度。 接下来要使用flex这个简写属性一次性设置flex-grow、flex-shrink和flex-basis属性，顺序就是这样，值以空格分隔： 123.navbar li&#123; flex: 1 0 0%;&#125; 注意，最后一个flex-basis值加了百分号。这是因为简写法中的flex-basis必须带单位，因此这里要么加百分号，要么就写成0px。 如果想让第一个项目占据的空间是其他项目的2倍，就把其flex-grow值设置为2： 1234567.navbar li&#123; flex: 1 0 0%;&#125;.navbar li:first-child&#123; flex-grow: 2;&#125; 将以上规则应用给包含4项的导航条标记后，第一项占据2&#x2F;5（40%）的宽度，后三项各占1&#x2F;5（20%）的宽度，如下图所示: 收缩项目 当项目宽度总和超过容器宽度时，Flexbox会按照flex-shrink属性来决定如何收缩它们。此时的收缩机制比flex-grow稍微麻烦一些。麻烦的根源在于，不能因为某个大项目总体宽度超出，就把小项目压缩得不可见了。让项目占据更多空间（比如前面的flex-grow）比较容易理解，不过是按比例分配而已。但收缩的时候，情况就不一样了。 再以之前1000像素宽的导航条为例，假设这一次两个子项目都通过flex-basis预先设置了宽度。两项宽度的总和超出了容器宽度300像素，如下图所示： 1234567.navbar li:first-child&#123; flex: 1 1 800px;&#125;.navbar li:last-child&#123; flex: 1 1 500px;&#125; 加在一起的首选宽度（1300像素）超出了容器宽度300像素。而且两个项目的flex-shrink值都是1。看起来似乎此时两个项目会分别收缩150像素，以便适应容器宽度。然而事实并非如此。它们会根据自己flex-shrink系数和flex-basis的值来按比例收缩。具体来说，每个项目先用自己的flex-shrink乘以自己的flex-basis，然后再用乘积除以每一项的flex-shrink与flex-basis的乘积之和，最后再拿得到的比例系数去乘以超出的宽度（负空间），从而得到该项目要收缩的空间数量。 将以上几个步骤简化一下表达：首选尺寸大的项目比首选尺寸小的项目收缩的更多（相对于flex-shrink系数而言）。因此就算这里两个项目的flex-shrink系数都是1，它们收缩的量也是不一样的。以下是求第一个项目要收缩的量的过程： 1((800* 1) / ((800 * 1) + (500 * 1 )) ) * 300 = 184.6 第一项要收缩184.6像素。用同一个公式计算第二项的收缩量： 1((500 * 1) / ((800 * 1) + (500 * 1))) * 300 = 115.4 第二项要收缩115.4像素。两者相加，正好是为适应容器宽度而必须减少的300像素： Flexbox布局前面导航条和作者元数据的例子只涉及一行内容。与行内块和浮动类似，Flexbox也支持让内容排布到多行（列），但具有更强的可控性。 这次设计一组标签，表示星球的种类。这些标签是包含链接的一个无序列表，跟导航条例子中类似。但这里的列表项目要多出好几倍，因此不可能让它们都挤在一行中。这里会给标签设置统一的背景颜色，并使用前面评注气泡中用到的伪元素技术，给它们应用实际标签的外观。 12345678910111213141516171819202122&lt;body&gt; &lt;ul class=&quot;tags&quot;&gt; &lt;li&gt;&lt;a href=&quot;/Binary_planet&quot;&gt;Binary planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Carbon_planet&quot;&gt;Carbon planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Coreless_planet&quot;&gt;Coreless planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Desert_planet&quot;&gt;Desert planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Dwarf_planet&quot;&gt;Dwarf planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Earth_analog&quot;&gt;Earth analog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Exoplanet&quot;&gt;Exoplanet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Gas_giant&quot;&gt;Gas giant&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Helium_planet&quot;&gt;Helium planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Ice_giant&quot;&gt;Ice giant&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Lava_planet&quot;&gt;Lava planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Mesoplanet&quot;&gt;Mesoplanet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Ocean_planet&quot;&gt;Ocean planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Pulsar_planet&quot;&gt;Pulsar planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Rogue_planet&quot;&gt;Rogue planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Terrestrial_planet&quot;&gt;Terrestrial planet&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Sub-brown_dwarf&quot;&gt;Sub-brown dwarf&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 样式有点多： 1234567891011121314151617181920212223242526272829303132333435body &#123; font-family: &#x27;Avenir Next&#x27;, Avenir, Corbel, &#x27;Franklin Gothic&#x27;, &#x27;Century Gothic&#x27;, CenturyGothic, AppleGothic, sans-serif;&#125;.tags &#123; border: 1px solid #c9e1f4; margin: 0; padding: 1em; list-style: none;&#125;.tags li &#123; display: inline-block; margin: .5em;&#125;.tags a &#123; display: block; padding: .25em .5em .25em .25em; background-color: #c9e1f4; border-radius: 0 .25em .25em 0; line-height: 1.5; text-decoration: none; color: #28448f; position: relative; text-align: center;&#125;.tags a:before &#123; position: absolute; content: &#x27;&#x27;; width: 0; height: 0; border: 1em solid transparent; border-right-width: .5em; border-right-color: #c9e1f4; left: -1.5em; top: 0;&#125; 应用上面的样式后，标签都成了行内块，可以随时折行。接下来该Flexbox上场了。首先，把列表元素转换为Flex容器，再通过flex-wrap属性的wrap值告诉它允许子元素折行： 12345678910111213.tags&#123; display: -webkit-flex; display: -ms-flexbox; display: -moz-box; display: flex; -webkit-flex-wrap: wrap; -ms-flex-wrap: wrap; flex-wrap: wrap; border: 1px solid #c9e1f4; margin: 0; padding: 1em; list-style: none;&#125; 结果跟刚才差不多。但现在可以用Flexbox来控制方向、大小和行的对齐了。 折行与方向 首先，可以反转行中标签的排布方向（跟导航条例子中一样）。把flex-direction的值改为row-reverse，所有标签一下子就变成了从右上角起从右向左排布，每一行都变成了右对齐，如下图所示： 也可以通过flex-wrap反转垂直排布的方向，让第一行从底部开头，然后向上折行！ 多行布局中可伸缩的大小 Flexbox对多行布局的另一个好处是，可以利用可伸缩的大小均匀填充每一行（如下图所示）。flex-grow的计算是以行为单位的，因此项目的可扩展空间以行的宽度为限。 123.tag li&#123; flex: 1 0 auto;&#125; 此时最后一个标签另起一行后变得非常长。然而，多行Flexbox布局中没有办法控制特定的某一行。换句话说，无法告诉这些项目，让它们到了最后一行就不再扩展了。 要解决当前这个问题，可以给所有标签设置max-width，限制可伸缩的范围（如下图所示）。 123456.tags li&#123; display: inline-block; margin: .5em; flex: 1 0 auto; max-width: 14em;&#125; 总体来说，可以填充多余空间是Flexbox的核心优势。通过综合使用flex-grow及min-width和max-width，就能实现非常智能的多行flexbox布局。无论屏幕多大，或者容器里项目有多少，所有项目都会有合理的大小。 对齐所有行 在前面介绍辅轴对齐属性（align-items和align-self）时，我们知道flexbox允许我们相对于一行的flex-start、center、baseline和flex-end这几个点来对齐项目。而在多行布局中，则可以相对于容器来对齐行或列。 如果在标签容器列表中设置了min-height: 300px，就可以知道相对于容器对齐行或列的align-content属性的效果了。默认情况下，这个属性的值是stretch，意思是每一行都会拉伸以填充自己应占的容器高度。如果通过浏览器右键菜单中“检查“来看一看标签，会发现每一个li元素都拉伸为容器高度的三分之一，如下图所示： 123456.tags&#123; display: flex; flex-wrap: wrap; min-height: 300px; /* align-content: stretch; 在这里是默认值 */&#125; align-content对容器中多行的作用，与justify-content对主轴内容排布的作用非常相似。换句话说，通过align-content还可以把多行排布到flex-start（容器顶部）、flex-end（容器底部）、center（容器中部），还可以通过space-between或space-arount让多行分隔开。 列布局与个别排序使用Flexbox的order属性，可以完全摆脱项目在源代码中顺序的约束。只要告诉浏览器这个项目排第几就可以了。默认情况下，每个项目的order值都为0，意味着按照它们在源代码中的顺序出现。 通过Flexbox可以任意摆放项目顺序。在接下来的例子中，来创建一个小小的“文章导读”组件，其中包含飞船文章的节选，有标题、图片，还有一个阅读全文的链接。这个组件会以一列的形式出现。 首先从标记开始，组件内容的次序按照它们的重要性来排定： 以文章标题为内容的标题 导读正文 与文本主题相关的插图 指向文章的链接 123456789101112&lt;div class=&quot;article-teaser&quot;&gt; &lt;h2&gt;The Dragon and other spaceships&lt;/h2&gt; &lt;div class=&quot;article-teaser-text&quot;&gt; &lt;p&gt;There are actual spaceships, flying in space right now, probably. For example, there’s the International Space Station, which is a spaceship of sorts. Well, actually it’s a space station, which is even cooler!&lt;/p&gt; &lt;/div&gt; &lt;img src=&quot;images/medium_spaceship.jpg&quot; alt=&quot;The Dragon spaceship in orbit around Earth.&quot;&gt; &lt;p class=&quot;article-teaser-more&quot;&gt; &lt;a href=&quot;/spaceships&quot;&gt;Read the whole Spaceship article&lt;/a&gt; &lt;/p&gt;&lt;/div&gt; 完成后的文章导读组件如下图所示。这里为组件添加了一些基本样式，主要是外边距、颜色和字体。 从设计上说，把图片放在最前面可以抓住读者的眼球。但在HTML中，把图片放在第一位不一定合适。这是因为对屏幕阅读器而言，最好是一上来就拿到文章标题，然后播报给读者。 为了能让图片排在最前头，需要把.article-teaser容器转换为一个Flexbox列： 1234.article-teaser&#123; display: flex; flex-direction: column;&#125; 然后，给图片一个比默认值0小的order值，让它第一个出现（如下图）： 嵌套的Flexbox布局最后一个例子会展示可嵌套的Flexbox布局，以及一种非常实用的技术。 重用上面的文章导读组件的例子，但这次有两个组件，并排在一起。为此，给它们加一个包装元素，将Flexbox方向设置为row。 1234567891011121314151617181920212223242526&lt;div class=&quot;article-teaser-group&quot;&gt; &lt;div class=&quot;article-teaser&quot;&gt; &lt;h2&gt;The Dragon and other spaceships&lt;/h2&gt; &lt;div class=&quot;article-teaser-text&quot;&gt; &lt;p&gt;There are actual spaceships, flying in space right now, probably. For example, there’s the International Space Station, which is a spaceship of sorts. Well, actually it’s a space station, which is even cooler!&lt;/p&gt; &lt;/div&gt; &lt;!-- image from SpaceX on Flick: https://flic.kr/p/rzuQdb --&gt; &lt;img src=&quot;images/medium_spaceship.jpg&quot; alt=&quot;The Dragon spaceship in orbit around Earth.&quot;&gt; &lt;p class=&quot;article-teaser-more&quot;&gt; &lt;a href=&quot;/spaceships&quot;&gt;Read the whole Spaceship article&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;article-teaser&quot;&gt; &lt;h2&gt;Mission to mars&lt;/h2&gt; &lt;div class=&quot;article-teaser-text&quot;&gt; &lt;p&gt;This is a pretty cool article about spaceships flying to Mars.&lt;/p&gt; &lt;/div&gt; &lt;!-- image from SpaceX on Flick: https://flic.kr/p/xGdh8d --&gt; &lt;img src=&quot;images/medium_mars.jpg&quot; alt=&quot;A spaceship about to land on Mars.&quot;&gt; &lt;p class=&quot;article-teaser-more&quot;&gt; &lt;a href=&quot;/spaceships&quot;&gt;Read the whole Mars article&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 将包装元素设置为一个Flexbox行： 123.article-teaser-group&#123; display: flex;&#125; 效果如下图： 之前也看到过等高的Flexbox可伸缩项。但在可伸缩项本身又是Flexbox容器时，比如本例的情况，还得再祭出一个“终极大法”。因为两个组件虽然一样高，但它们的内容却不是。第二个组件明显短一截，“阅读详情”按钮一个高一个低，视觉上明显不平衡。Flexbox可以解决这个问题。 还记得把外边距设为auto就能让可伸缩项吃掉所有剩余空间吗？所以这里只要在“阅读详情”元素上设置margin-top: auto，就可以把它推到列的底部，让两个组件的元素在视觉上对齐。 123.article-teaser-more&#123; margin-top: auto;&#125; 如果使用之前的老技术，比如浮动、行内块和定位，那么实现这种动态内容布局肯定会相当麻烦。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(5)——漂亮的盒子","slug":"精通CSS读书笔记(5)——漂亮的盒子","date":"2023-06-04T01:28:39.000Z","updated":"2023-11-27T15:34:23.886Z","comments":true,"path":"2023/06/04/精通CSS读书笔记(5)——漂亮的盒子/","link":"","permalink":"http://pvnk1u.github.io/2023/06/04/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E6%BC%82%E4%BA%AE%E7%9A%84%E7%9B%92%E5%AD%90/","excerpt":"","text":"背景颜色先从一个非常简单的例子开始：为整个页面添加背景颜色。以下代码会把页面背景设置成草绿色： 123body&#123; background-color: #bada55;&#125; 也可以直接使用更短的background属性: 123body&#123; background: #bada55;&#125; 颜色与不透明度 在这个例子里，使用了十六进制表示法指定了颜色。所谓十六进制表示法，就是一个#后面加上6位十六进制数字构成的字符串。 3组数字分别表示颜色中的红、绿、蓝（RGB）通道的值。每种颜色通道的值有256种可能。如果3组数字中每组的2位数字相同，可以简写成3位数字，比如#aabbcc可以简写成#abc。 RGB值可以用另一种方式表示，即rgb()函数式表示法。RGB的每个值可以是一个十进制数值，取值范围是0-255；也可以是一个百分比值，取值范围是0-100%。用rgb()表示法表示前面例子中的背景颜色，结果如下： 123body&#123; background-color: rgb(186,218,85);&#125; 接下来要介绍的颜色表示法是RGB的加强版，叫rgba()。其中末尾的a表示alpha，是用于控制透明度的阿尔法通道。如果想设置同样背景颜色的背景，但透明度为50%，可以这样做： 123.box&#123; background-color: rgba(186,218,85,0.5);&#125; 第四个参数值表示透明度，取值范围为0-1.0，1.0表示完全不透明，0表示完全透明。 背景图片添加背景颜色可以让页面色彩更加丰富。但有时候也想使用图片作为元素的背景。CSS为实现这些目标提供了充足的工具。 简单的背景图片示例假设设计的页面要像twitter或facebook等社交网站的用户首页一样，需要显示各式各样的页头。 我们的页面是一个猫咪社交网站，如下图所示，需要包含一个大幅页头图和带个人信息的头像。 首先设置一个灰蓝色的默认背景颜色，再添加一个背景图片。添加默认背景颜色很重要，以防图片加载失败： 123456.profile-box&#123; width:100%; height: 600px; background-color: #8Da9cf; background-image: url(img/big-cat.jpg)&#125; 组件的HTML代码如下： 12&lt;header class=&quot;profile-box&quot;&gt;&lt;/header&gt; 结果如图所示，图片在整个元素盒子范围内平铺，呈拼贴状： 为什么图片会平铺到整个元素盒子？这是由背景图片的另一个相关属性background-repeat的默认值决定的。background-repeat属性的默认值为repeat，意思是背景图片要沿x轴和y轴重复。这个特性对花纹图案的背景图片非常有用，但对照片可能就不合适了。可以明确声明repeat-x和repeat-y来限定图片只沿某个轴的方向重复，但在此要通过no-repeat完全禁止重复： 1234567.profile-box&#123; width:100%; height: 600px; background-color: #8Da9cf; background-image: url(img/big-cat.jpg); background-repeat: no-repeat;&#125; 最新的规范重新定义了这个属性，扩展了语法。支持以空格分隔的针对两个方向的关键词声明语法。换句话说，以下声明等同于使用repeat-x： 123.profile-box&#123; background-repeat: repeat no-repeat;&#125; 背景图片语法回到上面的例子，开始使用JPEG格式的图片来创建个人首页的示例。目前，图片已经平铺到元素的背景上，但仍然需要调整。目前的效果如下所示： 可以看到现在背景图片是靠左显示的，右侧有了大量的空白。为了解决这个问题，需要设置背景图片的位置。 背景位置背景图片的位置由background-position属性控制。 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Bigger image, positioned in middle&lt;/title&gt; &lt;style&gt; body &#123; padding: 0; margin: 0; font-family: &quot;Helvetica Neue&quot;, Arial, sans-serif; &#125; .profile-box &#123; width: 100%; height: 600px; background-color: #8Da9cf; background-image: url(img/big-cat.jpg); background-position: 50% 50%; background-repeat: no-repeat; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;profile-box&quot; role=&quot;banner&quot;&gt; &lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 此时，图片居中覆盖了整个元素。 background-position属性既可以使用关键字，也可以使用像素、em或百分比。最简单的情况下，可以只给两个值：一个表示相对于左侧的偏移量，一个表示相对于顶部的偏移量。 背景裁剪与原点默认情况下，背景图片是绘制到元素边框以内的。如果把背景图片定位到边框下方，而边框又被设置为半透明，那么图片边缘就会出现半透明的边框。 使用background-clip属性可以改变这个行为。这个属性的默认值为background-clip: border-box，将其改为padding-box就可以把图片裁剪到内边距盒子以内。而content-box值则会把图片位于内边距及其之外的部分裁剪掉。下面的例子展示了这三个值的区别： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Background clip example&lt;/title&gt; &lt;style&gt; body &#123; padding: 2em; margin: 0; font-family: &quot;Helvetica Neue&quot;, Arial, sans-serif; background-color: #fff; &#125; /* this default box is the same as background-clip: border-box; */ .profile-box &#123; display: inline-block; height: 200px; width: 400px; background-position: 50% 50%; background-repeat: no-repeat; background-image: url(img/cat.jpg); border: 10px solid rgba(220, 220, 160, 0.5); padding: 10px; &#125; .padding-box-clipped &#123; background-clip: padding-box; &#125; .content-box-clipped &#123; background-clip: content-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;profile-box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;profile-box padding-box-clipped&quot;&gt;&lt;/div&gt; &lt;div class=&quot;profile-box content-box-clipped&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 相应的效果如下： 背景附着背景会附着在指定元素的后面，如果滚动页面，那么背景也会随着元素移动而移动。可以通过background-attachment属性改变这种行为。如果想让示例中的大背景图在页面滚动时“粘”在页面上，可以使用如下代码： 123.profile-box&#123; background-attachment: fixed;&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Profile page with fixed background&lt;/title&gt; &lt;style&gt; /** * 1. &quot;Artificial&quot; height applied to body, just to trigger a scrollable are. * and see the effects. */ body &#123; padding: 0; margin: 0; font-family: &quot;Helvetica Neue&quot;, Arial, sans-serif; height: 4000px; /* [1] */ &#125; /** * 1. Note that the positioning of the background now is in relation to the * viewport, so we can&#x27;t position it in the vertical middle of the header. */ .profile-box &#123; position: relative; height: 600px; background-image: url(img/big-cat.jpg); background-position: 50% 0; /* [1] */ background-repeat: no-repeat; background-attachment: fixed; &#125; .profile-photo &#123; width: 160px; min-height: 200px; position: absolute; bottom: -60px; left: 5%; &#125; .profile-photo img &#123; display: block; max-width: 100%; height: auto; &#125; .username &#123; font-size: 20px; color: #666; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;profile-box&quot; role=&quot;banner&quot;&gt; &lt;div class=&quot;profile-photo&quot;&gt; &lt;img src=&quot;img/profile.jpg&quot; alt=&quot;Charles the Cat&quot;&gt; &lt;h1 class=&quot;username&quot;&gt;@CharlesTheCat&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 通过这种方式，可以实现随着页面滚动，头部的背景图片好像藏到了页面后面，很酷的效果。 背景大小在上一节的例子中，使用了一张大图覆盖了整个元素。这样的话，如果是在小屏幕上，那么图片会被裁切掉。反之，如果屏幕特别大，那么元素边缘可能出现空白。要避免上述情况，不管页面怎么缩放，都让内容保持自己的宽高比，就要使用background-size属性。 给background-size明确指定一个值，可以重新设置图片大小，也可以让它随元素大小缩放而缩放。 如果还是那张大图，由于某种原因希望它显示的小一点，那么可以重新给它一个尺寸： 123.profile-box&#123; background-size: 400px 240px;&#125; 要让图片随元素缩放而缩放，则必须使用百分比值。不过要注意，百分比值并不是相对于图片固有大小，而是相对于容器大小。因此，简单地把图片宽度和高度都设置成百分比值，可能会因容器高度变化而导致图片变形。 更好的做法是只给一个维度设置百分比值，另一个维度设置关键字值auto。比如，要是想让图片宽度始终保持为100%（即x轴，第一个值），同时保持自己固有的宽高比，可以这样写： 123.profile-box&#123; background-box: 100% auto;&#125; 百分比值赋予了我们控制的灵活度，但也不是任何情况下都适用。有时候，我们会希望背景图片的任何一边都不要被切掉。还有一种情况比如前面简介页面的头部区域，我们希望图片始终都能完全覆盖元素。好在CSS为此也提供了一些关键字值。 首先，可以把背景大小设置为contain。这个值可以让浏览器尽可能保持图片最大化，同时不改变图片的宽高比。与前面的例子类似，但浏览器会自动决定哪一边使用auto值，哪一边使用100%。代码如下所示： 123.profile-box&#123; background-size: contain;&#125; 在高而窄的元素中，方形背景最多100%宽，因此垂直方向会出现空白；而在较宽的元素中，背景最多100%高，因此水平方向会出现空白。 然后，第二个关键字是cover，意思是图片会缩放以保证覆盖元素的每一个像素，同时不会变形。这正是我们希望的个人简介页面的效果。使用这个关键字，在一个高而窄的元素中，元素高度会被填满，但图片左右两边会被切掉；而在一个较宽的元素中，元素宽度会被填满，但图片上下两边会被切掉。代码如下: 123.profile-box&#123; background-size: cover;&#125; 边框和圆角现代浏览器对边框都提供了一定的控制，包括插入图片和圆角，让边框不再是简单的矩形。 先简单回顾下边框属性。 可以分别为盒子的各边设置边框，也可以一次性为四边设置边框。 可以使用border-width一次性设置所有边框的宽度，也可以使用border-top-width这样的方位属性设置某条边框的宽度。除非明确指定box-sizing属性，否则边框宽度会影响盒子的尺寸。 同理，可以使用border-color设置所有边框的颜色，也可以使用border-left-color这样的方式属性设置某条边框的颜色。 边框的样式可以使用border-style（或border-right-style这样的方位属性）来设置，取值中最常用的是solid、dashed或dotted等关键字。 最后，可以使用border简写属性来设置所有边框属性。具体来说，可以把所有边设置成相同的宽度、样式、颜色，比如border: 2px solid #000; 边框半径：圆角给border-radius属性一个长度值，就可以一次性设置盒子四个角的半径。下面给简介页面添加一个头像，让包含头像的元素拥有圆角。首先是标记： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Profile with border radius&lt;/title&gt; &lt;style&gt; body &#123; padding: 0; margin: 0; font-family: &quot;Helvetica Neue&quot;, Arial, sans-serif; background-color: #ddd; &#125; .profile-box &#123; position: relative; height: 600px; background-image: url(img/big-cat.jpg); background-size: cover; background-position: 50% 30%; border-bottom: 1px solid #666; &#125; .profile-photo &#123; width: 160px; min-height: 200px; position: absolute; bottom: -60px; left: 5%; padding: .5em; -webkit-border-radius: .5em; border-radius: .5em; background-color: #fff; border: 1px solid #777; border-radius: 0.5em; &#125; .profile-photo img &#123; display: block; max-width: 100%; height: auto; &#125; .username &#123; font-size: 20px; color: #666; margin: .35em 0 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;profile-box&quot; role=&quot;banner&quot;&gt; &lt;div class=&quot;profile-photo&quot;&gt; &lt;img src=&quot;img/profile.jpg&quot; alt=&quot;Charles the Cat&quot;&gt; &lt;h1 class=&quot;username&quot;&gt;@CharlesTheCat&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 在这段代码里，首先设置了父header容器的定位为相对定位： 1234.profile-box&#123; position: relative; /* 其他代码 */&#125; 然后设置了头像元素.profile-photo的样式： 12345678910111213.profile-photo &#123; width: 160px; min-height: 200px; position: absolute; bottom: -60px; left: 5%; padding: .5em; -webkit-border-radius: .5em; border-radius: .5em; background-color: #fff; border: 1px solid #777; border-radius: 0.5em;&#125; 在这里，必须要先设置父header容器的定位为relative相对定位，子元素头像元素profile-photo的定位才会生效。这是因为：在父元素没有设置相对定位或绝对定位的情况下，子元素设置absolute绝对定位时是相对于根元素（即HTML元素）来定位的。当父元素设置了相对或绝对定位，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位。定位设置完成后，又通过border设置了头像元素边框的宽度及颜色，并通过border-radius设置边框样式为圆角。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(4)——网页排版","slug":"精通CSS读书笔记(4)——网页排版","date":"2023-06-03T01:28:39.000Z","updated":"2023-11-27T15:34:23.886Z","comments":true,"path":"2023/06/03/精通CSS读书笔记(4)——网页排版/","link":"","permalink":"http://pvnk1u.github.io/2023/06/03/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88/","excerpt":"","text":"CSS的基本排版技术拿到一个页面时，几乎所有设计师都会先考虑从基本的版式着手。从body元素开始，逐步细化，从而让整个页面具有基本的可行性、层次性和配色。接下来的例子就以此为目标：实现一个示例页面的基本版式。 下面的代码展示了一个非常简单的HTML文档，没有添加任何样式。此时的网页内容并没有乱作一团，这是因为浏览器有默认样式表，它为网页应用了一些必要的排版规则。 1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;A Simple Document About the Moon&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;article&gt; &lt;h1&gt;The Moon&lt;/h1&gt; &lt;p&gt;The &lt;strong&gt;Moon&lt;/strong&gt; (in Greek: σελήνη &lt;i&gt;Selene&lt;/i&gt;, in Latin: &lt;i&gt;Luna&lt;/i&gt;) is Earth’s only natural satellite. It is one of the largest natural satellites in the Solar System, and, among planetary satellites, the largest relative to the size of the planet it orbits (its primary). It is the second-densest satellite among those whose densities are known (after Jupiter&#x27;s satellite Io).&lt;/p&gt; &lt;p&gt;The Moon is thought to have formed approximately 4.5 billion years ago, not long after Earth. There are several hypotheses for its origin; the most widely accepted explanation is that the Moon formed from the debris left over after a giant impact between Earth and a Mars-sized body called Theia.&lt;/p&gt; &lt;h2&gt;Orbit&lt;/h2&gt; &lt;p&gt;The Moon is in synchronous rotation with Earth, always showing the same face with its near side marked by dark volcanic maria that fill between the bright ancient crustal highlands and the prominent impact craters. It is the second-brightest regularly visible celestial object in Earth’s sky after the Sun, as measured by illuminance on Earth’s surface. &lt;/p&gt; &lt;p&gt;Although it can appear a very bright white, its surface is actually dark, with a reflectance just slightly higher than that of worn asphalt. Its prominence in the sky and its regular cycle of phases have, since ancient times, made the Moon an important cultural influence on language, calendars, art, and mythology.&lt;/p&gt; &lt;h3&gt;Gravitational pull &amp;amp; distance&lt;/h3&gt; &lt;p&gt;The Moon’s gravitational influence produces the ocean tides, body tides, and the slight lengthening of the day. The Moon’s current orbital distance is about thirty times the diameter of Earth, causing it to have an apparent size in the sky almost the same as that of the Sun, with the result that the Moon covers the Sun nearly precisely in total solar eclipse. This matching of apparent visual size will not continue in the far future. The Moon’s linear distance from Earth is currently increasing at a rate of 3.82 ± 0.07 centimetres per year, but this rate is not constant.&lt;/p&gt; &lt;h2&gt;Lunar travels&lt;/h2&gt; &lt;p&gt;The Soviet Union’s Luna programme was the first to reach the Moon with unmanned spacecraft in 1959; the United States’ &lt;abbr title=&quot;National Aeronautics and Space Administration&quot;&gt;NASA&lt;/abbr&gt; Apollo program achieved the only manned missions to date, beginning with the first manned lunar orbiting mission by Apollo 8 in 1968, and six manned lunar landings between 1969 and 1972, with the first being Apollo 11. These missions returned over 380 &lt;abbr title=&quot;kilograms&quot;&gt;kg&lt;/abbr&gt; of lunar rocks, which have been used to develop a geological understanding of the Moon&#x27;s origin, the formation of its internal structure, and its subsequent history. After the Apollo 17 mission in 1972, the Moon has been visited only by unmanned spacecraft.&lt;/p&gt; &lt;p class=&quot;source&quot;&gt;Text fetched from &lt;cite&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Moon&quot;&gt;“Moon” article on Wikipedia&lt;/a&gt;&lt;/cite&gt; on &lt;time datetime=&quot;2016-02-23&quot;&gt;the 23&lt;sup&gt;rd&lt;/sup&gt; of February&amp;nbsp;2016.&lt;/time&gt;&lt;/p&gt; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 这个简单的文档包含几个标题和一些段落（段落文本中有一些行内元素，以便必要时添加样式），它们都包含在一个article元素中。这个没添加样式的网页虽然勉强能看，但效果非常不理想。我们的目标是以相对较少的样式来提升页面的易读性，并且让它变得更美观。 下面逐条分析要添加的规则，同时介绍相关术语，设置规则的原因，以及所涉及的排版属性背后的原理。 文本颜色默认情况下，浏览器会把绝大多数文本渲染为黑色，白底黑字的对比度极高。足够高的对比度是确保网页阅读无障碍的关键，但也往往会被过度强调。事实上，由于屏幕的高对比度，白底黑字会让大段文本显得过分密集，反而影响可读性。 对于上面的例子而言，标题仍然保持黑色，但正文要改成深蓝灰色。链接还是蓝色，但需要把“活力值”下调一点。 1234567p&#123; color: #3b4348;&#125;a&#123; color: #235ea7;&#125; 字体族字体族（font-family）属性的值是一个备选字体的列表，按优先级从左到右排列： 1234567body&#123; font-family: &#x27;Georgia Pro&#x27;,Georgia,Times,&#x27;Time New Roman&#x27;,serif;&#125;h1,h2,h3,h4,h5,h6&#123; font-family: Avenir Next,SegoeUI,arial,sans-serif;&#125; 这段CSS分别指定了body元素（以及几乎其他所有元素）和标题（h1、h2….）依次使用的字体，如果前面的字体在对应的操作系统中不存在的话，则依次尝试使用后面的字体。 字体大小与行高几乎所有浏览器中font-size的默认大小都是16像素，除非用户修改过偏好设置。这里不修改默认的font-size，而是选择使用em单位调整特定元素的大小： 123h3&#123; font-size: 1.314em;&#125; em单位用于font-size属性时，实际上是一个相应元素继承的font-size缩放因子。比如这里的h3元素，字型大小就是1.314*16&#x3D;21px。虽然可以直接设置21px，但em更灵活一些。多数浏览器都允许用户缩放整个页面，即使像素单位也可以缩放。而使用em之后，如果用户修改偏好中的默认font-size大小，那么相应元素的大小也会调整。 行间距、对齐和行盒子的构造随着给文本施加更多的控制，各种排版概念之间的关系便浮出水面。为了掌握这些概念，有必要深入理解CSS行内格式化模型，同时多理解一些排版术语。下图展示了一行文本的各个部分，这里仅以示例中第一段开头的两个词为例： 1&lt;p&gt;The &lt;strong&gt;Moon&lt;/strong&gt;...[etc]&lt;/p&gt; 每行文本都会生成一个行盒子。行盒子还可以进一步拆分成表示行内元素（比如上面例子中的strong元素）的行内盒子，或者连接两个行内元素的匿名行内盒子。 行内盒子中的内容区显示文本。内容区的高度由font-size的测量尺度，即图中的”Moon”末尾那个1em见方的块，以及这个块与字形本身的关系来决定。 行高指的是行盒子的总高度。更通俗的叫法是行间距，排版术语叫铅空，就是排字员用来分隔字符行的铅块。但与传统排版不同，CSS中的“铅空”始终都会同时应用到行盒子的上方和下方。 计算方法如下：行盒子的整体行高减去font-size，得到的值再平分成两份，也就是半铅空。如果line-height是30像素，而font-size是21像素，那么半铅空就是4.5像素。 设置行高 设置行高时，需要考虑当前字体大小。在这个例子中，对于Georgia这个font-family，给body设置的line-height值为1.5： 1234body&#123; font-family: Georgia,Times,&#x27;Times New Roman&#x27;,serif; line-height: 1.5;&#125; 关键在于行与行之间既不能太密，也不能太疏。对于较大的字体，行间距应该稍大一点。文本的长度和font-size也要考虑，短文本一般设置较小的line-height。 这里给line-height设置了没有单位的值1.5，意思就是当前font-size的1.5倍。body的font-size为16px，那么默认的line-height就是24px； 垂直对齐 除了line-height，行内盒子也会受到vertical-align属性的影响。它的默认值是baseline，即子元素的基线与父元素的基线对齐。在示例文章的末尾，有一个日期，其中的序数后缀“rd”包含在一个span中： 1&lt;time datetime=&quot;2016-02-23&quot;&gt;the 23&lt;span class=&quot;ordinal&quot;&gt;rd&lt;/span&gt;of February 2016.&lt;/time&gt; 这样可以通过vertical-align将其设置为上标文本，即使用super关键字（字号也小一些）： 1234.ordinal&#123; vertical-align: super; font-size: smaller;&#125; 文本粗细使用font-weight属性可设置标题文本的粗细。有些字体的变体很多，此时，可以不用给出变体的名字，而只使用关键字：normal、bold、bolder和lighter。也可以直接给出数字值，都是100的整数倍：100、200、300、400等等，最大为900。 默认值normal对应400，bold对应700，这两个粗细值是最常用的。关键字bolder和lighter的工作机制略有不同，它们的作用是在继承值的基础上把文本变粗或变细。 作为标题的默认值，这里使用了数字值500，而对h1和h2分别使用了超粗和中粗： 1234567891011h1,h2,h3,h4,h5,h6&#123; font-weight: 500;&#125;h1&#123; font-weight: 800;&#125;h2&#123; font-weight:600;&#125; 行长、律动和毛边接下来探讨一个对阅读体验有着重大影响的因素：行长。过长或过短的文本会打断人的眼球移动，导致读者无法连续阅读，最后甚至读不下去。 主体内容的文本行长通常是45-75个字符，平均值为66个字符。排版专家发现这个建议同样适用于今天的网页，特别是大屏幕中的网页。对于小屏幕而言，行长至少也应该有40个字符。 要控制行长，可以通过设定包含文本的段落、标题等元素的宽度来实现。 对于页面主体文本而言，Georgia字体的字母相对较宽，因此行长就要考虑使用前述范围的上限。为此，简单地将article元素的宽度设置为36em（平均每个字符0.5em），并令其在页面上居中。如果视口缩小到比这个值更窄，该元素会自动调整宽度。 1234article&#123; max-width: 36em; margin: 0 auto;&#125; 文本缩进与对齐默认情况下，文本是左对齐的。文本左对齐有助于眼睛找到下一行，保持阅读节奏。对于连续的段落，或者为相邻段落设置一行的外边距，或者设置首段缩进。在此选择后一种方案，使用相邻组合符设置text-indent属性： 123p + p&#123; text-indent: 1.25em;&#125; 相邻兄弟选择器 (+) 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父elment的子元素，则第二个元素将被选中。 这段代码将对相邻文本中的第二段文本设置文本缩进。 同时再居中显示h1元素，以及给它添加一个底部边框，从而让它能跟下面的文本连成一体： 1234h1&#123; text-align: center; border-bottom: 1px solid #c8bc9d;&#125; text-align属性可以接受下列任意一个关键字值：left、right、center和justify。 多栏文本把整篇文章宽度都限制在36em可以达到限制行长的目的，但是对于大屏幕而言，却又太浪费空间了，留着大片的空白很可惜。有时候，为了有效利用宽屏，可以把文本分成多栏，并对每栏的宽度加以限制。 如果把之前设置的max-width增加到70em，那么可以分成3栏。为此，要把columns属性设置为想要的最小宽度。栏间距通过column-gap属性控制： 123456article&#123; max-width: 70em; columns: 20em; coumn-gap:1.5em; margin: 0 auto;&#125; 这里的columns属性是column-count和column-width属性的简写形式。如果只设置column-count属性，浏览器会严格生成指定数量的栏，不管宽度如何。如果同时设置了column-count和column-width，则前者会作为最大栏数，后者会作为最小栏宽。 12345678910111213columns: 20em; /* 在保证最小宽度20em的前提下，自动设置栏数 */column-width: 20em; /* 同上 */ columns:3 /* 3栏，自动设置宽度 */ columns-count: 3; /* 同上 */ columns: 3 20em; /* 至少3栏，每栏宽度至少20em */ /* 以下两条声明的组合相当于以上代码的简写形式 */ column-count: 3; column-width: 20em;","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(3)——可见格式化模型","slug":"精通CSS读书笔记(3)——可见格式化模型","date":"2023-05-30T06:34:39.000Z","updated":"2023-11-27T15:34:23.886Z","comments":true,"path":"2023/05/30/精通CSS读书笔记(3)——可见格式化模型/","link":"","permalink":"http://pvnk1u.github.io/2023/05/30/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"浮动、定位和盒模型是学习CSS需要掌握的几个最重要的概念。这几个概念决定了元素在页面上排布和显示的方式，是很多布局技术的基础。搞清楚盒模型的各方面细节，绝对和相对定位的区别，以及浮动及清除的原理之后，使用CSS设计网站会变得更简单、更轻松。 盒模型盒模型是CSS的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作一个矩形盒子，这个盒子包含元素的内容、内边距、边框和外边距。 内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不致于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。 有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不会影响盒子的宽度和高度。因此，outline常用于调试复杂布局，或者演示布局效果。 盒模型如下图所示： 对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。当然，可以覆盖这些样式，要么在自己的样式表里覆盖，要么直接引用重置样式表。 盒子大小默认情况下，元素盒子的width和height属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加5像素的边框和5像素的内边距，同时又想让元素盒子的宽度为100像素，则应该像下面这样把内容区宽度设置为80像素。如果这个元素盒子周围还有10像素的外边距，那么整个盒子占据空间的宽度就是120像素（如下图所示）。 123456.mybox&#123; width: 80px; padding: 5px; border: 5px solid; margin: 10px;&#125; 通过修改box-sizing属性可以改变计算盒子大小的方式。box-sizing的默认值为content-box，即前面例子中看到的那样，把宽度值应用给内容区。通过修改box-sizing的值，设置元素的width和height属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。 如果把box-sizing的值修改为border-box，那么width和height属性的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到width中。这样，如下代码可以实现与上面的图一样的布局。 1234567.mybox&#123; box-sizing: border-box; width: 100px; padding: 5px; border: 5px; margin: 10px;&#125; 在很多情况下这都很有用，因为很多情况下，这种计算盒子大小的方式更加直观。之所以说这种计算方式“直观“，是因为现实中的盒子就是这样测量的。 如果把CSS中的盒子想象成一个包装箱，那么箱子的四壁就是边框，从视觉上规定了箱子的大小；内边距就是箱子内部的填充层，用于保护箱子里的物品。在箱子宽度既定的情况下，无论是加厚箱壁还是增加填充层厚度，都会挤压最终可用于盛放物品的空间。这样在码放箱子时，不管它们之间空出多大距离（对应CSS中的外边距），都不会影响箱子本身的宽度，以及箱子内部可用的空间。总之，这是一个有实物可以参照的方案。但是浏览器开发人员决定默认采用另一种方式来计算CSS盒模型的宽度，这实际上并不明智。 好在可以通过设置box-sizing属性来覆盖默认行为，简化CSS布局中的一些常用模式。举个例子： 1234&lt;div class=&quot;group&quot;&gt; &lt;article class=&quot;block&quot;&gt; &lt;/article&gt;&lt;/div&gt; 默认情况下，如果想让.group中的.block宽度在任何情况下都占其父元素的1&#x2F;3，可以使用以下规则： 123.group .block&#123; width: 33.3333%;&#125; 只要不给.block应用内边距，这样写就没问题。但如果给.block添加了内边距，它的宽度就会变成.group元素的1&#x2F;3外加应用给它的内边距。如果这是一个三栏布局，那么此时添加内边距很可能会破坏原有布局。下图展示了添加内边距前后的不同之处： 要解决这个问题，可以再增加一个内部元素，然后改为给这个元素添加内边距。或者，可以设置一个不同的box-sizing值，从而修改盒子宽度的计算方式(如下图所示)： 12345.group .block&#123; width: 33.3333%; box-sizing: border-box; padding: 20px;&#125; 此时，无论添加多少内边距和边框，.block的宽度始终保持为其父元素的1&#x2F;3。 内边距、边框和外边距可以应用于元素的四边，也可以应用于具体某一边。外边距甚至还可以使用负值，使得元素可以在页面中移动。 内边距和外边距的值可以是CSS规范中规定的任意长度单位（px、em或百分比）。其中，使用百分比长度时，有几个问题需要注意。假设还是前面的那个例子，下面代码中的5%到底是什么意思？ 123.block&#123; margin-left: 5%;&#125; 这里5%指的是父元素.group宽度的5%。如果.group宽度是100像素，那么这里左外边距的宽度就是5像素。 如果给一个元素的顶部和底部应用内、外边距，那么使用百分比值应该基于元素的高度来计算，对吧？错，因为元素的高度常常不会被声明，而且会因内容多少而差异很大，所以CSS规定，上、下方位的内、外边距，仍然基于包含块的宽度来计算。这里，包含块就是其父元素，但有时候不一定。具体会在后面详细说明。 最大值和最小值有时候，特别是响应式布局中，给一个元素应用min-width和max-width值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比min-width指定的值更窄，或者扩展到比max-width指定的值更宽。 与此类似的是min-height和max-height属性。不过在CSS中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即便出于种种原因，需要明确设定默认高度，也最好使用min-height，因为这个属性允许盒子随内容扩展。 可见格式化模型有了对盒模型的理解，下一步就可以探讨可见格式化及定位模型了。 大家常说p、h1盒article这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子的形式。相对而言，strong、span和time被称为行内元素，因为它们的内容会以行内盒子的形式显示在行内。 可以使用display属性改变生成的盒子类型。换句话说，可以通过把display属性设置为block，让span变得跟块级元素一样。如果把display属性设置为none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。 CSS中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有元素盒子都会在常规文档流中生成，即position属性的默认值为static。顾名思义，常规文档流中元素盒子的位置，由元素在HTML中的位置决定。 块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。 行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。 由一行文本形成的水平盒子叫行盒子（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。下图展示了一个段落的块级盒子及其包含的两行文本，其中有一个单词位于显示为行内盒子的strong元素中。 当然，也可以把元素的display属性设置为inline-block。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。 使用表格相关的标记（table、tr、th等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置display属性让非表格元素采用表格的布局方式。只要正确地应用table、table-row和table-cell等值，就可以实现表格布局，无须在HTML标记中使用表格标签。 Flexible Box Layout（也称为Flexbox）和Grid Layout等CSS模块，又进一步扩展了display属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。 在Display Level3模块中，上述外部和内部显示模式的差异正在标准化。在这个模块中，既有显示模式的相关属性和关键字都是可扩展的，从而支持更细粒度的控制。但无论如何，行内盒子和块级盒子仍然是HTML元素默认行为的基础，只是显示当中有了更多选项。 匿名盒子HTML元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在section这个块级元素的开头加入”some text“。此时，”some text“就算没有定义为块级元素，也会被当成块级元素。 1234&lt;section&gt; some text &lt;p&gt; some more text&lt;/p&gt;&lt;/section&gt; 这种情况下，这个盒子被称为匿名块盒子，因为这个盒子并不与任何特定的元素相关。 类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子。除了使用.first-line伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。关键要知道，在屏幕上看到的一切都会从属于某个盒子。 外边距折叠常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，但实践中常常给布局网页带来困惑。简而言之，垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度。 如下图所示，当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。 在一个元素嵌套着另一个元素的情况下，假设没有内边距或边框来分隔外边框，它们的上、下外边距也会折叠。 乍一看，这种情况不太正常，但事实还不止如此：甚至同一个元素的外边距都能折叠。假设有一个空元素，只有外边距而没有边框或内边距。此时，上外边距与下外边距接触，结果也会折叠： 更进一步，如果折叠后的外边距又碰到了其他元素的外边距，还会继续折叠。 这就是再多的空段落也只会占用一小块空间的原因：它们的外边距都折叠成一个小外边距了。 外边距折叠好像很奇怪，实际上却很有用。以一个包含几段文本的页面为例： 这一段上方的间距等于这一段的上外边距。如果没有外边距折叠，则后续所有段落的间距，都是相邻的上、下外边距之和。结果就是段间距是上页边距的两倍。有了外边距折叠，段间距才会与页边距相等。 外边距折叠只会发生在文档常规文本流中块级盒子的垂直方向上。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。 包含块知道什么决定一个元素的包含块非常重要，前面的例子中，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。 确定元素的包含块，要看元素是如何定位的。如果元素的定位方式为静态定位（即不指定position属性的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的display属性值必须能够提供类似块级的上下文，如block、inline-block、table-cell、list-item等。 默认情况下，width、height、margin和padding的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了absolute或fixed，那么计算依据就会发生变化。接下来逐个讨论不同的定位模型，以及如何确定与之对应的包含块。 相对定位把一个元素的display属性设置为relative，该元素仍然会呆在原来的地方。但此后，可以通过设置top、right、bottom和left属性，使该元素相对于初始位置平移一段距离。比如设置top属性为20像素，该元素就会相对于其初始位置垂直向下平移20像素。而设置left属性为20像素，则会将该元素向右移动20像素，其左侧会出现空白。 12345.mybox&#123; position: relative; left: 20px; top: 20px;&#125; 无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致遮挡其他元素。 绝对定位相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，彷佛绝对定位的那个元素没有存在过一样。 绝对定位元素的包含块是距离它最近的定位祖先，也就是display属性设置为static之外任意值的祖先元素。如果没有这么一个定位祖先，那么它就相当于文档的根元素即html元素定位。文档的根元素也叫作起始包含块。 与相对定位的盒子类似，绝对定位的盒子也可以相对于其包含块向上、下、左、右方向平移。平移绝对定位的元素提供了极大的灵活性，因为可以把元素移动到页面的任意位置。 绝对定位的盒子是脱离了常规文档流的，因此可能会遮挡页面上的其他元素。为了控制这些盒子层叠的次序，可以设置一个叫z-index的属性。z-index的属性值越大，盒子在层叠中的次序就越靠近用户的眼睛。 尽管绝对定位对于在页面上任意摆放元素非常有用，但近来已经很少被用来构建整体布局了。绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。web技术的特点决定了不太可能指定元素在页面上的确切位置和大小。绝对定位在整体布局上几乎没人用了。 固定定位固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport）。因此，固定定位可以用来创建始终停留在窗口相同位置的浮动元素。很多网站都用这个技术让导航区始终保持可见，有的固定侧栏，有的固定顶栏。这样能确保网站的可用性，因为用户不必再费事寻找了。 浮动另一种可见格式化模型是浮动模型。浮动盒子可以向左或向右移动，直到其外边沿接触包含块的外边沿，或接触另一个浮动盒子的外边沿。浮动盒子也会脱离常规文档流，因此常规流中的其他块级盒子的表现，几乎当浮动盒子根本不存在一样。 如下图所示，向右浮动Box1时，Box1会脱离文档流并向右移动，直至其右边沿接触包含块的右边沿。同时，Box1的宽度也会收缩为适应于其中内容的最小宽度，除非通过width或min-width&#x2F;max-width明确设置其宽度。 如下图所示，向左浮动Box1时，它脱离文档流并向左浮动，直至其左边接触包含块的左边沿。Box1已经不在文档流中，因此不会再占用空间，这导致它浮于上方，遮住了Box2。如果向左浮动全部3个元素，Box1会向左移动，直到接触其包含块；另外两个盒子也向左移动，直到接触自己前面的浮动盒子。 如果包含元素太窄，无法容纳所有浮动元素水平排列，则后面的浮动元素会向下浮动（如下图）。如果浮动元素高度不同，则后面的浮动元素在向下移动时可能会“卡”在前面的浮动元素右侧。 行盒子与清除 前面说到，浮动元素会脱离文档流，因此不会再像非浮动元素一样影响其他元素。实际上，严格来讲并非如此。如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就会当浮动元素不存在一样，该怎么布局就怎么布局。但是，这个元素盒子中的文本内容则会记住浮动元素的大小，并在排布时避开它，为其留出相应的空间。从技术上来讲，就是跟在浮动元素后面的行盒子会缩短，从而为浮动元素留空，造成文本环绕浮动盒子的效果。事实上，浮动就是为了在网页中实现文本环绕图片的效果而引入的一种布局模型。如下图所示： 要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的元素应用clear属性。clear属性的值有left、right、both和none，用于指定盒子的哪一侧不应该紧挨着浮动盒子。很多人认为clear属性只是简单地删除几个用于抵消前面浮动元素的标记，事实却没有这么简单。清除一个元素时，浏览器会在这个元素上方添加足够大的外边距，从而将元素的上边沿垂直向下推移到浮动元素下方(如下图所示)。因此，如果给“已清除的”元素添加外边距，那么除非外边距的值超过浏览器自动添加的值，否则不会看到什么效果。 浮动元素除了会导致后面的行盒子缩短，从而造成文本环绕效果外，不会对周围的元素有任何别的影响，毕竟它已经脱离了文档流。但清除一个元素本质上会为所有前面的浮动元素清理出一块垂直空间。这就为使用浮动布局创造了条件，因为周围的元素可以为浮动的元素腾出地方来。 下面看看怎么利用浮动实现一个简单的布局。假设想把一张图片浮动到一个标题左边，把一小段文本浮动到标题右边。这种布局一般叫作“媒体对象”。因为左侧放一个媒体（如插图、图片或视频）、右侧放一段说明文字是一种常见的布局模式。另外，如果希望这张图片及右侧的文本被包含在另一个有背景颜色和边框的元素中。那么可以写出如下规则： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;FloatDemo&lt;/title&gt;&lt;style&gt; .media-block&#123; backgroud-color: gray; border: solid 1px black; &#125; .media-fig&#123; float: left; width: 30%; /* 给文本留出70%的宽度 */ &#125; .media-body&#123; float:right; width: 65%; /* 左边再留出一点空隙来 */ &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;media-block&quot;&gt; &lt;img class=&quot;media-fig&quot; src=&quot;/img/pic.jpg&quot; alt=&quot;The pic&quot; /&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h3&gt;Title of this&lt;/h3&gt; &lt;p&gt;Brief description of this&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 不过，浮动的元素会被拿出文档流，因此类为.media-block的div不会占用空间：它只包含浮动的内容，因此无法在文档流中为它生成高度。怎样才能让这个元素从视觉上也包住浮动元素？需要在这个元素内部某处应用clear。这样就会像前面看到的一样，在清除的元素上方创造出足够的垂直外边距，从而为包住浮动元素创造出空间（如下图）。然而，由于这个例子中没有用来清除的元素，需要在结束后的div标签前额外加一添加一个空元素，然后清除该元素： 12345678910111213/* 后补的CSS */.clear&#123; clear: both;&#125;&lt;div class=&quot;media-block&quot;&gt; &lt;img class=&quot;media-fig&quot; src=&quot;/img/pic.jpg&quot; alt=&quot;The pic&quot; /&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h3&gt;Title of this&lt;/h3&gt; &lt;p&gt;Brief description of this&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;!-- 额外添加的空div --&gt;&lt;/div&gt; 这样就实现了想要的布局，但也引入了“多余”的标记。有时候可能会有现成的元素用于清除，但有时候就不得不像这里一样，额外加入与布局没什么关系的标记。其实还有更好的方法。 要改进这个例子，可以使用:after伪类来模拟额外的清除元素。把下面的规则应用给包含浮动元素的容器div，就会在它内部的末尾生成一个盒子，并在这个盒子上应用清除规则： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;FloatDemo&lt;/title&gt;&lt;style&gt; .media-block&#123; backgroud-color: gray; border: solid 1px black; &#125; .media-fig&#123; float: left; width: 30%; /* 给文本留出70%的宽度 */ &#125; .media-body&#123; float:right; width: 65%; /* 左边再留出一点空隙来 */ &#125; .media-block:after &#123; content: &#x27;&#x27;; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;media-block&quot;&gt; &lt;img class=&quot;media-fig&quot; src=&quot;./BoxModel.PNG&quot; alt=&quot;The pic&quot; /&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h3&gt;Title of this&lt;/h3&gt; &lt;p&gt;Brief description of this&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 格式化上下文当元素在页面上水平或垂直排布时，它们之间如何相互影响，CSS有几套不同的规则，其中一套规则叫作格式化上下文。前面已经介绍了行内格式化上下文的一些规则。比如，垂直外边距对于行内盒子没有影响。类似的，有的规则适用于块级盒子的叠放，比如上一节对应的外边距折叠。 此外，有些规则规定了页面必须自动包含突出的浮动元素（否则浮动元素中的内容可能会跑到可滚动区域之外），而且所有块级盒子的左边界默认与包含块的左边界对齐（如果文字顺序是从右向左，那么与包含块的右边界对齐）。这组规则就是块级格式化上下文。 还有些规则允许元素建立自己内部的块级格式化上下文，包括： display的属性值设置为inline-block或table-cell之类的元素，可以为内容创建类似块级的上下文。 float属性值不是none的元素。 绝对定位的元素。 overflow属性值不是visible的元素。 前面说过，块边界接触其包含块边界的规则同样适用于前面是浮动元素的内容。浮动元素从页面流中移出后，通过触发其后的元素中行盒子的缩短行为，制造了为自身腾出四周空间的视觉效果。而其后的元素仍然会按照需要，在浮动元素下方拉伸。 当一个元素具备了触发新块级格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则。此时，这个元素会收缩到适当大小；不仅行盒子如此，所有盒子都如此。利用这一点，可以通过更简单的规则实现前面的媒体对象组件： 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Media Object, utilizing the formatting context&lt;/title&gt; &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; .media-block &#123; background-color: gray; border: solid 1px black; &#125; .media-fig &#123; float: left; margin-right: 5%; &#125; .media-body, .media-block &#123; overflow: auto; /* 1 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;media-block&quot;&gt; &lt;img class=&quot;media-fig&quot; src=&quot;img/pic.png&quot; alt=&quot;The pic&quot; /&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h3&gt;Title of this&lt;/h3&gt; &lt;p&gt;Brief description of this&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 给.media-block和.media-body元素都设置了overflow: auto;之后，就为它们创建了新的块级格式化上下文。这样就实现了目标（如下图）： 不用设置清除规则，就可以让.media-block包住浮动的照片，因为块级格式化上下文自动包含浮动。 顺带着，可以放弃给.media-body声明宽度和浮动。这是因为它会自动调整以适应浮动元素旁边的剩余空间，并确保挨着图片的一边是直的。如果没有通过给.media-body设置overflow:auto，则.media-body就没有新的格式化上下文，此时如果.media-body的文本比较多，那么位于浮动.media-fig下方的盒子都会伸长，最终填满图片下方的空间。 尽量基于简单且可预测的行为来创建布局，这样可以降低代码复杂度，并提高布局稳健性。因此，知道什么时候可以使用这个技术，以避免浮动和清除元素之间的复杂交互，可以说是一件可喜的事。 如上图所示，如果只浮动.media-fig且文本足够多，就会有一些文本环绕到图片下方。而创建一个新的块级格式化上下文会强迫.media-body收缩。 其他CSS布局模块目前为止，已经介绍了CSS可见格式化模型的基础以及大部分公共的内容。这一节简单介绍其他相关内容。 对于CSS这种视觉表现语言来说，稳健又灵活的布局无论如何都是需要的。虽然道理显而易见，但这种模型的诞生却并不容易。过去曾想方设法地利用这门语言中可用的特性来达成目标，哪怕那些特性并不好用。比如最早曾使用表格布局，但问题是代码臃肿、语义不当。近来又在使用浮动和绝对定位，但这些技术同样也并非为页面布局而设计。无论是表格还是浮动与定位，都有非常严重地局限性。使用它们只是不得已的选择。 可喜的是，最近出现了一些专门针对创建灵活、稳健页面布局的CSS模块。 弹性盒布局弹性盒布局，常被称为Flexbox，是CSS3新引入的一种布局模型。Flexbox支持对子元素水平或垂直布局，以及设置这些子元素的大小、间距和对齐方式。此外，Flexbox还支持改变元素渲染到页面上的次序，可以跟它们在HTML中的次序不同。作为CSS常规流模型（行内和块）的升级版，无论是调整内容本身还是适应内容大小，Flexbox都做到了既精确又灵活。 网格布局网格布局是CSS最早成熟的高层布局工具，目标是取代浮动和定位元素的布局方式。网格布局实现了源代码次序的完全分离，从内容结构和个别模块的表现中抽象出了网格系统。Flexbox关注“微观”，而网格系统关注“宏观”，二者正好互补。 多栏布局多栏布局模块的用意很明确，就是实现内容的多栏布局。比如，要排成像报纸那样的多栏样式。可以先指定栏数，也可以先指定每一栏的宽度，然后让浏览器根据可用宽度自动确定栏数。当然，还可以控制栏间距，并在其中应用类似边框的视觉效果。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(2)——添加样式","slug":"精通CSS读书笔记(2)——添加样式","date":"2023-05-24T06:34:39.000Z","updated":"2023-11-27T15:34:23.885Z","comments":true,"path":"2023/05/24/精通CSS读书笔记(2)——添加样式/","link":"","permalink":"http://pvnk1u.github.io/2023/05/24/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"CSS选择符类型与后代选择符是最基本的选择符。类型选择符用于选择特定类型的元素，比如段落或标题元素，只要写出想添加样式的元素名即可。类型选择符有时候也被称为元素选择符。 123p&#123; color: black;&#125; 后代选择符用于选择某个或某组元素的后代。后代选择符的写法是在两个选择符之间添加空格。在下面的例子中，只有作为块引用后代的段落元素会被选中，从而缩进，其他段落都不会缩进： 123blockquote p&#123; padding-left: 2em;&#125; 类型选择符与后代选择符非常适合全面应用基础样式。要想更精确地选择目标元素，可以使用ID选择符和类选择符。这两个选择符通过对应ID和class属性的值来选择元素。ID选择符由j井号(#)开头，类选择符由句点（.）开头。下面例子中的第一条规则会把介绍性段落中的文字变成粗体，而第二条规则会把日期变成灰色。 123456789101112131415#intro&#123; font-weight: bold;&#125;.date-posted&#123; color: #ccc;&#125;&lt;p id=&quot;intro&quot;&gt; Happy Birthday&lt;/p&gt;&lt;p class=&quot;date-posted&quot;&gt; 20/1//2013&lt;/p&gt; 有时候，可以将ID和类选择符与类型和后代选择符组合起来使用，而不必为所有元素都添加ID和类选择符： 123456789101112#latest h1&#123; font-size: 1.8em;&#125;#latest .date-posted&#123; font-weight: bold;&#125;&lt;article id=&quot;latest&quot;&gt; &lt;h1&gt;Happy Birthday&lt;/h1&gt; &lt;p class=&quot;date-posted&quot;&gt;&lt;time datetime=&quot;2013-01-20&quot;&gt;20/1/2013&lt;/time&gt;&lt;/p&gt;&lt;/article&gt; 子选择符与同辈选择符除了基本选择符，CSS也提供了高级选择符。第一个高级选择符叫子选择符。与后代选择符会选择一个元素的所有后代不同，子选择符只选择一个元素的直接后代，也就是子元素。在下面的例子中，外部列表中的列表项前面会出现自定义的图标，而嵌套列表中的列表项则不会受影响： 12345678910111213141516#nav &gt; li&#123; background: url(folder.png) no-repeat left top; padding-left: 20px;&#125;&lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/home/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/services/&quot;&gt;Services&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/services/design/&quot;&gt;Design&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/services/development/&quot;&gt;Development&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/services/consultancy/&quot;&gt;Consultancy&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/contact/&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 有时候可能需要为与某个元素相邻的元素添加样式。使用相邻同辈选择符，就可以选择位于某个元素后面，并与该元素拥有共同父元素的元素。使用相邻后辈选择符，可以为第一个段落中的文本应用粗体、灰色，让它们比后面段落中的文本稍微大一点： 12345h2 + p&#123; font-size: 1.4em; font-weight: bold; color: #777;&#125; 这样选择标题后面的第一个段落是可行的，但更简单、更容易维护的方式，还是为开头这一段增加一个类名，比如intro-text。这样，intro-text类也可以应用于其他并非直接位于h2元素之后的段落。 &gt;和+在这里被称为组合子，因为它们描述了自身两侧的选择符组合的方式。实际上还有一个类似的组合子，那就是一般同辈组合子：~。仍以前面的例子来说明，使用一般同辈组合子可以选择h2元素后面的所有段落。 12345h2 ~ p&#123; font-size: 1.4em; font-weight: bold; color: #777;&#125; 通用选择符通用选择符可以匹配任何元素。与其他语言中的通配符类似，通用选择符也使用星号（*）表示。也就是说，只用一个星号，就可以匹配页面中的所有元素。那么，是否可以使用通用选择符来删除所有元素默认的内外边距呢？比如这样： 1234*&#123; padding: 0; margin: 0;&#125; 事实上，这样写可能带来很多意想不到的后果，特别是会影响button、select等表单元素。如果想重设样式，最近还是像下面这样明确指定元素： 12345h1,h2,h3,h4,h5,h6,ul,ol,li,dl,p&#123; padding: 0; margin: 0;&#125; 当然，通用选择符不仅限于给文档中的所有元素设置属性。还可以把它与组合子结合使用，选择某个特定的嵌套层次，此时重要的是层次而不是元素类型。看下面这个例子： 123.product-section &gt; *&#123; /* ... */&#125; 这个组合选择符会选择带有类名product-section的元素的直接后代，不管它是什么元素，有什么属性。 属性选择符属性选择符是基于元素是否有某个属性或者属性是否有某个值来选择元素。有了这种选择符，可以实现很多更有意思、更深入的选择。 比如，鼠标指针悬停在某个带有title属性的元素上时，多数浏览器都会显示一个提示条。利用这种行为，可以借助&lt;abbr&gt;元素对某些缩写词给出详尽的解释： 1&lt;p&gt;The term&lt;abbr title=&quot;self=contained underwater breathing apparatus&quot;&gt;SCUBA&lt;/abbr&gt; is an...&lt;/p&gt; 可是，如果不把鼠标放在这个元素上，谁也不知道它还会显示缩写词的解释。为此，可以使用属性选择符给带有title熟悉的abbr元素添加不同的样式，比如，在缩写词下面加一条点划线。然后把悬停状态的鼠标指针改成问号。 1234567abbr[title]&#123; border-botton: 1px dotted #999;&#125;abbr[title]:hover&#123; cursor: help;&#125; 除了可以根据是否存在某个属性来选择元素，还可以根据特定的属性值来应用样式。比如，下面这个例子可以用来修正一个问题，即鼠标悬停在提交按钮上时，不同浏览器显示的光标不一致。有了这条规则，所有type属性值为submit的input元素在鼠标指针悬停时，都会显示一个手状光标： 123input[type=&quot;submit&quot;]&#123; cursor: pointer;&#125; 有时候更关心的是属性值是否匹配某个模式，而非某个特定值。这时候，通过给属性选择符中的等号前面加上特殊字符，就可以表达出想要匹配的值的形式了。 要匹配以某些字符开头的属性值，在等号前面加上插入符（^）: 1a[href^=&quot;http:&quot;] 要匹配以某些字符结尾的属性值，在等号前面加上美元符号（$）： 1ims[src$=&quot;.jpg&quot;] 要匹配包含某些字符的属性值，在等号前面加上星号（*）： 1 a[href*=&quot;/about/&quot;] 要匹配以空格分隔的字符串中的属性值（比如rel属性的值），在等号前面加上波浪号（~）： 1a[rel~=next] 还有一个属性选择符，可以选择开头是指定值或指定值后连着一个短划线的情况。要匹配这种情况，在等号后加上竖线（|）： 1a[lang|=en] 伪元素有时候想选择的页面区域不是通过元素来表示的，而且也不想为此给页面增加额外的标记。css为这种情况提供了一种特殊选择符，叫做伪元素。 首先，可以使用::first-letter伪元素来选择一段文本的第一个字符。若要选择一段文本的第一行，可以使用::first-line。 此外，还有伪元素对应着内容开头和末尾处假想的元素，分别是::before和::after。这两个伪元素非常适合用来插入小图标及版面装饰符号。如果没有它们，要实现同样的视觉效果，就必须在HTML中插入真实的元素。 伪元素结合使用的例子： HTML: 1234&lt;h1&gt;A Study In Scarlet&lt;/h1&gt;&lt;section class=&quot;chapter&quot;&gt; &lt;p&gt;In the 1878 I took my degree od Doctor of Medicine of the University of London,and proceeded to Netley to go through the course prescribed for surgeons in the army. Having complted my studies there, I was duly attached to the Fifth Northumberland Fusiliers as Assistant Surgeon.&lt;/p&gt;&lt;/section&gt; CSS: 123456789101112131415.chapter::before&#123; content: &#x27;&quot;&quot;&#x27;; font-size: 15em;&#125;.chapter p::first-letter&#123; float: left; font-size: 3em; font-family: Georaia, Times, &quot;Times New Roman&quot;,serief;&#125;.chapter p::first-line&#123; font-family: Georaia, Times, &quot;Times New Roman&quot;,serief; text-transform: uppercase;&#125; 这里使用了::first-letter伪元素实现了段落的首字下沉效果。第一行也通过::first-line伪元素转换为全部大写，并应用了不一样的字体。.chapter开头那个装饰性的大引号则利用了::before伪元素。实现这么多视觉效果，却没有额外增加一个元素，确实方便。 伪类有时候会想基于文档结构以外的情形来为页面添加样式，比如基于超链接或表单元素的状态。这时候就可以使用伪类选择符。伪类选择符的语法是以一个冒号开头，用于选择元素的特定状态或关系。 一些最常见的用于超链接的伪类列举如下。在涵盖最常见HTML元素的基础样式表中，应该始终包括它们： 1234567891011121314151617181920/* 未访问过的链接为蓝色 */ a:link&#123; color: blue;&#125;/* 访问过的链接为绿色 */a:visted&#123; color: green;&#125;/* 超链接在鼠标悬停及获取键盘焦点时为红色 */a:hover,a:focus&#123; color: red;&#125;/* 活动状态时为紫色 */a:active&#123; color: purple&#125; 以上伪类的先后次序很重要。:link和:visited应该排在前面，然后才是与用户交互相关的那些。这样一来，当用户鼠标悬停在链接上，或者链接获得键盘焦点时，:hover和:focus规则会覆盖:link和:hover规则。最后，当鼠标点击或键盘回车选择链接时，应用:active规则。 目标与反选另一个有用的伪类是:target，它匹配的元素有一个ID属性，而且该属性的值出现在当前页面URL末尾的井号（#）后边。如果打开链接http:example.com&#x2F;blog&#x2F;1&#x2F;#comment-3，找到该页面中标记为&lt;article class=&quot;comment&quot; id=&quot;comment-3&quot;&gt;...&lt;/article&gt; 的评论，那么可以通过以下规则高亮该条评论： 123.comment:target&#123; background-color: #fffec4;&#125; 现在，假设想高亮一条评论，而该评论不是因投票否决而被隐藏的。也有一个选择符专门用于排除某些选择符：它就是反选（negation）伪类，或者:not()选择符。如果被标记为“投票否决”(downvoted)的评论都有一个特殊的类名，那么就可以像下面这样来改写规则： 123.comment:target:not(.comment-downvoted)&#123; backgroud-color: #fffec4;&#125; 结构化伪类CSS3新增了一大批与文档结构相关的新伪类。其中最常用的是nth-child选择符，可以用来交替地为表格应用样式： 123tr:nth-child(odd)&#123; background: yellow;&#125; 这条规则会从表格的第一行开始，将后面每隔一行的背景变成黄色。nth-child选择符就像一个函数，可以接受很多不同的表达式作为参数。如前例所示，它可以接受odd（奇数）和even（偶数）作为参数。这个参数还可以直接是数值，表示目标元素的序数位置。 还有一个伪类选择符也支持这种表达式，比如： 1:nth-last-child(N) :nth-last-child选择符与:nth-child选择符类似，只不过是从最后一个元素倒序计算。 表单伪类HTML5为表单输入框新增了几个属性，表示必填的required就是其中之一。 12&lt;label for=&quot;field-name&quot;&gt;Name: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;field-name&quot; id=&quot;field-name&quot; /&gt; 如果想高亮这个必填控件，可使用:required伪类来选择带有required属性的表单元素，并给它的边框设置一个不同的颜色。 123input:required&#123; outline: 2px solid #000;&#125; 类似的，可以像下面这样使用：optional伪类，为没有required属性的控件添加样式： 123input:optional&#123; border-color:#ccc;&#125; 此外，还有针对有效和无效控件的伪类。为满足某个输入框要求填写类型内容（如电子邮件地址）的需求，HTML5也为type属性新增了不少输入值，比如email： 1&lt;input type=&quot;email&quot; /&gt; 然后可以根据输入框中当前内容的有效性，应用不同的样式： 123456789/* 如果输入框中包含有效的电子邮件地址 */input[type=&quot;email&quot;]:valid&#123; border-color: green;&#125;/* 如果输入框中的内容不是有效的电子邮件地址 */input[type=&quot;email&quot;]:invalid&#123; border-color: red;&#125; 除此之外，还有针对type值为number的:inrange、:out-of-range伪类，针对readonly属性的:read-only伪类，以及针对没有readonly属性的:read-write伪类。 层叠稍微复杂点的样式表中都可能存在两条甚至多条规则同时选择一个元素的情况。CSS通过一种叫作层叠（cascade）的机制来处理这种冲突。从CSS这个名字就可知这种机制有多重要，因为其中的C就是cascade。层叠机制的原理是为规则赋予不同的重要程度。最重要的是作者样式表，即由网页开发者所写的样式。其次是用户样式表，用户可以通过浏览器的设置选项，为网页应用自己的样式。排在最后的是浏览器（或用户代码）的默认样式表，它们一般都会被作者样式表覆盖掉。为了给用户更高的优先权，CSS允许用户使用!import覆盖任何规则，包括网站作者使用!important标注的规则。!important标注要放在属性声明的后面： 1234p&#123; font-size: 1.5em !important; color: #666 !important;&#125; 允许用户使用!important标注来覆盖规则，主要是出于无障碍交互的需要。比如，允许诵读困难的用户使用高对比度的用户样式表。 归纳起来，层叠机制的重要性级别从高到低如下所示： 标注为!important的用户样式 标注为!important的作者样式 作者样式 用户样式 浏览器（或用户代码）的默认样式 在此基础上，规则再按选择符的特殊性排序。特殊性高的选择符会覆盖特殊性低的选择符。如果两条规则的特殊性相等，则后定义的优先。 特殊性为了量化规则的特殊性，每种选择符都对应着一个数值。这样，一条规则的特殊性就表示为其每个选择符的累加值。但这里的累加计算使用的并非正常的十进制加法，而是基于位置累加，以保证10个类选择符（或者40个，甚至更多的类选择符）累加的特殊性不会大于等于1个ID选择符的特殊性。这是为了避免ID这种高特殊性选择符被一堆低特殊性选择符（如类型选择符）的累加值所覆盖。如果某条规则中用到的选择符不足10个，为简单起见，也可以使用十进制来计算其特殊性。 任何选择符的特殊性都对应于如下4个级别，即a、b、c、d： 行内样式，a为1 b等于ID选择符的数目 c等于类（class）选择符、伪类选择符及属性选择符的数目 d等于类型（type）选择符和伪元素选择符的数目 根据以上规则，可以计算出CSS选择符的特殊性。下表是一些选择符以及它们所对应的特殊性规则： 选择符 特殊性 十进制特殊性 style&#x3D;”” 1,0,0,0 1000 #wrapper #content{} 0,2,0,0 200 #content .datePosted{} 0,1,1,0 110 div#content{} 0,1,0,1 101 #content{} 0,1,0,0 100 p.comment .datePosted{} 0,0,2,1 21 p.comment{} 0,0,1,1 11 div p{} 0,0,0,2 2 p{} 0,0,0,1 1 乍一看这种计算特殊性的方式有点不好理解，再多解释一下。本质上而言，如果样式被写在了元素的style属性里，那么这些样式的特殊性就最高。然后，通过ID属性应用的规则，其特殊性高于未通过ID属性应用的规则。同理，通过类选择符应用的规则，其特殊性高于只通过类型选择符应用的规则。最后，如果两条规则拥有相等的特殊性，则优先应用后定义的规则，也就是层叠机制。 利用层叠次序如果两条规则特殊性相等，则优先应用后定义的规则，这一点非常重要。这意味着我们在写样式的时候，必须考虑规则在样式中的位置，以及选择符的次序。 前面的对链接元素使用伪类的例子，就是一个利用层叠次序的典型。如果每个选择符的特殊性都一样，那么它们的次序就很重要了。要是把a:visited选择符放在a:hover选择符后面，那么在访问过链接之后，悬停样式将不会起作用，因为已经被a:visted样式给覆盖了。 控制特殊性理解特殊性是写好CSS的关键，而控制特殊性则是大型网站开发中最难处理的问题。利用特殊性，可以先为公用元素设置默认样式，然后在更特殊的元素上覆盖这些样式。在下面的例子中，为介绍性内容定义了几种不同的样式。首先将介绍性文本的颜色设为灰色，覆盖body元素上定义的默认黑色。而在主页上，介绍性文本的样式变成了浅灰色背景上的黑色字体，其中的链接是绿色： 123456789101112131415161718body&#123; color: black;&#125;.intro&#123; padding: 1em; font-size: 1.2em; color: gray;&#125;#home .intro&#123; color: black; background: lightgray;&#125;#home .intro a&#123; color: green;&#125; 以上几条规则包含了太多的特殊性。对于小网站这不是问题，但随着网站越来越大，样式也越来越复杂，这样定义规则会导致样式难以管理。这是因为，要想给主页中的介绍性文本添加样式，规则中必须至少包含一个ID选择符和一个类选择符。 比如，假设一个组件中包含着类为call-to-action的链接，为了让这个链接看上去更像按钮，可以通过如下规则为它应用背景颜色和内边距： 123456a.call-to-action&#123; text-decoration: none; background-color: green; color: white; padding: 0.25em;&#125; 把这个call-to-action链接放到主页的介绍性内容中，会出现什么效果？会不怎么好看，因为链接上的文本不见了：由于给定链接样式（#home.intro a）的特殊性高于这个组件样式（a.call-to-action）的特殊性，绿色背景上的文本也成了绿色的。 怎么办？必须想办法提高特殊性，比如给call-to-action组件加上更厉害的选择符： 1234567a.call-to-action,#home .intro a.call-to-action&#123; text-decoration: none; background-color: green; color: white; padding: 10px;&#125; 然而像这样因样式表增大而被迫提高特殊性，会导致选择符之间特殊性的竞争，最终导致代码不必要地复杂化。 更好的做法是从一开始就简化选择符、降低特殊性： 123456789101112131415161718192021222324body&#123; color: black;&#125;.intro&#123; font-size: 1.2em; color: gray;&#125;.intro-highlighted&#123; color: black; background: lightgray;&#125;.intro-highlighted a&#123; color: green;&#125;a.call-to-action&#123; text-decoration: none; background-color: green; color: white; padding: 10px;&#125; 以上重写的代码改进了两个方面。首先，去掉了ID选择符，把所有选择符的特殊性降到最低。其次，去掉了对介绍性文本上下文的引用。不再将介绍性文本限定为必须在主页中，而只在原始介绍性文本基础上再命名一个特殊的版本（即intro-highlighted）。于是在标记中可以这样使用类： 12&lt;p class=&quot;intro&quot;&gt;A general intro&lt;/p&gt;&lt;p class=&quot;intro intro-highlighted&quot;&gt;....&lt;a href=&quot;/promo-page&quot; class=&quot;call-to-action&quot;&gt;promo page&lt;/a&gt;.&lt;/p&gt; 这种简化的、目标更明确的手段让作者可以对样式进行更细粒度地控制。intro-highlighted链接的样式不会再覆盖到call-to-action链接的颜色。与此同时，无须修改CSS，即可将intro-highlighted重用到其他页面，这又是一个好处。 特殊性与调试特殊性对于调试而言非常重要，因为需要知道哪条规则优先，以及为什么优先。比如，假设有下列规则，两个标题会是什么颜色？ 123456789101112131415#content #main h2&#123; color: gray;&#125;div &gt; #main &gt; h2&#123; color: green;&#125;#content &gt; [id=&quot;main&quot;] .new-story:nth-of-type(1) h2.first&#123; color: hotpink;&#125;:root [id=&quot;content&quot;]:first-child &gt; #main h2:nth-last-child(3)&#123; color: gold;&#125; HTML如下： 12345678910&lt;div id=”content“&gt; &lt;main id=&quot;main&quot;&gt; &lt;h2&gt;Strange Times&lt;/h2&gt; &lt;p&gt;Here you can read bizarre news stories from around the globe.&lt;/p&gt; &lt;div class=&quot;news-story&quot;&gt; &lt;h2 class=&quot;first&quot;&gt;Bog Snorkeling Champion around the globe.&lt;/h2&gt; &lt;p&gt;The 2008 Bog ...&lt;/p&gt; &lt;/div&gt; &lt;/main&gt;&lt;/div&gt; 答案是两个标题都是灰色。这是因为，第一条规则有两个ID选择符，特殊性最高。后面几个选择符看起来挺复杂，但都只包含一个ID选择符，在特殊性的较量中都会败下阵来。值得注意的是，就算选择符中包含对ID属性的引用，它仍然是属性选择符，特殊性并不高。不过对于只能通过ID属性接入样式的情况，使用属性选择符倒是避免特殊性过高的较好选择。 测试特殊性问题比较难，但是现代浏览器都内置开发者工具，能非常清楚地显示应用给特殊元素的样式来自哪条规则。通过”检测元素“可以看到与元素匹配的所有CSS选择符以及规则，包括浏览器默认样式。 继承继承和层叠的概念虽然有点类似，但实际上它们有着本质的区别。有些属性，像颜色或字体大小，会被应用它们的元素的后代所继承。比如，把body元素的文本颜色设置为黑色，那么body所有后代元素的文本颜色都会继承这个黑色。字号也一样。 如果在body中设置了一个字号，就会发现页面中的标题并不会变成同样的字号。实际上，标题大小是浏览器默认样式表中设定的。任何直接应用给元素的样式都会覆盖继承的样式，因为继承的样式没有任何特殊性。继承的属性值没有任何特殊性，连0都说不上。这意味着使用特殊性为0的通用选择符设置的样式都可以覆盖继承的样式。为此可能会下面这种遇到”意料之外”的情况，表面上看em会继承h2的红色，但通用选择符给所有元素设置的黑色会覆盖它所继承的红色： 123456789*&#123; color: black;&#125;h2&#123; color:red;&#125;&lt;h2&gt;The emphasized text will be &lt;em&gt;black&lt;/em&gt;&lt;/h2&gt; 为文档应用样式写CSS就要知道怎么把它应用到HTML文档。为文档应用样式的方法不止一种，各有利弊。 link与style元素首先，可以把样式放在style元素中，直接放在文档的head部分： 123456&lt;style&gt; body&#123; font-family: Avenir Next,SegoeUI,sans-serief; color: grey; &#125;&lt;/style&gt; 如果样式不多，又希望立刻应用它们，并且不愿意因为浏览器额外下载文件而耽误时间，可以使用这种方法。不过，为了让样式表能在多个页面中重用，通常最好把它保存到一个外部文件中。如果样式在外部样式表中，那么有两种方式把它们挂接到网页上。最常用的方式是使用link元素： 1&lt;link href=&quot;/c/base.css&quot; rel=&quot;stylesheet&quot; /&gt; 除了link元素，还可以使用@import指令加载外部CSS文件： 123&lt;style&gt; @import url(&quot;/c/modules.css&quot;)&lt;/style&gt; 可以在HTML文档的head部分把@import指令放在style中，也可以在外部样式表中使用它。后一种用法意味着，如果网页加载外部样式表，那么浏览器后续可能还需要下载更多CSS文件。 向页面中添加样式表的时候，别忘了层叠机制的原理是次序决定优先级：如果为某个元素应用样式时，有两个或更多特殊性相等的规则互相竞争，则后声明的样式胜出。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"精通CSS读书笔记(1)——基础知识","slug":"精通CSS读书笔记(1)——基础知识","date":"2023-05-22T06:32:39.000Z","updated":"2023-11-27T15:34:23.884Z","comments":true,"path":"2023/05/22/精通CSS读书笔记(1)——基础知识/","link":"","permalink":"http://pvnk1u.github.io/2023/05/22/%E7%B2%BE%E9%80%9ACSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"组织代码HTML版本应该使用哪个版本对于CSS属性，可以访问“can i use”网站（caniuse）。这个网站可以搜索属性或属性组，结果配有统计信息，显示支持它们的浏览器百分比，包括桌面浏览器和移动浏览器。另一个非常有想法的项目是webplatform，是W3C和几家浏览器厂商及行业巨头搞出来的，目标是收集合并它们所有关于CSS、HTML、Javascript API等支持情况的文档。不过，就跟很多大型项目一样，最终要完成那么庞大的Web技术文档的聚合，需要花很长时间。此外，Mozzila的开发者文档，即MDN，也是一个非常好的参考。 渐进增强平衡向后兼容性与最新的HTML和CSS特性，涉及一种叫作渐进增强的策略。所谓渐进增强，大意就是“首先为最小公分母准备可用的内容，然后再为支持新特性的浏览器添加更多交互优化”。听起来有点复杂，而实际上HTML和CSS的实现已经部分内置了这一策略。 对HTML而言，这意味着浏览器在遇到未知元素或属性时并不会报错，而且也不会对页面产生什么影响。比如，可以在页面里使用HTML5定义的新input元素。假设表单中有一个电子邮件的标记如下： 1&lt;input type=&quot;text&quot; id=&quot;field-email&quot; name=&quot;field-email&quot;&gt; 要使用新的input元素，应该把type属性改成这样： 1&lt;input type=&quot;email&quot; id=&quot;field-email&quot; name=&quot;field-email&quot;&gt; 尚未实现这个新字段类型的浏览器碰到它只会想：这是啥意思呀？不明白。然后回退为默认的text类型，结果和上面的第一行代码一样。而实现了这个类型的新浏览器则知道email想让用户在这里填写什么样的数据。假如还在这里使用了内置的表单验证，那么支持它的新浏览器也会帮忙做验证。这样，既渐进增强了页面，也不会对旧版本浏览器产生不好的影响。 CSS中的渐进增强同样也反映在浏览器如何对待新属性上。任何浏览器无法识别的属性或值都会导致浏览器丢弃相应的声明。因此，只要同时提供合理的后备声明，使用新属性就不会带来不良后果。 举个例子，很多现代浏览器支持以rgba函数方式表示的颜色值。这种方式可以分别传入红、绿、蓝通道，以及阿尔法（alpha，即透明度）通道的值。可以这样使用它： 1234.overlay&#123; background-color: #000; background-color: rgba(0,0,0,0.8);&#125; 这条规则定义了类名为overlay的元素背景为黑色，但随后又用rgba声明背景色应稍微透明。如果浏览器不支持rgba，那么相应元素的背景色就是不透明的黑色。如果浏览器支持rgba，那么第二条声明就会覆盖第一条。也就是说，即使并非所有浏览器都支持rgba，我们也可以使用它，只是要先为它声明合适的后备代码。 厂商前缀 浏览器厂商也基于相同的原理为自家浏览器引入实验性特性。实验性特性的标准名称前面会加上一个特殊字符串，这样它们自己的浏览器就能识别该特性，而其他浏览器则会忽略掉该特性。比如： 123456.myThing&#123; -webkit-transform: translate(0,10px); -moz-transform: translate(0,10px); -ms-transform: translate(0,10px); transform: translate(0,10px);&#125; 这里使用了几个不同的前缀，给相应的元素应用了变换。以-webkit-开头的适用于基于Webkit的浏览器，如Safari。Chrome和Opera都基于Blick引擎，而Blink最初也是基于Webkit开发的，所以-webkit-前缀通常也适用于这3个浏览器。-moz-前缀适用于基于Mozilla的浏览器，如Firefox。-ms-前缀则适用于微软的IE。 最后又加了一条不带前缀的声明，这样那些支持标准属性名称的浏览器就不会漏网了。 条件规则与检测脚本 如果希望根据浏览器是否支持某个CSS特性来提供完全不同的样式，那么可以选择@support块。这个特殊的代码块称为条件规则，它会检测括号中的声明，并且仅在浏览器支持该声明的情况下，才会应用块中的规则： 123@support(display:grid)&#123; /* 在支持网格布局的浏览器中要应用的规则 */&#125; 创建结构化、语义化富HTML语义化标记是优秀HTML文档的基础。语义就是以系统方式表示的含义。对于根据一个形式符号的集合人工创造出的语言（比如HTML语言，及其元素和属性）来说，语义指的就是通过使用某个符号想要表示的含义。简而言之，语义化标记意味着在正确的地方使用正确的元素，从而得到有意义的文档。 结构良好的标记也能让页面在搜索引擎中排名更靠前。对于CSS来说更重要的是，有意义的标记本身为添加样式提供了方便。实际上，编写CSS的最新实践都建议先给网站一组“基础”样式。 ID和class属性有意义的元素提供了不错的基础，却没有提供应用视觉效果所必需的全部“接入点”。除了元素本身，还需要一种方式把样式“接入到”文档上，这就是ID和class属性。 给属性起名字非常重要，起什么名字意味着它是什么，或者应该怎么使用它，例如： 12345&lt;ul class=product-list&gt; &lt;li&gt;&lt;a href=&quot;/product/1&quot;&gt;Product1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/product/2&quot;&gt;Product2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/product/3&quot;&gt;Product3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 先利用css属性在文档中创造一个product-list模块。在css里，用类名来定义一类事物。这里的product-list就意味着它可以是任何商品列表。换句话说，为product-list写好样式后，不仅可以用在这里，还可以用在网站的任何地方。 给元素添加类名时，即使类名明确用于样式，也不要体现出其视觉效果。正确的做法是让类名表示组件的类型。比如这里的类名是product-list，而非泛泛的large-centered-list。 id和class最主要的区别是ID只能应用到页面中的一个元素。也就是说，不能像product-list那样使用ID把页面中的模块定义为可重用的“模板”。ID应该用来标识特定模块的特定实例，比如： 12345&lt;ul id=&quot;primary-product-list&quot; class=product-list&gt; &lt;li&gt;&lt;a href=&quot;/product/1&quot;&gt;Product1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/product/2&quot;&gt;Product2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/product/3&quot;&gt;Product3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 这是product-list的一个实例，它因为有同样的class属性而获得了相应的样式。但在这里，这个实例也被ID定义为primary-product-list。每个页面通常只能有一个主要商品的列表，因此这个ID值还是比较恰当的。利用这个ID，可以为这个模块实例添加额外的样式，可以增加一些JavaScript交互，还可以作为页内导航的目标。 实际开发中，一般不建议把ID属性作为CSS的“接入点”。利用类来添加样式往往能够让代码更简单也更容易维护。ID可以用于在文档中标识元素，但通常不用于添加样式。 结构化元素HTML5新增了一批结构化元素： section header footer nav article aside main 增加这些新元素是为了在HTML文档中创建逻辑性区块。它们可以用于包含独立内容（article）、导航组件（nav）、特定区块的头部（header），等等。其中，main元素是最新增加的，用于高亮页面中包含主要内容的区域。 除了main之外，所有其他新元素都可以在一个文档中多次出现，以便让机器人和人更好地理解文档。在HTML5引入这些新元素之前，经常能看到带有类似类名的div元素，如下： 123456&lt;div class=&quot;article&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;How I became a CSS Master&lt;/h1&gt; &lt;/div&gt; &lt;p&gt;Ten-thousand hours.&lt;/p&gt;&lt;/div&gt; 其中的div元素对文档而言并没有语义价值，只是借助类名作为添加样式的“接入点”而已。现在有了HTML5的新元素，这段标记可以改写成这样： 123456&lt;article&gt; &lt;header&gt; &lt;h1&gt;How I became a CSS Master&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;Ten-thousand hours.&lt;/p&gt;&lt;/article&gt; 经过修改，这段HTML的语义得到了增强，但同时也产生了意外的副作用。此时，只能通过article和header元素来添加样式了。添加样式的CSS可能会是这样： 1234567article&#123; /* 样式 */&#125;article header&#123; /* 其他样式 */&#125; 但article和header都可能在同一个页面中多次出现。如果确实存在这种重用的情况，那么这段CSS代码就会应用于所有其他相同的元素上，此时，更好的做法是把这两个例子结合起来： 123456&lt;article class=&quot;post&quot;&gt; &lt;header class=&quot;post-header&quot;&gt; &lt;h1&gt;How I became a CSS Master&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;Ten-thousand hours.&lt;/p&gt;&lt;/article&gt; 相应的CSS规则就可以使用类名为这段标记应用样式了： 1234567.post&#123; /* 样式 */&#125;.post-header&#123; /* 其他样式 */&#125; div和span即使有了新语义元素，div元素依然不多余。在没有合适的语义元素的情况下，div仍然是给内容分组的一个不错的选择。 与div元素类似的还有span。同样，在无须表示语义、仅需添加样式的情况中，可以使用span。与div不同，span是文本级元素，可以用于在文本流中建立结构。不过在使用无语义的span之前，也一样要确保真的不需要使用任何语义元素。比如，使用time标记时间和日期，使用q标记引用，使用em标记需要强调的内容，使用strong标记需要重点强调的内容。 重新定义的表现性文本元素时至今日，&lt;b&gt;和&lt;i&gt;可以算是幸存的表现型标记了，它们以前分别用于将文本标记为粗体（bold）和斜体（italic）。HTML5最终决定保留它们，但改变了它们的含义。多数情况下，应该选择使用&lt;em&gt;或&lt;strong&gt;，因为它们是用来强调及重点强调内容的语义正确的选择。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"}]},{"title":"JS高级程序设计读书笔记(14)——网络","slug":"JS高级程序设计读书笔记(14)——网络","date":"2023-05-15T04:26:39.000Z","updated":"2023-11-27T15:34:23.880Z","comments":true,"path":"2023/05/15/JS高级程序设计读书笔记(14)——网络/","link":"","permalink":"http://pvnk1u.github.io/2023/05/15/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(14)%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C/","excerpt":"","text":"2005 年，Jesse James Garrett 撰写了一篇文章，“Ajax—A New Approach to Web Applications”。这篇 文章中描绘了一个被他称作 Ajax（Asynchronous JavaScript+XML，即异步 JavaScript 加 XML）的技术。 这个技术涉及发送服务器请求额外数据而不刷新页面，从而实现更好的用户体验。Garrett 解释了这个技 术怎样改变自 Web 诞生以来就一直延续的传统单击等待的模式。 把 Ajax 推到历史舞台上的关键技术是 XMLHttpRequest（XHR）对象。这个对象最早由微软发明， 然后被其他浏览器所借鉴。在 XHR 出现之前，Ajax 风格的通信必须通过一些黑科技实现，主要是使用隐藏的窗格或内嵌窗格。XHR 为发送服务器请求和获取响应提供了合理的接口。这个接口可以实现异步从服务器获取额外数据，意味着用户点击不用页面刷新也可以获取数据。通过 XHR 对象获取数据后， 可以使用 DOM 方法把数据插入网页。虽然 Ajax 这个名称中包含 XML，但实际上 Ajax 通信与数据格式无关。这个技术主要是可以实现在不刷新页面的情况下从服务器获取数据，格式并不一定是 XML。 XHR 对象的 API 被普遍认为比较难用，而 Fetch API 自从诞生以后就迅速成为了 XHR 更现代的替代标准。Fetch API 支持期约（promise）和服务线程（service worker），已经成为极其强大的 Web 开发工具。 本章会全面介绍 XMLHttpRequest，但它实际上是过时 Web 规范的产物，应该只在旧版本浏览器中使用。实际开发中，应该尽可能使用 fetch()。 XMLHttpRequest对象所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象： 1let xhr = new XMLHttpRequest(); 使用XHR使用 XHR 对象首先要调用 open()方法，这个方法接收 3 个参数：请求类型（”get”、”post”等）、 请求 URL，以及表示请求是否异步的布尔值。下面是一个例子： 12let xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;example.php&quot;, false); 这行代码就可以向 example.php 发送一个同步的 GET 请求。关于这行代码需要说明几点。首先，这 里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，调用 open()不会实际发送请 求，只是为发送请求做好准备。 要发送定义好的请求，必须像下面这样调用 send()方法： 12xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);xhr.send(null); send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 null， 因为这个参数在某些浏览器中是必需的。调用 send()之后，请求就会发送到服务器。 因为这个请求是同步的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，XHR 对象的以下属性会被填充上数据。 responseText 作为响应体返回的文本 responseXML 如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，那就是包含响应 数据的 XML DOM 文档。 status 响应的HTTP状态 statusText 响应的HTTP状态描述 收到响应后，第一步要检查 status 属性以确保响应成功返回。一般来说，HTTP 状态码为 2xx 表 示成功。此时，responseText 或 responseXML（如果内容类型正确）属性中会有内容。如果 HTTP 状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态，如下所示： 1234567xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText);&#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status);&#125; 以上代码可能显示服务器返回的内容，也可能显示错误消息，取决于 HTTP 响应的状态码。为确定下一步该执行什么操作，最好检查 status 而不是 statusText 属性，因为后者已经被证明在跨浏览器 的情况下不可靠。无论是什么响应内容类型，responseText 属性始终会保存响应体，而 responseXML则对于非 XML 数据是 null。 虽然可以像前面的例子一样发送同步请求，但多数情况下最好使用异步请求，这样可以不阻塞JavaScript 代码继续执行。XHR 对象有一个 readyState 属性，表示当前处在请求&#x2F;响应过程的哪个阶段。 这个属性有如下可能的值。 0：未初始化(Uninitialized) 尚未调用open()方法 1：已打开（Open） 已调用open()方法，尚未调用send()方法 2：已发送（Sent） 已调用send()方法，尚未收到响应 3：接收中(Receiving) 已经收到部分响应 4：完成（Complete） 已经收到所有响应，可以使用了 每次 readyState 从一个值变成另一个值，都会触发 readystatechange 事件。可以借此机会检 查 readyState 的值。一般来说，唯一关心的 readyState 值是 4，表示数据已就绪。为保证跨浏览器兼容，onreadystatechange 事件处理程序应该在调用 open()之前赋值。来看下面的例子： 123456789101112let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);xhr.send(null); 以上代码使用 DOM Level 0 风格为 XHR 对象添加了事件处理程序，因为并不是所有浏览器都支持 DOM Level 2 风格。与其他事件处理程序不同，onreadystatechange 事件处理程序不会收到 event 对象。在事件处理程序中，必须使用 XHR 对象本身来确定接下来该做什么。 在收到响应之前如果想取消异步请求，可以调用 abort()方法： 1xhr.abort(); 调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象。 HTTP头部每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一 些方法暴露与请求和响应相关的头部字段。 默认情况下，XHR 请求会发送以下头部字段。 Accept 浏览器可以处理的内容类型 Accept-Charset 浏览器可以显示的字符集类型 Accept-Encoding 浏览器可以处理的压缩编码类型 Accept-Language 浏览器使用的语言 Connection 浏览器与服务器的连接类型 Cookie 页面中设置的Cookie Host 发送请求的页面所在的域 Referer 发送请求的页面的URI。这个字段在HTTP规范中就拼错了，所以考虑到兼容性也必须将错就错（正确的拼写应该是Referrer） User-Agent 浏览器的用户代理字符串。 虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。**如果需要发送额外的请求头部，可以使用setRequestHeader()方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在open()之后，send()之前调用setRequestHeader()**，如下面的例子所示： 12345678910111213let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;example.php&quot;, true);xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);xhr.send(null); 服务器通过读取自定义头部可以确定适当的操作。自定义头部一定要区别于浏览器正常发送的头部， 否则可能影响服务器正常响应。有些浏览器允许重写默认头部，有些浏览器则不允许。 可以使用 getResponseHeader()方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即 可。如果想取得所有响应头部，可以使用 getAllResponseHeaders()方法，这个方法会返回包含所有响应头部的字符串。下面是调用这两个方法的例子： 12let myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);let allHeaders xhr.getAllResponseHeaders(); 服务器可以使用头部向浏览器传递额外的结构化数据。getAllResponseHeaders()方法通常返回 类似如下的字符串： 123456Date: Sun, 14 Nov 2004 18:04:03 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powered-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1 GET请求最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL 后面添加查询字符串参数。对 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给 open()方法。 发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用 encodeURIComponent()编码，所有名&#x2F;值对必须以和号（&amp;）分隔，如下面的例子所示： 1xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true); 可以使用以下函数将查询字符串参数添加到现有的 URL 末尾： 12345function addURLParam(url, name, value) &#123; url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); return url;&#125; 可以使用这个函数构建请求 URL，如下面的例子所示： 123456let url = &quot;example.php&quot;;// 添加参数url = addURLParam(url, &quot;name&quot;, &quot;Nicholas&quot;);url = addURLParam(url, &quot;book&quot;, &quot;Professional JavaScript&quot;);// 初始化请求xhr.open(&quot;get&quot;, url, false); POST请求第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在 请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据 可以是任意格式。要初始化 POST 请求，open()方法的第一个参数要传”post”，比如： 1xhr.open(&quot;post&quot;, &quot;example.php&quot;, true); 接下来就是要给 send()方法传入要发送的数据。因为 XHR 最初主要设计用于发送 XML，所以可以传入序列化之后的 XML DOM 文档作为请求体。当然，也可以传入任意字符串。 默认情况下，对服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST 数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此，第一步需要把 ContentType 头部设置为”application&#x2F;x-www-formurlencoded”，这是提交表单时使用的内容类型。第二 步是创建对应格式的字符串。POST 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表 单需要序列化并通过 XHR 发送到服务器，则可以使用 serialize()函数来创建相应的字符串，如下所示： 12345678910111213141516function submitData() &#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125; &#125;; xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); let form = document.getElementById(&quot;user-info&quot;); xhr.send(serialize(form));&#125; 在这个函数中，来自 ID 为”user-info”的表单中的数据被序列化之后发送给了服务器。PHP 文件 postexample.php 随后可以通过$_POST 取得 POST 的数据。比如： 1234567&lt;?php header(&quot;Content-Type: text/plain&quot;); echo &lt;&lt;&lt;EOF Name: &#123;$_POST[&#x27;user-name&#x27;]&#125; Email: &#123;$_POST[&#x27;user-email&#x27;]&#125; EOF;?&gt; 假如没有发送 Content-Type 头部，PHP 的全局$_POST 变量中就不会包含数据，而需要通过 $HTTP_RAW_POST_DATA 来获取。 POST 请求相比 GET 请求要占用更多资源。从性能方面说，发送相同数量的数据， GET 请求比 POST 请求要快两倍。 XMLHttpRequest Level 2XHR 对象作为事实标准的迅速流行，也促使 W3C 为规范这一行为而制定了正式标准。 XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2 又进一步发展了 XHR 对象。并非所有浏览器都实现了 XMLHttpRequest Level 2 的所有部分，但所有浏览器都实现了其中部分功能。 FormData类型 现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了 FormData 类型。FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR 发送。下面的代码创建了一个 FormData 对象，并填充了一些数据： 12let data = new FormData();data.append(&quot;name&quot;, &quot;Nicholas&quot;); append()方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意 多个键&#x2F;值对数据。此外，通过直接给 FormData 构造函数传入一个表单元素，也可以将表单中的数据作为键&#x2F;值对填充进去： 1let data = new FormData(document.forms[0]); 有了 FormData 实例，可以像下面这样直接传给 XHR 对象的 send()方法： 12345678910111213let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);let form = document.getElementById(&quot;user-info&quot;);xhr.send(new FormData(form)); 使用 FormData 的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能 够识别作为 FormData 实例传入的数据类型并自动配置相应的头部。 超时 IE8 给 XHR 对象增加了一个 timeout 属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的 XHR 实现中增加了这个属性。在给 timeout 属性设置了一个 时间且在该时间过后没有收到响应时，XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理 程序。这个特性后来也被添加到了 XMLHttpRequest Level 2 规范。下面看一个例子： 1234567891011121314151617181920let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125; catch (ex) &#123; // 假设由 ontimeout 处理 &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);xhr.timeout = 1000; // 设置 1 秒超时xhr.ontimeout = function() &#123; alert(&quot;Request did not return in a second.&quot;);&#125;;xhr.send(null); 这个例子演示了使用 timeout 设置超时。给 timeout 设置 1000 毫秒意味着，如果请求没有在 1 秒钟内返回则会中断。此时则会触发 ontimeout 事件处理程序，readyState 仍然会变成 4，因此也 会调用 onreadystatechange 事件处理程序。不过，如果在超时之后访问 status 属性则会发生错误。 为做好防护，可以把检查 status 属性的代码封装在 try&#x2F;catch 语句中。 overrideMimeType()方法 Firefox 首先引入了 overrideMimeType()方法用于重写 XHR 响应的 MIME 类型。这个特性后来 也被添加到了 XMLHttpRequest Level 2。因为响应返回的 MIME 类型决定了 XHR 对象如何处理响应， 所以如果有办法覆盖服务器返回的类型，那么是有帮助的。 假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text&#x2F;plain。结果就会导致虽 然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType()可以保证将响应 当成 XML 而不是纯文本来处理： 1234let xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;text.php&quot;, true);xhr.overrideMimeType(&quot;text/xml&quot;);xhr.send(null); 这个例子强制让 XHR 把响应当成 XML 而不是纯文本来处理。为了正确覆盖响应的 MIME 类型， 必须在调用 send()之前调用 overrideMimeType()。 进度事件Progress Events 是 W3C 的工作草案，定义了客户端-服务器端通信。这些事件最初只针对 XHR，现 在也推广到了其他类似的 API。有以下 6 个进度相关的事件。 loadstart 在接收到响应的第一个字节时触发。 progress 在接收响应期间反复触发。 error 在请求出错时触发。 abort 在调用 abort()终止连接时触发。 load 在成功接收完响应时触发。 loadend 在通信完成时，且在 error、abort 或 load 之后触发。 每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后以 loadend 事件结束。 这些事件大部分都很好理解，但其中有两个需要说明一下。 load事件Firefox 最初在实现 XHR 的时候，曾致力于简化交互模式。最终，增加了一个 load 事件用于替代 readystatechange 事件。load 事件在响应接收完成后立即触发，这样就不用检查 readyState 属性了。onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。不过，并不是所有浏览器都实现了这个事件的 event 对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量： 12345678910let xhr = new XMLHttpRequest();xhr.onload = function() &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125;&#125;;xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);xhr.send(null); 只要是从服务器收到响应，无论状态码是什么，都会触发 load 事件。这意味着还需要检查 status 属性才能确定数据是否有效。Firefox、Opera、Chrome 和 Safari 都支持 load 事件。 progress事件Mozilla 在 XHR 对象上另一个创新是 progress 事件，在浏览器接收数据期间，这个事件会反复触发。每次触发时，onprogress 事件处理程序都会收到 event 对象，其 target 属性是 XHR 对象，且 包含 3 个额外属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是 一个布尔值，表示进度信息是否可用；position 是接收到的字节数；totalSize 是响应的 ContentLength 头部定义的总字节数。有了这些信息，就可以给用户提供进度条了。以下代码演示了如何向用户展示进度： 1234567891011121314151617181920let xhr = new XMLHttpRequest();xhr.onload = function(event) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125;&#125;;xhr.onprogress = function(event) &#123; let divStatus = document.getElementById(&quot;status&quot;); if (event.lengthComputable) &#123; divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);xhr.send(null); 为了保证正确执行，必须在调用 open()之前添加 onprogress 事件处理程序。在前面的例子中， 每次触发 progress 事件都会更新 HTML 元素中的信息。假设响应有 Content-Length 头部，就可以利用这些信息计算出已经收到响应的百分比。 跨域资源共享通过 XHR 进行 Ajax 通信的一个主要限制是跨源安全策略。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过，浏览器也需要支持合法跨源访问的能力。 跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。 CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。 对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text/plain 类型， 这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、 域名和端口），以便服务器确定是否为其提供响应。下面是 Origin 头部的一个示例： 1Origin: http://www.nczonline.net 如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源； 或者如果资源是公开的，那么就包含”*”。比如： 1Access-Control-Allow-Origin: http://www.nczonline.net 如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。 现代浏览器通过 XMLHttpRequest 对象原生支持 CORS。在尝试访问不同源的资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR对象并给 open()方法传入一个绝对 URL， 比如： 123456789101112let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;, true);xhr.send(null); 跨域 XHR 对象允许访问 status 和 statusText 属性，也允许同步请求。出于安全考虑，跨域 XHR 对象也施加了一些额外限制。 不能使用setRequestHeader()设置自定义头部 不能发送和接收cookie getAllResponseHeaders()方法始终返回空字符串 因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以更明确地区分使用场景，同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题。 预检请求CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET 和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。 Origin 与简单请求相同 Access-Control-Request-Method 请求希望使用的方法 Access-Control-Request-Headers （可选）要使用的逗号分隔的自定义头部列表。 下面是一个假设的 POST 请求，包含自定义的 NCZ 头部： 123Origin: http://www.nczonline.netAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。 Access-Control-Allow-Origin 与简单请求相同。 Access-Control-Allow-Methods 允许的方法（逗号分隔的列表）。 Access-Control-Allow-Headers 服务器允许的头部（逗号分隔的列表） Access-Control-Max-Age 缓存预检请求的秒数。 例如： 1234Access-Control-Allow-Origin: http://www.nczonline.netAccess-Control-Allow-Methods: POST, GETAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的 请求时才会多发送一次额外的 HTTP 请求。 替代性跨源技术CORS 出现之前，实现跨源 Ajax 通信是有点麻烦的。开发者需要依赖能够执行跨源请求的 DOM 特 性，在不使用 XHR 对象情况下发送某种类型的请求。虽然 CORS 目前已经得到广泛支持，但这些技术 仍然没有过时，因为它们不需要修改服务器。 图片检测图片探测是利用&lt;img&gt;标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的 onload 和 onerror 事件处理程序得知何时收到响应。 这种动态创建图片的技术经常用于图片探测（image pings）。图片探测是与服务器之间简单、跨域、 单向的通信。数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为 204 的状态码。 浏览器通过图片探测拿不到任何数据，但可以通过监听 onload 和 onerror 事件知道什么时候能接收 到响应。下面看一个例子： 12345let img = new Image();img.onload = img.onerror = function() &#123; alert(&quot;Done!&quot;);&#125;;img.src = &quot;http://www.example.com/test?name=Nicholas&quot;; 这个例子创建了一个新的 Image 实例，然后为它的 onload 和 onerror 事件处理程序添加了同一 个函数。这样可以确保请求完成时无论什么响应都会收到通知。设置完 src 属性之后请求就开始了，这个例子向服务器发送了一个 name 值。 图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，图片探测的缺点是只能发送 GET 请求和无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。 Fetch APIFetch API 能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在 Web 工作线程等现代 Web 工具中使用。XMLHttpRequest 可以选择异步，而 Fetch API 则必须是异步。Fetch API 是 WHATWG 的一个“活标准”（living standard），用规范原文说，就是“Fetch 标准定义请求、 响应，以及绑定二者的流程：获取（fetch）”。 Fetch API 本身是使用 JavaScript 请求资源的优秀工具，同时这个 API 也能够应用在服务线程 （service worker）中，提供拦截、重定向和修改通过 fetch()生成的请求接口。 基本用法fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法， 浏览器就会向给定 URL 发送请求。 分派请求 fetch()只有一个必需的参数 input。多数情况下，这个参数是要获取资源的 URL。这个方法返回 一个期约： 12let r = fetch(&#x27;/bar&#x27;);console.log(r); // Promise &lt;pending&gt; URL 的格式（相对路径、绝对路径等）的解释与 XHR 对象一样。 请求完成、资源可用时，期约会解决为一个 Response 对象。这个对象是 API 的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式， 如下所示： 12345fetch(&#x27;bar.txt&#x27;) .then((response) =&gt; &#123; console.log(response); &#125;);// Response &#123; type: &quot;basic&quot;, url: ... &#125; 读取响应 读取响应内容的最简单方式是取得纯文本格式的内容，这要用到 text()方法。这个方法返回一个期约，会解决为取得资源的完整内容： 1234567fetch(&#x27;bar.txt&#x27;) .then((response) =&gt; &#123; response.text().then((data) =&gt; &#123; console.log(data); &#125;); &#125;);// bar.txt 的内容 内容的结构通常是打平的： 1234fetch(&#x27;bar.txt&#x27;) .then((response) =&gt; response.text()) .then((data) =&gt; console.log(data));// bar.txt 的内容 处理状态码和请求失败 Fetch API 支持通过 Response 的 status（状态码）和 statusText（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为 200 的状态码，如下所示： 12345fetch(&#x27;/bar&#x27;) .then((response) =&gt; &#123; console.log(response.status); // 200 console.log(response.statusText); // OK &#125;); 请求不存在的资源通常会产生值为 404 的状态码： 12345fetch(&#x27;/does-not-exist&#x27;) .then((response) =&gt; &#123; console.log(response.status); // 404 console.log(response.statusText); // Not Found &#125;); 请求的 URL 如果抛出服务器错误会产生值为 500 的状态码： 12345fetch(&#x27;/throw-server-error&#x27;) .then((response) =&gt; &#123; console.log(response.status); // 500 console.log(response.statusText); // Internal Server Error &#125;); 可以显式地设置 fetch()在遇到重定向时的行为（本章后面会介绍），不过默认行为是跟随重定向 并返回状态码不是 300~399 的响应。跟随重定向时，响应对象的 redirected 属性会被设置为 true， 而状态码仍然是 200： 123456789fetch(&#x27;/permanent-redirect&#x27;) .then((response) =&gt; &#123; // 默认行为是跟随重定向直到最终 URL // 这个例子会出现至少两轮网络请求 // &lt;origin url&gt;/permanent-redirect -&gt; &lt;redirect url&gt; console.log(response.status); // 200 console.log(response.statusText); // OK console.log(response.redirected); // true &#125;); 在前面这几个例子中，虽然请求可能失败（如状态码为 500），但都只执行了期约的解决处理函数。 事实上，只要服务器返回了响应，fetch()期约都会解决。这个行为是合理的：系统级网络协议已经成 功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。 通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在 状态码非 200~299 时检查 Response 对象的 ok 属性： 1234567891011fetch(&#x27;/bar&#x27;) .then((response) =&gt; &#123; console.log(response.status); // 200 console.log(response.ok); // true &#125;); fetch(&#x27;/does-not-exist&#x27;) .then((response) =&gt; &#123; console.log(response.status); // 404 console.log(response.ok); // false &#125;); 因为服务器没有响应而导致浏览器超时，这样真正的 fetch()失败会导致期约被拒绝： 12345678fetch(&#x27;/hangs-forever&#x27;) .then((response) =&gt; &#123; console.log(response); &#125;, (err) =&gt; &#123; console.log(err); &#125;);//（浏览器超时后）// TypeError: &quot;NetworkError when attempting to fetch resource.&quot; 违反 CORS、无网络连接、HTTPS 错配及其他浏览器&#x2F;网络策略问题都会导致期约被拒绝。 可以通过 url 属性检查通过 fetch()发送请求时使用的完整 URL： 1234567891011121314// foo.com/bar/baz 发送的请求console.log(window.location.href); // https://foo.com/bar/bazfetch(&#x27;qux&#x27;).then((response) =&gt; console.log(response.url));// https://foo.com/bar/quxfetch(&#x27;/qux&#x27;).then((response) =&gt; console.log(response.url));// https://foo.com/quxfetch(&#x27;//qux.com&#x27;).then((response) =&gt; console.log(response.url));// https://qux.comfetch(&#x27;https://qux.com&#x27;).then((response) =&gt; console.log(response.url));// https://qux.com 自定义选项 只使用 URL 时，fetch()会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请 求，需要传入可选的第二个参数 init 对象。 常见fetch请求模式与 XMLHttpRequest 一样，fetch()既可以发送数据也可以接收数据。使用 init 对象参数，可以配置 fetch()在请求体中发送各种序列化的数据。 发送JSON数据 可以像下面这样发送简单 JSON 字符串： 12345678910111213let payload = JSON.stringify(&#123; foo: &#x27;bar&#x27;&#125;);let jsonHeaders = new Headers(&#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;);fetch(&#x27;/send-me-json&#x27;, &#123; method: &#x27;POST&#x27;, // 发送请求体时必须使用一种 HTTP 方法 body: payload, headers: jsonHeaders&#125;); 在请求体中发送参数 因为请求体支持任意字符串值，所以可以通过它发送请求参数： 12345678910let payload = &#x27;foo=bar&amp;baz=qux&#x27;;let paramHeaders = new Headers(&#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;&#125;);fetch(&#x27;/send-me-params&#x27;, &#123; method: &#x27;POST&#x27;, // 发送请求体时必须使用一种 HTTP 方法 body: payload, headers: paramHeaders&#125;); 发送文件 因为请求体支持 FormData 实现，所以 fetch()也可以序列化并发送文件字段中的文件： 123456789let imageFormData = new FormData();let imageInput = document.querySelector(&quot;input[type=&#x27;file&#x27;]&quot;);imageFormData.append(&#x27;image&#x27;, imageInput.files[0]);fetch(&#x27;/img-upload&#x27;, &#123; method: &#x27;POST&#x27;, body: imageFormData&#125;); 这个 fetch()实现可以支持多个文件： 123456789let imageFormData = new FormData();let imageInput = document.querySelector(&quot;input[type=&#x27;file&#x27;][multiple]&quot;);for (let i = 0; i &lt; imageInput.files.length; ++i) &#123; imageFormData.append(&#x27;image&#x27;, imageInput.files[i]);&#125;fetch(&#x27;/img-upload&#x27;, &#123; method: &#x27;POST&#x27;, body: imageFormData&#125;); 加载Blob文件 Fetch API也能提供 Blob 类型的响应，而 Blob 又可以兼容多种浏览器 API。一种常见的做法是明确将 图片文件加载到内存，然后将其添加到 HTML图片元素。为此，可以使用响应对象上暴露的 blob()方法。 这个方法返回一个期约，解决为一个 Blob 的实例。然后，可以将这个实例传给 URL.createObjectUrl() 以生成可以添加给图片元素 src 属性的值： 1234567const imageElement = document.querySelector(&#x27;img&#x27;);fetch(&#x27;my-image.png&#x27;) .then((response) =&gt; response.blob()) .then((blob) =&gt; &#123; imageElement.src = URL.createObjectURL(blob); &#125;); 发送跨源请求 从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。 123fetch(&#x27;//cross-origin.com&#x27;);// TypeError: Failed to fetch// No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. 如果代码不需要访问响应，也可以发送 no-cors 请求。此时响应的 type 属性值为 opaque，因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。 123fetch(&#x27;//cross-origin.com&#x27;, &#123; method: &#x27;no-cors&#x27; &#125;) .then((response) =&gt; console.log(response.type));// opaque 中断请求 Fetch API 支持通过 AbortController&#x2F;AbortSignal 对中断请求。调用 AbortController. abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的 fetch()请求会 导致包含错误的拒绝。 123456789let abortController = new AbortController();fetch(&#x27;wikipedia.zip&#x27;, &#123; signal: abortController.signal &#125;) .catch(() =&gt; console.log(&#x27;aborted!&#x27;); // 10 毫秒后中断请求setTimeout(() =&gt; abortController.abort(), 10);// 已经中断 Headers对象Headers 对象是所有外发请求和入站响应头部的容器。每个外发的 Request 实例都包含一个空的 Headers 实例，可以通过 Request.prototype.headers 访问，每个入站 Response 实例也可以通过 Response.prototype.headers 访问包含着响应头部的 Headers 对象。这两个属性都是可修改属性。 另外，使用 new Headers()也可以创建一个新实例。 Headers 与 Map 的相似之处 Headers 对象与 Map 对象极为相似。这是合理的，因为 HTTP 头部本质上是序列化后的键&#x2F;值对， 它们的 JavaScript 表示则是中间接口。Headers 与 Map 类型都有 get()、set()、has()和 delete() 等实例方法，如下面的代码所示： 1234567891011121314151617181920212223242526let h = new Headers();let m = new Map();// 设置键h.set(&#x27;foo&#x27;, &#x27;bar&#x27;);m.set(&#x27;foo&#x27;, &#x27;bar&#x27;);// 检查键console.log(h.has(&#x27;foo&#x27;)); // trueconsole.log(m.has(&#x27;foo&#x27;)); // trueconsole.log(h.has(&#x27;qux&#x27;)); // falseconsole.log(m.has(&#x27;qux&#x27;)); // false// 获取值console.log(h.get(&#x27;foo&#x27;)); // barconsole.log(m.get(&#x27;foo&#x27;)); // bar// 更新值h.set(&#x27;foo&#x27;, &#x27;baz&#x27;);m.set(&#x27;foo&#x27;, &#x27;baz&#x27;);// 取得更新的值console.log(h.get(&#x27;foo&#x27;)); // bazconsole.log(m.get(&#x27;foo&#x27;)); // baz// 删除值h.delete(&#x27;foo&#x27;);m.delete(&#x27;foo&#x27;);// 确定值已经删除console.log(h.get(&#x27;foo&#x27;)); // undefinedconsole.log(m.get(&#x27;foo&#x27;)); // undefined Headers 和 Map 都可以使用一个可迭代对象来初始化，比如： 12345let seed = [[&#x27;foo&#x27;, &#x27;bar&#x27;]];let h = new Headers(seed);let m = new Map(seed);console.log(h.get(&#x27;foo&#x27;)); // barconsole.log(m.get(&#x27;foo&#x27;)); // bar 而且，它们也都有相同的 keys()、values()和 entries()迭代器接口： 123456789let seed = [[&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;]];let h = new Headers(seed);let m = new Map(seed);console.log(...h.keys()); // foo, bazconsole.log(...m.keys()); // foo, bazconsole.log(...h.values()); // bar, quxconsole.log(...m.values()); // bar, quxconsole.log(...h.entries()); // [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;]console.log(...m.entries()); // [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;] Headers独有的特性 Headers 并不是与 Map 处处都一样。在初始化 Headers 对象时，也可以使用键&#x2F;值对形式的对象， 而 Map 则不可以： 1234567let seed = &#123;foo: &#x27;bar&#x27;&#125;;let h = new Headers(seed);console.log(h.get(&#x27;foo&#x27;)); // barlet m = new Map(seed);// TypeError: object is not iterable 一个 HTTP 头部字段可以有多个值，而 Headers 对象通过 append()方法支持添加多个值。在 Headers 实例中还不存在的头部上调用 append()方法相当于调用 set()。后续调用会以逗号为分隔符 拼接多个值： 1234567let h = new Headers();h.append(&#x27;foo&#x27;, &#x27;bar&#x27;);console.log(h.get(&#x27;foo&#x27;)); // &quot;bar&quot;h.append(&#x27;foo&#x27;, &#x27;baz&#x27;);console.log(h.get(&#x27;foo&#x27;)); // &quot;bar, baz&quot; 头部护卫 某些情况下，并非所有 HTTP 头部都可以被客户端修改，而 Headers 对象使用护卫来防止不被允 许的修改。不同的护卫设置会改变 set()、append()和 delete()的行为。违反护卫限制会抛出 TypeError。 Headers 实例会因来源不同而展现不同的行为，它们的行为由护卫来控制。JavaScript 可以决定 Headers 实例的护卫设置。下表列出了不同的护卫设置和每种设置对应的行为。 护卫 适用情形 限制 none 在通过构造函数创建 Headers 实例时激活 无 Request 在通过构造函数初始化 Request对象，且 mode 值为非 no-cors 时激活 不允许修改禁止修改的头部（参见 MDN 文档中 的 forbidden header name 词条） request-no-cors 在通过构造函数初始化 Request对象，且 mode 值为 no-cors 时激活 不允许修改非简单头部（参见 MDN 文档中的 simple header 词条） response 在通过构造函数初始化 Response 对象时激活 不允许修改禁止修改的响应头部（参见 MDN 文 档中的 forbidden response header name 词条） immutable 在通过 error()或 redirect()静态方法初始 化 Response 对象时激活 不允许修改任何头部 Request对象顾名思义，Request 对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。 创建Request对象 可以通过构造函数初始化 Request 对象。为此需要传入一个 input 参数，一般是 URL： 123let r = new Request(&#x27;https://foo.com&#x27;);console.log(r);// Request &#123;...&#125; Request 构造函数也接收第二个参数——一个 init 对象。这个 init 对象与前面介绍的 fetch() 的 init 对象一样。没有在 init 对象中涉及的值则会使用默认值： 123456789101112131415161718192021222324252627282930313233343536373839// 用所有默认值创建 Request 对象console.log(new Request(&#x27;&#x27;));// Request &#123;// bodyUsed: false// cache: &quot;default&quot;// credentials: &quot;same-origin&quot;// destination: &quot;&quot;// headers: Headers &#123;&#125;// integrity: &quot;&quot;// keepalive: false// method: &quot;GET&quot;// mode: &quot;cors&quot;// redirect: &quot;follow&quot;// referrer: &quot;about:client&quot;// referrerPolicy: &quot;&quot;// signal: AbortSignal &#123;aborted: false, onabort: null&#125;// url: &quot;&lt;current URL&gt;&quot;// &#125;// 用指定的初始值创建 Request 对象console.log(new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27; &#125;));// Request &#123;// bodyUsed: false// cache: &quot;default&quot;// credentials: &quot;same-origin&quot;// destination: &quot;&quot;// headers: Headers &#123;&#125;// integrity: &quot;&quot;// keepalive: false// method: &quot;POST&quot;// mode: &quot;cors&quot;// redirect: &quot;follow&quot;// referrer: &quot;about:client&quot;// referrerPolicy: &quot;&quot;// signal: AbortSignal &#123;aborted: false, onabort: null&#125;// url: &quot;https://foo.com/&quot;// &#125; 克隆Request对象 Fetch API 提供了两种不太一样的方式用于创建 Request 对象的副本：使用 Request 构造函数和使用 clone()方法。 将 Request 实例作为 input 参数传给 Request 构造函数，会得到该请求的一个副本： 1234let r1 = new Request(&#x27;https://foo.com&#x27;);let r2 = new Request(r1);console.log(r2.url); // https://foo.com/ 如果再传入 init 对象，则 init 对象的值会覆盖源对象中同名的值： 12345let r1 = new Request(&#x27;https://foo.com&#x27;);let r2 = new Request(r1, &#123;method: &#x27;POST&#x27;&#125;);console.log(r1.method); // GETconsole.log(r2.method); // POST 这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”： 1234567let r1 = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);let r2 = new Request(r1);console.log(r1.bodyUsed); // trueconsole.log(r2.bodyUsed); // false 如果源对象与创建的新对象不同源，则 referrer 属性会被清除。此外，如果源对象的 mode 为 navigate，则会被转换为 same-origin。 第二种克隆 Request 对象的方式是使用 clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”： 12345678let r1 = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);let r2 = r1.clone();console.log(r1.url); // https://foo.com/console.log(r2.url); // https://foo.com/console.log(r1.bodyUsed); // falseconsole.log(r2.bodyUsed); // false 如果请求对象的 bodyUsed 属性为 true（即请求体已被读取），那么上述任何一种方式都不能用来创建这个对象的副本。在请求体被读取之后再克隆会导致抛出 TypeError。 123456789101112let r = new Request(&#x27;https://foo.com&#x27;);r.clone();new Request(r);// 没有错误r.text(); // 设置 bodyUsed 为 truer.clone();// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Request&#x27;: Request body is already usednew Request(r);// TypeError: Failed to construct &#x27;Request&#x27;: Cannot construct a Request with aRequest object that has already been used. 在fetch()中使用Request对象 fetch()和 Request 构造函数拥有相同的函数签名并不是巧合。在调用 fetch()时，可以传入已经创建好的 Request 实例而不是 URL。与 Request 构造函数一样，传给 fetch()的 init 对象会覆 盖传入请求对象的值： 1234567let r = new Request(&#x27;https://foo.com&#x27;);// 向 foo.com 发送 GET 请求fetch(r);// 向 foo.com 发送 POST 请求fetch(r, &#123; method: &#x27;POST&#x27; &#125;); fetch()会在内部克隆传入的 Request 对象。与克隆 Request 一样，fetch()也不能拿请求体已经用过的 Request 对象来发送请求： 12345678let r = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);r.text();fetch(r);// TypeError: Cannot construct a Request with a Request object that has alreadybeen used. 关键在于，通过 fetch 使用 Request 会将请求体标记为已使用。也就是说，有请求体的 Request 只能在一次 fetch 中使用。（不包含请求体的请求不受此限制。）演示如下： 1234567let r = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);fetch(r);fetch(r);// TypeError: Cannot construct a Request with a Request object that has already been used. 要想基于包含请求体的相同 Request 对象多次调用 fetch()，必须在第一次发送 fetch()请求前 调用 clone()： 1234567let r = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);// 3 个都会成功fetch(r.clone());fetch(r.clone());fetch(r); Response对象顾名思义，Response 对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。 创建Response对象 可以通过构造函数初始化 Response 对象且不需要参数。此时响应实例的属性均为默认值，因为它并不代表实际的 HTTP 响应： 12345678910111213let r = new Response();console.log(r);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: true// redirected: false// status: 200// statusText: &quot;OK&quot;// type: &quot;default&quot;// url: &quot;&quot;// &#125; Response 构造函数接收一个可选的 body 参数。这个 body 可以是 null，等同于 fetch()参数 init 中的 body。还可以接收一个可选的 init 对象，这个对象可以包含下表所列的键和值。 键 值 headers 必须是 Headers 对象实例或包含字符串键&#x2F;值对的常规对象实例，默认为没有键&#x2F;值对的 Headers 对象 status 表示 HTTP 响应状态码的整数，默认为 200 statusText 表示 HTTP 响应状态的字符串，默认为空字符串 可以像下面这样使用 body 和 init 来构建 Response 对象： 1234567891011121314151617let r = new Response(&#x27;foobar&#x27;, &#123; status: 418, statusText: &#x27;I\\&#x27;m a teapot&#x27;&#125;);console.log(r);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: false// redirected: false// status: 418// statusText: &quot;I&#x27;m a teapot&quot;// type: &quot;default&quot;// url: &quot;&quot;// &#125; 大多数情况下，产生 Response 对象的主要方式是调用 fetch()，它返回一个最后会解决为 Response 对象的期约，这个 Response 对象代表实际的 HTTP 响应。下面的代码展示了这样得到的 Response 对象： 12345678910111213141516fetch(&#x27;https://foo.com&#x27;) .then((response) =&gt; &#123; console.log(response); &#125;);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: true// redirected: false// status: 200// statusText: &quot;OK&quot;// type: &quot;basic&quot;// url: &quot;https://foo.com/&quot;// &#125; Response 类还有两个用于生成 Response 对象的静态方法：Response.redirect()和 Response. error()。前者接收一个 URL 和一个重定向状态码（301、302、303、307 或 308），返回重定向的 Response 对象： 123456789101112console.log(Response.redirect(&#x27;https://foo.com&#x27;, 301));// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: false// redirected: false// status: 301// statusText: &quot;&quot;// type: &quot;default&quot;// url: &quot;&quot;// &#125; 提供的状态码必须对应重定向，否则会抛出错误： 12Response.redirect(&#x27;https://foo.com&#x27;, 200);// RangeError: Failed to execute &#x27;redirect&#x27; on &#x27;Response&#x27;: Invalid status code 另一个静态方法 Response.error()用于产生表示网络错误的 Response 对象（网络错误会导致 fetch()期约被拒绝）。 123456789101112console.log(Response.error());// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: false// redirected: false// status: 0// statusText: &quot;&quot;// type: &quot;error&quot;// url: &quot;&quot;// &#125; 读取响应状态信息 Response 对象包含一组只读属性，描述了请求完成后的状态，如下表所示。 属性 值 headers 响应包含的 Headers 对象 ok 布尔值，表示 HTTP 状态码的含义。200~299 的状态码返回 true，其他状态码返回 false redirected 布尔值，表示响应是否至少经过一次重定向 status 整数，表示响应的 HTTP 状态码 statusText 字符串，包含对 HTTP 状态码的正式描述。这个值派生自可选的 HTTP Reason-Phrase 字段，因此如果服务器以 Reason-Phrase 为由拒绝响应，这个字段可能是空字符串 type 字符串，包含响应类型。可能是下列字符串值之一1、basic：表示标准的同源响应2、cors：表示标准的跨源响应3、error：表示响应对象是通过 Response.error()创建的4、opaque：表示 no-cors 的 fetch()返回的跨源响应5、opaqueredirect：表示对 redirect 设置为 manual 的请求的响应 url 包含响应 URL 的字符串。对于重定向响应，这是最终的 URL，非重定向响应就是它产生的 以下代码演示了返回 200、302、404 和 500 状态码的 URL 对应的响应： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950fetch(&#x27;//foo.com&#x27;).then(console.log);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: true// redirected: false// status: 200// statusText: &quot;OK&quot;// type: &quot;basic&quot;// url: &quot;https://foo.com/&quot;// &#125;fetch(&#x27;//foo.com/redirect-me&#x27;).then(console.log);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: true// redirected: true// status: 200// statusText: &quot;OK&quot;// type: &quot;basic&quot;// url: &quot;https://foo.com/redirected-url/&quot;// &#125; fetch(&#x27;//foo.com/does-not-exist&#x27;).then(console.log);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: false// redirected: true// status: 404// statusText: &quot;Not Found&quot;// type: &quot;basic&quot;// url: &quot;https://foo.com/does-not-exist/&quot;// &#125;fetch(&#x27;//foo.com/throws-error&#x27;).then(console.log);// Response &#123;// body: (...)// bodyUsed: false// headers: Headers &#123;&#125;// ok: false// redirected: true// status: 500// statusText: &quot;Internal Server Error&quot;// type: &quot;basic&quot;// url: &quot;https://foo.com/throws-error/&quot;// &#125; 克隆Response对象 克隆 Response 对象的主要方式是使用 clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用： 12345let r1 = new Response(&#x27;foobar&#x27;);let r2 = r1.clone();console.log(r1.bodyUsed); // falseconsole.log(r2.bodyUsed); // false 如果响应对象的 bodyUsed 属性为 true（即响应体已被读取），则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出 TypeError。 12345678let r = new Response(&#x27;foobar&#x27;);r.clone();// 没有错误r.text(); // 设置 bodyUsed 为 truer.clone();// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Response&#x27;: Response body is already used 有响应体的 Response 对象只能读取一次。（不包含响应体的 Response 对象不受此限制。）比如： 123456let r = new Response(&#x27;foobar&#x27;);r.text().then(console.log); // foobarr.text().then(console.log);// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked 要多次读取包含响应体的同一个 Response 对象，必须在第一次读取前调用 clone()： 12345let r = new Response(&#x27;foobar&#x27;);r.clone().text().then(console.log); // foobarr.clone().text().then(console.log); // foobarr.text().then(console.log); // foobar 此外，通过创建带有原始响应体的 Response 实例，可以执行伪克隆操作。关键是这样不会把第一 个 Response 实例标记为已读，而是会在两个响应之间共享： 123456789let r1 = new Response(&#x27;foobar&#x27;);let r2 = new Response(r1.body);console.log(r1.bodyUsed); // falseconsole.log(r2.bodyUsed); // falser2.text().then(console.log); // foobarr1.text().then(console.log);// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked Request、Response 及 Body 混入Request 和 Response 都使用了 Fetch API 的 Body 混入，以实现两者承担有效载荷的能力。这个 混入为两个类型提供了只读的 body 属性（实现为 ReadableStream）、只读的 bodyUsed 布尔值（表 示 body 流是否已读）和一组方法，用于从流中读取内容并将结果转换为某种 JavaScript 对象类型。 通常，将 Request 和 Response 主体作为流来使用主要有两个原因。一个原因是有效载荷的大小 可能会导致网络延迟，另一个原因是流 API 本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。 Body 混入提供了 5 个方法，用于将 ReadableStream 转存到缓冲区的内存里，将缓冲区转换为某 种 JavaScript 对象类型，以及通过期约来产生结果。在解决之前，期约会等待主体流报告完成及缓冲被 解析。这意味着客户端必须等待响应的资源完全加载才能访问其内容。 Body.text() Body.text()方法返回期约，解决为将缓冲区转存得到的 UTF-8 格式字符串。下面的代码展示了 在 Response 对象上使用 Body.text()： 12345678fetch(&#x27;https://foo.com&#x27;) .then((response) =&gt; response.text()) .then(console.log); // &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;// &lt;head&gt;// &lt;meta charset=&quot;utf-8&quot;&gt;// ... 以下代码展示了在 Request 对象上使用 Body.text()： 1234567let request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;barbazqux&#x27; &#125;); request.text() .then(console.log);// barbazqux Body.json() Body.json()方法返回期约，解决为将缓冲区转存得到的 JSON。下面的代码展示了在 Response 对象上使用 Body.json()： 12345fetch(&#x27;https://foo.com/foo.json&#x27;) .then((response) =&gt; response.json()) .then(console.log); // &#123;&quot;foo&quot;: &quot;bar&quot;&#125; 以下代码展示了在 Request 对象上使用 Body.json()： 1234567let request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: JSON.stringify(&#123; bar: &#x27;baz&#x27; &#125;) &#125;);request.json() .then(console.log);// &#123;bar: &#x27;baz&#x27;&#125; Body.formData() 浏览器可以将 FormData 对象序列化&#x2F;反序列化为主体。例如，下面这个 FormData 实例： 12let myFormData = new FormData();myFormData.append(&#x27;foo&#x27;, &#x27;bar&#x27;); 在通过 HTTP 传送时，WebKit 浏览器会将其序列化为下列内容： 1234------WebKitFormBoundarydR9Q2kOzE6nbN7eRContent-Disposition: form-data; name=&quot;foo&quot; bar------WebKitFormBoundarydR9Q2kOzE6nbN7eR-- Body.formData()方法返回期约，解决为将缓冲区转存得到的 FormData 实例。下面的代码展示 了在 Response 对象上使用 Body.formData()： 12345fetch(&#x27;https://foo.com/form-data&#x27;) .then((response) =&gt; response.formData()) .then((formData) =&gt; console.log(formData.get(&#x27;foo&#x27;)); // bar 以下代码展示了在 Request 对象上使用 Body.formData()： 123456789let myFormData = new FormData();myFormData.append(&#x27;foo&#x27;, &#x27;bar&#x27;);let request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: myFormData &#125;);request.formData() .then((formData) =&gt; console.log(formData.get(&#x27;foo&#x27;));// bar Body.arrayBuffer() 有时候，可能需要以原始二进制格式查看和修改主体。为此，可以使用 Body.arrayBuffer()将 主体内容转换为 ArrayBuffer 实例。Body.arrayBuffer()方法返回期约，解决为将缓冲区转存得到 的 ArrayBuffer 实例。下面的代码展示了在 Response 对象上使用 Body.arrayBuffer()： 12345fetch(&#x27;https://foo.com&#x27;) .then((response) =&gt; response.arrayBuffer()) .then(console.log); // ArrayBuffer(...) &#123;&#125; 以下代码展示了在 Request 对象上使用 Body.arrayBuffer()： 12345678let request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: &#x27;abcdefg&#x27; &#125;);// 以整数形式打印二进制编码的字符串request.arrayBuffer() .then((buf) =&gt; console.log(new Int8Array(buf)));// Int8Array(7) [97, 98, 99, 100, 101, 102, 103] Body.blob() 有时候，可能需要以原始二进制格式使用主体，不用查看和修改。为此，可以使用 Body.blob() 将主体内容转换为 Blob 实例。Body.blob()方法返回期约，解决为将缓冲区转存得到的 Blob 实例。 下面的代码展示了在 Response 对象上使用 Body.blob()： 12345fetch(&#x27;https://foo.com&#x27;) .then((response) =&gt; response.blob()) .then(console.log); // Blob(...) &#123;size:..., type: &quot;...&quot;&#125; 以下代码展示了在 Request 对象上使用 Body.blob()： 1234567let request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: &#x27;abcdefg&#x27; &#125;);request.blob() .then(console.log);// Blob(7) &#123;size: 7, type: &quot;text/plain;charset=utf-8&quot;&#125; 一次性流 因为 Body 混入是构建在 ReadableStream 之上的，所以主体流只能使用一次。这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。 123456789fetch(&#x27;https://foo.com&#x27;) .then((response) =&gt; response.blob().then(() =&gt; response.blob()));// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is lockedlet request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);request.blob().then(() =&gt; request.blob());// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked 即使是在读取流的过程中，所有这些方法也会在它们被调用时给 ReadableStream 加锁，以阻止其他读取器访问： 12345678910111213fetch(&#x27;https://foo.com&#x27;) .then((response) =&gt; &#123; response.blob(); // 第一次调用给流加锁 response.blob(); // 第二次调用再次加锁会失败 &#125;);// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is lockedlet request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);request.blob(); // 第一次调用给流加锁request.blob(); // 第二次调用再次加锁会失败// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked 作为 Body 混入的一部分，bodyUsed 布尔值属性表示 ReadableStream 是否已摄受（disturbed）， 意思是读取器是否已经在流上加了锁。这不一定表示流已经被完全读取。下面的代码演示了这个属性： 123456789101112let request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;);let response = new Response(&#x27;foobar&#x27;);console.log(request.bodyUsed); // falseconsole.log(response.bodyUsed); // falserequest.text().then(console.log); // foobarresponse.text().then(console.log); // foobarconsole.log(request.bodyUsed); // trueconsole.log(response.bodyUsed); // true Web SocketWeb Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript 中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP 的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务 器实现，而必须使用支持该协议的专有服务器。 因为 Web Socket使用了自定义协议，所以 URL方案（scheme）稍有变化：不能再使用 http:&#x2F;&#x2F;或 https:&#x2F;&#x2F;， 而要使用 ws:&#x2F;&#x2F;和 wss:&#x2F;&#x2F;。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包 含 URL 方案，因为将来有可能再支持其他方案。 使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。 使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。Web Socket 得到了所有主流浏 览器支持。 API要创建一个新的 Web Socket，就要实例化一个 WebSocket 对象并传入提供连接的 URL： 1let socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;); 注意，必须给 WebSocket 构造函数传入一个绝对 URL。同源策略不适用于 Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在握手阶段就可以确定请求来自哪里。） 浏览器会在初始化 WebSocket 对象之后立即创建连接。与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态。不过，这个值与 XHR 中相应的值不一样。 WebSocket.OPENING（0）：连接正在建立。 WebSocket.OPEN（1）：连接已经建立。 WebSocket.CLOSING（2）：连接正在关闭。 WebSocket.CLOSE（3）：连接已经关闭。 WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件。 readyState 值从 0 开始。 任何时候都可以调用 close()方法关闭 Web Socket 连接： 1socket.close(); 调用 close()之后，readyState 立即变为 2（连接正在关闭），并会在关闭后变为 3（连接已经关闭）。 发送和接收数据打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用 send()方法并 传入一个字符串、ArrayBuffer 或 Blob，如下所示： 123456789let socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);let stringData = &quot;Hello world!&quot;;let arrayBufferData = Uint8Array.from([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]);let blobData = new Blob([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]);socket.send(stringData);socket.send(arrayBufferData.buffer);socket.send(blobData); 服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件。这个 message 事件与其 他消息协议类似，可以通过 event.data 属性访问到有效载荷： 1234socket.onmessage = function(event) &#123; let data = event.data; // 对数据执行某些操作&#125;; 与通过 send()方法发送的数据类似，event.data 返回的数据也可能是 ArrayBuffer 或 Blob。 这由 WebSocket 对象的 binaryType 属性决定，该属性可能是”blob”或”arraybuffer”。 其他事件WebSocket 对象在连接生命周期中有可能触发 3 个其他事件。 open：在连接成功建立时触发。 error：在发生错误时触发。连接无法存续。 close：在连接关闭时触发。 WebSocket 对象不支持 DOM Level 2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程 序来监听这些事件： 123456789101112let socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);socket.onopen = function() &#123; alert(&quot;Connection established.&quot;);&#125;;socket.onerror = function() &#123; alert(&quot;Connection error.&quot;);&#125;;socket.onclose = function() &#123; alert(&quot;Connection closed.&quot;);&#125;; 在这些事件中，只有 close 事件的 event 对象上有额外信息。这个对象上有 3 个额外属性： wasClean、code 和 reason。其中，wasClean 是一个布尔值，表示连接是否干净地关闭；code 是一 个来自服务器的数值状态码；reason 是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志： 123socket.onclose = function(event) &#123; console.log(`as clean? $&#123;event.wasClean&#125; Code=$&#123;event.code&#125; Reason=$&#123;event.reason&#125;`);&#125;;","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(13)——事件","slug":"JS高级程序设计读书笔记(13)——事件","date":"2023-05-13T04:26:39.000Z","updated":"2023-11-27T15:34:23.879Z","comments":true,"path":"2023/05/13/JS高级程序设计读书笔记(13)——事件/","link":"","permalink":"http://pvnk1u.github.io/2023/05/13/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(13)%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"JavaScript 与 HTML 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。 可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫 “观察者模式”，其能够做到页面行为（在 JavaScript 中定义）与页面展示（在 HTML 和 CSS 中定义）的分离。 事件流在第四代 Web 浏览器开始开发时，开发团队碰到了一个有意思的问题：页面哪个部分拥有特定的事件呢？要理解这个问题，可以在一张纸上画几个同心圆。把手指放 到圆心上，则手指不仅是在一个圆圈里，而且是在所有的圆圈里。两家浏览器的开发团队都是以同样的 方式看待浏览器事件的。当你点击一个按钮时，实际上不光点击了这个按钮，还点击了它的容器以及整 个页面。 事件流描述了页面接收事件的顺序。结果非常有意思，IE 和 Netscape 开发团队提出了几乎完全相反的事件流方案。IE 将支持事件冒泡流，而 Netscape Communicator 将支持事件捕获流。 事件冒泡IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。比如有如下 HTML 页面： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在点击页面中的&lt;div&gt;元素后，click 事件会以如下顺序发生： &lt;div&gt; &lt;body&gt; &lt;html&gt; document 也就是说，&lt;div&gt;元素，即被点击的元素，最先触发 click 事件。然后，click 事件沿 DOM 树一 路向上，在经过的每个节点上依次触发，直至到达 document 对象。 所有现代浏览器都支持事件冒泡。现代浏览器中的事件会一直冒泡到 window 对象。 事件捕获Netscape Communicator 团队提出了另一种名为事件捕获的事件流。事件捕获的意思是最不具体的节 点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。如果前面的例子使用事件捕获，则点击&lt;div&gt;元素会以下列顺序触发 click 事件： document &lt;html&gt; &lt;body&gt; &lt;div&gt; 在事件捕获中，click 事件首先由 document 元素捕获，然后沿 DOM 树依次向下传播，直至到达 实际的目标元素&lt;div&gt;。 虽然这是 Netscape Communicator 唯一的事件流模型，但事件捕获得到了所有现代浏览器的支持。 实际上，所有浏览器都是从 window 对象开始捕获事件，而 DOM2 Events规范规定的是从 document 开始。 由于旧版本浏览器不支持，因此实际当中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情 况下可以使用事件捕获。 DOM事件流DOM2 Events 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生， 为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个 阶段响应事件。仍以前面那个简单的 HTML 为例，点击&lt;div&gt;元素会以如图所示的顺序触发事件。 在 DOM 事件流中，实际的目标（&lt;div&gt;元素）在捕获阶段不会接收到事件。这是因为捕获阶段从 document 到&lt;html&gt;再到&lt;body&gt;就结束了。下一阶段，即会在&lt;div&gt;元素上触发事件的“到达目标” 阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后，冒泡阶段开始，事件反向传播至文档。 大多数支持 DOM 事件流的浏览器实现了一个小小的拓展。虽然 DOM2 Events 规范明确捕获阶段不命中事件目标，但现代浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。 事件处理程序事件意味着用户或浏览器执行的某种动作。比如，单击（click）、加载（load）、鼠标悬停 （mouseover）。为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字 以”on”开头，因此 click 事件的处理程序叫作 onclick，而 load 事件的处理程序叫作 onload。有 很多方式可以指定事件处理程序。 HTML事件处理程序特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。此时属性的值必须是能够执行的 JavaScript 代码。例如，要在按钮被点击时执行某些 JavaScript 代码，可以使用以下 HTML 属性： 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(&#x27;Clicked&#x27;)&quot;/&gt; 点击这个按钮后，控制台会输出一条消息。这种交互能力是通过为 onclick属性指定 JavaScript 代码值来实现的。注意，因为属性的值是 JavaScript 代码，所以不能在未经转义的情况下使用 HTML 语 法字符，比如和号（&amp;）、双引号（”）、小于号（&lt;）和大于号（&gt;）。此时，为了避免使用 HTML 实体， 可以使用单引号代替双引号。如果确实需要使用双引号，则要把代码改成下面这样： 12&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(&amp;quot;Clicked&amp;quot;)&quot;/&gt; 在 HTML 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，比如： 123456&lt;script&gt; function showMessage() &#123; console.log(&quot;Hello world!&quot;); &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot;/&gt; 在这个例子中，单击按钮会调用 showMessage()函数。showMessage()函数是在单独的&lt;script&gt;元素中定义的，而且也可以在外部文件中定义。作为事件处理程序执行的代码可以访问全局作用域中的一切。 以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象: 12&lt;!-- 输出&quot;click&quot; --&gt;&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(event.type)&quot;&gt; 有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了。 在这个函数中，this 值相当于事件的目标元素，如下面的例子所示： 12&lt;!-- 输出&quot;Click Me&quot; --&gt;&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(this.value)&quot;&gt; 这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中， document 和元素自身的成员都可以被当成局部变量来访问。这是通过使用 with 实现的： 1234567function() &#123; with(document) &#123; with(this) &#123; // 属性值 &#125; &#125;&#125; 这意味着事件处理程序可以更方便地访问自己的属性。下面的代码与前面的示例功能一样： 12&lt;!-- 输出&quot;Click Me&quot; --&gt;&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(value)&quot;&gt; 如果这个元素是一个表单输入框，则作用域链中还会包含表单元素，事件处理程序对应的函数等价于如下这样： 123456789function() &#123; with(document) &#123; with(this.form) &#123; with(this) &#123; // 属性值 &#125; &#125; &#125;&#125; 本质上，经过这样的扩展，事件处理程序的代码就可以不必引用表单元素，而直接访问同一表单中的其他成员了。下面的例子就展示了这种成员访问模式： 12345&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Echo Username&quot; onclick=&quot;console.log(username.value)&quot;&gt;&lt;/form&gt; 点击这个例子中的按钮会显示出文本框中包含的文本。注意，事件处理程序中的代码直接引用了 username。 在 HTML 中指定事件处理程序有一些问题。第一个问题是时机问题。有可能 HTML 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。比如在前面的例子中，如果 showMessage()函数是在页面后面，在按钮中代码的后面定义的，那么当用户在 showMessage()函数 被定义之前点击按钮时，就会发生错误。为此，大多数 HTML 事件处理程序会封装在 try/catch 块中， 以便在这种情况下静默失败，如下面的例子所示： 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try&#123;showMessage();&#125;catch(ex) &#123;&#125;&quot;&gt; 这样，如果在 showMessage()函数被定义之前点击了按钮，就不会发生 JavaScript错误了，这是因为错误在浏览器收到之前已经被拦截了。 另一个问题是对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同 JavaScript 引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。 使用 HTML 指定事件处理程序的最后一个问题是 HTML 与 JavaScript 强耦合。如果需要修改事件处理程序，则必须在两个地方，即 HTML 和 JavaScript 中，修改代码。这也是很多开发者不使用 HTML 事件处理程序，而使用 JavaScript 指定事件处理程序的主要原因。 DOM0事件处理程序在 JavaScript 中指定事件处理程序的传统方式是把一个函数赋值给（DOM 元素的）一个事件处理程序属性。这也是在第四代 Web 浏览器中开始支持的事件处理程序赋值方法，直到现在所有现代浏览器仍然都支持此方法，主要原因是简单。要使用 JavaScript指定事件处理程序，必须先取得要操作对象的引用。 每个元素（包括 window 和 document）都有通常小写的事件处理程序属性，比如 onclick。只要把这个属性赋值为一个函数即可： 1234let btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function() &#123; console.log(&quot;Clicked&quot;);&#125;; 这里先从文档中取得按钮，然后给它的 onclick 事件处理程序赋值一个函数。注意，前面的代码在运行之后才会给事件处理程序赋值。因此如果在页面中上面的代码出现在按钮之后，则有可能出现用户点击按钮没有反应的情况。 像这样使用 DOM0 方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 this 等于元素。下面的例子演示了使用 this 引用元素本身： 1234let btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function() &#123; console.log(this.id); // &quot;myBtn&quot;&#125;; 点击按钮，这段代码会显示元素的 ID。这个 ID 是通过 this.id 获取的。不仅仅是 id，在事件处理程序里通过 this 可以访问元素的任何属性和方法。以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。 通过将事件处理程序属性的值设置为 null，可以移除通过 DOM0 方式添加的事件处理程序，如下面的例子所示： 1btn.onclick = null; // 移除事件处理程序 把事件处理程序设置为 null，再点击按钮就不会执行任何操作了。 DOM2事件处理程序DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。 仍以给按钮添加 click 事件处理程序为例，可以这样写： 1234let btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(this.id);&#125;, false); 以上代码为按钮添加了会在事件冒泡阶段触发的 onclick 事件处理程序（因为最后一个参数值为 false）。与 DOM0 方式类似，这个事件处理程序同样在被附加到的元素的作用域中运行。使用 DOM2 方式的主要优势是可以为同一个事件添加多个事件处理程序。来看下面的例子： 123456789let btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(this.id);&#125;, false);btn.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(&quot;Hello world!&quot;);&#125;, false); 这里给按钮添加了两个事件处理程序。多个事件处理程序以添加顺序来触发，因此前面的代码会先打印元素 ID，然后显示消息“Hello world!”。 通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()并传入与添加时同样的参数来移除。这意味着使用 addEventListener()添加的匿名函数无法移除，如下面的例子所示： 123456789let btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(this.id); &#125;, false);// 其他代码btn.removeEventListener(&quot;click&quot;, function() &#123; // 没有效果！ console.log(this.id);&#125;, false); 这个例子通过 addEventListener()添加了一个匿名函数作为事件处理程序。然后，又以看起来 相同的参数调用了 removeEventListener()。但实际上，第二个参数与传给 addEventListener() 的完全不是一回事。传给 removeEventListener()的事件处理函数必须与传给 addEventListener() 的是同一个，如下面的例子所示： 123456789let btn = document.getElementById(&quot;myBtn&quot;);let handler = function() &#123; console.log(this.id);&#125;;btn.addEventListener(&quot;click&quot;, handler, false);// 其他代码btn.removeEventListener(&quot;click&quot;, handler, false); // 有效果！ 这个例子有效，因为调用 addEventListener()和 removeEventListener()时传入的是同一个函数。 大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。 事件对象在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。 例如，鼠标操作导致的事件会生成鼠标位置信息，而键盘操作导致的事件会生成与被按下的键有关的信息。所有浏览器都支持这个 event 对象，尽管支持方式不同。 DOM事件对象在 DOM 合规的浏览器中，event 对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0 或 DOM2）指定事件处理程序，都会传入这个 event 对象。下面的例子展示了在两种方式下都可以使用事件对象： 1234567let btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event) &#123; console.log(event.type); // &quot;click&quot;&#125;;btn.addEventListener(&quot;click&quot;, (event) =&gt; &#123; console.log(event.type); // &quot;click&quot;&#125;, false); 这个例子中的两个事件处理程序都会在控制台打出 event.type 属性包含的事件类型。这个属性中 始终包含被触发事件的类型，如”click”（与传给 addEventListener()和 removeEventListener() 方法的事件名一致）。 在通过 HTML 属性指定的事件处理程序中，同样可以使用变量 event 引用事件对象。下面的例子中演示了如何使用这个变量： 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(event.type)&quot;&gt; 以这种方式提供 event 对象，可以让 HTML 属性中的代码实现与 JavaScript 函数同样的功能。 如前所述，事件对象包含与特定事件相关的属性和方法。不同的事件生成的事件对象也会包含不同 的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。 属性&#x2F;方法 类型 读&#x2F;写 说明 bubbles 布尔值 只读 表示事件是否冒泡 cancelable 布尔值 只读 表示是否可以取消事件的默认行为 currentTarget 元素 只读 当前事件处理程序所在的元素 defaultPrevented 布尔值 只读 true 表示已经调用 preventDefault()方法（DOM3 Events 中新增） detail 整数 只读 事件相关的其他信息 eventPhase 整数 只读 表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段 preventDefault() 函数 只读 用于取消事件的默认行为。只有 cancelable 为 true 才 可以调用这个方法 stopImmediatePropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增） stopPropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡。只有 bubbles 为 true 才可以调用这个方法 target 元素 只读 事件目标 trusted 布尔值 只读 true 表示事件是由浏览器生成的。false 表示事件是开 发者通过 JavaScript 创建的（DOM3 Events 中新增） type 字符串 只读 被触发的事件类型 View AbstractView 只读 与事件相关的抽象视图。等于事件所发生的 window 对象 在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 this、currentTarget 和 target 的值是一样 的。下面的例子展示了这两个属性都等于 this 的情形： 12345let btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event) &#123; console.log(event.currentTarget === this); // true console.log(event.target === this); // true&#125;; 上面的代码检测了 currentTarget 和 target 的值是否等于 this。因为 click 事件的目标是按钮，所以这 3 个值是相等的。如果这个事件处理程序是添加到按钮的父节点（如 document.body）上， 那么它们的值就不一样了。比如下面的例子在 document.body 上添加了单击处理程序： 12345document.body.onclick = function(event) &#123; console.log(event.currentTarget === document.body); // true console.log(this === document.body); // true console.log(event.target === document.getElementById(&quot;myBtn&quot;)); // true&#125;; 这种情况下点击按钮，this 和 currentTarget 都等于 document.body，这是因为它是注册事件处理程序的元素。而 target 属性等于按钮本身，这是因为那才是 click 事件真正的目标。由于按钮本身并没有注册事件处理程序，因此 click 事件冒泡到 document.body，从而触发了在它上面注册的处理程序。 type 属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用了 event.type： 1234567891011121314151617let btn = document.getElementById(&quot;myBtn&quot;);let handler = function(event) &#123; switch(event.type) &#123; case &quot;click&quot;: console.log(&quot;Clicked&quot;); break; case &quot;mouseover&quot;: event.target.style.backgroundColor = &quot;red&quot;; break; case &quot;mouseout&quot;: event.target.style.backgroundColor = &quot;&quot;; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 在这个例子中，函数 handler 被用于处理 3 种不同的事件：click、mouseover 和 mouseout。 当按钮被点击时，应该在控制台打印一条消息，如前面的例子所示。而把鼠标放到按钮上，会导致按钮 背景变成红色，接着把鼠标从按钮上移开，背景颜色应该又恢复成默认值。这个函数使用 event.type 属性确定了事件类型，从而可以做出不同的响应。 preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到 href 属性指定的 URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消，如下面的例子所示： 1234let link = document.getElementById(&quot;myLink&quot;);link.onclick = function(event) &#123; event.preventDefault();&#125;; 任何可以通过 preventDefault()取消默认行为的事件，其事件对象的 cancelable 属性都会设置为 true。 stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。 例如，直接添加到按钮的事件处理程序中调用 stopPropagation()，可以阻止 document.body 上注册的事件处理程序执行。比如： 123456789let btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event) &#123; console.log(&quot;Clicked&quot;); event.stopPropagation();&#125;;document.body.onclick = function(event) &#123; console.log(&quot;Body clicked&quot;);&#125;; 如果这个例子中不调用stopPropagation()，那么点击按钮就会打印两条消息。但这里由于click 事件不会传播到 document.body，因此 onclick 事件处理程序永远不会执行。 eventPhase 属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则 eventPhase 等于 1；如果事件处理程序在目标上被调用，则 eventPhase 等于 2；如果事件处理程序在冒泡阶段被调用，则 eventPhase 等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的， 但其 eventPhase 仍然等于 2。下面的例子展示了 eventPhase 在不同阶段的值： 123456789101112let btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event) &#123; console.log(event.eventPhase); // 2&#125;;document.body.addEventListener(&quot;click&quot;, (event) =&gt; &#123; console.log(event.eventPhase); // 1&#125;, true);document.body.onclick = (event) =&gt; &#123; console.log(event.eventPhase); // 3&#125;; 在这个例子中，点击按钮首先会触发注册在捕获阶段的 document.body 上的事件处理程序， 显示 eventPhase 为 1。接着，会触发按钮本身的事件处理程序（尽管是注册在冒泡阶段），此时显示 eventPhase 等于 2。最后触发的是注册在冒泡阶段的 document.body 上的事件处理程序，显示 eventPhase 为 3。而当 eventPhase 等于 2 时，this、target 和 currentTarget 三者相等。 事件类型Web 浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。DOM3 Events 定义了如下事件类型。 用户界面事件（UIEvent） 涉及与 BOM 交互的通用浏览器事件。 焦点事件（FocusEvent） 在元素获得和失去焦点时触发。 鼠标事件（MouseEvent） 使用鼠标在页面上执行某些操作时触发。 滚轮事件（WheelEvent） 使用鼠标滚轮（或类似设备）时触发。 输入事件（InputEvent） 向文档中输入文本时触发。 键盘事件（KeyboardEvent） 使用键盘在页面上执行某些操作时触发。 合成事件（CompositionEvent） 在使用某种 IME（Input Method Editor，输入法编辑器）输入 字符时触发。 除了这些事件类型之外，HTML5 还定义了另一组事件，而浏览器通常在 DOM 和 BOM 上实现专有事件。这些专有事件基本上都是根据开发者需求而不是按照规范增加的，因此不同浏览器的实现可能不同。 DOM3 Events 在 DOM2 Events 基础上重新定义了事件，并增加了新的事件类型。所有主流浏览器 都支持 DOM2 Events 和 DOM3 Events。 用户界面事件用户界面事件或 UI 事件不一定跟用户操作有关。这类事件在 DOM 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。UI 事件主要有以下几种。 DOMActivate 元素被用户通过鼠标或键盘操作激活时触发（比 click 或 keydown 更通用）。 这个事件在 DOM3 Events 中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。 load 在 window 上当页面加载完成后触发，在窗套（&lt;frameset&gt;）上当所有窗格（&lt;frame&gt;） 都加载完成后触发，在&lt;img&gt;元素上当图片加载完成后触发，在&lt;object&gt;元素上当相应对象加载完成后触发。 unload 在 window 上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在&lt;object&gt;元素上当相应对象卸载完成后触发。 abort 在&lt;object&gt;元素上当相应对象加载完成前被用户提前终止下载时触发。 error 在 window 上当 JavaScript 报错时触发，在&lt;img&gt;元素上当无法加载指定图片时触发， 在元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。 select 在文本框（input或 textarea）上当用户选择了一个或多个字符时触发。 resize 在 window 或窗格上当窗口或窗格被缩放时触发。 scroll 当用户滚动包含滚动条的元素时在元素上触发。&lt;body&gt;元素包含已加载页面的滚动条。 大多数 HTML 事件与 window 对象和表单控件有关。 除了 DOMActivate，这些事件在 DOM2 Events 中都被归为 HTML Events（DOMActivate 在 DOM2 中仍旧是 UI 事件）。 焦点事件焦点事件在页面元素获得或失去焦点时触发。这些事件可以与 document.hasFocus()和 document.activeElement 一起为开发者提供用户在页面中导航的信息。焦点事件有以下 6 种。 blur 当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。 focus 当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。 focusin 当元素获得焦点时触发。这个事件是 focus 的冒泡版。 focusout 当元素失去焦点时触发。这个事件是 blur 的通用版。 焦点事件中的两个主要事件是 focus 和 blur，这两个事件在 JavaScript 早期就得到了浏览器支持。 它们最大的问题是不冒泡。这导致 IE后来又增加了 focusin 和 focusout，IE 新增的这两个事件已经被 DOM3 Events 标准化。 当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。 focuscout 在失去焦点的元素上触发。 focusin 在获得焦点的元素上触发。 blur 在失去焦点的元素上触发。 focus 在获得焦点的元素上触发。 其中，blur、focusout 的事件目标是失去焦点的元素，而 focus和 focusin 的事件目标是获得焦点的元素。 鼠标和滚轮事件鼠标事件是 Web 开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。DOM3 Events 定义了 9 种鼠标事件。 click 在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发 onclick 事件处理程序。 dblclick 在用户双击鼠标主键（通常是左键）时触发。这个事件不是在 DOM2 Events 中定义 的，但得到了很好的支持，DOM3 Events 将其进行了标准化。 mousedown 在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。 mouseenter 在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发。mouseenter 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events 中新增的事件。 mouseleave 在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseleave 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events 中新增的事件。 mousemove 在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。 mouseout 在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。 mouseover 在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。 mouseup 在用户释放鼠标键时触发。这个事件不能通过键盘触发。 页面中的所有元素都支持鼠标事件。除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡， 都可以被取消，而这会影响浏览器的默认行为。 由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。 比如，click 事件触发的前提是 mousedown 事件触发后，紧接着又在同一个元素上触发了 mouseup 事件。如果 mousedown 和 mouseup 中的任意一个事件被取消，那么 click 事件就不会触发。类似地， 两次连续的 click 事件会导致 dblclick 事件触发。只要有任何逻辑阻止了这两个 click 事件发生（比 如取消其中一个 click 事件或者取消 mousedown 或 mouseup 事件中的任一个），dblclick事件就不 会发生。这 4 个事件永远会按照如下顺序触发： mousedown mouseup click mousedown mouseup click dblclick click 和 dblclick 在触发前都依赖其他事件触发，mousedown 和 mouseup 则不会受其他事件影响。 键盘与输入事件键盘事件是用户操作键盘时触发的。DOM2 Events 最初定义了键盘事件，但该规范在最终发布前删除了相应内容。因此，键盘事件很大程度上是基于原始的 DOM0 实现的。 DOM3 Events 为键盘事件提供了一个首先在 IE9 中完全实现的规范。其他浏览器也开始实现该规范， 但仍然存在很多遗留的实现。 键盘事件包含 3 个事件： keydown 用户按下键盘上某个键时触发，而且持续按住会重复触发。 keypress 用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc 键也会 触发这个事件。DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。 keyup 用户释放键盘上某个键时触发。 虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。 输入事件只有一个，即 textInput。这个事件是对 keypress 事件的扩展，用于在文本显示给用 户之前更方便地截获文本输入。textInput 会在文本被插入到文本框之前触发。 当用户按下键盘上的某个字符键时，首先会触发 keydown 事件，然后触发 keypress 事件，最后 触发 keyup 事件。注意，这里 keydown 和 keypress 事件会在文本框出现变化之前触发，而 keyup事件会在文本框出现变化之后触发。如果一个字符键被按住不放，keydown 和 keypress 就会重复触 发，直到这个键被释放。 内存与性能在 JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理 程序所需访问 DOM 的次数会先期造成整个页面交互的延迟。只要在使用事件处理程序时多注意一些方 法，就可以改善页面性能。 事件委托“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件 处理程序来管理一种类型的事件。例如，click 事件冒泡到 document。这意味着可以为整个页面指定 一个 onclick事件处理程序，而不用为每个可点击元素分别指定事件处理程序。比如有以下 HTML： 12345&lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;&lt;/ul&gt; 这里的 HTML 包含 3 个列表项，在被点击时应该执行某个操作。对此，通常的做法是像这样指定 3 个事件处理程序： 123456789101112let item1 = document.getElementById(&quot;goSomewhere&quot;);let item2 = document.getElementById(&quot;doSomething&quot;);let item3 = document.getElementById(&quot;sayHi&quot;);item1.addEventListener(&quot;click&quot;, (event) =&gt; &#123; location.href = &quot;http:// www.wrox.com&quot;;&#125;);item2.addEventListener(&quot;click&quot;, (event) =&gt; &#123; document.title = &quot;I changed the document&#x27;s title&quot;;&#125;);item3.addEventListener(&quot;click&quot;, (event) =&gt; &#123; console.log(&quot;hi&quot;);&#125;); 如果对页面中所有需要使用 onclick 事件处理程序的元素都如法炮制，结果就会出现大片雷同的只为指定事件处理程序的代码。使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序， 就可以解决问题。比如： 12345678910111213141516let list = document.getElementById(&quot;myLinks&quot;);list.addEventListener(&quot;click&quot;, (event) =&gt; &#123; let target = event.target; switch(target.id) &#123; case &quot;doSomething&quot;: document.title = &quot;I changed the document&#x27;s title&quot;; break; case &quot;goSomewhere&quot;: location.href = &quot;http:// www.wrox.com&quot;; break; case &quot;sayHi&quot;: console.log(&quot;hi&quot;); break; &#125;&#125;); 这里只给&lt;div&gt;元素添加了一个 onclick 事件处理程序。因为所有列表项都是这个元素的后代，所以它们的事件会向上冒泡，最终都会由这个函数来处理。但事件目标是每个被点击的列表项，只要检查 event 对象的 id 属性就可以确定，然后再执行相应的操作即可。相对于前面不使用事件委托的代码，这里的代码不会导致先期延迟，因为只访问了一个 DOM 元素和添加了一个事件处理程 序。结果对用户来说没有区别，但这种方式占用内存更少。所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(12)——DOM扩展","slug":"JS高级程序设计读书笔记(12)——DOM扩展","date":"2023-05-10T21:26:39.000Z","updated":"2023-11-27T15:34:23.879Z","comments":true,"path":"2023/05/11/JS高级程序设计读书笔记(12)——DOM扩展/","link":"","permalink":"http://pvnk1u.github.io/2023/05/11/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(12)%E2%80%94%E2%80%94DOM%E6%89%A9%E5%B1%95/","excerpt":"","text":"Selectors API2008 年以前，大部分浏览器对 DOM 的扩展是专有的。此后，W3C 开始着手将这些已成为事实标准的专有扩展编制成正式规范。诞生了描述 DOM 扩展的两个标准：Selectors API 与 HTML5。这两个标准体现了社 区需求和标准化某些手段及 API 的愿景。另外还有较小的 Element Traversal 规范，增加了一些 DOM 属性。 JavaScript 库中最流行的一种能力就是根据 CSS 选择符的模式匹配 DOM 元素。比如，jQuery 就完全以 CSS 选择符查询 DOM 获取元素引用，而不是使用 getElementById()和 getElementsByTagName()。 Selectors API（参见 W3C 网站上的 Selectors API Level 1）是 W3C 推荐标准，规定了浏览器原生支持的 CSS 查询 API。支持这一特性的所有 JavaScript 库都会实现一个基本的 CSS 解析器，然后使用已有 的 DOM 方法搜索文档并匹配目标节点。虽然库开发者在不断改进其性能，但 JavaScript 代码能做到的毕竟有限。通过浏览器原生支持这个 API，解析和遍历 DOM 树可以通过底层编译语言实现，性能也有了数量级的提升。 Selectors API Level 1 的核心是两个方法：querySelector()和 querySelectorAll()。在兼容浏览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。 Selectors API Level 2 规范在 Element 类型上新增了更多方法，比如 matches()、find()和 findAll()。不过，目前还没有浏览器实现或宣称实现 find()和 findAll()。 querySelector()querySelector()方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 null。下面是一些例子： 1234567891011// 取得&lt;body&gt;元素let body = document.querySelector(&quot;body&quot;);// 取得 ID 为&quot;myDiv&quot;的元素let myDiv = document.querySelector(&quot;#myDiv&quot;);// 取得类名为&quot;selected&quot;的第一个元素let selected = document.querySelector(&quot;.selected&quot;);// 取得类名为&quot;button&quot;的图片let img = document.body.querySelector(&quot;img.button&quot;); 在 Document 上使用 querySelector()方法时，会从文档元素开始搜索；在 Element 上使用 querySelector()方法时，则只会从当前元素的后代中查询。 用于查询模式的 CSS选择符可繁可简，依需求而定。如果选择符有语法错误或碰到不支持的选择符， 则 querySelector()方法会抛出错误。 querySelectorAll()querySelectorAll()方法跟 querySelector()一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 NodeList 的静态实例。 再强调一次，querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一 个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 NodeList 对象可能造成的性能问题。 以有效 CSS 选择符调用 querySelectorAll()都会返回 NodeList，无论匹配多少个元素都可以。 如果没有匹配项，则返回空的 NodeList 实例。 与 querySelector()一样，querySelectorAll()也可以在 Document、DocumentFragment 和 Element 类型上使用。下面是几个例子： 12345678// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);// 取得所有类名中包含&quot;selected&quot;的元素let selecteds = document.querySelectorAll(&quot;.selected&quot;);// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs = document.querySelectorAll(&quot;p strong&quot;); 返回的 NodeList 对象可以通过 for-of 循环、item()方法或中括号语法取得个别元素。比如： 1234567891011121314let strongElements = document.querySelectorAll(&quot;p strong&quot;);// 以下 3 个循环的效果一样for (let strong of strongElements) &#123; strong.className = &quot;important&quot;;&#125;for (let i = 0; i &lt; strongElements.length; ++i) &#123; strongElements.item(i).className = &quot;important&quot;;&#125;for (let i = 0; i &lt; strongElements.length; ++i) &#123; strongElements[i].className = &quot;important&quot;;&#125; 与 querySelector()方法一样，如果选择符有语法错误或碰到不支持的选择符，则 querySelectorAll()方法会抛出错误。 matchs()matches()方法（在规范草案中称为 matchesSelector()）接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 true，否则返回 false。例如： 123if (document.body.matches(&quot;body.page1&quot;))&#123; // true&#125; 使用这个方法可以方便地检测某个元素会不会被 querySelector()或 querySelectorAll()方法返回。 元素遍历IE9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了 childNodes 和 firstChild 等属性上的差异。为了弥补这个差异，同时不影响 DOM 规范，W3C 通过新的 Element Traversal 规范定义了一组新属性。 Element Traversal API 为 DOM 元素添加了 5 个属性： childElementCount 返回子元素数量（不包含文本节点和注释）； firstElementChild 指向第一个 Element 类型的子元素（Element 版 firstChild）； lastElementChild 指向最后一个 Element 类型的子元素（Element 版 lastChild）； previousElementSibling 指向前一个 Element 类型的同胞元素（ Element 版 previousSibling）； nextElementSibling 指向后一个 Element 类型的同胞元素（Element 版 nextSibling）。 在支持的浏览器中，所有 DOM 元素都会有这些属性，为遍历 DOM 元素提供便利。这样开发者就 不用担心空白文本节点的问题了。 过去要以跨浏览器方式遍历特定元素的所有子元素，代码大致是这样写的： 123456789101112131415let parentElement = document.getElementById(&#x27;parent&#x27;);let currentChildNode = parentElement.firstChild;// 没有子元素，firstChild 返回 null，跳过循环while (currentChildNode) &#123; if (currentChildNode.nodeType === 1) &#123; // 如果有元素节点，则做相应处理 processChild(currentChildNode); &#125; if (currentChildNode === parentElement.lastChild) &#123; break; &#125; currentChildNode = currentChildNode.nextSibling;&#125; 使用 Element Traversal 属性之后，以上代码可以简化如下： 123456789101112let parentElement = document.getElementById(&#x27;parent&#x27;);let currentChildElement = parentElement.firstElementChild;// 没有子元素，firstElementChild 返回 null，跳过循环while (currentChildElement) &#123; // 这就是元素节点，做相应处理 processChild(currentChildElement); if (currentChildElement === parentElement.lastElementChild) &#123; break; &#125; currentChildElement = currentChildElement.nextElementSibling;&#125; HTML5HTML5 代表着与以前的 HTML 截然不同的方向。在所有以前的 HTML 规范中，从未出现过描述 JavaScript 接口的情形，HTML 就是一个纯标记语言。JavaScript 绑定的事，一概交给 DOM 规范去定义。 然而，HTML5 规范却包含了与标记相关的大量 JavaScript API 定义。其中有的 API 与 DOM 重合， 定义了浏览器应该提供的 DOM 扩展。 CSS类扩展自 HTML4 被广泛采用以来，Web 开发中一个主要的变化是 class 属性用得越来越多，其用处是为 元素添加样式以及语义信息。自然地，JavaScript 与 CSS 类的交互就增多了，包括动态修改类名，以及 根据给定的一个或一组类名查询元素，等等。为了适应开发者和他们对 class 属性的认可，HTML5 增 加了一些特性以方便使用 CSS 类。 getElementsByClassName() getElementsByClassName()是 HTML5 新增的最受欢迎的一个方法，暴露在 document 对象和 所有 HTML 元素上。这个方法脱胎于基于原有 DOM 特性实现该功能的 JavaScript库，提供了性能高好的原生实现。 getElementsByClassName()方法接收一个参数，即包含一个或多个类名的字符串，返回类名中 包含相应类的元素的 NodeList。如果提供了多个类名，则顺序无关紧要。下面是几个示例： 12345// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素// 这两个类名的顺序无关紧要let allCurrentUsernames = document.getElementsByClassName(&quot;username current&quot;);// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素let selected = document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); 这个方法只会返回以调用它的对象为根元素的子树中所有匹配的元素。在 document 上调用 getElementsByClassName()返回文档中所有匹配的元素，而在特定元素上调用 getElementsByClassName()则返回该元素后代中匹配的元素。 classList 属性 要操作类名，可以通过 className 属性实现添加、删除和替换。但 className 是一个字符串， 所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。以下面的 HTML 代码为例： 1&lt;div class=&quot;bd user disabled&quot;&gt;...&lt;/div&gt; 这个&lt;div&gt;元素有 3 个类名。要想删除其中一个，就得先把 className 拆开，删除不想要的那个， 再把包含剩余类的字符串设置回去。比如： 12345678910111213141516// 要删除&quot;user&quot;类let targetClass = &quot;user&quot;;// 把类名拆成数组let classNames = div.className.split(/\\s+/);// 找到要删除类名的索引let idx = classNames.indexOf(targetClass);// 如果有则删除if (idx &gt; -1) &#123; classNames.splice(i,1);&#125;// 重新设置类名div.className = classNames.join(&quot; &quot;); 这就是从&lt;div&gt;元素的类名中删除”user”类要写的代码。替换类名和检测类名也要涉及同样的算 法。添加类名只涉及字符串拼接，但必须先检查一下以确保不会重复添加相同的类名。很多 JavaScript 库为这些操作实现了便利方法。 HTML5 通过给所有元素增加 classList 属性为这些操作提供了更简单也更安全的实现方式。 classList 是一个新的集合类型 DOMTokenList的实例。与其他 DOM集合类型一样，DOMTokenList 也有 length 属性表示自己包含多少项，也可以通过 item()或中括号取得个别的元素。此外， DOMTokenList 还增加了以下方法。 add(value) 向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。 contains(value) 返回布尔值，表示给定的 value 是否存在。 remove(value) 从类名列表中删除指定的字符串值 value。 toggle(value) 如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。 这样以来，前面的例子中那么多行代码就可以简化成下面的一行： 1div.classList.remove(&quot;user&quot;); 这行代码可以在不影响其他类名的情况下完成删除。其他方法同样极大地简化了操作类名的复杂性，如下面的例子所示： 123456789101112131415161718// 删除&quot;disabled&quot;类div.classList.remove(&quot;disabled&quot;);// 添加&quot;current&quot;类div.classList.add(&quot;current&quot;);// 切换&quot;user&quot;类div.classList.toggle(&quot;user&quot;);// 检测类名if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;))&#123; // 执行操作)// 迭代类名for (let class of div.classList)&#123; doStuff(class);&#125; 添加了 classList 属性之后，除非是完全删除或完全重写元素的 class 属性，否则 className 属性就用不到了。 焦点管理HTML5 增加了辅助 DOM 焦点管理的功能。首先是 document.activeElement，始终包含当前拥有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 focus()方法）让某个元素自动获得焦点。例如： 123let button = document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement === button); // true 默认情况下，document.activeElement 在页面刚加载完之后会设置为 document.body。而在页面完全加载之前，document.activeElement 的值为 null。 其次是 document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点： 123let button = document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.hasFocus()); // true 确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面。 第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点， 而这对于保证 Web 应用程序的无障碍使用是非常重要的。无障碍 Web 应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。 HTMLDocument扩展HTML5 扩展了 HTMLDocument 类型，增加了更多功能。与其他 HTML5 定义的 DOM 扩展一样， 这些变化同样基于所有浏览器事实上都已经支持的专有扩展。为此，即使这些扩展的标准化相对较晚， 很多浏览器也早就实现了相应的功能。 readyState属性 readyState 是 IE4 最早添加到 document 对象上的属性，后来其他浏览器也都依葫芦画瓢地支持 这个属性。最终，HTML5 将这个属性写进了标准。document.readyState 属性有两个可能的值： loading 表示文档正在加载 complete 表示文档加载完成 实际开发中，最好是把 document.readState 当成一个指示器，以判断文档是否加载完毕。在这 个属性得到广泛支持以前，通常要依赖 onload 事件处理程序设置一个标记，表示文档加载完了。这个 属性的基本用法如下： 123if (document.readyState == &quot;complete&quot;)&#123; // 执行操作&#125; compatMode属性 自从 IE6 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。 IE 为 document 添加了 compatMode 属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。 如下面的例子所示，标准模式下 document.compatMode 的值是”CSS1Compat”，而在混杂模式下， document.compatMode 的值是”BackCompat”： 12345if (document.compatMode == &quot;CSS1Compat&quot;)&#123; console.log(&quot;Standards mode&quot;);&#125; else &#123; console.log(&quot;Quirks mode&quot;);&#125; HTML5 最终也把 compatMode 属性的实现标准化了。 head属性 作为对 document.body（指向文档的元素）的补充，HTML5 增加了 document.head 属 性，指向文档的元素。可以像下面这样直接取得元素： 1let head = document.head; 字符集属性HTML5 增加了几个与文档字符集有关的新属性。其中，characterSet 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是”UTF-16”，但可以通过元素或响应头， 以及新增的 characterSeet 属性来修改。下面是一个例子： 12console.log(document.characterSet); // &quot;UTF-16&quot;document.characterSet = &quot;UTF-8&quot;; 自定义数据属性HTML5 允许给元素指定非标准的属性，但要使用前缀 data-以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，data-后 面跟什么都可以。下面是一个例子： 1&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt; 定义了自定义数据属性后，可以通过元素的 dataset 属性来访问。dataset 属性是一个 DOMStringMap 的实例，包含一组键&#x2F;值对映射。元素的每个 data-name 属性在 dataset 中都可以通过 data-后面的字符串作为键来访问（例如，属性 data-myname、data-myName 可以通过 myname 访 问，但要注意 data-my-name、data-My-Name 要通过 myName 来访问）。下面是一个使用自定义数据 属性的例子： 123456789101112// 本例中使用的方法仅用于示范let div = document.getElementById(&quot;myDiv&quot;);// 取得自定义数据属性的值let appId = div.dataset.appId;let myName = div.dataset.myname;// 设置自定义数据属性的值div.dataset.appId = 23456;div.dataset.myname = &quot;Michael&quot;;// 有&quot;myname&quot;吗？if (div.dataset.myname)&#123; console.log(`Hello, $&#123;div.dataset.myname&#125;`);&#125; 自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识 页面的不同部分。另外，单页应用程序框架也非常多地使用了自定义数据属性。 插入标记DOM 虽然已经为操纵节点提供了很多 API，但向文档中一次性插入大量 HTML 时还是比较麻烦。 相比先创建一堆节点，再把它们以正确的顺序连接起来，直接插入一个 HTML 字符串要简单（快速） 得多。HTML5 已经通过以下 DOM 扩展将这种能力标准化了。 innerHTML属性 在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。 而在写入 innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。 比如下面的 HTML 代码： 12345678&lt;div id=&quot;content&quot;&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于这里的&lt;div&gt;元素而言，其 innerHTML 属性会返回以下字符串： 123456&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。 因为所赋的值默认为 HTML，所以其中的所有标签都会以浏览器处理 HTML 的方式转换为元素。如果赋值中不包含任何 HTML 标签，则直接生成一个文本节点， 如下所示： 1div.innerHTML = &quot;Hello world!&quot;; 因为浏览器会解析设置的值，所以给 innerHTML 设置包含 HTML 的字符串时，结果会大不一样。 来看下面的例子： 1div.innerHTML = &quot;Hello &amp; welcome, &lt;b&gt;\\&quot;reader\\&quot;!&lt;/b&gt;&quot;; 这个操作的结果相当于： 1&lt;div id=&quot;content&quot;&gt;Hello &amp;amp; welcome, &lt;b&gt;&amp;quot;reader&amp;quot;!&lt;/b&gt;&lt;/div&gt; 设置完innerHTML，马上就可以像访问其他节点一样访问这些新节点。 outerHTML 属性 读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。在写入 outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。比如 下面的 HTML 代码： 12345678&lt;div id=&quot;content&quot;&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在这个&lt;div&gt;元素上调用 outerHTML 会返回相同的字符串，包括&lt;div&gt;本身。 如果使用 outerHTML 设置 HTML，比如： 1div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;; 则会得到与执行以下脚本相同的结果： 123let p = document.createElement(&quot;p&quot;);p.appendChild(document.createTextNode(&quot;This is a paragraph.&quot;));div.parentNode.replaceChild(p, div); 新的&lt;p&gt;元素会取代 DOM 树中原来的&lt;div&gt;元素。 insertAdjacentHTML()与 insertAdjacentText() 关于插入标签的最后两个新增方法是 insertAdjacentHTML()和 insertAdjacentText()。这两 个方法最早源自 IE，它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。第一个参数 必须是下列值中的一个： beforebegin 插入当前元素前面，作为前一个同胞节点； afterbegin 插入当前元素内部，作为新的子节点或放在第一个子节点前面； beforeend 插入当前元素内部，作为新的子节点或放在最后一个子节点后面； afterend 插入当前元素后面，作为下一个同胞节点。 注意这几个值是不区分大小写的。第二个参数会作为 HTML 字符串解析（与 innerHTML 和 outerHTML 相同）或者作为纯文本解析（与 innerText 和 outerText 相同）。如果是 HTML，则会在解析出错时抛出错误。下面展示了基本用法： 123456789101112131415// 作为前一个同胞节点插入element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);element.insertAdjacentText(&quot;beforebegin&quot;, &quot;Hello world!&quot;);// 作为第一个子节点插入element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);element.insertAdjacentText(&quot;afterbegin&quot;, &quot;Hello world!&quot;);// 作为最后一个子节点插入element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);element.insertAdjacentText(&quot;beforeend&quot;, &quot;Hello world!&quot;);// 作为下一个同胞节点插入element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); element.insertAdjacentText(&quot;afterend&quot;, &quot;Hello world!&quot;); 内存与性能问题 使用本节介绍的方法替换子节点可能在浏览器（特别是 IE）中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他 JavaScript 对象（作为元素的属性），那它们之间的绑定关 系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 innerHTML、 outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和 JavaScript 对象。 使用这些属性当然有其方便之处，特别是innerHTML。一般来讲，插入大量的新 HTML 使用 innerHTML 比使用多次 DOM 操作创建节点再插入来得更便捷。这是因为 HTML 解析器会解析设置给 innerHTML（或 outerHTML）的值。解析器在浏览器中是底层代码（通常是 C++代码），比 JavaScript 快得多。不过，HTML 解析器的构建与解构也不是没有代价，因此最好限制使用 innerHTML 和 outerHTML 的次数。比如，下面的代码使用 innerHTML 创建了一些列表项： 123for (let value of values)&#123; ul.innerHTML += &#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;; // 别这样做！&#125; 这段代码效率低，因为每次迭代都要设置一次 innerHTML。不仅如此，每次循环还要先读取 innerHTML，也就是说循环一次要访问两次 innerHTML。为此，最好通过循环先构建一个独立的字符串，最后再一次性把生成的字符串赋值给 innerHTML，比如： 12345let itemsHtml = &quot;&quot;;for (let value of values)&#123; itemsHtml += &#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;;&#125;ul.innerHTML = itemsHtml; 这样修改之后效率就高多了，因为只有对 innerHTML 的一次赋值。当然，像下面这样一行代码也可以搞定： 1ul.innerHTML = values.map(value =&gt; &#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;).join(&#x27;&#x27;); 跨站点脚本 尽管 innerHTML 不会执行自己创建的&lt;script&gt;标签，但仍然向恶意用户暴露了很大的攻击面，因 为通过它可以毫不费力地创建元素并执行 onclick 之类的属性。 如果页面中要使用用户提供的信息，则不建议使用 innerHTML。与使用 innerHTML 获得的方便相 比，防止 XSS 攻击更让人头疼。此时一定要隔离要插入的数据，在插入页面前必须毫不犹豫地使用相关的库对它们进行转义。 scrollIntoView()DOM 规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5 选择了标准化 scrollIntoView()。 scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下： alignToTop是一个布尔值 true 窗口滚动后元素的顶部与视口顶部对齐。 false 窗口滚动后元素的底部与视口底部对齐。 scrollIntoViewOptions是一个选项对象。 behavior 定义过渡动画，可取的值为”smooth”和”auto”，默认为”auto”。 block 定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “start”。 inline 定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “nearest”。 不传参数等同于 alignToTop 为 true。 来看几个例子： 123456789// 确保元素可见document.forms[0].scrollIntoView();// 同上document.forms[0].scrollIntoView(true);document.forms[0].scrollIntoView(&#123;block: &#x27;start&#x27;&#125;);// 尝试将元素平滑地滚入视口document.forms[0].scrollIntoView(&#123;behavior: &#x27;smooth&#x27;, block: &#x27;start&#x27;&#125;); 这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览器将元素滚动到可见位置。 专有扩展除了已经标准化的，各家浏览器还有很多未被标准化的专有扩展。而这些功能后来则有可能被标准化，比如进入 HTML5。 children属性IE9 之前的版本与其他浏览器在处理空白文本节点上的差异导致了 children 属性的出现。 children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点。如果元素的子节点类型全部是元素类型，那 children 和 childNodes 中包含的节点应该是一样的。可以像下面这样使 用 children 属性： 12let childCount = element.children.length;let firstChild = element.children[0]; contains()方法DOM 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 contains()方法， 让开发者可以在不遍历 DOM 的情况下获取这个信息。contains()方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。 如果目标节点是被搜索节点的后代，contains()返回 true，否则返回 false。下面看一个例子： 1console.log(document.documentElement.contains(document.body)); // true 这个例子测试元素中是否包含元素，在格式正确的 HTML 中会返回 true。 插入标记HTML5 将 IE 发明的 innerHTML 和 outerHTML 纳入了标准，但还有两个属性没有入选。这两个剩 下的属性是 innerText 和 outerText。 innerText属性 innerText 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时， innerText 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，innerText 会移除元素的所有后代并插入一个包含该值的文本节点。来看下面的 HTML 代码： 12345678&lt;div id=&quot;content&quot;&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对这个例子中的&lt;div&gt;而言，innerText 属性会返回以下字符串： 1234This is a paragraph with a list following it.Item 1Item 2Item 3 下面再看一个使用 innerText 设置&lt;div&gt;元素内容的例子： 1div.innerText = &quot;Hello world!&quot;; 执行这行代码后，HTML 页面中的这个&lt;div&gt;元素实际上会变成这个样子： 1&lt;div id=&quot;content&quot;&gt;Hello world!&lt;/div&gt; 设置 innerText 会移除元素之前所有的后代节点，完全改变 DOM 子树。此外，设置 innerText 也会编码出现在字符串中的 HTML 语法字符（小于号、大于号、引号及和号）。下面是一个例子： 1div.innerText = &quot;Hello &amp; welcome, &lt;b&gt;\\&quot;reader\\&quot;!&lt;/b&gt;&quot;; 执行之后的结果如下： 1&lt;div id=&quot;content&quot;&gt;Hello &amp;amp; welcome, &amp;lt;b&amp;gt;&amp;quot;reader&amp;quot;!&amp;lt;/b&amp;gt;&lt;/div&gt; 通过将 innerText 设置为等于 innerText，可以去除所有 HTML 标签而只剩文本，如下所示： 1div.innerText = div.innerText; 执行以上代码后，容器元素的内容只会包含原先的文本内容。 outerText属性 outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点。要读取文本值时， outerText 与 innerText 实际上会返回同样的内容。但在写入文本值时，outerText 就大不相同了。 写入文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素。比如： 1div.outerText = &quot;Hello world!&quot;; 这行代码的执行效果就相当于以下两行代码： 12let text = document.createTextNode(&quot;Hello world!&quot;);div.parentNode.replaceChild(text, div); 本质上，这相当于用新的文本节点替代 outerText 所在的元素。此时，原来的元素会与文档脱离关系，因此也无法访问。 outerText 是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。 滚动如前所述，滚动是 HTML5 之前 DOM 标准没有涉及的领域。虽然 HTML5 把 scrollIntoView() 标准化了，但不同浏览器中仍然有其他专有方法。比如，scrollIntoViewIfNeeded()作为 HTMLElement 类型的扩展可以在所有元素上调用。scrollIntoViewIfNeeded(alingCenter)会在 元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法 什么也不做。如果将可选的参数 alingCenter 设置为 true，则浏览器会尝试将其放在视口中央。Safari、 Chrome 和 Opera 实现了这个方法。 考虑到 scrollIntoView()是唯一一个所有浏览器都支持的方法，所以只用它就可以了。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(11)——DOM","slug":"JS高级程序设计读书笔记(11)——DOM","date":"2023-04-16T21:26:39.000Z","updated":"2023-11-27T15:34:23.878Z","comments":true,"path":"2023/04/17/JS高级程序设计读书笔记(11)——DOM/","link":"","permalink":"http://pvnk1u.github.io/2023/04/17/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(11)%E2%80%94%E2%80%94DOM/","excerpt":"","text":"文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示 由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早 期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页 的方式。 DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 DOM，主要因为它与浏览器中的 HTML 网页相关，并且在 JavaScript 中提供了 DOM API。 节点层级任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每 种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 HTML 为例： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 如果表示为层级结构，则如下图所示。 其中，document 节点表示每个文档的根节点。在这里，根节点的唯一子节点是元素，称之为文档元素（documentElement）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终是元素。在 XML 文档中， 则没有这样预定义的元素，任何元素都可能成为文档元素。 HTML 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 HTML 元素，属性 节点表示属性，文档类型节点表示文档类型，注释节点表示注释。DOM 中总共有 12 种节点类型，这些 类型都继承一种基本类型。 Node类型DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。Node 接口 在 JavaScript中被实现为 Node 类型，在除 IE之外的所有浏览器中都可以直接访问这个类型。在JavaScript 中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。 每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值 常量表示： Node.ELEMENT_NODE（1） Node.ATTRIBUTE_NODE（2） Node.TEXT_NODE（3） Node.CDATA_SECTION_NODE（4） Node.ENTITY_REFERENCE_NODE（5） Node.ENTITY_NODE（6） Node.PROCESSING_INSTRUCTION_NODE（7） Node.COMMENT_NODE（8） Node.DOCUMENT_NODE（9） Node.DOCUMENT_TYPE_NODE（10） Node.DOCUMENT_FRAGMENT_NODE（11） Node.NOTATION_NODE（12） 节点类型可通过与这些常量比较来确定，比如： 123if (someNode.nodeType == Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element.&quot;);&#125; 这个例子比较了 someNode.nodeType 与 Node.ELEMENT_NODE 常量。如果两者相等，则意味着 someNode 是一个元素节点。 浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。 nodeName与nodeValue nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用 这两个属性前，最好先检测节点类型，如下所示： 123if (someNode.nodeType == 1)&#123; value = someNode.nodeName; // 会显示元素的标签名&#125; 在这个例子中，先检查了节点是不是元素。如果是，则将其 nodeName 的值赋给一个变量。对元素 而言，nodeName 始终等于元素的标签名，而 nodeValue 则始终为 null。 节点关系 文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。 在 HTML 中，&lt;body&gt;元素是&lt;html&gt;元素的子元素，而&lt;html&gt;元素则是&lt;body&gt;元素的父元素。 &lt;head&gt;元素是&lt;body&gt;元素的同胞元素，因为它们有共同的父元素&lt;html&gt;。 每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例。NodeList 是一个类数组 对象，用于存储可以按位置存取的有序节点。注意，**NodeList 并不是 Array 的实例，但可以使用中括 号访问它的值，而且它也有 length 属性。NodeList 对象独特的地方在于，它其实是一个对 DOM 结 构的查询，因此 DOM 结构的变化会自动地在 NodeList 中反映出来。我们通常说 NodeList 是实时的 活动对象，而不是第一次访问时所获得内容的快照。** 下面的例子展示了如何使用中括号或使用 item()方法访问 NodeList 中的元素： 123let firstChild = someNode.childNodes[0];let secondChild = someNode.childNodes.item(1);let count = someNode.childNodes.length; 无论是使用中括号还是 item()方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个 类数组对象。注意，**length 属性表示那一时刻 NodeList 中节点的数量。使用 Array.prototype.slice()可以像前面介绍 arguments 时一样把 NodeList 对象转换为数组。**比如： 1let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); 当然，使用 ES6 的 Array.from()静态方法，可以替换这种笨拙的方式： 1let arrayOfNodes = Array.from(someNode.childNodes); 每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素。childNodes 中的所有节点都有同一个父元素，因此它们的 parentNode 属性都指向同一个节点。此外，childNodes 列表中的每个 节点都是同一列表中其他节点的同胞节点。而使用 previousSibling 和 nextSibling 可以在这个列表的节点间导航。这个列表中第一个节点的 previousSibling 属性是 null，最后一个节点的 nextSibling 属性也是 null，如下所示： 12345if (someNode.nextSibling === null)&#123; alert(&quot;Last node in the parent&#x27;s childNodes list.&quot;);&#125; else if (someNode.previousSibling === null)&#123; alert(&quot;First node in the parent&#x27;s childNodes list.&quot;);&#125; 注意，如果 childNodes 中只有一个节点，则它的 previousSibling 和 nextSibling 属性都是 null。 父节点和它的第一个及最后一个子节点也有专门属性：firstChild 和 lastChild 分别指向 childNodes 中的第一个和最后一个子节点。someNode.firstChild 的值始终等于 someNode. childNodes[0]，而 someNode.lastChild 的值始终等于 someNode.childNodes[someNode. childNodes.length-1]。如果只有一个子节点，则 firstChild 和 lastChild 指向同一个节点。如 果没有子节点，则 firstChild 和 lastChild 都是 null。上述这些节点之间的关系为在文档树的节 点之间导航提供了方便。 有了这些关系，childNodes 属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是 childNodes 的最大亮点。还有一个便利的方法是 hasChildNodes()，这个方法如果返回 true 则说明节点有一个或多个子节点。相比查询 childNodes 的 length 属性，这个方法无疑更方便。 最后还有一个所有节点都共享的关系。ownerDocument 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。 操纵节点 因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。最常用的方法是 appendChild()，用于在 childNodes 列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。appendChild()方法返回新添加的节点，如下所示： 123let returnedNode = someNode.appendChild(newNode);alert(returnedNode == newNode); // truealert(someNode.lastChild == newNode); // true 如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置。 即使 DOM 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此， 如果调用 appendChild()传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点， 如下所示： 1234// 假设 someNode 有多个子节点let returnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.firstChild); // falsealert(returnedNode == someNode.lastChild); // true 如果想把节点放到 childNodes 中的特定位置而不是末尾，则可以使用 insertBefore()方法。 这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是 null，则 insertBefore()与 appendChild()效果相同，如下面的例子所示： 123456789101112// 作为最后一个子节点插入returnedNode = someNode.insertBefore(newNode, null);alert(newNode == someNode.lastChild); // true// 作为新的第一个子节点插入returnedNode = someNode.insertBefore(newNode, someNode.firstChild);alert(returnedNode == newNode); // truealert(newNode == someNode.firstChild); // true// 插入最后一个子节点前面returnedNode = someNode.insertBefore(newNode, someNode.lastChild);alert(newNode == someNode.childNodes[someNode.childNodes.length - 2]); // true appendChild() 和 insertBefore() 在插入节点时不会删除任何已有节点。相对地， replaceChild()方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档 树中完全移除，要插入的节点会取而代之。下面看一个例子： 12345// 替换第一个子节点let returnedNode = someNode.replaceChild(newNode, someNode.firstChild);// 替换最后一个子节点returnedNode = someNode.replaceChild(newNode, someNode.lastChild); 使用 replaceChild()插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。 要移除节点而不是替换节点，可以使用 removeChild()方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示： 12345// 删除第一个子节点let formerFirstChild = someNode.removeChild(someNode.firstChild);// 删除最后一个子节点let formerLastChild = someNode.removeChild(someNode.lastChild); 与 replaceChild()方法一样，通过 removeChild()被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。 上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使 用前面介绍的 parentNode 属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用 这些方法，则会导致抛出错误。 其他方法 所有节点类型还共享了两个方法。第一个是 cloneNode()，会返回与调用它的节点一模一样的节点。cloneNode()方法接收一个布尔值参数，表示是否深复制。在传入 true 参数时，会进行深复制， 即复制节点及其整个子 DOM 树。如果传入 false，则只会复制调用该方法的节点。复制返回的节点属 于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过 appendChild()、 insertBefore()或 replaceChild()方法把孤儿节点添加到文档中。以下面的 HTML 片段为例： 12345&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt; 如果myList保存着对这个元素的引用，则下列代码展示了使用cloneNode()方法的两种方式： 12345let deepList = myList.cloneNode(true);alert(deepList.childNodes.length); // 3（IE9 之前的版本）或 7（其他浏览器）let shallowList = myList.cloneNode(false);alert(shallowList.childNodes.length); // 0 在这个例子中，deepList 保存着 myList 的副本。这意味着 deepList有 3 个列表项，每个列表项又各自包含文本。变量 shallowList 则保存着 myList 的浅副本，因此没有子节点。 deepList.childNodes.length 的值会因 IE8 及更低版本和其他浏览器对空格的处理方式而不同。IE9 之前的版本不会为空格创建节点。 本节要介绍的最后一个方法是 normalize()。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用 normalize()方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。 这个方法将在本章后面进一步讨论。 Document类型Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTMLDocument 的实例（HTMLDocument继承 Document），表示整个 HTML 页面。document 是 window 对象的属性，因此是一个全局对象。Document类型的节点有以下特征： nodeType等于9 nodeName值为”#document” nodeValue值为null parentNode值为null ownerDocument值为null 子节点可以是DocumentType(最多一个)、Element（最多一个）、ProcessingInstruction或Comment类型。 Document类型可以表示HTML页面或其他XML文档，但最常用的还是通过HTMLDocument的实例取得document对象。document对象可用于获取关于页面的信息以及操纵其外观和底层结构。 文档子节点 虽然 DOM 规范规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingInstruction 或 Comment，但也提供了两个访问子节点的快捷方式。第一个是 documentElement 属 性，始终指向 HTML 页面中的元素。虽然 document.childNodes 中始终有元素，但使用 documentElement 属性可以更快更直接地访问该元素。假如有以下简单的页面： 1234&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 浏览器解析完这个页面之后，文档只有一个子节点，即元素。这个元素既可以通过 documentElement 属性获取，也可以通过 childNodes 列表访问，如下所示： 123let html = document.documentElement; // 取得对&lt;html&gt;的引用alert(html === document.childNodes[0]); // truealert(html === document.firstChild); // true 这个例子表明 documentElement、firstChild 和 childNodes[0]都指向同一个值，即元素。 作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向元素。因为 这个元素是开发者使用最多的元素，所以 JavaScript 代码中经常可以看到 document.body，比如： 1let body = document.body; // 取得对&lt;body&gt;的引用 所有主流浏览器都支持 document.documentElement 和 document.body。 Document 类型另一种可能的子节点是 DocumentType。标签是文档中独立的部分， 其信息可以通过 doctype 属性（在浏览器中是 document.doctype）来访问，比如： 1let doctype = document.doctype; // 取得对&lt;!doctype&gt;的引用 另外，严格来讲出现在元素外面的注释也是文档的子节点，它们的类型是 Comment。不过， 由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下 HTML 页面： 123456&lt;!-- 第一条注释 --&gt;&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 第二条注释 --&gt; 这个页面看起来有 3 个子节点：注释、元素、注释。逻辑上讲，document.childNodes 应该包含 3 项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待元素外部的 注释，比如忽略一个或两个注释。 一般来说，appendChild()、removeChild()和 replaceChild()方法不会用在 document 对象 上。这是因为文档类型（如果存在）是只读的，而且只能有一个 Element 类型的子节点（即&lt;html&gt;， 已经存在了）。 文档信息 document 作为 HTMLDocument 的实例，还有一些标准 Document 对象上所没有的属性。这些属性 提供浏览器所加载网页的信息。其中第一个属性是 title，包含&lt;title&gt;元素中的文本，通常显示在浏 览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题 栏上。不过，修改 title 属性并不会改变&lt;title&gt;元素。下面是一个例子： 12345// 读取文档标题let originalTitle = document.title;// 修改文档标题document.title = &quot;New page title&quot;; 接下来要介绍的 3 个属性是 URL、domain 和 referrer。其中，URL 包含当前页面的完整 URL（地址栏中的 URL），domain 包含页面的域名，而 referrer 包含链接到当前页面的那个页面的 URL。如 果当前页面没有来源，则 referrer 属性包含空字符串。所有这些信息都可以在请求的 HTTP 头部信息 中获取，只是在 JavaScript 中通过这几个属性暴露出来而已，如下面的例子所示： 12345678// 取得完整的 URLlet url = document.URL;// 取得域名let domain = document.domain;// 取得来源let referrer = document.referrer; URL 跟域名是相关的。比如，如果 document.URL 是 http://www.wrox.com/WileyCDA/，则 document.domain 就是 www.wrox.com。 在这些属性中，只有 domain 属性是可以设置的。出于安全考虑，给 domain 属性设置的值是有限制的。如果 URL包含子域名如 p2p.wrox.com，则可以将 domain 设置为”wrox.com”（URL包含“www” 时也一样，比如 www.wrox.com）。不能给这个属性设置 URL 中不包含的值，比如： 123// 页面来自 p2p.wrox.comdocument.domain = &quot;wrox.com&quot;; // 成功document.domain = &quot;nczonline.net&quot;; // 出错！ 当页面中包含来自某个不同子域的窗格（&lt;frame&gt;）或内嵌窗格（&lt;iframe&gt;)时，设置document.domain是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。此时，在每个页面上把 document.domain 设置为相同的值，这些页面就可以访问对方的 JavaScript 对象了。比如，一个加载自 www.wrox.com 的页面中包含一个内嵌窗格，其中的页面加载自 p2p.wrox.com。这两个页面的 document.domain 包含不同的字符串，内部和外部页面相互之间不能 访问对方的 JavaScript对象。如果每个页面都把 document.domain 设置为 wrox.com，那这两个页面之间就可以通信了。 浏览器对 domain 属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把 document.domain 设置为”wrox.com”之后，就不能再将其设置回”p2p.wrox.com”，后者会导致错误，比如： 123// 页面来自 p2p.wrox.comdocument.domain = &quot;wrox.com&quot;; // 放松，成功document.domain = &quot;p2p.wrox.com&quot;; // 收紧，错误 定位元素 使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。 document 对象上暴露了一些方法，可以实现这些操作。getElementById()和 getElementsByTagName()就是 Document 类型提供的两个方法。 getElementById()方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果 没找到则返回 null。参数 ID 必须跟元素在页面中的 id 属性值完全匹配，包括大小写。比如页面中有以下元素： 1&lt;div id=&quot;myDiv&quot;&gt;Some text&lt;/div&gt; 可以使用如下代码取得这个元素： 1let div = document.getElementById(&quot;myDiv&quot;); // 取得对这个&lt;div&gt;元素的引用 但参数大小写不匹配会返回 null： 1let div = document.getElementById(&quot;mydiv&quot;); // null 如果页面中存在多个具有相同 ID 的元素，则 getElementById()返回在文档中出现的第一个元素。 getElementsByTagName()是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 NodeList。在 HTML 文档中，这个方法返回一个 HTMLCollection 对象。考虑到二者都是“实时”列表，HTMLCollection 与 NodeList 是很相似的。 例如，下面的代码会取得页面中所有的&lt;img&gt;元素并返回包含它们的 HTMLCollection： 1let images = document.getElementsByTagName(&quot;img&quot;); 这里把返回的 HTMLCollection 对象保存在了变量 images 中。与 NodeList 对象一样，也可以 使用中括号或 item()方法从 HTMLCollection 取得特定的元素。而取得元素的数量同样可以通过 length 属性得知，如下所示： 123alert(images.length); // 图片数量alert(images[0].src); // 第一张图片的 src 属性alert(images.item(0).src); // 同上 HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项 的引用。例如，假设页面中包含如下的&lt;img&gt;元素： 1&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt; 那么也可以像这样从 images 中取得对这个&lt;img&gt;元素的引用： 1let myImage = images.namedItem(&quot;myImage&quot;); 这样，HTMLCollection 就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了 便利。对于 name 属性的元素，还可以直接使用中括号来获取，如下面的例子所示： 1let myImage = images[&quot;myImage&quot;]; 对 HTMLCollection 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台， 数值索引会调用 item()，字符串索引会调用 namedItem()。 要取得文档中的所有元素，可以给 getElementsByTagName()传入*。在 JavaScript 和 CSS 中，* 一般被认为是匹配一切的字符。来看下面的例子： 1let allElements = document.getElementsByTagName(&quot;*&quot;); 这行代码可以返回包含页面中所有元素的 HTMLCollection 对象，顺序就是它们在页面中出现的 顺序。因此第一项是&lt;html&gt;元素，第二项是&lt;head&gt;元素，以此类推。 HTMLDocument 类型上定义的获取元素的第三个方法是 getElementsByName()。顾名思义，这个 方法会返回具有给定 name 属性的所有元素。getElementsByName()方法最常用于单选按钮，因为同 一字段的单选按钮必须具有相同的 name 属性才能确保把正确的值发送给服务器，比如下面的例子： 1234567891011121314151617&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt; &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt; &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt; &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/fieldset&gt; 这里所有的单选按钮都有名为”color”的 name 属性，但它们的 ID 都不一样。这是因为 ID 是为了 匹配对应的元素，而 name 相同是为了保证只将三个中的一个值发送给服务器。然后就可以像 下面这样取得所有单选按钮： 1let radios = document.getElementsByName(&quot;color&quot;); 与 getElementsByTagName()一样，getElementsByName()方法也返回 HTMLCollection。不 过在这种情况下，namedItem()方法只会取得第一项（因为所有项的 name 属性都一样）。 特殊集合 document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。 document.anchors包含文档中所有带 name 属性的&lt;a&gt;元素。 document.applets 包含文档中所有元素（因为元素已经不建议使用，所 以这个集合已经废弃）。 document.forms 包含文档中所有元素（与 document.getElementsByTagName (&quot;form&quot;) 返回的结果相同）。 document.images 包含文档中所有&lt;img&gt;元素（与 document.getElementsByTagName (&quot;img&quot;) 返回的结果相同)。 document.links 包含文档中所有带 href 属性的&lt;a&gt;元素。 这些特殊集合始终存在于 HTMLDocument 对象上，而且与所有 HTMLCollection 对象一样，其内容也会实时更新以符合当前文档的内容。 DOM兼容性检测 由于 DOM 有多个 Level和多个部分，因此确定浏览器实现了 DOM 的哪些部分是很必要的。 document.implementation 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。 DOM Level 1 在 document.implementation 上只定义了一个方法，即 hasFeature()。这个方法接收两个参数：特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则 hasFeature()方法返回 true，如下面的例子所示： 1let hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;); 由于实现不一致，因此 hasFeature()的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回 true。 文档写入 document 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：write()、 writeln()、open()和 close()。其中，write()和 writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中。write()简单地写入文本，而 writeln()还会在字符串末尾追加一个换行符 （\\n）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示： 123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;The current date and time is: &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;&lt;strong&gt;&quot; + (new Date()).toString() + &quot;&lt;/strong&gt;&quot;); &lt;/script&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这个例子会在页面加载过程中输出当前日期和时间。日期放在了&lt;strong&gt;元素中，如同它们之前 就包含在 HTML 页面中一样。这意味着会创建一个 DOM 元素，以后也可以访问。通过 write()和 writeln()输出的任何 HTML 都会以这种方式来处理。 write()和 writeln()方法经常用于动态包含外部资源，如 JavaScript 文件。在包含 JavaScript 文 件时，记住不能像下面的例子中这样直接包含字符串””，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;file.js\\&quot;&gt;&quot; + &quot;&lt;/script&gt;&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虽然这样写看起来没错，但输出之后的”&lt;/script&gt;“会匹配最外层的&lt;script&gt;标签，导致页面中 显示出”);。为避免出现这个问题，需要对前面的例子稍加修改： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;file.js\\&quot;&gt;&quot; + &quot;&lt;\\/script&gt;&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里的字符串”&lt;\\/script&gt;“不会再匹配最外层的&lt;script&gt;标签，因此不会在页面中输出额外内容。 前面的例子展示了在页面渲染期间通过 document.write()向文档中输出内容。如果是在页面加 载完之后再调用 document.write()，则输出的内容会重写整个页面，如下面的例子所示： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is some content that you won&#x27;t get to see because it will be overwritten.&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.write(&quot;Hello world!&quot;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个例子使用了 window.onload 事件处理程序，将调用 document.write()的函数推迟到页面 加载完毕后执行。执行之后，字符串”Hello world!”会重写整个页面内容。 open()和 close()方法分别用于打开和关闭网页输出流。在调用 write()和 writeln()时，这两 个方法都不是必需的。 Element类型除了Document 类型，Element 类型就是Web开发中最常用的类型了。Element 表示XML或HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。Element 类型的节点具有以下特征： nodeType等于1 nodeName值为元素的标签名 nodeValue值为null parentNode值为Document或Element对象 子节点可以是Element、Text、Comment、ProcessingInstruction、CDTASection、EntityReference类型。 可以通过 nodeName 或 tagName 属性来获取元素的标签名。这两个属性返回同样的值（添加后一 个属性明显是为了不让人误会）。比如有下面的元素： 1&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; 可以像这样取得这个元素的标签名： 123let div = document.getElementById(&quot;myDiv&quot;);alert(div.tagName); // &quot;DIV&quot;alert(div.tagName == div.nodeName); // true 例子中的元素标签名为 div，ID 为”myDiv”。注意，div.tagName 实际上返回的是”DIV”而不是 “div”。在 HTML 中，元素标签名始终以全大写表示；在 XML（包括 XHTML）中，标签名始终与源 代码中的大小写一致。如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较： 1234567if (element.tagName == &quot;div&quot;)&#123; // 不要这样做，可能出错！ // do something here&#125;if (element.tagName.toLowerCase() == &quot;div&quot;)&#123; // 推荐，适用于所有文档 // 做点什么&#125; HTML元素 所有 HTML 元素都通过 HTMLElement 类型表示，包括其直接实例和间接实例。另外，HTMLElement 直接继承 Element 并增加了一些属性。每个属性都对应下列属性之一，它们是所有 HTML 元素上都有 的标准属性： id，元素在文档中的唯一标识符 title，包含元素的额外信息，通常以提示条形式展示 lang，元素内容的语言代码（很少用） dir，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右向左，同样很少用） className，相当于class属性，用于指定元素的 CSS 类（因为 class 是 ECMAScript 关键字， 所以不能直接用这个名字）。 所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 HTML 元素： 1&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt; 这个元素中的所有属性都可以使用下列 JavaScript 代码读取： 123456let div = document.getElementById(&quot;myDiv&quot;);alert(div.id); // &quot;myDiv&quot;alert(div.className); // &quot;bd&quot;alert(div.title); // &quot;Body text&quot;alert(div.lang); // &quot;en&quot;alert(div.dir); // &quot;ltr&quot; 而且，可以使用下列代码修改元素的属性： 12345div.id = &quot;someOtherId&quot;;div.className = &quot;ft&quot;;div.title = &quot;Some other text&quot;;div.lang = &quot;fr&quot;;div.dir =&quot;rtl&quot;; 并非所有这些属性的修改都会对页面产生影响。比如，把 id 或 lang 改成其他值对用户是不可见 的（假设没有基于这两个属性应用 CSS 样式），而修改 title 属性则只会在鼠标移到这个元素上时才会 反映出来。修改 dir 会导致页面文本立即向左或向右对齐。修改 className 会立即反映应用到新类名 的 CSS 样式（如果定义了不同的样式）。 如前所述，所有 HTML 元素都是 HTMLElement 或其子类型的实例。下表列出了所有 HTML 元素 及其对应的类型（斜体表示已经废弃的元素）。 元素 类型 元素 类型 A HTMLAnchorElement COL HTMLTableColElement ABBR HTMLElement COLGROUP HTMLTableColElement ACRONYM HTMLElement DD HTMLElement ADDRESS HTMLElement DEL HTMLModElement APPLET HTMLAppletElement DFN HTMLElement AREA HTMLAreaElement DIR HTMLDirectoryElement B HTMLElement DIV HTMLDivElement BASE HTMLBaseElement DL HTMLDListElement BASEFONT HTMLBaseFontElement DT HTMLElement BDO HTMLElement EM HTMLElement BIG HTMLElement FIELDSET HTMLFieldSetElement BLOCKQUOTE HTMLQuoteElement FONT HTMLFontElement BODY HTMLBodyElement FORM HTMLFormElement BR HTMLBRElement FRAME HTMLFrameElement BUTTON HTMLButtonElement FRAMESET HTMLFrameSetElement CAPTION HTMLTableCaptionElement H1 HTMLHeadingElement CENTER HTMLElement H2 HTMLHeadingElement CITE HTMLElement H3 HTMLHeadingElement CODE HTMLElement H4 HTMLHeadingElement H5 HTMLHeadingElement PRE HTMLPreElement H6 HTMLHeadingElement Q HTMLQuoteElement HEAD HTMLHeadElement S HTMLElement HR HTMLHRElement SAMP HTMLElement HTML HTMLHtmlElement SCRIPT HTMLScriptElement I HTMLElement SELECT HTMLSelectElement IFRAME HTMLIFrameElement SMALL HTMLElement IMG HTMLImageElement SPAN HTMLElement INPUT HTMLInputElement STRIKE HTMLElement INS HTMLModElement STRONG HTMLElement ISINDEX HTMLIsIndexElement STYLE HTMLStyleElement KBD HTMLElement SUB HTMLElement LABEL HTMLLabelElement SUP HTMLElement LEGEND HTMLLegendElement TABLE HTMLTableElement LI HTMLLIElement TBODY HTMLTableSectionElement LINK HTMLLinkElement TD HTMLTableCellElement MAP HTMLMapElement TEXTAREA HTMLTextAreaElement MENU HTMLMenuElement TFOOT HTMLTableSectionElement META HTMLMetaElement TH HTMLTableCellElement NOFRAMES HTMLElement THEAD HTMLTableSectionElement NOSCRIPT HTMLElement TITLE HTMLTitleElement OBJECT HTMLObjectElement TR HTMLTableRowElement OL HTMLOListElement TT HTMLElement OPTGROUP HTMLOptGroupElement U HTMLElement OPTION HTMLOptionElement UL HTMLUListElement P HTMLParagraphElement VAR HTMLElement PARAM HTMLParamElement 这里列出的每种类型都有关联的属性和方法。接下来的内容会涉及其中的很多类型。 取得属性 每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 DOM 方法 主要有 3 个：getAttribute()、setAttribute()和 removeAttribute()。这些方法主要用于操纵属性，包括在 HTMLElement 类型上定义的属性。下面看一个例子： 123456let div = document.getElementById(&quot;myDiv&quot;);alert(div.getAttribute(&quot;id&quot;)); // &quot;myDiv&quot;alert(div.getAttribute(&quot;class&quot;)); // &quot;bd&quot;alert(div.getAttribute(&quot;title&quot;)); // &quot;Body text&quot;alert(div.getAttribute(&quot;lang&quot;)); // &quot;en&quot;alert(div.getAttribute(&quot;dir&quot;)); // &quot;ltr&quot; 注意传给 getAttribute()的属性名与它们实际的属性名是一样的，因此这里要传”class”而非”className”（className 是作为对象属性时才那么拼写的）。如果给定的属性不存在，则 getAttribute() 返回 null。 getAttribute()方法也能取得不是 HTML 语言正式属性的自定义属性的值。比如下面的元素： 1&lt;div id=&quot;myDiv&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt; 这个元素有一个自定义属性 my_special_attribute，值为”hello!”。可以像其他属性一样使用 getAttribute()取得这个属性的值： 1let value = div.getAttribute(&quot;my_special_attribute&quot;); 注意，属性名不区分大小写，因此”ID”和”id”被认为是同一个属性。另外，根据 HTML5 规范的 要求，自定义属性名应该前缀 data-以方便验证。 元素的所有属性也可以通过相应 DOM 元素对象的属性来取得。当然，这包括 HTMLElement 上定义的直接映射对应属性的 5 个属性，还有所有公认（非自定义）的属性也会被添加为 DOM 对象的属性。 比如下面的例子： 1&lt;div id=&quot;myDiv&quot; align=&quot;left&quot; my_special_attribute=&quot;hello&quot;&gt;&lt;/div&gt; 因为 id 和 align 在 HTML 中是元素公认的属性，所以 DOM 对象上也会有这两个属性。但 my_special_attribute 是自定义属性，因此不会成为 DOM 对象的属性。 通过 DOM 对象访问的属性中有两个返回的值跟使用 getAttribute()取得的值不一样。首先是 style 属性，这个属性用于为元素设定 CSS 样式。在使用 getAttribute()访问 style 属性时，返回的 是 CSS 字符串。而在通过 DOM 对象的属性访问时，style 属性返回的是一个（CSSStyleDeclaration） 对象。DOM 对象的 style 属性用于以编程方式读写元素样式，因此不会直接映射为元素中 style 属性的字符串值。 第二个属性其实是一类，即事件处理程序（或者事件属性），比如 onclick。在元素上使用事件属 性时（比如 onclick），属性的值是一段 JavaScript 代码。如果使用 getAttribute()访问事件属性， 则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的则是一个 JavaScript 函数（未指定该属性则返回 null）。这是因为 onclick 及其他事件属性是可以接受函数作为值的。 考虑到以上差异，开发者在进行DOM编程时通常会放弃使用getAttribute()而只使用对象属性。 getAttribute()主要用于取得自定义属性的值。 设置属性 与 getAttribute()配套的方法是 setAttribute()，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则 setAttribute()会以指定的值替换原来的值；如果属性不存在， 则 setAttribute()会以指定的值创建该属性。下面看一个例子： 12345div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);div.setAttribute(&quot;class&quot;, &quot;ft&quot;);div.setAttribute(&quot;title&quot;, &quot;Some other text&quot;);div.setAttribute(&quot;lang&quot;,&quot;fr&quot;);div.setAttribute(&quot;dir&quot;, &quot;rtl&quot;); setAttribute()适用于 HTML 属性，也适用于自定义属性。另外，使用 setAttribute()方法 设置的属性名会规范为小写形式，因此”ID”会变成”id”。 因为元素属性也是 DOM 对象属性，所以直接给 DOM 对象的属性赋值也可以设置元素属性的值， 如下所示： 12div.id = &quot;someOtherId&quot;;div.align = &quot;left&quot;; 注意，在 DOM 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性： 12div.mycolor = &quot;red&quot;;alert(div.getAttribute(&quot;mycolor&quot;)); // null（IE 除外） 这个例子添加了一个自定义属性 mycolor 并将其值设置为”red”。在多数浏览器中，这个属性不 会自动变成元素属性。因此调用 getAttribute()取得 mycolor 的值会返回 null。 最后一个方法 removeAttribute()用于从元素中删除属性。这样不单单是清除属性的值，而是会 把整个属性完全从元素中去掉，如下所示： 1div.removeAttribute(&quot;class&quot;); 这个方法用得并不多，但在序列化 DOM 元素时可以通过它控制要包含的属性。 attributes属性 Element 类型是唯一使用 attributes 属性的 DOM 节点类型。attributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。元素的每个属性都表示为一个 Attr 节 点，并保存在这个 NamedNodeMap 对象中。NamedNodeMap 对象包含下列方法： getNamedItem(name)，返回 nodeName 属性等于 name 的节点； removeNamedItem(name)，删除 nodeName 属性等于 name 的节点； setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引； item(pos)，返回索引位置 pos 处的节点。 attributes属性中的每个节点的 nodeName 是对应属性的名字，nodeValue 是属性的值。比如， 要取得元素 id 属性的值，可以使用以下代码： 1let id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue; 下面是使用中括号访问属性的简写形式： 1let id = element.attributes[&quot;id&quot;].nodeValue; 同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值，如下所示： 1element.attributes[&quot;id&quot;].nodeValue = &quot;someOtherId&quot;; removeNamedItem()方法与元素上的 removeAttribute()方法类似，也是删除指定名字的属性。 下面的例子展示了这两个方法唯一的不同之处，就是removeNamedItem()返回表示被删除属性的Attr 节点： 1let oldAttr = element.attributes.removeNamedItem(&quot;id&quot;); setNamedItem()方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示： 1element.attributes.setNamedItem(newAttr); 一般来说，因为使用起来更简便，通常开发者更喜欢使用 getAttribute()、removeAttribute() 和 setAttribute()方法，而不是刚刚介绍的 NamedNodeMap 对象的方法。 attributes 属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 DOM 结构 序列化为 XML 或 HTML 字符串。比如，以下代码能够迭代一个元素上的所有属性并以 attribute1= &quot;value1&quot; attribute2=&quot;value2&quot;的形式生成格式化字符串： 12345678function outputAttributes(element) &#123; let pairs = []; for (let i = 0, len = element.attributes.length; i &lt; len; ++i) &#123; const attribute = element.attributes[i]; pairs.push(`$&#123;attribute.nodeName&#125;=&quot;$&#123;attribute.nodeValue&#125;&quot;`); &#125; return pairs.join(&quot; &quot;);&#125; 这个函数使用数组存储每个名&#x2F;值对，迭代完所有属性后，再将这些名&#x2F;值对用空格拼接在一起。（这 个技术常用于序列化为长字符串。）这个函数中的 for 循环使用 attributes.length 属性迭代每个属 性，将每个属性的名字和值输出为字符串。不同浏览器返回的 attributes 中的属性顺序也可能不一样。 HTML 或 XML 代码中属性出现的顺序不一定与 attributes 中的顺序一致。 创建元素 可以使用 document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素 的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档（包括 XHTML）是区分大小写 的。要创建元素，可以使用下面的代码： 1let div = document.createElement(&quot;div&quot;); 使用 createElement()方法创建新元素的同时也会将其 ownerDocument 属性设置为 document。 此时，可以再为其添加属性、添加更多子元素。比如： 12div.id = &quot;myNewDiv&quot;;div.className = &quot;box&quot;; 在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用 appendChild()、insertBefore()或 replaceChild()。 比如，以下代码会把刚才创建的元素添加到文档的元素中： 1document.body.appendChild(div); 元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。 元素后代 元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。childNodes 属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在 识别这些节点时的表现有明显不同。比如下面的代码： 12345&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 在解析以上代码时，&lt;ul&gt;元素会包含 7 个子元素，其中 3 个是&lt;li&gt;元素，还有 4 个 Text 节点（表示&lt;li&gt;元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点： 1&lt;ul id=&quot;myList&quot;&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 所有浏览器解析上面的代码后，&lt;ul&gt;元素都会包含 3 个子节点。考虑到这种情况，通常在执行某个 操作之后需要先检测一下节点的 nodeType，如下所示： 12345for (let i = 0, len = element.childNodes.length; i &lt; len; ++i) &#123; if (element.childNodes[i].nodeType == 1) &#123; // 执行某个操作 &#125;&#125; 以上代码会遍历某个元素的子节点，并且只在 nodeType 等于 1（即 Element 节点）时执行某个操作。 要取得某个元素的子节点和其他后代节点，可以使用元素的 getElementsByTagName()方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面&lt;ul&gt;的例子，可以像下面这样取得其所有的&lt;li&gt;元素： 12let ul = document.getElementById(&quot;myList&quot;);let items = ul.getElementsByTagName(&quot;li&quot;); 这里例子中的&lt;ul&gt;元素只有一级子节点，如果它包含更多层级，则所有层级中的&lt;li&gt;元素都会返回。 Text节点Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。Text 类型的节点具有以下特征： nodeType 等于 3； nodeName 值为”#text”； nodeValue 值为节点中包含的文本； parentNode 值为 Element 对象； 不支持子节点。 Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问，这两个属性包含相同的值。修改 nodeValue 或 data 的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法： appendData(text)，向节点末尾添加文本 text； deleteData(offset, count)，从位置 offset 开始删除 count 个字符； insertData(offset, text)，在位置 offset 插入 text； replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的 文本； splitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点； substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。 除了这些方法，还可以通过 length 属性获取文本节点中包含的字符数量。这个值等于 nodeValue. length 和 data.length。 默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如： 12345678&lt;!-- 没有内容，因此没有文本节点 --&gt;&lt;div&gt;&lt;/div&gt;&lt;!-- 有空格，因此有一个文本节点 --&gt;&lt;div&gt; &lt;/div&gt;&lt;!-- 有内容，因此有一个文本节点 --&gt;&lt;div&gt;Hello World!&lt;/div&gt; 示例中的第一个&lt;div&gt;元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个&lt;div&gt;元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的 nodeValue 就是一个空格。第三个&lt;div&gt;元素也有一个文本节点的子节点，其nodeValue 的值为”Hello World!”。下列代码可以用来访问这个文本节点： 1let textNode = div.firstChild; // 或 div.childNodes[0] 取得文本节点的引用后，可以像这样来修改它： 1div.firstChild.nodeValue = &quot;Some other message&quot;; 只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是 HTML 或 XML 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示： 12// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot;div.firstChild.nodeValue = &quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;; 这实际上是在将 HTML 字符串插入 DOM 文档前进行编码的有效方式。 创建文本节点 document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。 跟设置已有文本节点的值一样，这些要插入的文本也会应用 HTML 或 XML 编码，如下面的例子所示： 1let textNode = document.createTextNode(&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;); 创建新文本节点后，其 ownerDocument 属性会被设置为 document。但在把这个节点添加到文档 树之前，我们不会在浏览器中看到它。以下代码创建了一个元素并给它添加了一段文本消息： 1234567let element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;let textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);document.body.appendChild(element); 这个例子首先创建了一个&lt;div&gt;元素并给它添加了值为”message”的 class 属性，然后又创建了 一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。 一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示： 12345678910let element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;let textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element); 在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。 规范化文本节点 DOM 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样， DOM 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法 叫 normalize()，是在 Node 类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用 normalize()时，所有同胞文本节点会被合并为一个文本节点，这个 文本节点的 nodeValue 就等于之前所有同胞节点 nodeValue 拼接在一起得到的字符串。来看下面的例子： 12345678910111213141516let element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;let textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length); // 2element.normalize();alert(element.childNodes.length); // 1alert(element.firstChild.nodeValue); // &quot;Hello world!Yippee!&quot; 浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 DOM 脚本生成的文档树中。 拆分文本节点 Text 类型定义了一个与 normalize()相反的方法——splitText()。这个方法可以在指定的偏移位置拆分 nodeValue，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到 偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点 相同的 parentNode。来看下面的例子： 123456789101112let element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;let textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);document.body.appendChild(element);let newNode = element.firstChild.splitText(5);alert(element.firstChild.nodeValue); // &quot;Hello&quot;alert(newNode.nodeValue); // &quot; world!&quot;alert(element.childNodes.length); // 2 在这个例子中，包含”Hello world!”的文本节点被从位置 5 拆分成两个文本节点。位置 5 对应 “Hello”和”world!”之间的空格，因此原始文本节点包含字符串”Hello”，而新文本节点包含文本” world!”（包含空格）。 拆分文本节点最常用于从文本节点中提取数据的 DOM 解析技术。 Comment类型DOM 中的注释通过Comment类型表示。Comment类型的节点具有以下特征： nodeType等于8 nodeName值为”#comment”； nodeValue 值为注释的内容； parentNode 值为 Document 或 Element 对象； 不支持子节点。 Comment 类型与 Text 类型继承同一个基类（CharacterData），因此拥有除 splitText()之外 Text 节点所有的字符串操作方法。与 Text 类型相似，注释的实际内容可以通过 nodeValue 或 data 属性获得。 注释节点可以作为父节点的子节点来访问。比如下面的 HTML 代码： 1&lt;div id=&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;/div&gt; 这里的注释是&lt;div&gt;元素的子节点，这意味着可以像下面这样访问它： 123let div = document.getElementById(&quot;myDiv&quot;);let comment = div.firstChild;alert(comment.data); // &quot;A comment&quot; DOM编程很多时候，操作 DOM 是很直观的。通过 HTML 代码能实现的，也一样能通过 JavaScript 实现。但 有时候，DOM 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 DOM 的某些方面会复杂一些。 动态脚本&lt;script&gt;元素用于向网页中插入 JavaScript 代码，可以是 src 属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。与对应的 HTML 元素一样，有两种方式通过&lt;script&gt;动态为网页添加脚本：引入外部文件和直接插入源代码。 动态加载外部文件很容易实现，比如下面的&lt;script&gt;元素： 1&lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt; 可以像这样通过 DOM 编程创建这个节点： 123let script = document.createElement(&quot;script&quot;);script.src = &quot;foo.js&quot;;document.body.appendChild(script); 这里的 DOM 代码实际上完全照搬了它要表示的 HTML 代码。注意，在上面最后一行把&lt;script&gt;元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到&lt;head&gt;元素，同样可以实 现动态脚本加载。这个过程可以抽象为一个函数，比如： 12345function loadScript(url) &#123; let script = document.createElement(&quot;script&quot;); script.src = url; document.body.appendChild(script);&#125; 然后，就可以像下面这样加载外部 JavaScript 文件了： 1loadScript(&quot;client.js&quot;); 加载之后，这个脚本就可以对页面执行操作了。这里有个问题：怎么能知道脚本什么时候加载完？ 这个问题并没有标准答案，具体情况取决于使用的浏览器。 另一个动态插入 JavaScript 的方式是嵌入源代码，如下面的例子所示： 12345&lt;script&gt; function sayHi() &#123; alert(&quot;hi&quot;); &#125;&lt;/script&gt; 使用 DOM，可以实现以下逻辑： 123let script = document.createElement(&quot;script&quot;);script.appendChild(document.createTextNode(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;));document.body.appendChild(script); 以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在 全局作用域中把源代码传给 eval()方法。 注意，通过 innerHTML 属性创建的&lt;script&gt;元素永远不会执行。浏览器会尽责地创建script元素，以及其中的脚本文本，但解析器会给这个&lt;script&gt;元素打上永不执行的标签。只要是使用 innerHTML 创建的&lt;script&gt;元素，以后也没有办法强制其执行。 动态样式CSS 样式在 HTML页面中可以通过两个元素加载。元素用于包含 CSS 外部文件，而&lt;style&gt;元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。 来看下面这个典型的&lt;link&gt;元素： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; 这个元素很容易使用 DOM 编程创建出来： 123456let link = document.createElement(&quot;link&quot;);link.rel = &quot;stylesheet&quot;;link.type = &quot;text/css&quot;;link.href = &quot;styles.css&quot;;let head = document.getElementsByTagName(&quot;head&quot;)[0];head.appendChild(link); 以上代码在所有主流浏览器中都能正常运行。注意应该把&lt;link&gt;元素添加到&lt;head&gt;元素而不是&lt;body&gt;元素，这样才能保证所有浏览器都能正常运行。这个过程可以抽象为以下通用函数： 12345678function loadStyles(url)&#123; let link = document.createElement(&quot;link&quot;); link.rel = &quot;stylesheet&quot;; link.type = &quot;text/css&quot;; link.href = url; let head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(link);&#125; 然后就可以这样调用这个 loadStyles()函数了： 1loadStyles(&quot;styles.css&quot;); 通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后 顺序。一般来说，也没有必要知道样式什么时候加载完成。 另一种定义样式的方式是使用&lt;script&gt;元素包含嵌入的 CSS 规则，例如： 12345&lt;style type=&quot;text/css&quot;&gt; body &#123; background-color: red; &#125;&lt;/style&gt; 逻辑上，下列 DOM 代码会有同样的效果： 12345let style = document.createElement(&quot;style&quot;);style.type = &quot;text/css&quot;;style.appendChild(document.createTextNode(&quot;body&#123;background-color:red&#125;&quot;));let head = document.getElementsByTagName(&quot;head&quot;)[0];head.appendChild(style); 操作表格表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建&lt;table&gt;元素，通常要涉及大量标签，包 括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。假设要通过 DOM 来创建以下 HTML 表格： 123456789101112&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell 1,2&lt;/td&gt; &lt;td&gt;Cell 2,2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 下面就是以 DOM 编程方式重建这个表格的代码： 12345678910111213141516171819202122232425262728293031// 创建表格let table = document.createElement(&quot;table&quot;);table.border = 1;table.width = &quot;100%&quot;;// 创建表体let tbody = document.createElement(&quot;tbody&quot;);table.appendChild(tbody);// 创建第一行let row1 = document.createElement(&quot;tr&quot;);tbody.appendChild(row1);let cell1_1 = document.createElement(&quot;td&quot;);cell1_1.appendChild(document.createTextNode(&quot;Cell 1,1&quot;));row1.appendChild(cell1_1);let cell2_1 = document.createElement(&quot;td&quot;);cell2_1.appendChild(document.createTextNode(&quot;Cell 2,1&quot;));row1.appendChild(cell2_1);// 创建第二行let row2 = document.createElement(&quot;tr&quot;);tbody.appendChild(row2);let cell1_2 = document.createElement(&quot;td&quot;);cell1_2.appendChild(document.createTextNode(&quot;Cell 1,2&quot;));row2.appendChild(cell1_2);let cell2_2= document.createElement(&quot;td&quot;);cell2_2.appendChild(document.createTextNode(&quot;Cell 2,2&quot;));row2.appendChild(cell2_2);// 把表格添加到文档主体document.body.appendChild(table); 以上代码相当烦琐，也不好理解。为了方便创建表格，HTML DOM 给&lt;table&gt;、&lt;tbody&gt;和&lt;tr&gt;元素添加了一些属性和方法。 &lt;table&gt;&gt;元素添加了以下属性和方法： caption，指向&#96;&#96;&#96;元素的指针（如果存在） tBodies，包含&lt;tbody&gt;元素的 HTMLCollection； tFoot，指向&lt;tfoot&gt;元素（如果存在） tHead，指向&lt;thead&gt;元素（如果存在） rows，包含表示所有行的 HTMLCollection； createTHead()，创建&lt;thead&gt;元素，放到表格中，返回引用； createTFoot()，创建&lt;tfoot&gt;元素，放到表格中，返回引用； createCaption()，创建&lt;caption&gt;元素，放到表格中，返回引用； deleteTHead()，删除&lt;thead&gt;元素； deleteTFoot()，删除&lt;tfoot&gt;元素； deleteCaption()，删除&lt;caption&gt;元素； deleteRow(pos)，删除给定位置的行； insertRow(pos)，在行集合中给定位置插入一行。 &lt;tbody&gt;元素添加了以下属性和方法： rows，包含&lt;tbody&gt;元素中所有行的 HTMLCollection； deleteRow(pos)，删除给定位置的行； insertRow(pos)，在行集合中给定位置插入一行，返回该行的引用。 &lt;tr&gt;元素添加了以下属性和方法： cells，包含&lt;tr&gt;元素所有表元的 HTMLCollection； deleteCell(pos)，删除给定位置的表元； insertCell(pos)，在表元集合给定位置插入一个表元，返回该表元的引用。 这些属性和方法极大地减少了创建表格所需的代码量。例如，使用这些方法重写前面的代码之后是 这样的（加粗代码表示更新的部分）： 12345678910111213141516171819202122232425// 创建表格let table = document.createElement(&quot;table&quot;);table.border = 1;table.width = &quot;100%&quot;;// 创建表体let tbody = document.createElement(&quot;tbody&quot;);table.appendChild(tbody);// 创建第一行tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));// 创建第二行tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));// 把表格添加到文档主体document.body.appendChild(table); 这里创建&lt;table&gt;和&lt;tbody&gt;元素的代码没有变。变化的是创建两行的部分，这次使用了 HTML DOM 表格的属性和方法。创建第一行时，在&lt;tbody&gt;元素上调用了 insertRow()方法。传入参数 0， 表示把这一行放在什么位置。然后，使用 tbody.rows[0]来引用这一行，因为这一行刚刚创建并被添 加到了&lt;tbody&gt;的位置 0。 创建表元的方式也与之类似。在&lt;tr&gt;元素上调用 insertCell()方法，传入参数 0，表示把这个表元放在什么位置上。然后，使用 tbody.rows[0].cells[0]来引用这个表元，因为这个表元刚刚创建 并被添加到了&lt;tr&gt;的位置 0。 虽然以上两种代码在技术上都是正确的，但使用这些属性和方法创建表格让代码变得更有逻辑性， 也更容易理解。 使用NodeList理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，NodeList 就是基于 DOM 文档的实时查询。例如，下面的代码会导致无穷循环： 123456let divs = document.getElementsByTagName(&quot;div&quot;);for (let i = 0; i &lt; divs.length; ++i)&#123; let div = document.createElement(&quot;div&quot;); document.body.appendChild(div);&#125; 使用 ES6 迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导 致无穷循环： 1234for (let div of document.getElementsByTagName(&quot;div&quot;))&#123; let newDiv = document.createElement(&quot;div&quot;); document.body.appendChild(newDiv);&#125; 任何时候要迭代 NodeList，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这 个变量进行比较，如下所示： 12345let divs = document.getElementsByTagName(&quot;div&quot;);for (let i = 0, len = divs.length; i &lt; len; ++i) &#123; let div = document.createElement(&quot;div&quot;); document.body.appendChild(div);&#125; 在这个例子中，又初始化了一个保存集合长度的变量 len。因为 len 保存着循环开始时集合的长度， 而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。本章还会使用这种技术来演示迭代 NodeList 对象的首选方式。 另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合： 12345let divs = document.getElementsByTagName(&quot;div&quot;);for (let i = divs.length - 1; i &gt;= 0; --i) &#123; let div = document.createElement(&quot;div&quot;); document.body.appendChild(div);&#125; 一般来说，最好限制操作 NodeList 的次数。因为每次查询都会搜索整个文档，所以最好把查询到 的 NodeList 缓存起来。 MutationObserver接口不久前添加到 DOM 规范中的 MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使 用 MutationObserver 可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。 基本用法MutationObserver 的实例要通过调用 MutationObserver 构造函数并传入一个回调函数来创建： 1let observer = new MutationObserver(() =&gt; console.log(&#x27;DOM was mutated!&#x27;)); observe()方法 新创建的 MutationObserver 实例不会关联 DOM 的任何部分。要把这个 observer 与 DOM 关 联起来，需要使用 observe()方法。这个方法接收两个必需的参数：要观察其变化的 DOM 节点，以及 一个 MutationObserverInit 对象。 MutationObserverInit 对象用于控制观察哪些方面的变化，是一个键&#x2F;值对形式配置选项的字典。 例如，下面的代码会创建一个观察者（observer）并配置它观察元素上的属性变化： 12let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body, &#123; attributes: true &#125;); 执行以上代码后，&lt;body&gt;元素上任何属性发生变化都会被这个 MutationObserver 实例发现，然 后就会异步执行注册的回调函数。元素后代的修改或其他非属性修改都不会触发回调进入任务 队列。可以通过以下代码来验证： 123456789let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;;console.log(&#x27;Changed body class&#x27;);// Changed body class// &lt;body&gt; attributes changed 注意，回调中的console.log()是后执行的。这表明回调并非与实际的 DOM 变化同步执行。 回调与MutationRecord 每个回调都会收到一个 MutationRecord 实例的数组。MutationRecord 实例包含的信息包括发 生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 MutationRecord 实例的数组。 下面展示了反映一个属性变化的 MutationRecord 实例的数组： 12345678910111213141516171819let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; attributes: true &#125;);document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// [// &#123;// addedNodes: NodeList [],// attributeName: &quot;foo&quot;,// attributeNamespace: null,// nextSibling: null,// oldValue: null,// previousSibling: null// removedNodes: NodeList [],// target: body// type: &quot;attributes&quot;// &#125;// ] 下面是一次涉及命名空间的类似变化： 12345678910111213141516171819let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; attributes: true &#125;);document.body.setAttributeNS(&#x27;baz&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;);// [// &#123;// addedNodes: NodeList [],// attributeName: &quot;foo&quot;,// attributeNamespace: &quot;baz&quot;,// nextSibling: null,// oldValue: null,// previousSibling: null// removedNodes: NodeList [],// target: body// type: &quot;attributes&quot;// &#125;// ] 连续修改会生成多个 MutationRecord 实例，下次回调执行时就会收到包含所有这些实例的数组， 顺序为变化事件发生的顺序： 12345678910let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;;document.body.className = &#x27;bar&#x27;;document.body.className = &#x27;baz&#x27;;// [MutationRecord, MutationRecord, MutationRecord] 下表列出了 MutationRecord 实例的属性。 属性 说明 target 被修改影响的目标节点 type 字符串，表示变化的类型：”attributes”、”characterData”或”childList” oldValue 如果在 MutationObserverInit 对象中启用（attributeOldValue 或 characterData OldValue 为 true），”attributes”或”characterData”的变化事件会设置这个属性为被替代的值 “childList”类型的变化始终将这个属性设置为 null attributeName 对于”attributes”类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null attributeNamespace 对于使用了命名空间的”attributes”类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null addedNodes 对于”childList”类型的变化，返回包含变化中添加节点的 NodeList 默认为空 NodeList removedNodes 对于”childList”类型的变化，返回包含变化中删除节点的 NodeList 默认为空 NodeList previousSibling 对于”childList”类型的变化，返回变化节点的前一个同胞 Node 默认为 null nextSibling 对于”childList”类型的变化，返回变化节点的后一个同胞 Node 默认为 null 传给回调函数的第二个参数是观察变化的 MutationObserver 的实例，演示如下： 123456let observer = new MutationObserver( (mutationRecords, mutationObserver) =&gt; console.log(mutationRecords,mutationObserver));observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;;// [MutationRecord], MutationObserver disconnect()方法 默认情况下，只要被观察的元素不被垃圾回收，MutationObserver 的回调就会响应 DOM 变化事 件，从而被执行。要提前终止执行回调，可以调用 disconnect()方法。下面的例子演示了同步调用 disconnect()之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调： 1234567891011let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;;observer.disconnect();document.body.className = &#x27;bar&#x27;;//（没有日志输出） 要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用 disconnect()： 123456789101112let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;;setTimeout(() =&gt; &#123; observer.disconnect(); document.body.className = &#x27;bar&#x27;;&#125;, 0);// &lt;body&gt; attributes changed 复用 MutationObserver 多次调用 observe()方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。此 时，MutationRecord 的 target 属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程： 12345678910111213141516171819let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt;x.target)));// 向页面主体添加两个子节点let childA = document.createElement(&#x27;div&#x27;), childB = document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);// 观察两个子节点observer.observe(childA, &#123; attributes: true &#125;);observer.observe(childB, &#123; attributes: true &#125;);// 修改两个子节点的属性childA.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// [&lt;div&gt;, &lt;span&gt;] disconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标： 123456789101112131415161718192021let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt;x.target)));// 向页面主体添加两个子节点let childA = document.createElement(&#x27;div&#x27;), childB = document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);// 观察两个子节点observer.observe(childA, &#123; attributes: true &#125;);observer.observe(childB, &#123; attributes: true &#125;);observer.disconnect();// 修改两个子节点的属性childA.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// （没有日志输出） 重用 MutationObserver 调用 disconnect()并不会结束 MutationObserver 的生命。还可以重新使用这个观察者，再将 它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与元素的关联： 12345678910111213141516171819202122232425let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributeschanged&#x27;)); observer.observe(document.body, &#123; attributes: true &#125;);// 这行代码会触发变化事件document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);setTimeout(() =&gt; &#123; observer.disconnect(); // 这行代码不会触发变化事件 document.body.setAttribute(&#x27;bar&#x27;, &#x27;baz&#x27;);&#125;, 0);setTimeout(() =&gt; &#123; // Reattach observer.observe(document.body, &#123; attributes: true &#125;); // 这行代码会触发变化事件 document.body.setAttribute(&#x27;baz&#x27;, &#x27;qux&#x27;);&#125;, 0);// &lt;body&gt; attributes changed// &lt;body&gt; attributes changed MutationObserverInit 与观察范围MutationObserverInit 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。 下表列出了 MutationObserverInit 对象的属性。 属性 说明 subtree 布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是 false，则只观察目标节点的变化；如果是 true，则观察目标节点及其整个子树 默认为 false attributes 布尔值，表示是否观察目标节点的属性变化 默认为 false attributeFilter 字符串数组，表示要观察哪些属性的变化 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为观察所有属性 attributeOldValue 布尔值，表示 MutationRecord 是否记录变化之前的属性值 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为 false characterData 布尔值，表示修改字符数据是否触发变化事件 默认为 false characterDataOldValue 布尔值，表示 MutationRecord 是否记录变化之前的字符数据 把这个值设置为 true 也会将 characterData 的值转换为 true 默认为 false childList 布尔值，表示修改目标节点的子节点是否触发变化事件 默认为 false 在调用 observe()时，MutationObserverInit 对象中的 attribute、characterData 和 childList 属性必须至少有一项为 true（无论是直接设置这几个属性，还是通过设置 attributeOldValue 等属性间接导致它们的值转换为 true）。否则会抛出错误，因为没有任何变化事件可能触发回调。 观察属性 MutationObserver 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 MutationObserverInit 对象中将 attributes 属性设置为 true，如下所示： 12345678910111213141516let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; attributes: true &#125;);// 添加属性document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// 修改属性document.body.setAttribute(&#x27;foo&#x27;, &#x27;baz&#x27;);// 移除属性document.body.removeAttribute(&#x27;foo&#x27;);// 以上变化都被记录下来了// [MutationRecord, MutationRecord, MutationRecord] 把 attributes 设置为 true 的默认行为是观察所有属性，但不会在 MutationRecord 对象中记 录原来的属性值。如果想观察某个或某几个属性，可以使用 attributeFilter 属性来设置白名单，即 一个属性名字符串数组： 123456789101112let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; attributeFilter: [&#x27;foo&#x27;] &#125;);// 添加白名单属性document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// 添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;, &#x27;qux&#x27;);// 只有 foo 属性的变化被记录了// [MutationRecord] 如果想在变化记录中保存属性原来的值，可以将 attributeOldValue 属性设置为 true： 1234567891011let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.oldValue)));observer.observe(document.body, &#123; attributeOldValue: true &#125;);document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);document.body.setAttribute(&#x27;foo&#x27;, &#x27;baz&#x27;);document.body.setAttribute(&#x27;foo&#x27;, &#x27;qux&#x27;);// 每次变化都保留了上一次的值// [null, &#x27;bar&#x27;, &#x27;baz&#x27;] 观察字符数据 MutationObserver 可以观察文本节点（如 Text、Comment或 ProcessingInstruction 节点） 中字符的添加、删除和修改。要为字符数据注册回调，需要在 MutationObserverInit对象中将 characterData 属性设置为 true，如下所示： 12345678910111213141516171819let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));// 创建要观察的文本节点document.body.firstChild.textContent = &#x27;foo&#x27;;observer.observe(document.body.firstChild, &#123; characterData: true &#125;);// 赋值为相同的字符串document.body.firstChild.textContent = &#x27;foo&#x27;;// 赋值为新字符串document.body.firstChild.textContent = &#x27;bar&#x27;;// 通过节点设置函数赋值document.body.firstChild.textContent = &#x27;baz&#x27;;// 以上变化都被记录下来了// [MutationRecord, MutationRecord, MutationRecord] 将 characterData 属性设置为 true 的默认行为不会在 MutationRecord 对象中记录原来的字符 数据。如果想在变化记录中保存原来的字符数据，可以将 characterDataOldValue 属性设置为 true： 123456789101112let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.oldValue)));document.body.innerText = &#x27;foo&#x27;;observer.observe(document.body.firstChild, &#123; characterDataOldValue: true &#125;);document.body.innerText = &#x27;foo&#x27;;document.body.innerText = &#x27;bar&#x27;;document.body.firstChild.textContent = &#x27;baz&#x27;;// 每次变化都保留了上一次的值// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;] 观察子节点 MutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 MutationObserverInit 对象中将 childList 属性设置为 true。 下面的例子演示了添加子节点： 1234567891011121314151617181920// 清空主体document.body.innerHTML = &#x27;&#x27;;let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; childList: true &#125;);document.body.appendChild(document.createElement(&#x27;div&#x27;));// [// &#123;// addedNodes: NodeList[div],// attributeName: null,// attributeNamespace: null,// oldValue: null,// nextSibling: null,// previousSibling: null,// removedNodes: NodeList[],// target: body,// type: &quot;childList&quot;,// &#125;// ] 下面的例子演示了移除子节点： 1234567891011121314151617181920212223// 清空主体document.body.innerHTML = &#x27;&#x27;;let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; childList: true &#125;);document.body.appendChild(document.createElement(&#x27;div&#x27;));// [// &#123;// addedNodes: NodeList[],// attributeName: null,// attributeNamespace: null,// oldValue: null,// nextSibling: null,// previousSibling: null,// removedNodes: NodeList[div],// target: body,// type: &quot;childList&quot;,// &#125;// ] 对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移 除和再添加： 1234567891011121314151617181920212223242526272829303132333435363738394041// 清空主体document.body.innerHTML = &#x27;&#x27;;let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));// 创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;));document.body.appendChild(document.createElement(&#x27;span&#x27;));observer.observe(document.body, &#123; childList: true &#125;);// 交换子节点顺序document.body.insertBefore(document.body.lastChild, document.body.firstChild);// 发生了两次变化：第一次是节点被移除，第二次是节点被添加// [// &#123;// addedNodes: NodeList[],// attributeName: null,// attributeNamespace: null,// oldValue: null,// nextSibling: null,// previousSibling: div,// removedNodes: NodeList[span],// target: body,// type: childList,// &#125;,// &#123;// addedNodes: NodeList[span],// attributeName: null,// attributeNamespace: null,// oldValue: null,// nextSibling: div,// previousSibling: null,// removedNodes: NodeList[],// target: body,// type: &quot;childList&quot;,// &#125;// ] 观察子树 默认情况下，MutationObserver 将观察的范围限定为一个元素及其子节点的变化。可以把观察 的范围扩展到这个元素的子树（所有后代节点），这需要在 MutationObserverInit 对象中将 subtree 属性设置为 true。 下面的代码展示了观察元素及其后代节点属性的变化： 12345678910111213141516171819202122232425// 清空主体document.body.innerHTML = &#x27;&#x27;;let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));// 创建一个后代document.body.appendChild(document.createElement(&#x27;div&#x27;));// 观察&lt;body&gt;元素及其子树observer.observe(document.body, &#123; attributes: true, subtree: true &#125;);// 修改&lt;body&gt;元素的子树document.body.firstChild.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// 记录了子树变化的事件// [// &#123;// addedNodes: NodeList[],// attributeName: &quot;foo&quot;,// attributeNamespace: null,// oldValue: null,// nextSibling: null,// previousSibling: null,// removedNodes: NodeList[],// target: div,// type: &quot;attributes&quot;,// &#125;// ] 有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。 下面的代码演示了这种情况： 1234567891011121314151617181920212223// 清空主体document.body.innerHTML = &#x27;&#x27;;let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));let subtreeRoot = document.createElement(&#x27;div&#x27;), subtreeLeaf = document.createElement(&#x27;span&#x27;);// 创建包含两层的子树document.body.appendChild(subtreeRoot);subtreeRoot.appendChild(subtreeLeaf);// 观察子树observer.observe(subtreeRoot, &#123; attributes: true, subtree: true &#125;);// 把节点转移到其他子树document.body.insertBefore(subtreeLeaf, subtreeRoot);subtreeLeaf.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;);// 移出的节点仍然触发变化事件// [MutationRecord] 异步回调与记录队列MutationObserver 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在 大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 MutationRecord 实例中，然后添加到记录队列。这个队列对每个 MutationObserver 实例都是唯一的，是所有 DOM 变化事件的有序列表。 记录队列 每次 MutationRecord 被添加到 MutationObserver 的记录队列时，仅当之前没有已排期的微任 务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 MutationObserver 时传入） 作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。 不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一 个 MutationRecord 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一 个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 MutationRecord 就用不着了， 因此记录队列会被清空，其内容会被丢弃。 takeRecords()方法 调用 MutationObserver 实例的 takeRecords()方法可以清空记录队列，取出并返回其中的所 有 MutationRecord 实例。看这个例子： 1234567891011121314let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;;document.body.className = &#x27;bar&#x27;;document.body.className = &#x27;baz&#x27;;console.log(observer.takeRecords());console.log(observer.takeRecords());// [MutationRecord, MutationRecord, MutationRecord]// [] 这在希望断开与观察目标的联系，但又希望处理由于调用 disconnect()而被抛弃的记录队列中的 MutationRecord 实例时比较有用。 性能、内存与垃圾回收DOM Level 2 规范中描述的 MutationEvent 定义了一组会在各种 DOM 变化时触发的事件。由于 浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。 MutationObserver 接口就是为替代这些事件而设计的更实用、性能更好的方案。 将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 MutationObserver 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。 无论如何，使用 MutationObserver 仍然不是没有代价的。因此理解什么时候避免出现这种情况就很重要了。 MutationObserver 的引用 MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要 观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。 然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后 被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。 MutationRecord 的引用 记录队列中的每个 MutationRecord 实例至少包含对已有 DOM 节点的一个引用。如果变化是 childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理 每个 MutationRecord，然后让它们超出作用域并被垃圾回收。 有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存 它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 MutationRecord 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(10)——BOM","slug":"JS高级程序设计读书笔记(10)——BOM","date":"2023-04-15T21:26:39.000Z","updated":"2023-11-27T15:34:23.878Z","comments":true,"path":"2023/04/16/JS高级程序设计读书笔记(10)——BOM/","link":"","permalink":"http://pvnk1u.github.io/2023/04/16/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(10)%E2%80%94%E2%80%94BOM/","excerpt":"","text":"虽然 ECMAScript 把浏览器对象模型（BOM，Browser Object Model）描述为 JavaScript 的核心，但 实际上 BOM 是使用 JavaScript 开发 Web 应用程序的核心。BOM 提供了与网页无关的浏览器功能对象。 多年来，BOM 是在缺乏规范的背景下发展起来的，因此既充满乐趣又问题多多。毕竟，浏览器开发商 都按照自己的意愿来为它添砖加瓦。最终，浏览器实现之间共通的部分成为了事实标准，为 Web 开发 提供了浏览器间互操作的基础。HTML5 规范中有一部分涵盖了 BOM 的主要内容，因为 W3C 希望将 JavaScript 在浏览器中最基础的部分标准化。 window对象BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是 ECMAScript 中的 Global 对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有 对象、变量和函数都以 window作为其 Global对象，都可以访问其上定义的 parseInt()等全局方法。 Global作用域因为 window 对象被复用为 ECMAScript的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。比如： 123456var age = 29;var sayAge = () =&gt; alert(this.age);alert(window.age); // 29sayAge(); // 29window.sayAge(); // 29 这里，变量 age 和函数 sayAge()被定义在全局作用域中，它们自动成为了 window 对象的成员。 因此，变量 age 可以通过 window.age 来访问，而函数 sayAge()也可以通过 window.sayAge()来访问。 因为 sayAge()存在于全局作用域，this.age 映射到 window.age，所以就可以显示正确的结果了。 如果在这里使用 let 或 const 替代 var，则不会把变量添加给全局对象： 123456let age = 29;const sayAge = () =&gt; alert(this.age);alert(window.age); // undefinedsayAge(); // undefinedwindow.sayAge(); // TypeError: window.sayAge is not a function 另外，访问未声明的变量会抛出错误，但是可以在 window 对象上查询是否存在可能未声明的变量。 比如： 12345// 这会导致抛出错误，因为 oldValue 没有声明var newValue = oldValue;// 这不会抛出错误，因为这里是属性查询// newValue 会被设置为 undefinedvar newValue = window.oldValue; JavaScript 中有很多对象都暴露在全局作用域中，比如 location 和 navigator，因而它们也是 window 对象的属性。 窗口关系top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top（都等于 window）。最上层的 window 如果不是通过 window.open()打开的，那么其 name 属性就不会包含值。 还有一个 self 对象，它是终极 window 属性，始终会指向 window。实际上，self 和 window 就 是同一个对象。之所以还要暴露 self，就是为了和 top、parent 保持一致。 这些属性都是 window 对象的属性，因此访问 window.parent、window.top 和 window.self 都可以。这意味着可以把访问多个窗口的 window 对象串联起来，比如 window.parent.parent。 窗口位置与像素比window 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 screenLeft 和 screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。 可以使用 moveTo()和 moveBy()方法移动窗口。这两个方法都接收两个参数，其中 moveTo()接收要移动到的新位置的绝对坐标 x 和 y；而 moveBy()则接收相对当前位置在两个方向上移动的像素数。 比如： 1234567891011// 把窗口移动到左上角window.moveTo(0,0);// 把窗口向下移动 100 像素window.moveBy(0, 100); // 把窗口移动到坐标位置(200, 300)window.moveTo(200, 300);// 把窗口向左移动 50 像素window.moveBy(-50, 0); 窗口大小在不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持 4 个属性： innerWidth、innerHeight、outerWidth 和 outerHeight。outerWidth 和 outerHeight 返回浏 览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格中使用）。innerWidth 和 innerHeight 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。 document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回页面视口的宽度和高度。 定时器JavaScript 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就 执行相应的代码。setTimeout()用于指定在一定时间后执行某些代码，而 setInterval()用于指定 每隔一段时间执行某些代码。 setTimeout()方法通常接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）。第 一个参数可以是包含 JavaScript 代码的字符串（类似于传给 eval()的字符串）或者一个函数，比如： 12// 在 1 秒后显示警告框setTimeout(() =&gt; alert(&quot;Hello world!&quot;), 1000); 第二个参数是要等待的毫秒数，而不是要执行代码的确切时间。JavaScript 是单线程的，所以每次 只能执行一段代码。为了调度不同代码的执行，JavaScript 维护了一个任务队列。其中的任务会按照添 加到队列的先后顺序执行。setTimeout()的第二个参数只是告诉 JavaScript 引擎在指定的毫秒数过后 把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待 前面的任务执行完才能执行。 调用 setTimeout()时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超 时 ID，如下面的例子所示： 12345// 设置超时任务let timeoutId = setTimeout(() =&gt; alert(&quot;Hello world!&quot;), 1000);// 取消超时任务clearTimeout(timeoutId); 只要是在指定时间到达之前调用 clearTimeout()，就可以取消超时任务。在任务执行后再调用 clearTimeout()没有效果。 setInterval()与 setTimeout()的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。setInterval()同样可以接收两个参数：要执行的代码（字符 串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。下面是一个例子： 1setInterval(() =&gt; alert(&quot;Hello world!&quot;), 10000); 这里的关键点是，第二个参数，也就是间隔时间，指的是向队列添加新任务之前等 待的时间。比如，调用 setInterval()的时间为 01:00:00，间隔时间为 3000 毫秒。这意 味着 01:00:03 时，浏览器会把任务添加到执行队列。浏览器不关心这个任务什么时候执行 或者执行要花多长时间。因此，到了 01:00:06，它会再向队列中添加一个任务。由此可看 出，执行时间短、非阻塞的回调函数比较适合 setInterval()。 setInterval()方法也会返回一个循环定时 ID，可以用于在未来某个时间点上取消循环定时。要 取消循环定时，可以调用 clearInterval()并传入定时 ID。相对于 setTimeout()而言，取消定时的能力对 setInterval()更加重要。毕竟，如果一直不管它，那么定时任务会一直执行到页面卸载。 setIntervale()在实践中很少会在 生产环境下使用，因为一个任务结束和下一个任务开始之间的时间间隔是无法保证的，有些循环定时任务可能会因此而被跳过。而像前面这个例子中一样使用 setTimeout()则能确保不会出现这种情况。一 般来说，最好不要使用 setInterval()。 系统对话框使用 alert()、confirm()和 prompt()方法，可以让浏览器调用系统对话框向用户显示消息。这 些对话框与浏览器中显示的网页无关，而且也不包含 HTML。它们的外观由操作系统或者浏览器决定， 无法使用 CSS 设置。此外，这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行， 在它们消失以后，代码才会恢复执行。 确认框，通过调用 confirm()来显示。确认框跟警告框类似，都会向用户显示消 息。但不同之处在于，确认框有两个按钮：“Cancel”（取消）和“OK”（确定）。用户通过单击不同的按 钮表明希望接下来执行什么操作。要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值：true 表示单击 了 OK 按钮，false 表示单击了 Cancel 按钮或者通过单击某一角上的 X 图标关闭了确认框。 最后一种对话框是提示框，通过调用 prompt()方法来显示。提示框的用途是提示用户输入消息。 除了 OK 和 Cancel 按钮，提示框还会显示一个文本框，让用户输入内容。prompt()方法接收两个参数： 要显示给用户的文本，以及文本框的默认值（可以是空字符串）。 如果用户单击了 OK 按钮，则 prompt()会返回文本框中的值。如果用户单击了 Cancel 按钮，或者 对话框被关闭，则 prompt()会返回 null。 location对象location 是最有用的 BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。 这个对象独特的地方在于，它既是 window 的属性，也是 document 的属性。也就是说， window.location 和 document.location 指向同一个对象。location 对象不仅保存着当前加载文 档的信息，也保存着把 URL 解析为离散片段后能够通过属性访问的信息。 假设浏览器当前加载的 URL 是 http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents，location 对象的内容如下表所示。 属性 值 说明 location.hash “#contents” URL 散列值（井号后跟零或多个字符），如果没有则 为空字符串 location.host “www.wrox.com:80“ 服务器名及端口号 location.hostname “www.wrox.com“ 服务器名 location.href “http://www.wrox.com:80/WileyCDA/ ?q&#x3D;javascript#contents” 当前加载页面的完整 URL。location 的 toString() 方法返回这个值 location.pathname “&#x2F;WileyCDA&#x2F;“ URL 中的路径和（或）文件名 location.port “80 请求的端口。如果 URL中没有端口，则返回空字符串 location.protocol “http:” 页面使用的协议。通常是”http:”或”https:” location.search “?q&#x3D;javascript” URL 的查询字符串。这个字符串以问号开头 location.username “foouser” 域名前指定的用户名 location.password “barpassword” 域名前指定的密码 location.origin “http://www.wrox.com“ URL 的源地址。只读","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(9)——期约与异步函数","slug":"JS高级程序设计读书笔记(9)——期约与异步函数","date":"2023-03-13T18:26:39.000Z","updated":"2023-11-27T15:34:23.884Z","comments":true,"path":"2023/03/14/JS高级程序设计读书笔记(9)——期约与异步函数/","link":"","permalink":"http://pvnk1u.github.io/2023/03/14/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(9)%E2%80%94%E2%80%94%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/","excerpt":"","text":"ECMAScript 6 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特 性。ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用 async和 await 关键字定义异步函数的机制。 本章示例将大量使用异步日志输出的方式 setTimeout(console.log, 0, ... params)，旨在演示执行顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约等返回的值达到其最终状态。 此外，浏览器控制台的输出经常能打印出 JavaScript 运行中无法获取的对象信息（比如期约的状态）。 异步编程同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。 重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线 程执行，那么任何时候都可以使用。 同步与异步同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。 同步操作的例子可以是执行一次简单的数学计算： 12let x = 3;x = x + 4; 在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。 这两行 JavaScript 代码对应的低级指令（从 JavaScript 到 x86）并不难想象。首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。 相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。 异步操作的例子可以是在定时回调中执行一次简单的数学计算： 12let x = 3;setTimeout(() =&gt; x = x + 4, 1000); 这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值 何时会改变，因为这取决于回调何时从消息队列出列并执行。 异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发 这个中断，这对 JavaScript 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前 线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法 知道系统状态何时变化。 为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。 设计一个能够知道 x 什么时候可以读取的系统是非常难的。JavaScript 在实现这样一个系统的过程中也经历了几次迭代。 以往的异步编程模式异步行为是 JavaScript 的基础，但以前的实现不理想。在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回 调地狱”）来解决。 假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作： 12345function double(value) &#123; setTimeout(() =&gt; setTimeout(console.log, 0, value * 2), 1000);&#125;double(3);// 6（大约 1000 毫秒之后） 这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout 可以定义一个 在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，JavaScript 运行时会把回 调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 JavaScript 代码 就完全不可见了。还有一点，double()函数在 setTimeout 成功调度异步操作之后会立即退出。 异步返回值 假设 setTimeout 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。 12345function double(value, callback) &#123; setTimeout(() =&gt; callback(value * 2), 1000);&#125;double(3, (x) =&gt; console.log(`I was given: $&#123;x&#125;`));// I was given: 6（大约 1000 毫秒之后） 这里的 setTimeout 调用告诉 JavaScript 运行时在 1000 毫秒之后把一个函数推到消息队列上。这 个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。 失败处理 异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调： 1234567891011121314151617181920function double(value, success, failure) &#123; setTimeout(() =&gt; &#123; try &#123; if (typeof value !== &#x27;number&#x27;) &#123; throw &#x27;Must provide number as first argument&#x27;; &#125; success(2 * value); &#125; catch (e) &#123; failure(e); &#125; &#125;, 1000);&#125;const successCallback = (x) =&gt; console.log(`Success: $&#123;x&#125;`);const failureCallback = (e) =&gt; console.log(`Failure: $&#123;e&#125;`);double(3, successCallback, failureCallback);double(&#x27;b&#x27;, successCallback, failureCallback);// Success: 6（大约 1000 毫秒之后）// Failure: Must provide number as first argument（大约 1000 毫秒之后） 这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。 嵌套异步回调 如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这 就要求嵌套回调： 12345678910111213141516171819202122function double(value, success, failure) &#123; setTimeout(() =&gt; &#123; try &#123; if (typeof value !== &#x27;number&#x27;) &#123; throw &#x27;Must provide number as first argument&#x27;; &#125; success(2 * value); &#125; catch (e) &#123; failure(e); &#125; &#125;, 1000); &#125;const successCallback = (x) =&gt; &#123; double(x, (y) =&gt; console.log(`Success: $&#123;y&#125;`));&#125;;const failureCallback = (e) =&gt; console.log(`Failure: $&#123;e&#125;`);double(3, successCallback, failureCallback);// Success: 12（大约 1000 毫秒之后） 显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。 嵌套回调的代码维护起来就是噩梦。 期约Promises&#x2F;A+规范早期的期约机制在 jQuery 和 Dojo 中是以 Deferred API 的形式出现的。到了 2010 年，CommonJS 项 目实现的 Promises/A 规范日益流行起来。Q 和 Bluebird 等第三方 JavaScript 期约库也越来越得到社区认 可，虽然这些库的实现多少都有些不同。为弥合现有实现之间的差异，2012 年 Promises/A+组织分叉（fork） 了 CommonJS 的 Promises/A 建议，并以相同的名字制定了 Promises/A+规范。这个规范最终成为了 ECMAScript 6 规范实现的范本。 ECMAScript 6 增加了对 Promises/A+规范的完善支持，即 Promise 类型。一经推出，Promise 就 大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 ES6 期约，很多其他浏览器 API（如 fetch()和 Battery Status API）也以期约为基础。 期约基础ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解释器： 12let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 SyntaxError。 期约状态机 在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该 实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一： 待定（pending） 兑现（fulfilled，有时候也称之为”解决”，resolved） 拒绝（rejected） 待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现 （fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该具有恰当的行为。 重要的是，期约的状态是私有的，不能直接通过 JavaScript检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 JavaScript 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。 解决值、拒绝理由及期约用例 期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定” 表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。 某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。比如，假设期约要向服务器发送一个 HTTP 请求。请求返回 200~299 范围内的状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在 200~299 这个范围内， 那么就会把期约状态切换为“拒绝”。 在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。比如，假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON。如果请求返回范围在 200~299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。类似地，如果请求返回的状 态码不在 200~299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 Error 对象，包含着 HTTP 状态码及相关错误消息。 为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地， 每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状 态时执行的异步代码始终会收到这个值或理由。 通过执行函数控制期约状态 由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用 resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛 出错误（后面会讨论这个错误）。 123456let p1 = new Promise((resolve, reject) =&gt; resolve());setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;let p2 = new Promise((resolve, reject) =&gt; reject());setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught error (in promise) 在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序： 12345new Promise(() =&gt; setTimeout(console.log, 0, &#x27;executor&#x27;));setTimeout(console.log, 0, &#x27;promise initialized&#x27;);// executor// promise initialized 添加 setTimeout 可以推迟切换状态： 1234let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示： 123456let p = new Promise((resolve, reject) =&gt; &#123; resolve(); reject(); // 没有效果&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt; 为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 setTimeout 设置一个 10 秒钟后无论如何都会拒绝期约的回调： 12345678let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 10000); // 10 秒后调用 reject() // 执行函数的逻辑&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;setTimeout(console.log, 11000, p); // 11 秒后再检查状态// (After 10 seconds) Uncaught error// (After 11 seconds) Promise &lt;rejected&gt; 因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。 Promise.resolve() 期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用 Promise.resolve()静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的： 12let p1 = new Promise((resolve, reject) =&gt; resolve());let p2 = Promise.resolve(); 这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约： 123456789setTimeout(console.log, 0, Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6));// Promise &lt;resolved&gt;: 4 12345678setTimeout(console.log, 0, Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6)); 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此， Promise.resolve()可以说是一个幂等方法，如下所示： 1234567let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p));// truesetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)));// true 这个幂等性会保留传入期约的状态： 123456let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;setTimeout(console.log, 0, Promise.resolve(p)); // Promise &lt;pending&gt;setTimeout(console.log, 0, p === Promise.resolve(p)); // true Promise.reject() 与 Promise.resolve()类似，**Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误 （这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。**下面的两个期约实例实际上是 一样的： 12let p1 = new Promise((resolve, reject) =&gt; reject());let p2 = Promise.reject(); 这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序： 1234let p = Promise.reject(3);setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3p.then(null, (e) =&gt; setTimeout(console.log, 0, e)); // 3 关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由： 12setTimeout(console.log, 0, Promise.reject(Promise.resolve()));// Promise &lt;rejected&gt;: Promise &lt;resolved&gt; 同步&#x2F;异步执行的二元性 Promise 的设计很大程度上会导致一种完全不同于 JavaScript 的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形： 1234567891011try &#123; throw new Error(&#x27;foo&#x27;);&#125; catch(e) &#123; console.log(e); // Error: foo&#125;try &#123; Promise.reject(new Error(&#x27;bar&#x27;));&#125; catch(e) &#123; console.log(e);&#125;// Uncaught (in promise) Error: bar 第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。 在这个例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。 期约的实例方法期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。 实现Thenable接口 在 ECMAScript 暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了 Thenable 接口。下面的例子展示了实现这一接口的最简单的类： 123class MyThenable &#123; then() &#123;&#125;&#125; ECMAScript 的 Promise 类型实现了 Thenable 接口。这个简化的接口跟 TypeScript 或其他包中的接口或类型定义不同，它们都设定了 Thenable 接口更具体的形式。 Promise.prototype.then() Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话， 则会在期约分别进入“兑现”和“拒绝”状态时执行。 123456789101112131415function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;);&#125;function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;);&#125;let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000));p1.then(() =&gt; onResolved(&#x27;p1&#x27;), () =&gt; onRejected(&#x27;p1&#x27;));p2.then(() =&gt; onResolved(&#x27;p2&#x27;), () =&gt; onRejected(&#x27;p2&#x27;));//（3 秒后）// p1 resolved// p2 rejected 因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。 如前所述，两个处理程序参数都是可选的。而且，传给 then()的任何非函数类型的参数都会被静默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这 样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。 1234567891011121314151617function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;);&#125;function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;);&#125;let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000));// 非函数处理程序会被静默忽略，不推荐p1.then(&#x27;gobbeltygook&#x27;);// 不传 onResolved 处理程序的规范写法p2.then(null, () =&gt; onRejected(&#x27;p2&#x27;));// p2 rejected（3 秒后） Promise.prototype.then()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;);let p2 = p1.then();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt;setTimeout(console.log, 0, p2); // Promise &lt;pending&gt;setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回值 undefined。 1234567891011121314let p1 = Promise.resolve(&#x27;foo&#x27;);// 若调用 then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo// 这些都一样let p3 = p1.then(() =&gt; undefined);let p4 = p1.then(() =&gt; &#123;&#125;);let p5 = p1.then(() =&gt; Promise.resolve());setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined 如果有显式的返回值，则 Promise.resolve()会包装这个值： 123456789101112131415...// 这些都一样let p6 = p1.then(() =&gt; &#x27;bar&#x27;);let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;));setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: barsetTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar// Promise.resolve()保留返回的期约let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;));let p9 = p1.then(() =&gt; Promise.reject());// Uncaught (in promise): undefinedsetTimeout(console.log, 0, p8); // Promise &lt;pending&gt;setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined 抛出异常会返回拒绝的期约： 123456...let p10 = p1.then(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;);// Uncaught (in promise) bazsetTimeout(console.log, 0, p10); // Promise &lt;rejected&gt; baz 注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中： 123...let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;));setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。 下面的代码片段展示了用 Promise.reject()替代之前例子中的 Promise.resolve()之后的 结果： 123456789101112131415161718192021222324252627282930313233343536373839let p1 = Promise.reject(&#x27;foo&#x27;);// 调用 then()时不传处理程序则原样向后传let p2 = p1.then();// Uncaught (in promise) foo setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: foo// 这些都一样let p3 = p1.then(null, () =&gt; undefined);let p4 = p1.then(null, () =&gt; &#123;&#125;);let p5 = p1.then(null, () =&gt; Promise.resolve());setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined // 这些都一样let p6 = p1.then(null, () =&gt; &#x27;bar&#x27;);let p7 = p1.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;));setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: barsetTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar// Promise.resolve()保留返回的期约let p8 = p1.then(null, () =&gt; new Promise(() =&gt; &#123;&#125;));let p9 = p1.then(null, () =&gt; Promise.reject());// Uncaught (in promise): undefinedsetTimeout(console.log, 0, p8); // Promise &lt;pending&gt;setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefinedlet p10 = p1.then(null, () =&gt; &#123; throw &#x27;baz&#x27;; &#125;);// Uncaught (in promise) bazsetTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: bazlet p11 = p1.then(null, () =&gt; Error(&#x27;qux&#x27;));setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux Promise.prototype.catch() Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected)。 下面的代码展示了这两种同样的情况： 12345678let p = Promise.reject();let onRejected = function(e) &#123; setTimeout(console.log, 0, &#x27;rejected&#x27;);&#125;;// 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejectedp.catch(onRejected); // rejected Promise.prototype.catch()返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;);let p2 = p1.catch();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt;setTimeout(console.log, 0, p2); // Promise &lt;pending&gt;setTimeout(console.log, 0, p1 === p2); // false 在返回新期约实例方面，Promise.prototype.catch()的行为与 Promise.prototype.then() 的 onRejected 处理程序是一样的。 Promise.prototype.finally() Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用 于添加清理代码。 12345678let p1 = Promise.resolve();let p2 = Promise.reject();let onFinally = function() &#123; setTimeout(console.log, 0, &#x27;Finally!&#x27;)&#125;p1.finally(onFinally); // Finallyp2.finally(onFinally); // Finally Promise.prototype.finally()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;);let p2 = p1.finally();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt;setTimeout(console.log, 0, p2); // Promise &lt;pending&gt;setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。 123456789101112131415161718let p1 = Promise.resolve(&#x27;foo&#x27;);// 这里都会原样后传let p2 = p1.finally();let p3 = p1.finally(() =&gt; undefined);let p4 = p1.finally(() =&gt; &#123;&#125;);let p5 = p1.finally(() =&gt; Promise.resolve());let p6 = p1.finally(() =&gt; &#x27;bar&#x27;);let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;));let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;));setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo 如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示： 12345678910111213...// Promise.resolve()保留返回的期约let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;));let p10 = p1.finally(() =&gt; Promise.reject());// Uncaught (in promise): undefinedsetTimeout(console.log, 0, p9); // Promise &lt;pending&gt;setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefinedlet p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;);// Uncaught (in promise) bazsetTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz 返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约： 123456789101112let p1 = Promise.resolve(&#x27;foo&#x27;);// 忽略解决的值let p2 = p1.finally( () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&#x27;bar&#x27;), 100))); setTimeout(console.log, 0, p2); // Promise &lt;pending&gt;setTimeout(() =&gt; setTimeout(console.log, 0, p2), 200);// 200 毫秒后：// Promise &lt;resolved&gt;: foo 非重入期约方法 当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。下面的例子演示了这个特性： 12345678910111213// 创建解决的期约let p = Promise.resolve();// 添加解决处理程序// 直觉上，这个处理程序会等期约一解决就执行p.then(() =&gt; console.log(&#x27;onResolved handler&#x27;));// 同步输出，证明 then()已经返回console.log(&#x27;then() returns&#x27;);// 实际的输出：// then() returns// onResolved handler 在这个例子中，在一个解决期约上调用 then()会把 onResolved 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 then()后面的同步代码一定先于处理程序执行。 先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。下面的例子展示了即使先添加了 onResolved 处理程序，再同步调用 resolve()，处理程序也不会进入同步线程执行： 123456789101112131415161718192021222324let synchronousResolve;// 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) =&gt; &#123; synchronousResolve = function() &#123; console.log(&#x27;1: invoking resolve()&#x27;); resolve(); console.log(&#x27;2: resolve() returns&#x27;); &#125;;&#125;);p.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;));console.log(&#x27;0: first of all&#x27;);synchronousResolve();console.log(&#x27;3: synchronousResolve() returns&#x27;);// 实际的输出：// 0: first of all// 1: invoking resolve()// 2: resolve() returns// 3: synchronousResolve() returns// 4: then() handler executes 在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。 非重入适用于 onResolved/onRejected 处理程序、catch()处理程序和 finally()处理程序。 下面的例子演示了这些处理程序都只能异步执行： 12345678910111213141516171819202122232425let p1 = Promise.resolve();p1.then(() =&gt; console.log(&#x27;p1.then() onResolved&#x27;));console.log(&#x27;p1.then() returns&#x27;);let p2 = Promise.reject();p2.then(null, () =&gt; console.log(&#x27;p2.then() onRejected&#x27;));console.log(&#x27;p2.then() returns&#x27;);let p3 = Promise.reject();p3.catch(() =&gt; console.log(&#x27;p3.catch() onRejected&#x27;));console.log(&#x27;p3.catch() returns&#x27;);let p4 = Promise.resolve();p4.finally(() =&gt; console.log(&#x27;p4.finally() onFinally&#x27;));console.log(&#x27;p4.finally() returns&#x27;);// p1.then() returns// p2.then() returns// p3.catch() returns// p4.finally() returns// p1.then() onResolved// p2.then() onRejected// p3.catch() onRejected// p4.finally() onFinally 邻近处理程序的执行顺序 如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then()、catch()还是 finally()添加的处理程序都是如此。 12345678910111213141516171819202122let p1 = Promise.resolve();let p2 = Promise.reject();p1.then(() =&gt; setTimeout(console.log, 0, 1));p1.then(() =&gt; setTimeout(console.log, 0, 2));// 1// 2p2.then(null, () =&gt; setTimeout(console.log, 0, 3));p2.then(null, () =&gt; setTimeout(console.log, 0, 4));// 3// 4p2.catch(() =&gt; setTimeout(console.log, 0, 5));p2.catch(() =&gt; setTimeout(console.log, 0, 6));// 5// 6p1.finally(() =&gt; setTimeout(console.log, 0, 7));p1.finally(() =&gt; setTimeout(console.log, 0, 8));// 7// 8 传递解决值和拒绝理由 到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。 在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。下面的例子展示了上述传递过程： 12345let p1 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;));p1.then((value) =&gt; console.log(value)); // foolet p2 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;));p2.catch((reason) =&gt; console.log(reason)); // bar Promise.resolve()和 Promise.reject()在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 onResolved 或 onRejected 处理程序： 12345let p1 = Promise.resolve(&#x27;foo&#x27;);p1.then((value) =&gt; console.log(value)); // foolet p2 = Promise.reject(&#x27;bar&#x27;);p2.catch((reason) =&gt; console.log(reason)); // bar 拒绝期约与拒绝错误处理 拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期 约都会以一个错误对象为由被拒绝： 1234567891011let p1 = new Promise((resolve, reject) =&gt; reject(Error(&#x27;foo&#x27;)));let p2 = new Promise((resolve, reject) =&gt; &#123; throw Error(&#x27;foo&#x27;); &#125;);let p3 = Promise.resolve().then(() =&gt; &#123; throw Error(&#x27;foo&#x27;); &#125;);let p4 = Promise.reject(Error(&#x27;foo&#x27;));setTimeout(console.log, 0, p1); // Promise &lt;rejected&gt;: Error: foosetTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: Error: foosetTimeout(console.log, 0, p3); // Promise &lt;rejected&gt;: Error: foosetTimeout(console.log, 0, p4); // Promise &lt;rejected&gt;: Error: foo // 也会抛出 4 个未捕获错误 期约可以以任何理由拒绝，包括 undefined，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的 4 个错误的栈追踪信息如下： 123456789101112Uncaught (in promise) Error: foo at Promise (test.html:5) at new Promise (&lt;anonymous&gt;) at test.html:5Uncaught (in promise) Error: foo at Promise (test.html:6) at new Promise (&lt;anonymous&gt;) at test.html:6Uncaught (in promise) Error: foo at test.html:8Uncaught (in promise) Error: foo at Promise.resolve.then (test.html:7) 所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：Promise.resolve().then()的错误最后才出现，这是因为它需要在运行时消息队列中 添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。 这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过 throw()关键字抛出错误时， JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令： 1234throw Error(&#x27;foo&#x27;);console.log(&#x27;bar&#x27;); // 这一行不会执行// Uncaught Error: foo 但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令： 12345Promise.reject(Error(&#x27;foo&#x27;));console.log(&#x27;bar&#x27;);// bar// Uncaught (in promise) Error: foo 如本章前面的 Promise.reject()示例所示，异步错误只能通过异步的 onRejected处理程序 捕获： 1234567// 正确Promise.reject(Error(&#x27;foo&#x27;)).catch((e) =&gt; &#123;&#125;);// 不正确try &#123; Promise.reject(Error(&#x27;foo&#x27;));&#125; catch(e) &#123;&#125; 这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 try/catch 在执行函数 中捕获错误： 123456789let p = new Promise((resolve, reject) =&gt; &#123; try &#123; throw Error(&#x27;foo&#x27;); &#125; catch(e) &#123;&#125; resolve(&#x27;bar&#x27;);&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt;: bar then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理： 12345678910111213141516171819202122232425console.log(&#x27;begin synchronous execution&#x27;);try &#123; throw Error(&#x27;foo&#x27;);&#125; catch(e) &#123; console.log(&#x27;caught error&#x27;, e);&#125;console.log(&#x27;continue synchronous execution&#x27;);// begin synchronous execution// caught error Error: foo// continue synchronous executionnew Promise((resolve, reject) =&gt; &#123; console.log(&#x27;begin asynchronous execution&#x27;); reject(Error(&#x27;bar&#x27;));&#125;).catch((e) =&gt; &#123; console.log(&#x27;caught error&#x27;, e);&#125;).then(() =&gt; &#123; console.log(&#x27;continue asynchronous execution&#x27;);&#125;);// begin asynchronous execution// caught error Error: bar// continue asynchronous execution 期约连锁与合约生成多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。 期约连锁 把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方 法（then()、catch()和 finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。比如： 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;first&#x27;); resolve();&#125;);p.then(() =&gt; console.log(&#x27;second&#x27;)) .then(() =&gt; console.log(&#x27;third&#x27;)) .then(() =&gt; console.log(&#x27;fourth&#x27;)); // first// second// third// fourth 这个实现最终执行了一连串同步任务。正因为如此，这种方式执行的任务没有那么有用，毕竟分别 使用 4 个同步函数也可以做到： 1234(() =&gt; console.log(&#x27;first&#x27;))();(() =&gt; console.log(&#x27;second&#x27;))();(() =&gt; console.log(&#x27;third&#x27;))();(() =&gt; console.log(&#x27;fourth&#x27;))(); 要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务。比如，可以像下面这样让每个期约在一定时间后解决： 12345678910111213141516171819202122let p1 = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;p1 executor&#x27;); setTimeout(resolve, 1000);&#125;);p1.then(() =&gt; new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;p2 executor&#x27;); setTimeout(resolve, 1000); &#125;)) .then(() =&gt; new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;p3 executor&#x27;); setTimeout(resolve, 1000); &#125;)) .then(() =&gt; new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;p4 executor&#x27;); setTimeout(resolve, 1000); &#125;)); // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后） 把生成期约的代码提取到一个工厂函数中，就可以写成这样： 12345678910111213141516function delayedResolve(str) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(str); setTimeout(resolve, 1000); &#125;);&#125; delayedResolve(&#x27;p1 executor&#x27;) .then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;))// p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后） 每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。假如这种情况下不使用期约，那么前面的代码可能就要这样写了： 12345678910111213141516171819function delayedExecute(str, callback = null) &#123; setTimeout(() =&gt; &#123; console.log(str); callback &amp;&amp; callback(); &#125;, 1000)&#125;delayedExecute(&#x27;p1 callback&#x27;, () =&gt; &#123; delayedExecute(&#x27;p2 callback&#x27;, () =&gt; &#123; delayedExecute(&#x27;p3 callback&#x27;, () =&gt; &#123; delayedExecute(&#x27;p4 callback&#x27;); &#125;); &#125;);&#125;);// p1 callback（1 秒后）// p2 callback（2 秒后）// p3 callback（3 秒后）// p4 callback（4 秒后） 可以发现，这不正是期约所要解决的回调地狱问题吗？ 因为 then()、catch()和 finally()都返回期约，所以串联这些方法也很直观。下面的例子同时 使用这 3 个实例方法： 12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;initial promise rejects&#x27;); reject();&#125;);p.catch(() =&gt; console.log(&#x27;reject handler&#x27;)) .then(() =&gt; console.log(&#x27;resolve handler&#x27;)) .finally(() =&gt; console.log(&#x27;finally handler&#x27;));// initial promise rejects// reject handler// resolve handler// finally handler 期约图 因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等 待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。 下面的例子展示了一种期约有向图，也就是二叉树： 123456789101112131415161718192021222324252627// A// / \\// B C// /\\ /\\// D E F Glet A = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;); resolve();&#125;);let B = A.then(() =&gt; console.log(&#x27;B&#x27;));let C = A.then(() =&gt; console.log(&#x27;C&#x27;));B.then(() =&gt; console.log(&#x27;D&#x27;));B.then(() =&gt; console.log(&#x27;E&#x27;));C.then(() =&gt; console.log(&#x27;F&#x27;));C.then(() =&gt; console.log(&#x27;G&#x27;));// A// B// C// D// E// F// G 注意，日志的输出语句是对二叉树的层序遍历。如前所述，期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。 Promise.all()和Promise.race() Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和 Promise.race()。 而合成后期约的行为取决于内部期约的行为。 Promise.all() Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约： 1234567891011121314let p1 = Promise.all([ Promise.resolve(), Promise.resolve()]);// 可迭代对象中的元素会通过 Promise.resolve()转换为期约let p2 = Promise.all([3, 4]);// 空的可迭代对象等价于 Promise.resolve()let p3 = Promise.all([]);// 无效的语法let p4 = Promise.all();// TypeError: cannot read Symbol.iterator of undefined 合成的期约只会在每个包含的期约都解决之后才解决： 123456789let p = Promise.all([ Promise.resolve(), new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000))]);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;p.then(() =&gt; setTimeout(console.log, 0, &#x27;all() resolved!&#x27;));// all() resolved!（大约 1 秒后） 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝： 12345678910111213// 永远待定let p1 = Promise.all([new Promise(() =&gt; &#123;&#125;)]);setTimeout(console.log, 0, p1); // Promise &lt;pending&gt;// 一次拒绝会导致最终期约拒绝let p2 = Promise.all([ Promise.resolve(), Promise.reject(), Promise.resolve()]);setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught (in promise) undefined 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序： 1234567let p = Promise.all([ Promise.resolve(3), Promise.resolve(), Promise.resolve(4)]);p.then((values) =&gt; setTimeout(console.log, 0, values)); // [3, undefined, 4] 如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示： 1234567891011// 虽然只有第一个期约的拒绝理由会进入// 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.all([ Promise.reject(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000))]);p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3// 没有未处理的错误 Promise.race() Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约： 1234567891011121314let p1 = Promise.race([ Promise.resolve(), Promise.resolve()]);// 可迭代对象中的元素会通过 Promise.resolve()转换为期约let p2 = Promise.race([3, 4]);// 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;)let p3 = Promise.race([]);// 无效的语法let p4 = Promise.race();// TypeError: cannot read Symbol.iterator of undefined Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约： 123456789101112131415161718192021// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([ Promise.resolve(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000))]);setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3// 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([ Promise.reject(4), new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000))]);setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4// 迭代顺序决定了落定顺序let p3 = Promise.race([ Promise.resolve(5), Promise.resolve(6), Promise.resolve(7)]);setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5 如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 Promise.all() 类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示： 1234567891011// 虽然只有第一个期约的拒绝理由会进入// 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.race([ Promise.reject(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000))]);p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3// 没有未处理的错误 串行期约合成 到目前为止，讨论期约连锁一直围绕期约的串行执行，忽略了期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数，比如： 123456789function addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function addTen(x) &#123; return addFive(addTwo(addThree(x)));&#125;console.log(addTen(7)); // 17 在这个例子中，有 3 个函数基于一个值合成为一个函数。类似地，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果： 123456789101112function addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function addTen(x) &#123; return Promise.resolve(x) .then(addTwo) .then(addThree) .then(addFive);&#125;addTen(8).then(console.log); // 18 使用 Array.prototype.reduce()可以写成更简洁的形式： 12345678910function addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function addTen(x) &#123; return [addTwo, addThree, addFive] .reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x));&#125;addTen(8).then(console.log); // 18 这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连 锁。这个通用的合成函数可以这样实现： 1234567891011function addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function compose(...fns) &#123; return (x) =&gt; fns.reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x))&#125;let addTen = compose(addTwo, addThree, addFive);addTen(8).then(console.log); // 18 期约扩展ES6 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 ECMAScript 规范却未涉及的两个特性：期约取消和进度追踪。 期约取消 经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。这时候如果能够取消期约就 好了。某些第三方库，比如 Bluebird，就提供了这个特性。实际上，TC39 委员会也曾准备增加这个特性， 但相关提案最终被撤回了。结果，**ES6 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。** 实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。基本使用如下： 123456789101112131415161718192021const controller = new AbortController();const signal = controller.signal;const downloadBtn = document.querySelector(&#x27;.download&#x27;);const abortBtn = document.querySelector(&#x27;.abort&#x27;);downloadBtn.addEventListener(&#x27;click&#x27;, fetchVideo);abortBtn.addEventListener(&#x27;click&#x27;, function() &#123; controller.abort(); console.log(&#x27;Download aborted&#x27;);&#125;);function fetchVideo() &#123; ... fetch(url, &#123;signal&#125;).then(function(response) &#123; ... &#125;).catch(function(e) &#123; reports.textContent = &#x27;Download error: &#x27; + e.message; &#125;)&#125; 上面的关键点，也就是在 fetch 调用的时候多传一个 signal，然后后续如果想取消，就调用 controller.abort ，fetch 可以检测到 signal 的变化，从而中断请求。 根据这个特性，我们扩展一个可取消的 fetch API。 1234567891011121314151617181920function makeCancelableFetch(url: string) &#123; const controller = new AbortController(); const signal = controller.signal; const promise = fetch(url, &#123;signal&#125;) const cancel = () =&gt; &#123; controller.abort(); &#125; return &#123; promise, cancel &#125;&#125;const &#123;promise, cancel&#125; = makeCancelableFetch(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;)cancel()promise.then(res =&gt; &#123; console.log(res)&#125;, (err) =&gt; &#123;console.log(err)&#125;) // DOMException: The user aborted a request. 期约进度通知 执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期 约的执行进度会很有用。ECMAScript 6 期约并不支持进度追踪，但是可以通过扩展来实现。 一种实现方式是扩展 Promise 类，为它添加 notify()方法，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class TrackablePromise extends Promise &#123; constructor(executor) &#123; const notifyHandlers = []; super((resolve, reject) =&gt; &#123; // 执行期约执行器函数调用指定的handler输出期约进度通知 return executor(resolve, reject, (statusContent) =&gt; &#123; notifyHandlers.map((handler) =&gt; handler(statusContent)); &#125;); &#125;); this.notifyHandlers = notifyHandlers; &#125; notify(notifyHandler) &#123; this.notifyHandlers.push(notifyHandler); return this; &#125;&#125;// 这里的printFunc是上边return executor方法里的第三个参数的函数：// (statusContent) =&gt; &#123;// notifyHandlers.map((handler) =&gt; handler(statusContent));// &#125;let p = new TrackablePromise((resolve, reject, printFunc) =&gt; &#123; function countdown(x) &#123; if (x &gt; 0) &#123; printFunc(`$&#123;20 * x&#125;% remaining`); setTimeout(() =&gt; countdown(x - 1), 1000); &#125; else &#123; resolve(); &#125; &#125; countdown(5);&#125;); // 指定Promise的notifyHandler为 (x) =&gt; setTimeout(console.log, 0, &#x27;progress:&#x27;, x)p.notify((x) =&gt; setTimeout(console.log, 0, &#x27;progress:&#x27;, x));p.then(() =&gt; setTimeout(console.log, 0, &#x27;completed&#x27;));// （约 1 秒后）80% remaining// （约 2 秒后）60% remaining// （约 3 秒后）40% remaining// （约 4 秒后）20% remaining// （约 5 秒后）completed 这个期约会连续5次递归地设置1000毫秒的超时。每个超时回调都会调用notify()并传入状态值。 notify()函数会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的 每条消息分别执行一遍，如下所示： 12345678910111213...p.notify((x) =&gt; setTimeout(console.log, 0, &#x27;a:&#x27;, x)).notify((x) =&gt; setTimeout(console.log, 0, &#x27;b:&#x27;, x));p.then(() =&gt; setTimeout(console.log, 0, &#x27;completed&#x27;));// （约 1 秒后） a: 80% remaining// （约 1 秒后） b: 80% remaining// （约 2 秒后） a: 60% remaining// （约 2 秒后） b: 60% remaining// （约 3 秒后） a: 40% remaining// （约 3 秒后） b: 40% remaining// （约 4 秒后） a: 20% remaining// （约 4 秒后） b: 20% remaining// （约 5 秒后） completed 注意：ES6 不支持取消期约和进度通知，一个主要原因就是这样会导致期约连锁和期约合成 过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了 通知，那么接下来应该发生什么完全说不清楚。毕竟，如果取消了 Promise.all()中的一个 期约，或者期约连锁中前面的期约发送了一个通知，那么接下来应该怎么办才比较合理呢？ 异步函数异步函数，也称为“async&#x2F;await”（语法关键字），是 ES6 期约模式在 ECMAScript 函数中的应用。 async/await 是 ES8 规范新增的。这个特性从行为和语法上都增强了 JavaScript，让以同步方式写的代码能够异步执行。下面来看一个最简单的例子，这个期约在超时之后会解决为一个值： 1let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3)); 这个期约在 1000 毫秒之后解决为数值 3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序： 12let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3));p.then((x) =&gt; console.log(x)); // 3 这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数： 123function handler(x) &#123; console.log(x); &#125;let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3));p.then(handler); // 3 这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式 来接收这个值。也就是说，代码照样还是要放到处理程序里。ES8 为此提供了 async/await 关键字。 异步函数ES8 的 async/await 旨在解决利用异步结构组织代码的问题。为此，ECMAScript 对函数进行了扩展， 为其增加了两个新关键字：async 和 await。 async async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上： 123456789async function foo() &#123;&#125;let bar = async function() &#123;&#125;;let baz = async () =&gt; &#123;&#125;;class Qux &#123; async qux() &#123;&#125;&#125; 使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭 包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。正如下面的例子所示，foo()函数仍然会 在后面的指令之前被求值： 123456789async function foo() &#123; console.log(1);&#125;foo();console.log(2);// 1// 2 不过，异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这 个值会被 Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约： 12345678910async function foo() &#123; console.log(1); return 3;&#125;// 给返回的期约添加一个解决处理程序foo().then(console.log);console.log(2);// 1// 2// 3 当然，直接返回一个期约对象也是一样的： 12345678910111213async function foo() &#123; console.log(1); return Promise.resolve(3);&#125;// 给返回的期约添加一个解决处理程序foo().then(console.log);console.log(2);// 1// 2// 3 异步函数的返回值期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。 如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then()的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。下面的代码演示了这些情况： 123456789101112131415161718192021222324252627282930// 返回一个原始值async function foo() &#123; return &#x27;foo&#x27;;&#125;foo().then(console.log);// foo// 返回一个没有实现 thenable 接口的对象async function bar() &#123; return [&#x27;bar&#x27;];&#125;bar().then(console.log);// [&#x27;bar&#x27;]// 返回一个实现了 thenable 接口的非期约对象async function baz() &#123; const thenable = &#123; then(callback) &#123; callback(&#x27;baz&#x27;); &#125; &#125;; return thenable;&#125;baz().then(console.log);// baz// 返回一个期约async function qux() &#123; return Promise.resolve(&#x27;qux&#x27;);&#125;qux().then(console.log);// qux 与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约: 12345678910async function foo() &#123; console.log(1); throw 3;&#125;// 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2);// 1// 2// 3 不过，拒绝期约的错误不会被异步函数捕获： 123456789101112async function foo() &#123; console.log(1); Promise.reject(3);&#125;// Attach a rejected handler to the returned promisefoo().catch(console.log);console.log(2);// 1// 2// Uncaught (in promise): 3 await 因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。来看下面这个本章开始就出现过的例子： 12let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3));p.then((x) =&gt; console.log(x)); // 3 使用 async/await 可以写成这样： 1234567async function foo() &#123; let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3)); console.log(await p);&#125;foo();// 3 注意，await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。 await 关键字的用法与 JavaScript 的一元操作一样。它可以单独使用，也可以在表达式中使用，如下面的例子所示： 123456789101112131415161718192021// 异步打印&quot;foo&quot;async function foo() &#123; console.log(await Promise.resolve(&#x27;foo&#x27;));&#125;foo();// foo// 异步打印&quot;bar&quot;async function bar() &#123; return await Promise.resolve(&#x27;bar&#x27;);&#125;bar().then(console.log);// bar// 1000 毫秒后异步打印&quot;baz&quot;async function baz() &#123; await new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)); console.log(&#x27;baz&#x27;);&#125;baz();// baz（1000 毫秒后） await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如 果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况： 123456789101112131415161718192021222324252627282930// 等待一个原始值async function foo() &#123; console.log(await &#x27;foo&#x27;);&#125;foo();// foo// 等待一个没有实现 thenable 接口的对象async function bar() &#123; console.log(await [&#x27;bar&#x27;]);&#125;bar();// [&#x27;bar&#x27;]// 等待一个实现了 thenable 接口的非期约对象async function baz() &#123; const thenable = &#123; then(callback) &#123; callback(&#x27;baz&#x27;); &#125; &#125;; console.log(await thenable);&#125;baz();// baz// 等待一个期约async function qux() &#123; console.log(await Promise.resolve(&#x27;qux&#x27;));&#125;qux();// qux 等待会抛出错误的同步操作，会返回拒绝的期约： 12345678910async function foo() &#123; console.log(1); await (() =&gt; &#123; throw 3; &#125;)();&#125;// 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2);// 1// 2// 3 如前面的例子所示，单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 await 则会释放（unwrap）错误值（将拒绝期约返回）： 1234567891011async function foo() &#123; console.log(1); await Promise.reject(3); console.log(4); // 这行代码不会执行&#125;// 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2);// 1// 2// 3 await的限制 await 关键字必须在异步函数中使用，不能在顶级上下文如&lt;script&gt;标签或模块中使用。不过， 定义并立即调用异步函数是没问题的。下面两段代码实际是相同的： 1234567891011async function foo() &#123; console.log(await Promise.resolve(3));&#125;foo();// 3// 立即调用的异步函数表达式(async function() &#123; console.log(await Promise.resolve(3));&#125;)();// 3 此外，异步函数的特质不会扩展到嵌套函数。因此，await 关键字也只能直接出现在异步函数的定 义中。在同步函数内部使用 await 会抛出 SyntaxError。 下面展示了一些会出错的例子： 1234567891011121314151617181920212223242526272829// 不允许：await 出现在了箭头函数中function foo() &#123; const syncFn = () =&gt; &#123; return await Promise.resolve(&#x27;foo&#x27;); &#125;; console.log(syncFn());&#125;// 不允许：await 出现在了同步函数声明中function bar() &#123; function syncFn() &#123; return await Promise.resolve(&#x27;bar&#x27;); &#125; console.log(syncFn());&#125;// 不允许：await 出现在了同步函数表达式中function baz() &#123; const syncFn = function() &#123; return await Promise.resolve(&#x27;baz&#x27;); &#125;; console.log(syncFn());&#125;// 不允许：IIFE 使用同步函数表达式或箭头函数function qux() &#123; (function () &#123; console.log(await Promise.resolve(&#x27;qux&#x27;)); &#125;)(); (() =&gt; console.log(await Promise.resolve(&#x27;qux&#x27;)))();&#125; 停止和恢复执行使用 await 关键字之后的区别其实比看上去的还要微妙一些。比如，下面的例子中按顺序调用了 3 个函数，但它们的输出结果顺序是相反的： 12345678910111213141516171819async function foo() &#123; console.log(await Promise.resolve(&#x27;foo&#x27;));&#125;async function bar() &#123; console.log(await &#x27;bar&#x27;);&#125;async function baz() &#123; console.log(&#x27;baz&#x27;);&#125;foo();bar();baz();// baz// bar// foo async/await 中真正起作用的是 await。async 关键字，无论从哪方面来看，都不过是一个标识符。 毕竟，异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别： 12345678910async function foo() &#123; console.log(2);&#125;console.log(1);foo();console.log(3);// 1// 2// 3 要完全理解 await 关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript 运行时在碰 到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。 因此，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。下面的例子演示了这一点： 1234567891011121314async function foo() &#123; console.log(2); await null; console.log(4);&#125;console.log(1);foo();console.log(3);// 1// 2// 3// 4 控制台中输出结果的顺序很好地解释了运行时的工作过程： 打印1 调用异步函数foo() (在foo()中)打印2 (在foo()中)await关键字暂停执行，为立即可用的值 null 向消息队列中添加一个任务； foo()退出 打印3 同步线程的代码执行完毕 JavaScript运行时从消息队列中取出任务，恢复异步函数执行 (在foo中)恢复执行，await取得null值（这里并没有使用） (在foo()中)打印4 foo()返回 如果 await 后面是一个期约，则问题会稍微复杂一些。TC39 对 await 后面是期约的情况如何处理做过一次修改。修改后，await后面是期约的情况只会生成一个 异步任务： 123456789101112131415161718192021222324252627async function foo() &#123; console.log(2); console.log(await Promise.resolve(8)); console.log(9);&#125;async function bar() &#123; console.log(4); console.log(await 6); console.log(7);&#125;console.log(1);foo();console.log(3);bar();console.log(5);// 1// 2// 3// 4// 5// 8// 9// 6// 7 实际开发中，对于并行的异步操作我们通常 更关注结果，而不依赖执行顺序。 异步函数策略因为简单实用，所以异步函数很快成为 JavaScript 项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。 实现sleep() 很多人在刚开始学习 JavaScript 时，想找到一个类似 Java 中 Thread.sleep()之类的函数，好在程序中加入非阻塞的暂停。以前，这个需求基本上都通过 setTimeout()利用 JavaScript 运行时的行为来 实现的。 有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现 sleep()： 1234567891011function sleep(delay) &#123; return new Promise((resolve) =&gt; setTimeout(resolve, delay));&#125;async function foo() &#123; const t0 = Date.now(); await sleep(1500); // 暂停约 1500 毫秒 console.log(Date.now() - t0);&#125;foo();// 1502 利用平行执行 如果使用 await 时不留心，则很可能错过平行加速的机会。来看下面的例子，其中顺序等待了 5 个随机的超时： 1234567891011121314151617181920212223242526async function randomDelay(id) &#123; // 延迟 0~1000 毫秒 const delay = Math.random() * 1000; return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(`$&#123;id&#125; finished`); resolve(); &#125;, delay));&#125;async function foo() &#123; const t0 = Date.now(); await randomDelay(0); await randomDelay(1); await randomDelay(2); await randomDelay(3); await randomDelay(4); console.log(`$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo();// 0 finished// 1 finished// 2 finished// 3 finished// 4 finished// 877ms elapsed 用一个 for 循环重写，就是： 12345678910111213141516171819202122async function randomDelay(id) &#123; // 延迟 0~1000 毫秒 const delay = Math.random() * 1000; return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(`$&#123;id&#125; finished`); resolve(); &#125;, delay));&#125;async function foo() &#123; const t0 = Date.now(); for (let i = 0; i &lt; 5; ++i) &#123; await randomDelay(i); &#125; console.log(`$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo();// 0 finished// 1 finished// 2 finished// 3 finished// 4 finished// 877ms elapsed 就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序， 但总执行时间会变长。 如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。比如： 123456789101112131415161718192021222324252627282930async function randomDelay(id) &#123; // 延迟 0~1000 毫秒 const delay = Math.random() * 1000; return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; setTimeout(console.log, 0, `$&#123;id&#125; finished`); resolve(); &#125;, delay));&#125;async function foo() &#123; const t0 = Date.now(); const p0 = randomDelay(0); const p1 = randomDelay(1); const p2 = randomDelay(2); const p3 = randomDelay(3); const p4 = randomDelay(4); await p0; await p1; await p2; await p3; await p4; setTimeout(console.log, 0, `$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo(); // 1 finished// 4 finished// 3 finished// 0 finished// 2 finished// 877ms elapsed 用数组和 for 循环再包装一下就是： 12345678910111213141516171819202122232425async function randomDelay(id) &#123; // 延迟 0~1000 毫秒 const delay = Math.random() * 1000; return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(`$&#123;id&#125; finished`); resolve(); &#125;, delay));&#125;async function foo() &#123; const t0 = Date.now(); const promises = Array(5).fill(null).map((_, i) =&gt; randomDelay(i)); for (const p of promises) &#123; await p; &#125; console.log(`$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo();// 4 finished// 2 finished// 1 finished// 0 finished// 3 finished// 877ms elapsed 注意，虽然期约没有按照顺序执行，但 await 按顺序收到了每个期约的值： 12345678910111213141516171819202122232425262728293031async function randomDelay(id) &#123; // 延迟 0~1000 毫秒 const delay = Math.random() * 1000; return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(`$&#123;id&#125; finished`); resolve(id); &#125;, delay));&#125;async function foo() &#123; const t0 = Date.now(); const promises = Array(5).fill(null).map((_, i) =&gt; randomDelay(i)); for (const p of promises) &#123; console.log(`awaited $&#123;await p&#125;`); &#125; console.log(`$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo(); // 1 finished// 2 finished// 4 finished// 3 finished// 0 finished// awaited 0// awaited 1// awaited 2// awaited 3// awaited 4// 645ms elapsed 串行执行期约 使用 async/await，期约连锁会变得很简单： 123456789101112function addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;async function addTen(x) &#123; for (const fn of [addTwo, addThree, addFive]) &#123; x = await fn(x); &#125; return x;&#125;addTen(9).then(console.log); // 19 这里，await 直接传递了每个函数的返回值，结果通过迭代产生。当然，这个例子并没有使用期约， 如果要使用期约，则可以把所有函数都改成异步函数。这样它们就都返回期约了： 123456789101112async function addTwo(x) &#123;return x + 2;&#125;async function addThree(x) &#123;return x + 3;&#125;async function addFive(x) &#123;return x + 5;&#125;async function addTen(x) &#123; for (const fn of [addTwo, addThree, addFive]) &#123; x = await fn(x); &#125; return x;&#125;addTen(9).then(console.log); // 19 栈追踪与内存管理 期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。看看下面的例子， 它展示了拒绝期约的栈追踪信息： 1234567891011121314function fooPromiseExecutor(resolve, reject) &#123; setTimeout(reject, 1000, &#x27;bar&#x27;);&#125;function foo() &#123; new Promise(fooPromiseExecutor);&#125;foo();// Uncaught (in promise) bar// setTimeout// setTimeout (async)// fooPromiseExecutor// foo JavaScript 引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时， 调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息 会占用内存，从而带来一些计算和存储成本。 如果在前面的例子中使用的是异步函数，那又会怎样呢？比如： 12345678910111213function fooPromiseExecutor(resolve, reject) &#123; setTimeout(reject, 1000, &#x27;bar&#x27;);&#125;async function foo() &#123; await new Promise(fooPromiseExecutor);&#125;foo();// Uncaught (in promise) bar// foo// async function (async)// foo 这样一改，栈追踪信息就准确地反映了当前的调用栈。fooPromiseExecutor()已经返回，所以它不在错误信息中。但 foo()此时被挂起了，并没有退出。JavaScript 运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(8)——函数","slug":"JS高级程序设计读书笔记(8)——函数","date":"2023-03-08T04:26:39.000Z","updated":"2023-11-27T15:34:23.883Z","comments":true,"path":"2023/03/08/JS高级程序设计读书笔记(8)——函数/","link":"","permalink":"http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数是 ECMAScript中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是 Function类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。 因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，比如： 123function sum (num1, num2) &#123; return num1 + num2;&#125; 注意函数定义最后没有加分号。 另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的： 123let sum = function(num1, num2) &#123; return num1 + num2;&#125;; 这里，代码定义了一个变量 sum 并将其初始化为一个函数。注意 function 关键字后面没有名称，因为不需要。这个函数可以通过变量 sum 来引用。 还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function），如下所示： 123let sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 最后一种定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子： 1let sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); // 不推荐 箭头函数ECMAScript 6 新增了使用胖箭头（=&gt;）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数： 12345678910let arrowSum = (a, b) =&gt; &#123; return a + b;&#125;;let functionExpressionSum = function(a, b) &#123; return a + b;&#125;;console.log(arrowSum(5, 8)); // 13console.log(functionExpressionSum(5, 8)); // 13 箭头函数简洁的语法非常适合嵌入函数的场景： 1234let ints = [1, 2, 3];console.log(ints.map(function(i) &#123; return i + 1; &#125;)); // [2, 3, 4]console.log(ints.map((i) =&gt; &#123; return i + 1 &#125;)); // [2, 3, 4] 如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号： 123456789// 以下两种写法都有效let double = (x) =&gt; &#123; return 2 * x; &#125;;let triple = x =&gt; &#123; return 3 * x; &#125;;// 没有参数需要括号let getRandom = () =&gt; &#123; return Math.random(); &#125;;// 多个参数需要括号let sum = (a, b) =&gt; &#123; return a + b; &#125;;// 无效的写法：let multiply = a, b =&gt; &#123; return a * b; &#125;; 箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以 在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码， 比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值： 123456789101112// 以下两种写法都有效，而且返回相应的值let double = (x) =&gt; &#123; return 2 * x; &#125;;let triple = (x) =&gt; 3 * x;// 可以赋值let value = &#123;&#125;;let setName = (x) =&gt; x.name = &quot;Matt&quot;;setName(value);console.log(value.name); // &quot;Matt&quot;// 无效的写法：let multiply = (a, b) =&gt; return a * b; 箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。 函数名因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称，如下所示： 1234567891011function sum(num1, num2) &#123; return num1 + num2;&#125;console.log(sum(10, 10)); // 20let anotherSum = sum;console.log(anotherSum(10, 10)); // 20sum = null;console.log(anotherSum(10, 10)); // 20 以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 anotherSum， 并将它的值设置为等于 sum。注意，使用不带括号的函数名会访问函数指针，而不会执行函数。此时， anotherSum 和 sum 都指向同一个函数。调用 anotherSum()也可以返回结果。把 sum 设置为 null之后，就切断了它与函数之间的关联。而 anotherSum()还是可以照常调用，没有问题。 ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情 况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称， 也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成”anonymous”： 123456789function foo() &#123;&#125;let bar = function() &#123;&#125;;let baz = () =&gt; &#123;&#125;;console.log(foo.name); // fooconsole.log(bar.name); // barconsole.log(baz.name); // bazconsole.log((() =&gt; &#123;&#125;).name); //（空字符串）console.log((new Function()).name); // anonymous 如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀： 1234567891011121314151617function foo() &#123;&#125;console.log(foo.bind(null).name); // bound foolet dog = &#123; years: 1, get age() &#123; return this.years; &#125;, set age(newAge) &#123; this.years = newAge; &#125;&#125;let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, &#x27;age&#x27;);console.log(propertyDescriptor.get.name); // get ageconsole.log(propertyDescriptor.set.name); // set age 理解参数ECMAScript 函数的参数跟大多数其他语言不同。**ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。可以传一 个、三个，甚至一个也不传，解释器都不会报错。** 之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。函数被调用时总会接 收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元 素超出了要求，那也没问题。事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。 arguments 对象是一个类数组对象（但不是 Array 的实例），因此可以使用中括号语法访问其中的 元素（第一个参数是 arguments[0]，第二个参数是 arguments[1]）。而要确定传进来多少个参数， 可以访问 arguments.length 属性。 在下面的例子中，sayHi()函数的第一个参数叫 name： 123function sayHi(name, message) &#123; console.log(&quot;Hello &quot; + name + &quot;, &quot; + message);&#125; 可以通过 arguments[0]取得相同的参数值。因此，把函数重写成不声明参数也可以： 123function sayHi() &#123; console.log(&quot;Hello &quot; + arguments[0] + &quot;, &quot; + arguments[1]);&#125; 在重写后的代码中，没有命名参数。name 和 message 参数都不见了，但函数照样可以调用。这就 表明，ECMAScript 函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在 ECMAScript 中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名 参数的机制。 也可以通过 arguments 对象的 length 属性检查传入的参数个数。下面的例子展示了在每调用一 个函数时，都会打印出传入的参数个数： 123456function howManyArgs() &#123; console.log(arguments.length);&#125;howManyArgs(&quot;string&quot;, 45); // 2howManyArgs(); // 0howManyArgs(12); // 1 这个例子分别打印出 2、0 和 1（按顺序）。既然如此，那么开发者可以想传多少参数就传多少参数。 比如： 123456789function doAdd() &#123; if (arguments.length === 1) &#123; console.log(arguments[0] + 10); &#125; else if (arguments.length === 2) &#123; console.log(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); // 20doAdd(30, 20); // 50 这个函数 doAdd()在只传一个参数时会加 10，在传两个参数时会将它们相加，然后返回。因此 doAdd(10)返回 20，而 doAdd(30,20)返回 50。虽然不像真正的函数重载那么明确，但这已经足以弥 补 ECMAScript 在这方面的缺失了。 还有一个必须理解的重要方面，那就是 arguments 对象可以跟命名参数一起使用，比如： 1234567function doAdd(num1, num2) &#123; if (arguments.length === 1) &#123; console.log(num1 + 10); &#125; else if (arguments.length === 2) &#123; console.log(arguments[0] + num2); &#125;&#125; 在这个 doAdd()函数中，同时使用了两个命名参数和 arguments 对象。命名参数 num1 保存着与 arugments[0]一样的值，因此使用谁都无所谓。（同样，num2 也保存着跟 arguments[1]一样的值。） arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子： 1234function doAdd(num1, num2) &#123; arguments[1] = 10; console.log(arguments[0] + num2);&#125; 这个 doAdd()函数把第二个参数的值重写为 10。因为 arguments 对象的值会自动同步到对应的命 名参数，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都 访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是 因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。 1234567891011121314function doAdd(num1, num2) &#123; arguments[1] = 10; console.log(arguments[0]); console.log(arguments[1]); console.log(num1); console.log(num2); console.log(arguments.length);&#125; doAdd(1)// 1// 10// 1// undefined// 1 对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 undefined。这就类似于 定义了变量而没有初始化。比如，如果只给 doAdd()传了一个参数，那么 num2 的值就是 undefined。 严格模式下，arguments 会有一些变化。首先，像前面那样给 arguments[1]赋值不会再影响 num2 的值。就算把 arguments[1]设置为 10，num2 的值仍然还是传入的值。其次，在函数中尝试重写 arguments 对象会导致语法错误。（代码也不会执行。） 箭头函数中的参数 如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。 12345678function foo() &#123; console.log(arguments[0]);&#125;foo(5); // 5let bar = () =&gt; &#123; console.log(arguments[0]);&#125;;bar(5); // ReferenceError: arguments is not defined 虽然箭头函数中没有 arguments 对象，但可以在包装函数中把它提供给箭头函数： 1234567function foo() &#123; let bar = () =&gt; &#123; console.log(arguments[0]); // 5 &#125;; bar();&#125;foo(5); ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。 没有重载ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义， 只要签名（接收参数的类型和数量）不同就行。如前所述，**ECMAScript 函数没有签名，因为参数是由 包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载**。 如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子： 1234567function addSomeNumber(num) &#123; return num + 100;&#125;function addSomeNumber(num) &#123; return num + 200;&#125;let result = addSomeNumber(100); // 300 前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。 把函数名当成指针也有助于理解为什么 ECMAScript 没有函数重载。在前面的例子中，定义两个同名的函数显然会导致后定义的重写先定义的。而那个例子几乎跟下面这个是一样的： 12345678let addSomeNumber = function(num) &#123; return num + 100;&#125;;addSomeNumber = function(num) &#123; return num + 200;&#125;; let result = addSomeNumber(100); // 300 看这段代码应该更容易理解发生了什么。在创建第二个函数时，变量 addSomeNumber 被重写成保存第二个函数对象了。 默认参数值在 ECMAScript5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 undefined， 如果是则意味着没有传这个参数，那就给它赋一个值： 123456function makeKing(name) &#123; name = (typeof name !== &#x27;undefined&#x27;) ? name : &#x27;Henry&#x27;; return `King $&#123;name&#125; VIII`;&#125;console.log(makeKing()); // &#x27;King Henry VIII&#x27;console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis VIII&#x27; ECMAScript 6 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价 的 ES6 写法，只要在函数定义中的参数后面用&#x3D;就可以为参数赋一个默认值： 12345function makeKing(name = &#x27;Henry&#x27;) &#123; return `King $&#123;name&#125; VIII`;&#125;console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis VIII&#x27;console.log(makeKing()); // &#x27;King Henry VIII&#x27; 给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值： 123456function makeKing(name = &#x27;Henry&#x27;, numerals = &#x27;VIII&#x27;) &#123; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125;console.log(makeKing()); // &#x27;King Henry VIII&#x27;console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis VIII&#x27;console.log(makeKing(undefined, &#x27;VI&#x27;)); // &#x27;King Henry VI&#x27; 在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然， 跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准： 123456function makeKing(name = &#x27;Henry&#x27;) &#123; name = &#x27;Louis&#x27;; return `King $&#123;arguments[0]&#125;`;&#125;console.log(makeKing()); // &#x27;King undefined&#x27;console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis&#x27; 默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值： 123456789101112131415let romanNumerals = [&#x27;I&#x27;, &#x27;II&#x27;, &#x27;III&#x27;, &#x27;IV&#x27;, &#x27;V&#x27;, &#x27;VI&#x27;];let ordinality = 0;function getNumerals() &#123; // 每次调用后递增 return romanNumerals[ordinality++];&#125;function makeKing(name = &#x27;Henry&#x27;, numerals = getNumerals()) &#123; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125;console.log(makeKing()); // &#x27;King Henry I&#x27;console.log(makeKing(&#x27;Louis&#x27;, &#x27;XVI&#x27;)); // &#x27;King Louis XVI&#x27;console.log(makeKing()); // &#x27;King Henry II&#x27;console.log(makeKing()); // &#x27;King Henry III&#x27; 函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。 箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了： 12let makeKing = (name = &#x27;Henry&#x27;) =&gt; `King $&#123;name&#125;`;console.log(makeKing()); // King Henry 默认参数作用域与暂时性死区 因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。 给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。来看下面的例子： 1234function makeKing(name = &#x27;Henry&#x27;, numerals = &#x27;VIII&#x27;) &#123; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125;console.log(makeKing()); // King Henry VIII 这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象一下这个过程： 12345function makeKing() &#123; let name = &#x27;Henry&#x27;; let numerals = &#x27;VIII&#x27;; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125; 因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子： 1234function makeKing(name = &#x27;Henry&#x27;, numerals = name) &#123; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125;console.log(makeKing()); // King Henry Henry 参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误： 1234// 调用时不传第一个参数会报错function makeKing(name = numerals, numerals = &#x27;VIII&#x27;) &#123; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125; 参数也存在于自己的作用域中，它们不能引用函数体的作用域： 12345// 调用时不传第二个参数会报错function makeKing(name = &#x27;Henry&#x27;, numerals = defaultNumeral) &#123; let defaultNumeral = &#x27;VIII&#x27;; return `King $&#123;name&#125; $&#123;numerals&#125;`;&#125; 参数扩展与收集ECMAScript 6 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。 扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。 扩展参数在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。 假设有如下函数定义，它会将所有传入的参数累加起来： 12345678let values = [1, 2, 3, 4];function getSum() &#123; let sum = 0; for (let i = 0; i &lt; arguments.length; ++i) &#123; sum += arguments[i]; &#125; return sum;&#125; 这个函数希望将所有加数逐个传进来，然后通过迭代 arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply()方法： 1console.log(getSum.apply(null, values)); // 10 但在 ECMAScript 6 中，可以通过扩展操作符极为简洁地实现这种操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。 比如，使用扩展操作符可以将前面例子中的数组像这样直接传给函数： 1console.log(getSum(...values)); // 10 因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值， 包括使用扩展操作符传其他参数： 1234console.log(getSum(-1, ...values)); // 9console.log(getSum(...values, 5)); // 15console.log(getSum(-1, ...values, 5)); // 14console.log(getSum(...values, ...[5,6,7])); // 28 对函数中的 arguments 对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值： 12345678910let values = [1,2,3,4]function countArguments() &#123; console.log(arguments.length);&#125;countArguments(-1, ...values); // 5countArguments(...values, 5); // 5countArguments(-1, ...values, 5); // 6countArguments(...values, ...[5,6,7]); // 7 arguments 对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数： 123456789101112131415function getProduct(a, b, c = 1) &#123; return a * b * c;&#125;let getSum = (a, b, c = 0) =&gt; &#123; return a + b + c;&#125;console.log(getProduct(...[1,2])); // 2console.log(getProduct(...[1,2,3])); // 6console.log(getProduct(...[1,2,3,4])); // 6console.log(getSum(...[0,1])); // 1console.log(getSum(...[0,1,2])); // 3console.log(getSum(...[0,1,2,3])); // 3 收集参数在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似 arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。 1234567function getSum(...values) &#123; // 顺序累加 values 中的所有值 // 初始值的总和为 0 return values.reduce((x, y) =&gt; x + y, 0);&#125;console.log(getSum(1,2,3)); // 6 收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数： 123456789101112// 不可以function getProduct(...values, lastValue) &#123;&#125;// 可以function ignoreFirst(firstValue, ...values) &#123; console.log(values);&#125;ignoreFirst(); // []ignoreFirst(1); // []ignoreFirst(1,2); // [2]ignoreFirst(1,2,3); // [2, 3] 箭头函数虽然不支持 arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用 arguments 一样的逻辑： 1234let getSum = (...values) =&gt; &#123; return values.reduce((x, y) =&gt; x + y, 0);&#125;console.log(getSum(1,2,3)); // 6 另外，使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数： 1234567function getSum(...values) &#123; console.log(arguments.length); // 3 console.log(arguments); // [1, 2, 3] console.log(values); // [1, 2, 3]&#125;console.log(getSum(1,2,3)); 函数声明与函数表达式到目前为止一直没有把函数声明和函数表达式区分得很清楚。事实上，**JavaScript 引擎在加载数据时对函数声明和函数表达式是区别对待的。** JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。来看下面的例子： 12345// 没问题console.log(sum(10, 10));function sum(num1, num2) &#123; return num1 + num2;&#125; 以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作函数声明提升（function declaration hoisting）。在执行代码时，JavaScript 引擎会先执行一遍扫描， 把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把 函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错： 12345// 会出错console.log(sum(10, 10));let sum = function(num1, num2) &#123; return num1 + num2;&#125;; 上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。 这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰到同样的问题： 1234console.log(sum(10, 10));var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。 函数作为值因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。来看下面的例子： 123function callSomeFunction(someFunction, someArgument) &#123; return someFunction(someArgument);&#125; 这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传给这个函数的值。任何函数都可以像下面这样作为参数传递： 12345678910111213function add10(num) &#123; return num + 10;&#125;let result1 = callSomeFunction(add10, 10);console.log(result1); // 20function getGreeting(name) &#123; return &quot;Hello, &quot; + name;&#125;let result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);console.log(result2); // &quot;Hello, Nicholas&quot; callSomeFunction()函数是通用的，第一个参数传入的是什么函数都可以，而且它始终返回调用 作为第一个参数传入的函数的结果。要注意的是，如果是访问函数而不是调用函数，那就必须不带括号， 所以传给 callSomeFunction()的必须是 add10 和 getGreeting，而不能是它们的执行结果。 从一个函数中返回另一个函数也是可以的，而且非常有用。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个 sort()方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。比如： 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; let value1 = object1[propertyName]; let value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 这个函数的语法乍一看比较复杂，但实际上就是在一个函数中返回另一个函数，注意那个 return 操作符。内部函数可以访问 propertyName 参数，并通过中括号语法取得要比较的对象的相应属性值。 取得属性值以后，再按照 sort()方法的需要返回比较值就行了。这个函数可以像下面这样使用： 12345678let data = [ &#123;name: &quot;Zachary&quot;, age: 28&#125;, &#123;name: &quot;Nicholas&quot;, age: 29&#125;];data.sort(createComparisonFunction(&quot;name&quot;));console.log(data[0].name); // Nicholasdata.sort(createComparisonFunction(&quot;age&quot;));console.log(data[0].name); // Zachary 在上面的代码中，数组 data 中包含两个结构相同的对象。每个对象都有一个 name 属性和一个 age 属性。默认情况下，sort()方法要对这两个对象执行 toString()，然后再决定它们的顺序，但这样 得不到有意义的结果。而通过调用 createComparisonFunction(&quot;name&quot;)来创建一个比较函数，就 可以根据每个对象 name 属性的值来排序，结果 name 属性值为”Nicholas”、age 属性值为 29 的对象 会排在前面。而调用 createComparisonFunction(&quot;age&quot;)则会创建一个根据每个对象 age 属性的值 来排序的比较函数，结果 name 属性值为”Zachary”、age 属性值为 28 的对象会排在前面。 函数内部在 ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和 this。ECMAScript 6 又新增 了 new.target 属性。 argumentsarguments 对象前面讨论过多次了，它是一个类数组对象，包含调用函数时传入的所有参数。这 个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针。来看下面这个经典的阶乘函数： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; 阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 factorial，从而导致 了紧密耦合。使用 arguments.callee 就可以让函数逻辑与函数名解耦： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; 这个重写之后的 factorial()函数已经用 arguments.callee 代替了之前硬编码的 factorial。 这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况： 12345678let trueFactorial = factorial;factorial = function() &#123; return 0;&#125;;console.log(trueFactorial(5)); // 120console.log(factorial(5)); // 0 这里，trueFactorial 变量被赋值为 factorial，实际上把同一个函数的指针又保存到了另一个 位置。然后，factorial 函数又被重写为一个返回 0 的函数。如果像 factorial()最初的版本那样不 使用 arguments.callee，那么像上面这样调用 trueFactorial()就会返回 0。不过，通过将函数与 名称解耦，trueFactorial()就可以正确计算阶乘，而 factorial()则只能返回 0。 this另一个特殊的对象是 this，它在标准函数和箭头函数中有不同的行为。 在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在 网页的全局上下文中调用函数时，this 指向 windows）。来看下面的例子： 12345678910111213window.color = &#x27;red&#x27;;let o = &#123; color: &#x27;blue&#x27;&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); // &#x27;red&#x27;o.sayColor = sayColor;o.sayColor(); // &#x27;blue&#x27; 定义在全局上下文中的函数 sayColor()引用了 this 对象。这个 this 到底引用哪个对象必须到 函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用 sayColor()，这结果会输出”red”，因为 this 指向 window，而 this.color 相当于 window.color。 而在把 sayColor()赋值给 o 之后再调用 o.sayColor()，this 会指向 o，即 this.color 相当于 o.color，所以会显示”blue”。 在箭头函数中，this引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对sayColor() 的两次调用中，this 引用的都是 window 对象，因为这个箭头函数是在 window 上下文中定义的： 123456789101112window.color = &#x27;red&#x27;;let o = &#123; color: &#x27;blue&#x27;&#125;;let sayColor = () =&gt; console.log(this.color);sayColor(); // &#x27;red&#x27;o.sayColor = sayColor;o.sayColor(); // &#x27;red&#x27; 在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文： 1234567891011121314function King() &#123; this.royaltyName = &#x27;Henry&#x27;; // this 引用 King 的实例 setTimeout(() =&gt; console.log(this.royaltyName), 1000);&#125; function Queen() &#123; this.royaltyName = &#x27;Elizabeth&#x27;; // this 引用 window 对象 setTimeout(function() &#123; console.log(this.royaltyName); &#125;, 1000);&#125;new King(); // Henrynew Queen(); // undefined 注意：函数名只是保存指针的变量。因此全局定义的 ·ayColor()函数和 o.sayColor() 是同一个函数，只不过执行的上下文不同。 callerECMAScript 5 也会给函数对象上添加一个属性：caller。虽然ECMAScript 3 中并没有定义，但所 有浏览器除了早期版本的 Opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是 在全局作用域中调用的则为 null。比如： 12345678function outer() &#123; inner();&#125;function inner() &#123; console.log(inner.caller);&#125;outer(); 以上代码会显示 outer()函数的源代码。这是因为 ourter()调用了 inner()，inner.caller 指向 outer()。如果要降低耦合度，则可以通过 arguments.callee.caller 来引用同样的值: 123456789function outer() &#123; inner();&#125;function inner() &#123; console.log(arguments.callee.caller);&#125;outer(); 在严格模式下访问 arguments.callee会报错。ECMAScript 5 也定义了 arguments.caller，但 在严格模式下访问它会报错，在非严格模式下则始终是 undefined。这是为了分清 arguments.caller 和函数的 caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同 一上下文中运行的其他代码。 new.targetECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。 ECMAScript 6 新增了检测函数是否使用 new关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new关键字调用的，则 new.target 将引用被调用的构造函数。 123456789function King() &#123; if (!new.target) &#123; throw &#x27;King must be instantiated using &quot;new&quot;&#x27; &#125; console.log(&#x27;King instantiated using &quot;new&quot;&#x27;);&#125;new King(); // King instantiated using &quot;new&quot;King(); // Error: King must be instantiated using &quot;new&quot; 函数属性与方法前面提到过，ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length 和 prototype。其中，length 属性保存函数定义的命名参数的个数，如下例所示： 123456789101112131415function sayName(name) &#123; console.log(name);&#125;function sum(num1, num2) &#123; return num1 + num2;&#125;function sayHi() &#123; console.log(&quot;hi&quot;);&#125;console.log(sayName.length); // 1console.log(sum.length); // 2console.log(sayHi.length); // 0 以上代码定义了 3 个函数，每个函数的命名参数个数都不一样。sayName()函数有 1 个命名参数， 所以其 length 属性为 1。类似地，sum()函数有两个命名参数，所以其 length 属性是 2。而 sayHi() 没有命名参数，其 length 属性为 0。 prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实 例共享。这个属性在自定义类型时特别重要。（相关内容已经在对象、类与面向对象一章详细介绍过了。）在 ECMAScript 5 中，prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。 函数还有两个方法：apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设置调用函数时函数体内 this 对象的值。apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象。来看下面的例子: 1234567891011121314function sum(num1, num2) &#123; return num1 + num2;&#125;function callSum1(num1, num2) &#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125; function callSum2(num1, num2) &#123; return sum.apply(this, [num1, num2]); // 传入数组&#125;console.log(callSum1(10, 10)); // 20console.log(callSum2(10, 10)); // 20 在这个例子中，callSum1()会调用 sum()函数，将 this 作为函数体内的 this 值（这里等于 window，因为是在全局作用域中调用的）传入，同时还传入了 arguments 对象。callSum2()也会调 用 sum()函数，但会传入参数的数组。这两个函数都会执行并返回正确的结果。 在严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。 除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成undefined。 call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须将参数一个一个地列出来，比如： 12345678function sum(num1, num2) &#123; return num1 + num2;&#125;function callSum(num1, num2) &#123; return sum.call(this, num1, num2);&#125;console.log(callSum(10, 10)); // 20 这里的 callSum()函数必须逐个地把参数传给 call()方法。结果跟 apply()的例子一样。到底是使用 apply()还是 call()，完全取决于怎么给要调用的函数传参更方便。如果想直接传 arguments 对象或者一个数组，那就用 apply()；否则，就用 call()。当然，如果不用给被调用的函数传参，则 使用哪个方法都一样。 apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this 值的能力。考虑下面的例子： 123456789101112131415window.color = &#x27;red&#x27;;let o = &#123; color: &#x27;blue&#x27;&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); // redsayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue 这个例子是在之前那个关于 this 对象的例子基础上修改而成的。同样，sayColor()是一个全局 函数，如果在全局作用域中调用它，那么会显示”red”。这是因为 this.color 会求值为 window.color。 如果在全局作用域中显式调用 sayColor.call(this)或者 sayColor.call(window)，则同样都会显示”red”。而在使用 sayColor.call(o)把函数的执行上下文即 this 切换为对象 o 之后，结果就变成 了显示”blue”了。 使用 call()或 apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。在前面例子最初的版本中，为切换上下文需要先把 sayColor()直接赋值为 o 的属性，然后再 调用。而在这个修改后的版本中，就不需要这一步操作了。 ECMAScript 5 出于同样的目的定义了一个新方法：bind()。bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象。比如： 123456789101112window.color = &#x27;red&#x27;;var o = &#123; color: &#x27;blue&#x27;&#125;;function sayColor() &#123; console.log(this.color);&#125;let objectSayColor = sayColor.bind(o);objectSayColor(); // blue 这里，在 sayColor()上调用 bind()并传入对象 o 创建了一个新函数 objectSayColor()。 objectSayColor()中的 this 值被设置为 o，因此直接调用这个函数，即使是在全局作用域中调用， 也会返回字符串”blue”。 对函数而言，继承的方法 toLocaleString()和 toString()始终返回函数的代码。返回代码的 具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚 至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在 调试中使用它们。继承的方法 valueOf()返回函数本身。 函数表达式函数表达式虽然更强大，但也更容易让人迷惑。我们知道，定义函数有两种方式：函数声明和函数表达式。函数声明是这样的： 123function functionName(arg0, arg1, arg2) &#123; // 函数体&#125; 函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明 可以出现在调用它的代码之后： 1234sayHi();function sayHi() &#123; console.log(&quot;Hi!&quot;);&#125; 这个例子不会抛出错误，因为 JavaScript 引擎会先读取函数声明，然后再执行代码。 第二种创建函数的方式就是函数表达式。函数表达式有几种不同的形式，最常见的是这样的： 123let functionName = function(arg0, arg1, arg2) &#123; // 函数体&#125;; 函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为 function 关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 name 属性是空字符串。 函数表达式跟 JavaScript 中的其他表达式一样，需要先赋值再使用。下面的例子会导致错误： 1234sayHi(); // Error! function doesn&#x27;t exist yetlet sayHi = function() &#123; console.log(&quot;Hi!&quot;);&#125;; 理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎 意料： 12345678910// 千万别这样做！if (condition) &#123; function sayHi() &#123; console.log(&#x27;Hi!&#x27;); &#125;&#125; else &#123; function sayHi() &#123; console.log(&#x27;Yo!&#x27;); &#125;&#125; 这段代码看起来很正常，就是如果 condition 为 true，则使用第一个 sayHi()定义；否则，就 使用第二个。事实上，这种写法在 ECAMScript 中不是有效的语法。JavaScript 引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略 condition 直接返回第二个声明。Firefox 会在 condition 为 true 时返回第一个声明。这种写法很危险，不要使用。不过， 如果把上面的函数声明换成函数表达式就没问题了： 1234567891011// 没问题let sayHi;if (condition) &#123; sayHi = function() &#123; console.log(&quot;Hi!&quot;); &#125;;&#125; else &#123; sayHi = function() &#123; console.log(&quot;Yo!&quot;); &#125;;&#125; 这个例子可以如预期一样，根据 condition 的值为变量 sayHi 赋予相应的函数。 创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回： 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; let value1 = object1[propertyName]; let value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 这里的 createComparisonFunction()函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在 createComparisonFunction()内部，那个函数是匿名的。任何时候， 只要函数被当作值来使用，它就是一个函数表达式。本章后面会介绍，这并不是使用函数表达式的唯一 方式。 递归递归函数通常的形式是一个函数通过名称调用自己，如下面的例子所示： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; 这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题： 123let anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4)); // 报错 这里把 factorial()函数保存在了另一个变量 anotherFactorial 中，然后将 factorial 设置 为 null，于是只保留了一个对原始函数的引用。而在调用 anotherFactorial()时，要递归调用 factorial()，但因为它已经不是函数了，所以会出错。在写递归函数时使用 arguments.callee 可以避免这个问题。 arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; 像这里else分支里的这一行一样，把函数名称替换成 arguments.callee，可以确保无论通过什么变量 调用这个函数都不会出问题。因此在编写递归函数时，arguments.callee 是引用当前函数的首选。 不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可 以使用命名函数表达式（named function expression）达到目的。比如： 1234567const factorial = (function f(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num - 1); &#125;&#125;); 这里创建了一个命名函数表达式 f()，然后将它赋值给了变量 factorial。即使把函数赋值给另 一个变量，函数表达式的名称 f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。 尾调用优化ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。 具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如： 123function outerFunction() &#123; return innerFunction(); // 尾调用&#125; 在 ES6 优化之前，执行这个例子会在内存中发生如下操作。 执行到 outerFunction 函数体，第一个栈帧被推到栈上。 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。 执行到 innerFunction 函数体，第二个栈帧被推到栈上。 执行 innerFunction 函数体，计算其返回值。 将返回值传回 outerFunction，然后 outerFunction 再返回值。 将栈帧弹出栈外。 在 ES6 优化之后，执行这个例子会在内存中发生如下操作。 执行到 outerFunction 函数体，第一个栈帧被推到栈上。 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction 的返回值。 弹出 outerFunction 的栈帧。 执行到 innerFunction 函数体，栈帧被推到栈上。 执行 innerFunction 函数体，计算其返回值。 将 innerFunction 的栈帧弹出栈外。 很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多 少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。 尾调用优化的条件尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下： 代码在严格模式下执行 外部函数的返回值是对尾调用函数的调用； 尾调用函数返回后不需要执行额外的逻辑； 尾调用函数不是引用外部函数作用域中自由变量的闭包。 下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求： 123456789101112131415161718192021222324&quot;use strict&quot;;// 无优化：尾调用没有返回function outerFunction() &#123; innerFunction();&#125;// 无优化：尾调用没有直接返回function outerFunction() &#123; let innerFunctionResult = innerFunction(); return innerFunctionResult;&#125;// 无优化：尾调用返回后必须转型为字符串function outerFunction() &#123; return innerFunction().toString();&#125; // 无优化：尾调用是一个闭包function outerFunction() &#123; let foo = &#x27;bar&#x27;; function innerFunction() &#123; return foo; &#125; return innerFunction();&#125; 下面是几个符合尾调用优化条件的例子： 12345678910111213141516171819&quot;use strict&quot;;// 有优化：栈帧销毁前执行参数计算function outerFunction(a, b) &#123; return innerFunction(a + b);&#125;// 有优化：初始返回值不涉及栈帧function outerFunction(a, b) &#123; if (a &lt; b) &#123; return a; &#125; return innerFunction(a + b);&#125;// 有优化：两个内部函数都在尾部function outerFunction(condition) &#123; return condition ? innerFunctionA() : innerFunctionB();&#125; 差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效 果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。 尾调用优化的代码可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数： 1234567891011121314function fib(n) &#123; if (n &lt; 2) &#123; return n; &#125; return fib(n - 1) + fib(n - 2);&#125;console.log(fib(0)); // 0console.log(fib(1)); // 1console.log(fib(2)); // 1console.log(fib(3)); // 2console.log(fib(4)); // 3console.log(fib(5)); // 5console.log(fib(6)); // 8 显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈 帧数的内存复杂度是 O(2^n)。因此，即使这么一个简单的调用也可以给浏览器带来麻烦： 1fib(1000); 当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实 现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归： 1234567891011121314&quot;use strict&quot;;// 基础框架function fib(n) &#123; return fibImpl(0, 1, n);&#125;// 执行递归function fibImpl(a, b, n) &#123; if (n === 0) &#123; return a; &#125; return fibImpl(b, a + b, n - 1);&#125; 这样重构之后，就可以满足尾调用优化的所有条件，再调用 fib(1000)就不会对浏览器造成威胁了。 闭包匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数： 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; let value1 = object1[propertyName]; let value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 其中： 12let value1 = object1[propertyName];let value2 = object2[propertyName]; 两行代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含 createComparisonFunction()函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么。 理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。 在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码： 1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;let result = compare(5, 10); 这里定义的 compare()函数是在全局上下文中调用的。第一次调用 compare()时，会为它创建一 个包含 arguments、value1 和 value2 的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是 compare()作用域链上的第二个对象，其中包含 this、result 和 compare。 函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义 compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在 调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着 会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare() 函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。 函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。 在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。 12let compare = createComparisonFunction(&#x27;name&#x27;);let result = compare(&#123; name: &#x27;Nicholas&#x27; &#125;, &#123; name: &#x27;Matt&#x27; &#125;); 在 createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含 createComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到 createComparisonFunction()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的 活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁： 12345678// 创建比较函数let compareNames = createComparisonFunction(&#x27;name&#x27;);// 调用函数let result = compareNames(&#123; name: &#x27;Nicholas&#x27; &#125;, &#123; name: &#x27;Matt&#x27; &#125;);// 解除对函数的引用，这样就可以释放内存了compareNames = null; 这里，创建的比较函数被保存在变量 compareNames 中。把 compareNames 设置为等于 null 会 解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。 因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭 包可能导致内存过度占用，因此建议仅在十分必要时使用。 this对象在闭包中使用 this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 this 在非严格模式下等于 window，在严 格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情 况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。 不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子： 1234567891011window.identity = &#x27;The Window&#x27;;let object = &#123; identity: &#x27;My Object&#x27;, getIdentityFunc() &#123; return function() &#123; return this.identity; &#125;; &#125;&#125;;console.log(object.getIdentityFunc()()); // &#x27;The Window&#x27; 这里先创建了一个全局变量 identity，之后又创建一个包含 identity 属性的对象。这个对象还 包含一个 getIdentityFunc()方法，返回一个匿名函数。这个匿名函数返回 this.identity。因为 getIdentityFunc()返回函数，所以 object.getIdentityFunc()()会立即调用这个返回的函数， 从而得到一个字符串。可是，此时返回的字符串是”The Winodw”，即全局变量 identity 的值。为什么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？ 前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把 this 保存到闭包可以访问的另一个变量中， 则是行得通的。比如： 1234567891011window.identity = &#x27;The Window&#x27;;let object = &#123; identity: &#x27;My Object&#x27;, getIdentityFunc() &#123; let that = this; return function() &#123; return that.identity; &#125;; &#125;&#125;;console.log(object.getIdentityFunc()()); // &#x27;My Object&#x27; 这里加粗的代码展示了与前面那个例子的区别。在定义匿名函数之前，先把外部函数的 this 保存 到变量 that 中。然后在定义闭包时，就可以让它访问 that，因为这是包含函数中名称没有任何冲突的 一个变量。即使在外部函数返回之后，that 仍然指向 object，所以调用 object.getIdentityFunc()() 就会返回”My Object”。 注意：this 和 arguments 都是不能直接在内部函数中访问的。如果想访问包含作用域中 的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。 在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子： 1234567window.identity = &#x27;The Window&#x27;;let object = &#123; identity: &#x27;My Object&#x27;, getIdentity () &#123; return this.identity; &#125;&#125;; getIdentity()方法就是返回 this.identity 的值。以下是几种调用 object.getIdentity() 的方式及返回值： 123object.getIdentity(); // &#x27;My Object&#x27;(object.getIdentity)(); // &#x27;My Object&#x27;(object.getIdentity = object.getIdentity)(); // &#x27;The Window&#x27; 第一行调用 object.getIdentity()是正常调用，会返回”My Object”，因为 this.identity 就是 object.identity。第二行在调用时把 object.getIdentity 放在了括号里。虽然加了括号之 后看起来是对一个函数的引用，但 this 值并没有变。这是因为按照规范，object.getIdentity 和 (object.getIdentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是”The Window”。 一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道， 即使语法稍有不同，也可能影响 this 的值。 内存泄漏来看下面的例子： 1234function assignHandler() &#123; let element = document.getElementById(&#x27;someElement&#x27;); element.onclick = () =&gt; console.log(element.id);&#125; 以上代码创建了一个闭包，即 element 元素的事件处理程序（事件处理程序将在后续讨论）。 而这个处理程序又创建了一个循环引用。匿名函数引用着 assignHandler()的活动对象，阻止了对 element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于 1。也就是说， 内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如： 123456function assignHandler() &#123; let element = document.getElementById(&#x27;someElement&#x27;); let id = element.id; element.onclick = () =&gt; console.log(id); element = null;&#125; 在这个修改后的版本中，闭包改为引用一个保存着 element.id 的变量 id，从而消除了循环引用。 不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含 element。即使闭包没有直接引用 element，包含函数的活动对象上还是保存着对它的引用。因此，必 须再把 element 设置为 null。这样就解除了对这个 COM 对象的引用，其引用计数也会减少，从而确 保其内存可以在适当的时候被回收。 立即调用的函数表达式立即调用的匿名函数又被称作立即调用的函数表达式（IIFE，Immediately Invoked Function Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组 括号后面的第二组括号会立即调用前面的函数表达式。下面是一个简单的例子： 123(function() &#123; // 块级作用域&#125;)(); 使用 IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE 模拟块级作用域是相当普遍的。比如下面的例子： 1234567// IIFE(function () &#123; for (var i = 0; i &lt; count; i++) &#123; console.log(i); &#125;&#125;)();console.log(i); // 抛出错误 前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义 的，在外部访问不到。在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。 这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕， 其作用域链就可以被销毁。 在 ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离。下面展示了两种不同的块级作用域形式： 12345678910111213// 内嵌块级作用域&#123; let i; for (i = 0; i &lt; count; i++) &#123; console.log(i); &#125;&#125;console.log(i); // 抛出错误// 循环的块级作用域for (let i = 0; i &lt; count; i++) &#123; console.log(i);&#125;console.log(i); // 抛出错误 说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如： 1234567let divs = document.querySelectorAll(&#x27;div&#x27;);// 达不到目的！for (var i = 0; i &lt; divs.length; ++i) &#123; divs[i].addEventListener(&#x27;click&#x27;, function() &#123; console.log(i); &#125;);&#125; 这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。 因此，渲染到页面上之后，点击每个&lt;div&gt;都会弹出元素总数。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。 以前，为了实现点击第几个就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值： 123456789let divs = document.querySelectorAll(&#x27;div&#x27;);for (var i = 0; i &lt; divs.length; ++i) &#123; divs[i].addEventListener(&#x27;click&#x27;, (function(frozenCounter) &#123; return function() &#123; console.log(frozenCounter); &#125;; &#125;)(i));&#125; 而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了： 123456let divs = document.querySelectorAll(&#x27;div&#x27;);for (let i = 0; i &lt; divs.length; ++i) &#123; divs[i].addEventListener(&#x27;click&#x27;, function() &#123; console.log(i); &#125;);&#125; 这样就可以让每次点击都显示正确的索引了。这里，事件处理程序执行时就会引用 for 循环块级作用域中的索引值。这是因为在 ECMAScript 6 中，如果对 for 循环使用块级作用域变量关键字(在这里就是 let)，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。 但要注意，如果把变量声明拿到 for 循环外部，那就不行了。下面这种写法会碰到跟在循环中使用 var i = 0 同样的问题： 12345678let divs = document.querySelectorAll(&#x27;div&#x27;);// 达不到目的！let i;for (i = 0; i &lt; divs.length; ++i) &#123; divs[i].addEventListener(&#x27;click&#x27;, function() &#123; console.log(i); &#125;);&#125; 私有变量严格来讲，JavaScript 没有私有成员的概念，所有对象属性都是公有的。不过，倒是有私有变量的概 念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的 变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。来看下面的例子： 1234function add(num1, num2) &#123; let sum = num1 + num2; return sum;&#125; 在这个函数中，函数 add()有 3 个私有变量：num1、num2 和 sum。这几个变量只能在函数内部使 用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部 的这 3 个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。 特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有 两种方式创建特权方法。第一种是在构造函数中实现，比如： 12345678910111213function MyObject() &#123; // 私有变量和私有函数 let privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; 这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访 问构造函数中定义的所有变量和函数的能力。在这个例子中，变量 privateVariable 和函数 privateFunction()只能通过 publicMethod()方法来访问。在创建 MyObject 的实例后，没有办法 直接访问 privateVariable 和 privateFunction()，唯一的办法是使用 publicMethod()。 如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据： 1234567891011121314function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125;let person = new Person(&#x27;Nicholas&#x27;);console.log(person.getName()); // &#x27;Nicholas&#x27;person.setName(&#x27;Greg&#x27;);console.log(person.getName()); // &#x27;Greg&#x27; 这段代码中的构造函数定义了两个特权方法：getName()和 setName()。每个方法都可以构造函 数外部调用，并通过它们来读写私有的 name 变量。在 Person 构造函数外部，没有别的办法访问 name。 因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问 name 的闭包。私有变量 name 对每个 Person 实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。 不过这样也有个问题：必须通过构造函数来实现这种隔离。而构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。 静态私有变量特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示： 1234567891011121314151617(function() &#123; // 私有变量和私有函数 let privateVariable = 10; function privateFunction() &#123; return false; &#125; // 构造函数 MyObject = function() &#123;&#125;; // 公有和特权方法 MyObject.prototype.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后又定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。注意，这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里并不是必需的。基于同样的原因（但操作相反），这里声明 MyObject 并没有使 用任何关键字。因为不使用关键字声明的变量会创建在全局作用域中，所以 MyObject 变成了全局变量， 可以在这个私有作用域外部被访问。注意在严格模式下给未声明的变量赋值会导致错误。 这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。来看下面的例子： 123456789101112131415161718192021222324(function() &#123; let name = &#x27;&#x27;; Person = function(value) &#123; name = value; &#125;; Person.prototype.getName = function() &#123; return name; &#125;; Person.prototype.setName = function(value) &#123; name = value; &#125;;&#125;)();let person1 = new Person(&#x27;Nicholas&#x27;);console.log(person1.getName()); // &#x27;Nicholas&#x27;person1.setName(&#x27;Matt&#x27;);console.log(person1.getName()); // &#x27;Matt&#x27;let person2 = new Person(&#x27;Michael&#x27;);console.log(person1.getName()); // &#x27;Michael&#x27;console.log(person2.getName()); // &#x27;Michael&#x27; 这里的 Person 构造函数可以访问私有变量 name，跟 getName()和 setName()方法一样。使用这种模式，name 变成了静态变量（因为原型方法getName()和setName()中使用了name变量，所以把name变提升为了原型变量），可供所有实例使用。这意味着在任何实例上调用 setName()修改这个 变量都会影响其他实例。调用 setName()或创建新的 Person 实例都要把 name 变量设置为一个新值。 而所有实例都会返回相同的值。 像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。 模块模式前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的 Douglas Crockford 所说的 模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript是通过对象字面量来创建单例对象的，如下面的例子所示： 123456let singleton = &#123; name: value, method() &#123; // 方法的代码 &#125;&#125;; 模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下： 1234567891011121314151617let singleton = function() &#123; // 私有变量和私有函数 let privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权/公有方法和属性 return &#123; publicProperty: true, publicMethod() &#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后， 创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因 为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函 数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式： 12345678910111213141516171819let application = function() &#123; // 私有变量和私有函数 let components = new Array(); // 初始化 components.push(new BaseComponent()); // 公共接口 return &#123; getComponentCount() &#123; return components.length; &#125;, registerComponent(component) &#123; if (typeof component == &#x27;object&#x27;) &#123; components.push(component); &#125; &#125; &#125;;&#125;(); 在 Web 开发中，经常需要使用单例对象管理应用程序级的信息。上面这个简单的例子创建了一个 application 对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组 components， 然后将一个 BaseComponent 组件的新实例添加到数组中。（BaseComponent 组件的代码并不重要，在这里用它只是为了说明模块模式的用法。）对象字面量中定义的 getComponentCount()和 registerComponent()方法都是可以访问 components 私有数组的特权方法。前一个方法返回注册组件的数量， 后一个方法负责注册新组件。 在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以 通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 Object 的实例，因为最终单例都 由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以可以避免使用 instanceof 操作符确定参数是不是对象类型的需求。 模块增强模式另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类 型的实例，但又必须给它添加额外属性或方法的场景。来看下面的例子： 123456789101112131415161718let singleton = function() &#123; // 私有变量和私有函数 let privateVariable = 10; function privateFunction() &#123; return false; &#125; // 创建对象 let object = new CustomType(); // 添加特权/公有属性和方法 object.publicProperty = true; object.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;; // 返回对象 return object;&#125;(); 如果前一节的 application 对象必须是 BaseComponent 的实例，那么就可以使用下面的代码来 创建它： 1234567891011121314151617181920let application = function() &#123; // 私有变量和私有函数 let components = new Array(); // 初始化 components.push(new BaseComponent()); // 创建局部变量保存实例 let app = new BaseComponent(); // 公共接口 app.getComponentCount = function() &#123; return components.length; &#125;; app.registerComponent = function(component) &#123; if (typeof component == &quot;object&quot;) &#123; components.push(component); &#125; &#125;; // 返回实例 return app;&#125;(); 在这个重写的 application 单例对象的例子中，首先定义了私有变量和私有函数，跟之前例子中 一样。主要区别在于这里创建了一个名为 app 的变量，其中保存了 BaseComponent 组件的实例。这是 最终要变成 application 的那个对象的局部版本。在给这个局部变量 app 添加了能够访问私有变量的 公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给 application。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(7)——代理与反射","slug":"JS高级程序设计读书笔记(7)——代理与反射","date":"2023-03-07T19:54:39.000Z","updated":"2023-11-27T15:34:23.883Z","comments":true,"path":"2023/03/08/JS高级程序设计读书笔记(7)——代理与反射/","link":"","permalink":"http://pvnk1u.github.io/2023/03/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/","excerpt":"","text":"ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。 在 ES6 之前，ECMAScript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的 ECMAScript 代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。 代理基础代理是目标对象的抽象。它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。 创建空代理最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。 代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。 如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。 1234567891011121314151617181920212223242526272829303132333435363738const target = &#123; id: &#x27;target&#x27;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);// id 属性会访问同一个值console.log(target.id); // targetconsole.log(proxy.id); // target// 给目标属性赋值会反映在两个对象上// 因为两个对象访问的是同一个值target.id = &#x27;foo&#x27;;console.log(target.id); // fooconsole.log(proxy.id); // foo// 给代理属性赋值会反映在两个对象上// 因为这个赋值会转移到目标对象proxy.id = &#x27;bar&#x27;;console.log(target.id); // barconsole.log(proxy.id); // bar// hasOwnProperty()方法在两个地方// 都会应用到目标对象console.log(target.hasOwnProperty(&#x27;id&#x27;)); // trueconsole.log(proxy.hasOwnProperty(&#x27;id&#x27;)); // true// Proxy.prototype 是 undefined// 因此不能使用 instanceof 操作符console.log(target instanceof Proxy); // TypeError: Function has non-object prototype&#x27;undefined&#x27; in instanceof checkconsole.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype&#x27;undefined&#x27; in instanceof check// 严格相等可以用来区分代理和目标console.log(target === proxy); // false 定义捕获器使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。 例如，可以定义一个 get()捕获器，在 ECMAScript 操作以某种形式调用 get()时触发。下面的例子定义了一个 get()捕获器： 123456789101112const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; // 捕获器在处理程序对象中以方法名为键 get() &#123; return &#x27;handler override&#x27;; &#125;&#125;;const proxy = new Proxy(target, handler); 这样，当通过代理对象执行 get()操作时，就会触发定义的 get()捕获器。当然，get()不是ECMAScript 对象可以调用的方法。这个操作在 JavaScript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[property]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。 123456789101112131415161718192021const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; // 捕获器在处理程序对象中以方法名为键 get() &#123; return &#x27;handler override&#x27;; &#125;&#125;;const proxy = new Proxy(target, handler);console.log(target.foo); // barconsole.log(proxy.foo); // handler overrideconsole.log(target[&#x27;foo&#x27;]); // barconsole.log(proxy[&#x27;foo&#x27;]); // handler overrideconsole.log(Object.create(target)[&#x27;foo&#x27;]); // barconsole.log(Object.create(proxy)[&#x27;foo&#x27;]); // handler override 捕获器参数和反射API所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。 12345678910111213141516const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; get(trapTarget, property, receiver) &#123; console.log(trapTarget === target); console.log(property); console.log(receiver === proxy); &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo;// true// foo// true 有了这些参数，就可以重建被捕获方法的原始行为： 1234567891011121314const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; get(trapTarget, property, receiver) &#123; return trapTarget[property]; &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar 所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。 处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象： 1234567891011121314const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; get() &#123; return Reflect.get(...arguments); &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar 甚至还可以写得更简洁一些： 123456789101112const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; get: Reflect.get&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar 事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象： 12345678const target = &#123; foo: &#x27;bar&#x27;&#125;;const proxy = new Proxy(target, Reflect);console.log(proxy.foo); // barconsole.log(target.foo); // bar 反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰： 12345678910111213141516171819202122const target = &#123; foo: &#x27;bar&#x27;, baz: &#x27;qux&#x27;&#125;;const handler = &#123; get(trapTarget, property, receiver) &#123; let decoration = &#x27;&#x27;; if (property === &#x27;foo&#x27;) &#123; decoration = &#x27;!!!&#x27;; &#125; return Reflect.get(...arguments) + decoration; &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // bar!!!console.log(target.foo); // barconsole.log(proxy.baz); // quxconsole.log(target.baz); // qux 捕获器不变式使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。 比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError： 1234567891011121314151617const target = &#123;&#125;;Object.defineProperty(target, &#x27;foo&#x27;, &#123; configurable: false, writable: false, value: &#x27;bar&#x27;&#125;);const handler = &#123; get() &#123; return &#x27;qux&#x27;; &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo);// TypeError 可撤销代理有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。 Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。 撤销函数和代理对象是在实例化时同时生成的： 123456789101112131415161718const target = &#123; foo: &#x27;bar&#x27;&#125;;const handler = &#123; get() &#123; return &#x27;intercepted&#x27;; &#125;&#125;;const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);console.log(proxy.foo); // interceptedconsole.log(target.foo); // barrevoke();console.log(proxy.foo); // TypeError 实用反射API某些情况下应该优先使用反射 API，这是有一些理由的。 反射API与对象API 在使用反射 API 时，要记住： 反射 API 并不限于捕获处理程序； 大多数反射 API 方法在 Object 类型上有对应的方法。 通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。 状态标记 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。例如，可以使用反射API 对下面的代码进行重构： 123456789// 初始代码const o = &#123;&#125;;try &#123; Object.defineProperty(o, &#x27;foo&#x27;, &#x27;bar&#x27;); console.log(&#x27;success&#x27;);&#125; catch(e) &#123; console.log(&#x27;failure&#x27;);&#125; 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码： 1234567// 重构后的代码const o = &#123;&#125;;if(Reflect.defineProperty(o, &#x27;foo&#x27;, &#123;value: &#x27;bar&#x27;&#125;)) &#123; console.log(&#x27;success&#x27;);&#125; else &#123; console.log(&#x27;failure&#x27;);&#125; 以下反射方法都会提供状态标记： Reflect.defineProperty() Reflect.preventExtensions() Reflect.setPropertyOf() Reflect.set() Relect.deleteProperty() 用一等函数替代操作符 以下反射方法提供只有通过操作符才能完成的操作 Reflect.get()：可以替代对象属性访问操作符 Reflect.set()：可以替代&#x3D;赋值操作符 Reflect.has()：可以替代in操作符或with() Reflect.deleteProperty()：可以替代delete操作符 Reflect.construct()：可以替代new操作符 安全地应用函数 在通过apply方法调用函数时，被调用的函数可能也定义了自己的apply属性(虽然可能性极小)。为绕过这个问题，可以使用定义在Function原型上的apply方法，比如： 1Function.prototype.apply.call(myFunc, thisVal, argumentList); 这种可怕的代码完全可以使用 Reflect.apply 来避免： 1Reflect.apply(myFunc, thisVal, argumentsList); 代理另一个代理代理可以拦截反射API的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网： 123456789101112131415161718192021const target = &#123; foo: &#x27;bar&#x27;&#125;;const firstProxy = new Proxy(target, &#123; get() &#123; console.log(&#x27;first proxy&#x27;); return Reflect.get(...arguments); &#125;&#125;);const secondProxy = new Proxy(firstProxy, &#123; get() &#123; console.log(&#x27;second proxy&#x27;); return Reflect.get(...arguments); &#125;&#125;);console.log(secondProxy.foo);// second proxy// first proxy// bar 代理的问题与不足代理是在 ECMAScript 现有基础之上构建起来的一套新 API，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 ECMAScript机制很好地协同。 代理中的this 代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象： 12345678const target = &#123; thisValEqualsProxy() &#123; return this === proxy; &#125;&#125;const proxy = new Proxy(target, &#123;&#125;);console.log(target.thisValEqualsProxy()); // falseconsole.log(proxy.thisValEqualsProxy()); // true 从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 proxy.outerMethod()，而这个方法进而又会调用另一个方法，如 this.innerMethod()，实际上都会调用 proxy.innerMethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。 123456789101112131415const wm = new WeakMap();class User &#123; constructor(userId) &#123; wm.set(this, userId); &#125; set id(userId) &#123; wm.set(this, userId); &#125; get id() &#123; return wm.get(this); &#125;&#125; 由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题： 1234const user = new User(123);console.log(user.id); // 123const userInstanceProxy = new Proxy(user, &#123;&#125;);console.log(userInstanceProxy.id); // undefined 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了： 123const UserClassProxy = new Proxy(User, &#123;&#125;);const proxyUser = new UserClassProxy(456);console.log(proxyUser.id); 代理与内部槽位 代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。 一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError： 123456const target = new Date();const proxy = new Proxy(target, &#123;&#125;);console.log(proxy instanceof Date); // trueproxy.getDate(); // TypeError: &#x27;this&#x27; is not a Date object 代理捕获器与反射方法代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript操作和不变式。 正如前面示例所展示的，有几种不同的 JavaScript 操作会调用同一个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。 只要在代理上调用，所有捕获器都会拦截它们对应的反射 API 操作。 get()get()捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()。 1234567891011const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; get(target, property, receiver) &#123; console.log(&#x27;get()&#x27;); return Reflect.get(...arguments) &#125;&#125;);proxy.foo;// get() 返回值 返回值无限制 拦截的操作 proxy.property proxy[property] Object.create(proxy)[property] Reflect.get(proxy,property,receiver) 捕获器处理程序参数 target：目标对象 property：引用的目标对象上的字符串键属性 receiver：代理对象或继承代理对象的对象 捕获器不变式 如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。如果 target.property 不可配置且[[Get]]特性为 undefined，处理程序的返回值也必须是 undefined。 set()set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。 1234567891011const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; set(target, property, value, receiver) &#123; console.log(&#x27;set()&#x27;); return Reflect.set(...arguments) &#125;&#125;);proxy.foo = &#x27;bar&#x27;;// set() 返回值 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。 拦截的操作 proxy.property &#x3D; value proxy[property] &#x3D; value Object.create(proxy)[property] &#x3D; value Reflect.set(proxy,property,value,receiver) 捕获器处理程序参数 target：目标对象 property：引用的目标对象上的字符串键属性 value：要赋给属性的值 receiver：接收最初赋值的对象 捕获器不变式 如果 target.property 不可写且不可配置，则不能修改目标属性的值。 如果 target.property 不可配置且[[Set]]特性为 undefined，则不能修改目标属性的值。在严格模式下，处理程序中返回 false 会抛出 TypeError。 has()has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; has(target, property) &#123; console.log(&#x27;has()&#x27;); return Reflect.has(...arguments) &#125;&#125;);&#x27;foo&#x27; in proxy;// has() 返回值 has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。 拦截的操作 property in proxy property in Object.create(proxy) with(proxy) {(property);} Reflect.has(proxy,property) 捕获器处理程序参数 target：目标对象 property：引用的目标对象上的字符串键属性 捕获器不变式 如果 target.property 存在且不可配置，则处理程序必须返回 true。如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。 defineProperty()defineProperty()捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为Reflect.defineProperty()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; defineProperty(target, property, descriptor) &#123; console.log(&#x27;defineProperty()&#x27;); return Reflect.defineProperty(...arguments) &#125;&#125;);Object.defineProperty(proxy, &#x27;foo&#x27;, &#123; value: &#x27;bar&#x27; &#125;);// defineProperty() 返回值 defineProperty()必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。 拦截的操作 Object.defineProperty(proxy, property, descriptor) Reflect.defineProperty(proxy, property, descriptor) 捕获器处理程序参数 target：目标对象 property：引用的目标对象上的字符串键属性 descriptor：包含可选的enumerable、configurable、writable、value、get和set定义的对象 捕获器不变式 如果目标对象不可扩展，则无法定义属性。如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。 getOwnPropertyDescriptor()getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()。 1234567891011const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; getOwnPropertyDescriptor(target, property) &#123; console.log(&#x27;getOwnPropertyDescriptor()&#x27;); return Reflect.getOwnPropertyDescriptor(...arguments) &#125;&#125;);Object.getOwnPropertyDescriptor(proxy, &#x27;foo&#x27;);// getOwnPropertyDescriptor() 返回值 getOwnPropertyDescriptor()必须返回对象，或者在属性不存在时返回 undefined。 拦截的操作 Object.getOwnPropertyDescriptor(proxy,property) Reflect.getOwnPropertyDescriptor(proxy,property) 捕获器处理程序参数 target：目标对象 property：引用的目标对象上的字符串键属性 捕获器不变式 如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象。如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属性不存在。如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象。 deleteProperty()deleteProperty()捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect.deleteProperty()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; deleteProperty(target, property) &#123; console.log(&#x27;deleteProperty()&#x27;); return Reflect.deleteProperty(...arguments) &#125;&#125;);delete proxy.foo// deleteProperty() 返回值 deleteProperty()必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。 拦截的操作 delete proxy.property delete proxy[property] Reflect.deleteProperty(proxy, property) 捕获器处理程序参数 target：目标对象 property：引用的目标对象上的字符串键属性 捕获器不变式 如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性。 ownKeys()ownKeys()捕获器会在 Object.keys()及类似方法中被调用。对应的反射 API 方法为 Reflect.ownKeys()。 1234567891011const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; ownKeys(target) &#123; console.log(&#x27;ownKeys()&#x27;); return Reflect.ownKeys(...arguments) &#125;&#125;);Object.keys(proxy);// ownKeys() 返回值 ownKeys()必须返回包含字符串或符号的可枚举对象。 拦截的操作 Object.getOwnPropertyNames(proxy) Object.getOwnPropertySymbols(proxy) Object.keys(proxy) Reflect.ownKeys(proxy) 捕获器处理程序参数 target：目标对象 捕获器不定式 返回的可枚举对象必须包含 target 的所有不可配置的自有属性。如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键。 getPrototypeOf()getPrototypeOf()捕获器会在 Object.getPrototypeOf()中被调用。对应的反射 API 方法为Reflect.getPrototypeOf()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; getPrototypeOf(target) &#123; console.log(&#x27;getPrototypeOf()&#x27;); return Reflect.getPrototypeOf(...arguments) &#125;&#125;);Object.getPrototypeOf(proxy);// getPrototypeOf() 返回值 getPrototypeOf()必须返回对象或 null。 拦截的操作 Object.getPrototypeOf(proxy) Reflect.getPrototypeOf(proxy) proxy.__proxy__ Object.prototype.isPrototypeOf(proxy) proxy instanceof Object 捕获器处理程序参数 target：目标对象 捕获器不变式 如果 target 不可扩展，则 Object.getPrototypeOf(proxy)唯一有效的返回值就是 Object.getPrototypeOf(target)的返回值。 setPrototypeOf()setPrototypeOf()捕获器会在 Object.setPrototypeOf()中被调用。对应的反射 API 方法为Reflect.setPrototypeOf()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; setPrototypeOf(target, prototype) &#123; console.log(&#x27;setPrototypeOf()&#x27;); return Reflect.setPrototypeOf(...arguments) &#125;&#125;);Object.setPrototypeOf(proxy, Object);// setPrototypeOf() 返回值 setPrototypeOf()必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。 拦截的操作 Object.setPrototypeOf(proxy) Reflect.setPrototypeOf(proxy) 捕获器处理程序参数 target：目标参数 prototype：target的替代原型，如果是顶级原型则为null 捕获器不变式 如果 target 不可扩展，则唯一有效的 prototype 参数就是 Object.getPrototypeOf(target)的返回值。 isExtensible()isExtensible()捕获器会在 Object.isExtensible()中被调用。对应的反射 API 方法为Reflect.isExtensible()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; isExtensible(target) &#123; console.log(&#x27;isExtensible()&#x27;); return Reflect.isExtensible(...arguments) &#125;&#125;);Object.isExtensible(proxy);// isExtensible() 返回值 isExtensible()必须返回布尔值，表示 target 是否可扩展。返回非布尔值会被转型为布尔值。 拦截的操作 Object.isExtenible(proxy) Reflect.isEntensible(proxy) 捕获器处理程序参数 target：目标对象 捕获器不变式 如果 target 可扩展，则处理程序必须返回 true。如果 target 不可扩展，则处理程序必须返回 false。 preventExtensions()preventExtensions()捕获器会在 Object.preventExtensions()中被调用。对应的反射 API方法为 Reflect.preventExtensions()。 12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; preventExtensions(target) &#123; console.log(&#x27;preventExtensions()&#x27;); return Reflect.preventExtensions(...arguments) &#125;&#125;);Object.preventExtensions(proxy);// preventExtensions() 返回值 preventExtensions()必须返回布尔值，表示 target 是否已经不可扩展。返回非布尔值会被转型为布尔值。 拦截的操作 Object.preventExtensions(proxy) Reflect.preventExtensions(proxy) 捕获器处理程序参数 target：目标对象 捕获器不变式 如果Object.isExtensible(proxy)是false，则处理程序必须返回true。 apply()apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。 12345678910const myTarget = () =&gt; &#123;&#125;;const proxy = new Proxy(myTarget, &#123; apply(target, thisArg, ...argumentsList) &#123; console.log(&#x27;apply()&#x27;); return Reflect.apply(...arguments) &#125;&#125;);proxy();// apply() 返回值 返回值无限制 拦截的操作 proxy(…argumentsList) Function.prototype.apply(thisArg, argumentsList) Function.prototype.call(thisArg, …argumentsList) Reflect.apply(target, thisArgument, argumentsList) 捕获器处理程序参数 target：目标对象 thisArg：调用函数时的this参数 argumentsList：调用函数时的参数列表 捕获器不变式 target必须是一个函数对象 construct()construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()。 12345678910const myTarget = function() &#123;&#125;;const proxy = new Proxy(myTarget, &#123; construct(target, argumentsList, newTarget) &#123; console.log(&#x27;construct()&#x27;); return Reflect.construct(...arguments) &#125;&#125;);new proxy;// construct() 返回值 construct()必须返回一个对象。 拦截的操作 new Proxy(…argumentsList) Reflect.construct(target,argumentsList,newTarget) 捕获器处理程序参数 target：目标构造函数 argumentsList：传给目标构造函数的参数列表 newTarget：最初被调用的构造函数 捕获器不定式 target必须可以用作构造函数 代理模式使用代理可以在代码中实现一些有用的编程模式。 跟踪属性访问通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过： 123456789101112131415161718const user = &#123; name: &#x27;Jake&#x27;&#125;;const proxy = new Proxy(user, &#123; get(target, property, receiver) &#123; console.log(`Getting $&#123;property&#125;`); return Reflect.get(...arguments); &#125;, set(target, property, value, receiver) &#123; console.log(`Setting $&#123;property&#125;=$&#123;value&#125;`); return Reflect.set(...arguments); &#125;&#125;);proxy.name; // Getting nameproxy.age = 27; // Setting age=27 隐藏属性代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。比如： 1234567891011121314151617181920212223242526272829303132333435const hiddenProperties = [&#x27;foo&#x27;, &#x27;bar&#x27;];const targetObject = &#123; foo: 1, bar: 2, baz: 3&#125;;const proxy = new Proxy(targetObject, &#123; get(target, property) &#123; if (hiddenProperties.includes(property)) &#123; return undefined; &#125; else &#123; return Reflect.get(...arguments); &#125; &#125;, has(target, property) &#123; if (hiddenProperties.includes(property)) &#123; return false; &#125; else &#123; return Reflect.has(...arguments); &#125; &#125;&#125;);// get()console.log(proxy.foo); // undefinedconsole.log(proxy.bar); // undefinedconsole.log(proxy.baz); // 3// has()console.log(&#x27;foo&#x27; in proxy); // falseconsole.log(&#x27;bar&#x27; in proxy); // falseconsole.log(&#x27;baz&#x27; in proxy); // true 属性验证因为所有赋值操作都会触发 set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值： 1234567891011121314151617const target = &#123; onlyNumbersGoHere: 0&#125;;const proxy = new Proxy(target, &#123; set(target, property, value) &#123; if (typeof value !== &#x27;number&#x27;) &#123; return false; &#125; else &#123; return Reflect.set(...arguments); &#125; &#125;&#125;);proxy.onlyNumbersGoHere = 1;console.log(proxy.onlyNumbersGoHere); // 1proxy.onlyNumbersGoHere = &#x27;2&#x27;;console.log(proxy.onlyNumbersGoHere); // 1 函数与构造函数参数验证跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值： 1234567891011121314151617function median(...nums) &#123; return nums.sort()[Math.floor(nums.length / 2)];&#125;const proxy = new Proxy(median, &#123; apply(target, thisArg, argumentsList) &#123; for (const arg of argumentsList) &#123; if (typeof arg !== &#x27;number&#x27;) &#123; throw &#x27;Non-number argument provided&#x27;; &#125; &#125; return Reflect.apply(...arguments); &#125;&#125;);console.log(proxy(4, 7, 1)); // 4console.log(proxy(4, &#x27;7&#x27;, 1));// Error: Non-number argument provided 类似地，可以要求实例化时必须给构造函数传参： 123456789101112131415161718class User &#123; constructor(id) &#123; this.id_ = id; &#125;&#125;const proxy = new Proxy(User, &#123; construct(target, argumentsList, newTarget) &#123; if (argumentsList[0] === undefined) &#123; throw &#x27;User cannot be instantiated without id&#x27;; &#125; else &#123; return Reflect.construct(...arguments); &#125; &#125;&#125;);new proxy(1);new proxy();// Error: User cannot be instantiated without id 数据绑定与可观察对象通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。 比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中： 1234567891011121314151617181920const userList = [];class User &#123; constructor(name) &#123; this.name_ = name; &#125;&#125;const proxy = new Proxy(User, &#123; construct() &#123; const newUser = Reflect.construct(...arguments); userList.push(newUser); return newUser; &#125;&#125;);new proxy(&#x27;John&#x27;);new proxy(&#x27;Jacob&#x27;);new proxy(&#x27;Jingleheimerschmidt&#x27;);console.log(userList); // [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;] 另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息： 12345678910111213141516171819const userList = [];function emit(newValue) &#123; console.log(newValue);&#125;const proxy = new Proxy(userList, &#123; set(target, property, value, receiver) &#123; const result = Reflect.set(...arguments); if (result) &#123; emit(Reflect.get(target, property, receiver)); &#125; return result; &#125;&#125;);proxy.push(&#x27;John&#x27;);// Johnproxy.push(&#x27;Jacob&#x27;);// Jacob","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(6)——对象、类与面向对象编程","slug":"JS高级程序设计读书笔记(6)——对象、类与面向对象编程","date":"2023-02-08T03:56:39.000Z","updated":"2023-11-27T15:34:23.882Z","comments":true,"path":"2023/02/08/JS高级程序设计读书笔记(6)——对象、类与面向对象编程/","link":"","permalink":"http://pvnk1u.github.io/2023/02/08/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"ECMA-262将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名&#x2F;值对，值可以是数据或者函数。 理解对象创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示： 1234567let person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29; person.job = &quot;Software Engineer&quot;; person.sayName = function() &#123; console.log(this.name); &#125;; 早期 JavaScript 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写： 12345678let person = &#123; name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName() &#123; console.log(this.name); &#125; &#125;; 这个例子中的 person 对象跟前面例子中的 person对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。 属性的类型ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义 的。因此，开发者不能在 JavaScript 中直接访问这些特性。**为了将某个特性标识为内部特性，规范会用 两个中括号把特性的名称括起来，比如[[Enumerable]]**。 属性分两种：数据属性和访问器属性。 数据属性 数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4 个特性描述它们的行为。 [[Configurable]] 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特 性都是 true，如前面的例子所示。 [[Enumerable]] 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true，如前面的例子所示。 [[Writable]] 表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的 这个特性都是 true，如前面的例子所示。 [[Value]] 包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性 的默认值为 undefined。 在像前面例子中那样将属性显式添加到对象之后，[[Configurable]]、[[Enumerable]]和 [[Writable]]都会被设置为 true，而[[Value]]特性会被设置为指定的值。 要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包 含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如： 12345678let person = &#123;&#125;; Object.defineProperty(person, &quot;name&quot;, &#123; writable: false, value: &quot;Nicholas&quot; &#125;); console.log(person.name); // &quot;Nicholas&quot; person.name = &quot;Greg&quot;; console.log(person.name); // &quot;Nicholas&quot; 在严格模式下，尝试修改只读属性 的值会抛出错误。 类似的规则也适用于创建不可配置的属性。比如: 12345678let person = &#123;&#125;; Object.defineProperty(person, &quot;name&quot;, &#123; configurable: false, value: &quot;Nicholas&quot; &#125;); console.log(person.name); // &quot;Nicholas&quot; delete person.name; console.log(person.name); // &quot;Nicholas&quot; 这个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除。非严格模式下对 这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就 不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误： 12345678910let person = &#123;&#125;; Object.defineProperty(person, &quot;name&quot;, &#123; configurable: false, value: &quot;Nicholas&quot; &#125;); // 抛出错误Object.defineProperty(person, &quot;name&quot;, &#123; configurable: true, value: &quot;Nicholas&quot; &#125;); 因此，虽然可以对同一个属性多次调用 Object.defineProperty()，但在把 configurable 设 置为 false 之后就会受限制了。 在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不 指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。 访问器属性 访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不 过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。 [[Configurable]] 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。 [[Enumerable]] 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。 [[Get]] 获取函数，在读取属性时调用。默认值为 undefined。 [[Set]] 设置函数，在写入属性时调用。默认值为 undefined。 **访问器属性是不能直接定义的，必须使用 Object.defineProperty()**。下面是一个例子： 123456789101112131415161718// 定义一个对象，包含伪私有成员 year_和公共成员 edition let book = &#123; year_: 2017, edition: 1&#125;; Object.defineProperty(book, &quot;year&quot;, &#123; get() &#123; return this.year_; &#125;, set(newValue) &#123; if (newValue &gt; 2017) &#123; this.year_ = newValue; this.edition += newValue - 2017; &#125; &#125; &#125;); book.year = 2018; console.log(book.edition); // 2 在这个例子中，对象 book 有两个默认属性：year_和 edition。year_中的下划线常用来表示该 属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简 单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改 为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。 获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽 略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性 是不能读取的，非严格模式下读取会返回 undefined，严格模式下会抛出错误。 在不支持 Object.defineProperty()的浏览器中没有办法修改[[Configurable]]或[[Enumerable]]。 定义多个属性在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添 加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如： 1234567891011121314151617181920let book = &#123;&#125;; Object.defineProperties(book, &#123; year_: &#123; value: 2017 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get() &#123; return this.year_; &#125;, set(newValue) &#123; if (newValue &gt; 2017) &#123; this.year_ = newValue; this.edition += newValue - 2017; &#125; &#125; &#125; &#125;); 这段代码在 book 对象上定义了两个数据属性 year_和 edition，还有一个访问器属性 year。 最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的 configurable、enumerable 和 writable 特性值都是 false。 读取属性的特性使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接 收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、 writable 和 value 属性。比如： 1234567891011121314151617181920212223242526272829let book = &#123;&#125;; Object.defineProperties(book, &#123; year_: &#123; value: 2017 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this.year_; &#125;, set: function(newValue)&#123; if (newValue &gt; 2017) &#123; this.year_ = newValue; this.edition += newValue - 2017; &#125; &#125; &#125; &#125;); let descriptor = Object.getOwnPropertyDescriptor(book, &quot;year_&quot;); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // &quot;undefined&quot; let descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // &quot;function&quot; ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors()静态方法。这个方法实际上 会在每个自有属性上调用 Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。对于 前面的例子，使用这个静态方法会返回如下对象： 123456789101112131415161718192021222324252627282930313233343536373839404142let book = &#123;&#125;; Object.defineProperties(book, &#123; year_: &#123; value: 2017 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this.year_; &#125;, set: function(newValue)&#123; if (newValue &gt; 2017) &#123; this.year_ = newValue; this.edition += newValue - 2017; &#125; &#125; &#125; &#125;); console.log(Object.getOwnPropertyDescriptors(book)); // &#123; // edition: &#123; // configurable: false, // enumerable: false, // value: 1, // writable: false // &#125;, // year: &#123; // configurable: false, // enumerable: false, // get: f(), // set: f(newValue), // &#125;, // year_: &#123; // configurable: false, // enumerable: false, // value: 2017, // writable: false // &#125; // &#125; 合并对象JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的 本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入 源对象的属性得到了增强。 ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个 或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true） 和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标 对象上的[[Set]]设置属性的值。 1234567891011121314151617181920212223242526272829303132333435363738394041let dest, src, result; /** * 简单复制 */ dest = &#123;&#125;; src = &#123; id: &#x27;src&#x27; &#125;; result = Object.assign(dest, src); // Object.assign 修改目标对象// 也会返回修改后的目标对象console.log(dest === result); // true console.log(dest !== src); // true console.log(result); // &#123; id: src &#125; console.log(dest); // &#123; id: src &#125; /** * 多个源对象 */ dest = &#123;&#125;; result = Object.assign(dest, &#123; a: &#x27;foo&#x27; &#125;, &#123; b: &#x27;bar&#x27; &#125;); console.log(result); // &#123; a: foo, b: bar &#125; /** * 获取函数与设置函数 */ dest = &#123; set a(val) &#123; console.log(`Invoked dest setter with param $&#123;val&#125;`); &#125; &#125;; src = &#123; get a() &#123; console.log(&#x27;Invoked src getter&#x27;); return &#x27;foo&#x27;; &#125; &#125;;Object.assign(dest, src); // 调用 src 的获取方法// 调用 dest 的设置方法并传入参数&quot;foo&quot; // 因为这里的设置函数不执行赋值操作// 所以实际上并没有把值转移过来console.log(dest); // &#123; set a(val) &#123;...&#125; &#125; Object.assign()实际上对每个源对象执行的是浅复制(只复制对象的引用)。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目 标对象。换句话说，不能在两个对象间转移获取函数和设置函数。 12345678910111213141516171819202122232425262728let dest, src, result; /** * 覆盖属性 */ dest = &#123; id: &#x27;dest&#x27; &#125;; result = Object.assign(dest, &#123; id: &#x27;src1&#x27;, a: &#x27;foo&#x27; &#125;, &#123; id: &#x27;src2&#x27;, b: &#x27;bar&#x27; &#125;); // Object.assign 会覆盖重复的属性console.log(result); // &#123; id: src2, a: foo, b: bar &#125; // 可以通过目标对象上的设置函数观察到覆盖的过程：dest = &#123; set id(x) &#123; console.log(x); &#125; &#125;; Object.assign(dest, &#123; id: &#x27;first&#x27; &#125;, &#123; id: &#x27;second&#x27; &#125;, &#123; id: &#x27;third&#x27; &#125;); // first // second // third /** * 对象引用 */ dest = &#123;&#125;; src = &#123; a: &#123;&#125; &#125;; Object.assign(dest, src); // 浅复制意味着只会复制对象的引用console.log(dest); // &#123; a :&#123;&#125; &#125; console.log(dest.a === src.a); // true 如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前 赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。 12345678910111213141516171819let dest, src, result; /** * 错误处理 */ dest = &#123;&#125;; src = &#123; a: &#x27;foo&#x27;, get b() &#123; // Object.assign()在调用这个获取函数时会抛出错误 throw new Error(); &#125;, c: &#x27;bar&#x27; &#125;; try &#123; Object.assign(dest, src); &#125; catch(e) &#123;&#125; // Object.assign()没办法回滚已经完成的修改// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：console.log(dest); // &#123; a: foo &#125; 对象标识及相等判定 ECMAScript 6 之前，有些特殊情况即使是&#x3D;&#x3D;&#x3D;操作符也无能为力： 1234567891011// 这些是===符合预期的情况console.log(true === 1); // false console.log(&#123;&#125; === &#123;&#125;); // false console.log(&quot;2&quot; === 2); // false // 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等console.log(+0 === -0); // true console.log(+0 === 0); // true console.log(-0 === 0); // true // 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN() console.log(NaN === NaN); // false console.log(isNaN(NaN)); // true 为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与&#x3D;&#x3D;&#x3D;很像，但同时也考虑 到了上述边界情形。这个方法必须接收两个参数： 123456789console.log(Object.is(true, 1)); // false console.log(Object.is(&#123;&#125;, &#123;&#125;)); // false console.log(Object.is(&quot;2&quot;, 2)); // false // 正确的 0、-0、+0 相等/不等判定console.log(Object.is(+0, -0)); // false console.log(Object.is(+0, 0)); // true console.log(Object.is(-0, 0)); // false // 正确的 NaN 相等判定console.log(Object.is(NaN, NaN)); // true 要检查超过两个值，递归地利用相等性传递即可： 1234function recursivelyCheckEqual(x, ...rest) &#123; return Object.is(x, rest[0]) &amp;&amp; (rest.length &lt; 2 || recursivelyCheckEqual(...rest)); &#125; 增强的对象语法ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎 的行为，但极大地提升了处理对象的方便程度。 属性值简写 在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如： 12345let name = &#x27;Matt&#x27;; let person = &#123; name: name &#125;; console.log(person); // &#123; name: &#x27;Matt&#x27; &#125; 为此，简写属性名语法出现了。简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同 名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。 以下代码和之前的代码是等价的： 12345let name = &#x27;Matt&#x27;; let person = &#123; name &#125;; console.log(person); // &#123; name: &#x27;Matt&#x27; &#125; 代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。以下面的代码为例： 1234567function makePerson(name) &#123; return &#123; name &#125;; &#125; let person = makePerson(&#x27;Matt&#x27;); console.log(person.name); // Matt 可计算属性 在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如: 12345678const nameKey = &#x27;name&#x27;; const ageKey = &#x27;age&#x27;; const jobKey = &#x27;job&#x27;; let person = &#123;&#125;; person[nameKey] = &#x27;Matt&#x27;; person[ageKey] = 27; person[jobKey] = &#x27;Software engineer&#x27;; console.log(person); // &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125; 有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时 将其作为 JavaScript 表达式而不是字符串来求值： 123456789const nameKey = &#x27;name&#x27;; const ageKey = &#x27;age&#x27;; const jobKey = &#x27;job&#x27;; let person = &#123; [nameKey]: &#x27;Matt&#x27;, [ageKey]: 27, [jobKey]: &#x27;Software engineer&#x27; &#125;; console.log(person); // &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125; 因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值： 12345678910111213const nameKey = &#x27;name&#x27;; const ageKey = &#x27;age&#x27;; const jobKey = &#x27;job&#x27;; let uniqueToken = 0; function getUniqueKey(key) &#123; return `$&#123;key&#125;_$&#123;uniqueToken++&#125;`; &#125; let person = &#123; [getUniqueKey(nameKey)]: &#x27;Matt&#x27;, [getUniqueKey(ageKey)]: 27, [getUniqueKey(jobKey)]: &#x27;Software engineer&#x27; &#125;; console.log(person); // &#123; name_0: &#x27;Matt&#x27;, age_1: 27, job_2: &#x27;Software engineer&#x27; &#125; 可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副 作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。 简写方法名 在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示： 123456let person = &#123; sayName: function(name) &#123; console.log(`My name is $&#123;name&#125;`); &#125; &#125;; person.sayName(&#x27;Matt&#x27;); // My name is Matt 新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数命名通常没什么用）。相应地，这样也可以明显缩短方法声明。 以下代码和之前的代码在行为上是等价的： 123456let person = &#123; sayName(name) &#123; console.log(`My name is $&#123;name&#125;`); &#125; &#125;; person.sayName(&#x27;Matt&#x27;); // My name is Matt 简写方法名对获取函数和设置函数也是适用的： 1234567891011121314let person = &#123; name_: &#x27;&#x27;, get name() &#123; return this.name_; &#125;, set name(name) &#123; this.name_ = name; &#125;, sayName() &#123; console.log(`My name is $&#123;this.name_&#125;`); &#125; &#125;; person.name = &#x27;Matt&#x27;; person.sayName(); // My name is Matt 简写方法名与可计算属性键相互兼容： 1234567const methodKey = &#x27;sayName&#x27;; let person = &#123; [methodKey](name) &#123; console.log(`My name is $&#123;name&#125;`); &#125; &#125; person.sayName(&#x27;Matt&#x27;); // My name is Matt 对象解构ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。 下面的例子展示了两段等价的代码，首先是不使用对象解构的： 123456789// 不使用对象解构let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; let personName = person.name, personAge = person.age; console.log(personName); // Matt console.log(personAge); // 27 然后，是使用对象解构的： 12345678// 使用对象解构let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; let &#123; name: personName, age: personAge &#125; = person; console.log(personName); // Matt console.log(personAge); // 27 使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如： 1234567let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; let &#123; name, age &#125; = person; console.log(name); // Matt console.log(age); // 27 解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined： 1234567let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; let &#123; name, job &#125; = person; console.log(name); // Matt console.log(job); // undefined 也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况： 1234567let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; let &#123; name, job=&#x27;Software engineer&#x27; &#125; = person; console.log(name); // Matt console.log(job); // Software engineer 解构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。这 意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject()的定义），null 和 undefined 不能被解构，否则会抛出错误。 123456789let &#123; length &#125; = &#x27;foobar&#x27;; console.log(length); // 6 let &#123; constructor: c &#125; = 4; console.log(c === Number); // true let &#123; _ &#125; = null; // TypeError let &#123; _ &#125; = undefined; // TypeError 解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中： 1234567let personName, personAge; let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; (&#123;name: personName, age: personAge&#125; = person); console.log(personName, personAge); // Matt, 27 嵌套解构 解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性： 123456789101112131415161718192021222324let person = &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Software engineer&#x27; &#125; &#125;; let personCopy = &#123;&#125;; (&#123; name: personCopy.name, age: personCopy.age, job: personCopy.job &#125; = person); // 因为一个对象的引用被赋值给 personCopy，所以修改// person.job 对象的属性也会影响 personCopy person.job.title = &#x27;Hacker&#x27; console.log(person); // &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;console.log(personCopy); // &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125; 解构赋值可以使用嵌套结构，以匹配嵌套的属性： 12345678910let person = &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Software engineer&#x27; &#125; &#125;; // 声明 title 变量并将 person.job.title 的值赋给它let &#123; job: &#123; title &#125; &#125; = person; console.log(title); // Software engineer 在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样： 123456789101112131415161718192021let person = &#123; job: &#123; title: &#x27;Software engineer&#x27; &#125; &#125;; let personCopy = &#123;&#125;; // 视图把源对象上的foo对象下的bar 值赋值给目标对象的bar 但foo 在源对象上是 undefined (&#123; foo: &#123; bar: personCopy.bar &#125; &#125; = person); // TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;. // 视图把源对象上的job对象里的title赋值给目标对象personCopy里的job对象里的title，但job 在目标对象上是 undefined (&#123; job: &#123; title: personCopy.job.title &#125; &#125; = person); // TypeError: Cannot set property &#x27;title&#x27; of undefined 部分解构 需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及 多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分： 1234567891011121314let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; let personName, personBar, personAge; try &#123; // person.foo 是 undefined，因此会抛出错误 (&#123;name: personName, foo: &#123; bar: personBar &#125;, age: personAge&#125; = person); &#125; catch(e) &#123;&#125; console.log(personName, personBar, personAge); // Matt, undefined, undefined 上下文参数匹配 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量： 123456789101112131415161718let person = &#123; name: &#x27;Matt&#x27;, age: 27 &#125;; function printPerson(foo, &#123;name, age&#125;, bar) &#123; console.log(arguments); console.log(name, age); &#125; function printPerson2(foo, &#123;name: personName, age: personAge&#125;, bar) &#123; console.log(arguments); console.log(personName, personAge); &#125; printPerson(&#x27;1st&#x27;, person, &#x27;2nd&#x27;); // [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;] // &#x27;Matt&#x27;, 27 printPerson2(&#x27;1st&#x27;, person, &#x27;2nd&#x27;); // [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;] // &#x27;Matt&#x27;, 27 创建对象虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。 概述ECMAScript 5.1 并没有正式支持面向对象的结构，比如类或继承。但是，正如接下来会介绍的，巧妙地运用原型式继承可以成功地模拟类或继承。 ECMAScript 6 开始正式支持类和继承。**ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，ES6的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已。** 采用面向对象编程模式的 JavaScript 代码还是应该使用 ECMAScript 6 的 类。但不管怎么说，理解 ES6 类出现之前的惯例总是有益无害的。特别是 ES6 的类定义本身就相当于对原有结构的封装。 工厂模式工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。下面的例子展示了一种按照特定接口创 建对象的方式： 123456789101112function createPerson(name, age, job) &#123; let o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125;; return o; &#125; let person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); let person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 这里，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象。 可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。 构造函数模式ECMAScript 中的构造函数是用于创建特定类型对象的。像 Object 和 Array 这 样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。 比如，前面的例子使用构造函数模式可以这样写: 123456789101112function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;; &#125; let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.sayName(); // Nicholas person2.sayName(); // Greg 在这个例子中，Person()构造函数代替了 createPerson()工厂函数。实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别。 没有显式创建对象 属性和方法直接赋值给了this 没有return 另外，要注意函数名 Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的， 非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在 ECMAScript 中区分构造函数和普通函数。毕竟 ECMAScript 的构造函数就是能创建对象的函数。 要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。 在内存中创建一个新对象 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。 执行构造函数内部的代码（给新对象添加属性）。 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。 上一个例子的最后，person1 和 person2 分别保存着 Person的不同实例。这两个对象都有一个 constructor 属性指向 Person，如下所示： 12console.log(person1.constructor == Person); // true console.log(person2.constructor == Person); // true constructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例，如下面调用 instanceof 操作符的结果所示： 1234console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true 定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在 这个例子中，**person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承 自 Object**（后面再详细讨论这一点）。 构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数： 12345678910111213141516let Person = function(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;; &#125; let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.sayName(); // Nicholas person2.sayName(); // Greg console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true 在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数： 1234567891011121314function Person() &#123; this.name = &quot;Jake&quot;; this.sayName = function() &#123; console.log(this.name); &#125;; &#125; let person1 = new Person(); let person2 = new Person;person1.sayName(); // Jake person2.sayName(); // Jake console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true 构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操 作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用： 12345678910// 作为构造函数 let person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); person.sayName(); // &quot;Nicholas&quot; // 作为函数调用Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到 window 对象window.sayName(); // &quot;Greg&quot; // 在另一个对象的作用域中调用let o = new Object(); Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;); o.sayName(); // &quot;Kristen&quot; 这个例子一开始展示了典型的构造函数调用方式，即使用 new 操作符创建一个新对象。然后是普通函数的调用方式，这时候没有使用 new 操作符调用 Person()，结果会将属性和方法添加到 window 对象。这里要记住，在调用一个函数而没有明确设置 this 值的情况下（即没有作为对象的方法调用，或者没有使用 call()&#x2F;apply()调用），this 始终指向 Global 对象（在浏览器中就是 window 对象）。 因此在上面的调用之后，window 对象上就有了一个 sayName()方法，调用它会返回”Greg”。最后展示的调用方式是通过 call()（或 apply()）调用函数，同时将特定对象指定为作用域。这里的调用将对象 o 指定为 Person()内部的 this 值，因此执行完函数代码后，所有属性和 sayName()方法都会添 加到对象 o 上面。 构造函数的问题 构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方 法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会 初始化一个对象。逻辑上讲，这个构造函数实际上是这样的： 123456function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;console.log(this.name)&quot;); // 逻辑等价&#125; 这样理解这个构造函数可以更清楚地知道，每个 Person 实例都会有自己的 Function 实例用于显示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function 实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示： 1console.log(person1.sayName == person2.sayName); // false 因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。 要解决这个问题，可以把函数定义转移到构造函数外部： 12345678910111213function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName; &#125; function sayName() &#123; console.log(this.name); &#125; let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.sayName(); // Nicholas person2.sayName(); // Greg 在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName() 函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2 共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但 全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法， 那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。 原型模式每个函数本身都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，**这个对象就是通过调用构造函数创建的对象的原型。 ** 使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示： 123456789101112function Person() &#123;&#125; Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function() &#123; console.log(this.name); &#125;; let person1 = new Person(); person1.sayName(); // &quot;Nicholas&quot; let person2 = new Person(); person2.sayName(); // &quot;Nicholas&quot; console.log(person1.sayName == person2.sayName); // true 使用函数表达式也可以： 123456789101112let Person = function() &#123;&#125;; Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function() &#123; console.log(this.name); &#125;; let person1 = new Person(); person1.sayName(); // &quot;Nicholas&quot; let person2 = new Person(); person2.sayName(); // &quot;Nicholas&quot; console.log(person1.sayName == person2.sayName); // true 这里，所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的 都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。 理解原型 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。 在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之 间没有。 这种关系不好可视化，但可以通过下面的代码来理解原型的行为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 构造函数可以是函数表达式 * 也可以是函数声明，因此以下两种形式都可以： * function Person() &#123;&#125; * let Person = function() &#123;&#125; */ function Person() &#123;&#125; /** * 声明之后，构造函数就有了一个 * 与之关联的原型对象： */ console.log(typeof Person.prototype); console.log(Person.prototype); // &#123; // constructor: f Person(), // __proto__: Object// &#125; /** * 如前所述，构造函数有一个 prototype 属性 * 引用其原型对象，而这个原型对象也有一个 * constructor 属性，引用这个构造函数 * 换句话说，两者循环引用： */ console.log(Person.prototype.constructor === Person); // true /** * 正常的原型链都会终止于 Object 的原型对象 * Object 原型的原型是 null */ console.log(Person.prototype.__proto__ === Object.prototype); // true console.log(Person.prototype.__proto__.constructor === Object); // true console.log(Person.prototype.__proto__.__proto__ === null); // true console.log(Person.prototype.__proto__); // &#123; // constructor: f Object(), // toString: ... // hasOwnProperty: ... // isPrototypeOf: ... // ... // &#125;let person1 = new Person(), person2 = new Person(); /** * 构造函数、原型对象和实例 * 是 3 个完全不同的对象： */ console.log(person1 !== Person); // true console.log(person1 !== Person.prototype); // true console.log(Person.prototype !== Person); // true /** * 实例通过__proto__链接到原型对象， * 它实际上指向隐藏特性[[Prototype]] * * 构造函数通过 prototype 属性链接到原型对象 * * 实例与构造函数没有直接联系，与原型对象有直接联系 */ console.log(person1.__proto__ === Person.prototype); // true conosle.log(person1.__proto__.constructor === Person); // true /** * 同一个构造函数创建的两个实例 * 共享同一个原型对象： */ console.log(person1.__proto__ === person2.__proto__); // true /** * instanceof 检查实例的原型链中 * 是否包含指定构造函数的原型： */ console.log(person1 instanceof Person); // true console.log(person1 instanceof Object); // true console.log(Person.prototype instanceof Object); // true，构造函数的原型对象也是由Object的原型对象派生的 上图展示了 Person 构造函数、Person 的原型对象和 Person 现有两个实例之间的关系。注意，Person.prototype 指向原型对象，而 Person.prototype.contructor 指回 Person 构造函数。原型对象包含 constructor 属性和其他后来添加的属性。Person 的两个实例 person1 和 person2 都只有一个内部属性指回 Person.prototype，而且两者都与构造函数没有直接联系。另外要注意，虽然这两个实例都没有属性和方法，但 person1.sayName()可以正常调用。这是由于对象属性查找机制的原因。 虽然不是所有实现都对外暴露了[[Prototype]]，但可以使用 isPrototypeOf()方法确定两个对象之间的这种关系。本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回 true，如下所示： 12console.log(Person.prototype.isPrototypeOf(person1)); // trueconsole.log(Person.prototype.isPrototypeOf(person2)); // true 这里通过原型对象调用 isPrototypeOf()方法检查了 person1 和 person2。因为这两个例子内部都有链接指向 Person.prototype，所以结果都返回 true。 ECMAScript 的 Object 类型有一个方法叫 Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值。例如： 12console.log(Object.getPrototypeOf(person1) == Person.prototype); // trueconsole.log(Object.getPrototypeOf(person1).name); // &quot;Nicholas&quot; 第一行代码简单确认了 Object.getPrototypeOf()返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上 name 属性的值，即”Nicholas”。使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要。 Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系： 12345678910let biped = &#123; numLegs: 2&#125;;let person = &#123; name: &#x27;Matt&#x27;&#125;;Object.setPrototypeOf(person, biped);console.log(person.name); // Mattconsole.log(person.numLegs); // 2console.log(Object.getPrototypeOf(person) === biped); // true Object.setPrototypeOf()可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码。” 为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型： 12345678let biped = &#123; numLegs: 2&#125;;let person = Object.create(biped);person.name = &#x27;Matt&#x27;;console.log(person.name); // Mattconsole.log(person.numLegs); // 2console.log(Object.getPrototypeOf(person) === biped); // true 原型层级 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。因此，在调用 person1.sayName()时，会发生两步搜索。首先，JavaScript 引擎会问：“person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“person1 的原型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用 person2.sayName()时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。下面看一个例子： 123456789101112131415function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person1 = new Person();let person2 = new Person();person1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person2.name); // &quot;Nicholas&quot;，来自原型 在这个例子中，person1 的 name 属性遮蔽了原型对象上的同名属性。虽然 person1.name 和person2.name 都返回了值，但前者返回的是”Greg”（来自实例），后者返回的是”Nicholas”（来自原型）。当 console.log()访问 person1.name 时，会先在实例上搜索个属性。因为这个属性在实例上存在，所以就不会再搜索原型对象了。而在访问 person2.name 时，并没有在实例上找到这个属性，所以会继续搜索原型对象并使用定义在原型上的属性。 只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为 null，也不会恢复它和原型的联系。不过，使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。 123456789101112131415161718function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person1 = new Person();let person2 = new Person();person1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person2.name); // &quot;Nicholas&quot;，来自原型delete person1.name;console.log(person1.name); // &quot;Nicholas&quot;，来自原型 hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object的，会在属性存在于调用它的对象实例上时返回 true，如下面的例子所示： 1234567891011121314151617181920212223function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person1 = new Person();let person2 = new Person();console.log(person1.hasOwnProperty(&quot;name&quot;)); // falseperson1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person1.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(person2.name); // &quot;Nicholas&quot;，来自原型console.log(person2.hasOwnProperty(&quot;name&quot;)); // falsedelete person1.name;console.log(person1.name); // &quot;Nicholas&quot;，来自原型console.log(person1.hasOwnProperty(&quot;name&quot;)); // false 在这个例子中，通过调用 hasOwnProperty()能够清楚地看到访问的是实例属性还是原型属性。调用 person1.hasOwnProperty(&quot;name&quot;)只在重写 person1 上 name 属性的情况下才返回 true，表明此时 name 是一个实例属性，不是原型属性。 ECMAScript 的 Object.getOwnPropertyDescriptor()方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用 Object.getOwnProperty-Descriptor()。 原型和in操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子： 12345678910111213141516171819202122232425262728function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person1 = new Person();let person2 = new Person();console.log(person1.hasOwnProperty(&quot;name&quot;)); // falseconsole.log(&quot;name&quot; in person1); // trueperson1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person1.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(&quot;name&quot; in person1); // trueconsole.log(person2.name); // &quot;Nicholas&quot;，来自原型console.log(person2.hasOwnProperty(&quot;name&quot;)); // falseconsole.log(&quot;name&quot; in person2); // truedelete person1.name;console.log(person1.name); // &quot;Nicholas&quot;，来自原型console.log(person1.hasOwnProperty(&quot;name&quot;)); // falseconsole.log(&quot;name&quot; in person1); // true 如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用 hasOwnProperty()和 in 操作符： 123function hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。 要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如： 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;let keys = Object.keys(Person.prototype);console.log(keys); // &quot;name,age,job,sayName&quot;let p1 = new Person();p1.name = &quot;Rob&quot;;p1.age = 31;let p1keys = Object.keys(p1);console.log(p1keys); // &quot;[name,age]&quot; 这里，keys 变量保存的数组中包含”name”、”age”、”job”和”sayName”。这是正常情况下通过for-in 返回的顺序。而在 Person 的实例上调用时，Object.keys()返回的数组中只包含”name”和”age”两个属性。 如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()： 12let keys = Object.getOwnPropertyNames(Person.prototype);console.log(keys); // &quot;[constructor,name,age,job,sayName]&quot; 注意，返回的结果中包含了一个不可枚举的属性 constructor。Object.keys()和 Object.getOwnPropertyNames()在适当的时候都可用来代替 for-in 循环。 在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已: 123456789let k1 = Symbol(&#x27;k1&#x27;), k2 = Symbol(&#x27;k2&#x27;);let o = &#123; [k1]: &#x27;k1&#x27;, [k2]: &#x27;k2&#x27;&#125;;console.log(Object.getOwnPropertySymbols(o));// [Symbol(k1), Symbol(k2)] 属性枚举顺序 for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。 Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。 123456789101112131415161718192021let k1 = Symbol(&#x27;k1&#x27;), k2 = Symbol(&#x27;k2&#x27;);let o = &#123; 1: 1, first: &#x27;first&#x27;, [k1]: &#x27;sym2&#x27;, second: &#x27;second&#x27;, 0: 0&#125;;o[k2] = &#x27;sym2&#x27;;o[3] = 3;o.third = &#x27;third&#x27;;o[2] = 2;console.log(Object.getOwnPropertyNames(o));// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]console.log(Object.getOwnPropertySymbols(o));// [Symbol(k1), Symbol(k2)] 对象迭代在 JavaScript 有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键&#x2F;值对的数组。 1234567891011const o = &#123; foo: &#x27;bar&#x27;, baz: 1, qux: &#123;&#125;&#125;;console.log(Object.values(o));/ [&quot;bar&quot;, 1, &#123;&#125;]console.log(Object.entries((o)));// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]] 注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制： 123456789const o = &#123; qux: &#123;&#125;&#125;;console.log(Object.values(o)[0] === o.qux);// trueconsole.log(Object.entries(o)[0][1] === o.qux);// true 符号属性会被忽略： 12345678const sym = Symbol();const o = &#123; [sym]: &#x27;foo&#x27;&#125;;console.log(Object.values(o));// []console.log(Object.entries((o)));// [] 其他原型语法 在前面的例子中，每次定义一个属性或方法都会把 Person.prototype 重写一遍。为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法，如下面的例子所示： 12345678910function Person() &#123;&#125;Person.prototype = &#123; name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName() &#123; console.log(this.name); &#125;&#125;; 在这个例子中，Person.prototype 被设置为等于一个通过对象字面量创建的新对象。最终结果是一样的，只有一个问题：这样重写之后，Person.prototype 的 constructor 属性就不指向 Person了。在创建函数时，也会创建它的 prototype 对象，同时会自动给这个原型的 constructor 属性赋值。而上面的写法完全重写了默认的 prototype 对象，因此其 constructor 属性也指向了完全不同的新对象（Object 构造函数），不再指向原来的构造函数。虽然 instanceof 操作符还能可靠地返回值，但我们不能再依靠 constructor 属性来识别类型了，如下面的例子所示： 123456let friend = new Person();console.log(friend instanceof Object); // trueconsole.log(friend instanceof Person); // trueconsole.log(friend.constructor == Person); // falseconsole.log(friend.constructor == Object); // true 这里，instanceof 仍然对Object 和Person 都返回true。但constructor 属性现在等于Object而不是 Person 了。如果 constructor 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值： 1234567891011function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName() &#123; console.log(this.name); &#125;&#125;; 但要注意，以这种方式恢复 constructor 属性会创建一个[[Enumerable]]为 true 的属性。而原生 constructor 属性默认是不可枚举的。因此，如果你使用的是兼容 ECMAScript 的JavaScript引擎，那可能会改为使用 Object.defineProperty()方法来定义 constructor 属性： 123456789101112131415function Person() &#123;&#125;Person.prototype = &#123; name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName() &#123; console.log(this.name); &#125;&#125;;// 恢复 constructor 属性Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123; enumerable: false, value: Person&#125;); 原型的动态性 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。下面是一个例子： 12345let friend = new Person();Person.prototype.sayHi = function() &#123; console.log(&quot;hi&quot;);&#125;;friend.sayHi(); // &quot;hi&quot;，没问题！ 以上代码先创建一个 Person 实例并保存在 friend 中。然后一条语句在 Person.prototype 上添加了一个名为 sayHi()的方法。虽然 friend 实例是在添加方法之前创建的，但它仍然可以访问这个方法。之所以会这样，主要原因是实例与原型之间松散的联系。在调用 friend.sayHi()时，首先会从这个实例中搜索名为 sayHi 的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到 sayHi 属性并返回这个属性保存的函数。 虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的[[Prototype]]指针是在调用构造函数时自动赋值的，即使把原型修改为不同的对象，实例的这个指针指向的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。来看下面的例子： 1234567891011121314function Person() &#123;&#125;let friend = new Person();Person.prototype = &#123; constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName() &#123; console.log(this.name); &#125;&#125;;friend.sayName(); // 错误 在这个例子中，Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName()的时候，会导致错误。这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。下图展示了这里边的原因： 重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。 原生对象原型 原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法。比如，数组实例的 sort()方法就是 Array.prototype 上定义的，而字符串包装对象的 substring()方法也是在 String.prototype 上定义的，如下所示: 12console.log(typeof Array.prototype.sort); // &quot;function&quot;console.log(typeof String.prototype.substring); // &quot;function&quot; 通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给 String原始值包装类型的实例添加了一个 startsWith()方法： 123456String.prototype.startsWith = function (text) &#123; return this.indexOf(text) === 0;&#125;;let msg = &quot;Hello world!&quot;;console.log(msg.startsWith(&quot;Hello&quot;)); // true 如果给定字符串的开头出现了调用 startsWith()方法的文本，那么该方法会返回 true。因为这个方法是被定义在 String.prototype 上，所以当前环境下所有的字符串都可以使用这个方法。msg是个字符串，在读取它的属性时，后台会自动创建 String 的包装实例，从而找到并调用 startsWith()方法。 尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。 原型的问题 原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共享特性。 原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，如前面例子中所示，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性。来看下面的例子： 123456789101112131415161718192021function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;], sayName() &#123; console.log(this.name); &#125;&#125;;let person1 = new Person();let person2 = new Person();person1.friends.push(&quot;Van&quot;);console.log(person1.friends); // &quot;Shelby,Court,Van&quot;console.log(person2.friends); // &quot;Shelby,Court,Van&quot;console.log(person1.friends === person2.friends); // true 这里，Person.prototype 有一个名为 friends的属性，它包含一个字符串数组。然后这里创建了两个 Person 的实例。person1.friends 通过 push 方法向数组中添加了一个字符串。由于这个friends 属性存在于 Person.prototype 而非 person1 上，新加的这个字符串也会在（指向同一个数组的）person2.friends 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。 继承继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在 ECMAScript 中是不可能的，因为函数没有签名。实现继承是 ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。 原型链ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。 实现原型链涉及如下代码模式： 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;let instance = new SubType();console.log(instance.getSuperValue()); // true 以上代码定义了两个类型：SuperType 和 SubType。这两个类型分别定义了一个属性和一个方法。这两个类型的主要区别是 SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.prototype 实现了对 SuperType 的继承。这个赋值重写了 SubType 最初的原型，将其替换为SuperType 的实例。这意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype。这样实现继承之后，代码紧接着又给 SubType.prototype，也就是这个 SuperType 的实例添加了一个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue()方法。 下图展示了子类的实例与两个构造函数及其对应的原型之间的关系： 这个例子中实现继承的关键，是 SubType 没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是 SuperType 的实例。这样一来，SubType 的实例不仅能从 SuperType 的实例中继承属性和方法，而且还与 SuperType 的原型挂上了钩。于是 instance（通过内部的[[Prototype]]）指向SubType.prototype，而 SubType.prototype（作为 SuperType 的实例又通过内部的[[Prototype]]）指向 SuperType.prototype。注意，getSuperValue()方法还在 SuperType.prototype 对象上，而 property 属性则在 SubType.prototype 上。这是因为 getSuperValue()是一个原型方法，而property 是一个实例属性。SubType.prototype 现在是 SuperType 的一个实例，因此 property才会存储在它上面。还要注意，由于 SubType.prototype 的 constructor 属性被重写为指向SuperType，所以 instance.constructor 也指向 SuperType。 原型链扩展了前面描述的原型搜索机制。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。对前面的例子而言，调用 instance.getSuperValue()经过了 3 步搜索：instance、SubType.prototype 和 SuperType.prototype，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。 默认原型 实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括 toString()、valueOf()在内的所有默认方法的原因。因此前面的例子还有额外一层继承关系。下图展示了完整的原型链： SubType 继承 SuperType，而 SuperType 继承 Object。在调用 instance.toString()时，实际上调用的是保存在 Object.prototype 上的方法。 原型与继承关系 原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true。如下例所示： 123console.log(instance instanceof Object); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(instance instanceof SubType); // true 从技术上讲，instance 是 Object、SuperType 和 SubType 的实例，因为 instance 的原型链中包含这些构造函数的原型。结果就是 instanceof 对所有这些构造函数都返回 true。 确定这种关系的第二种方式是使用 isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回 true： 123console.log(Object.prototype.isPrototypeOf(instance)); // trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); // trueconsole.log(SubType.prototype.isPrototypeOf(instance)); // true 关于方法 子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。来看下面的例子： 123456789101112131415161718192021222324252627function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();// 新方法SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;// 覆盖已有的方法SubType.prototype.getSuperValue = function () &#123; return false;&#125;;let instance = new SubType();console.log(instance.getSuperValue()); // false 在上面的代码中，加粗的部分涉及两个方法。第一个方法 getSubValue()是 SubType 的新方法，而第二个方法 getSuperValue()是原型链上已经存在但在这里被遮蔽的方法。后面在 SubType 实例上调用 getSuperValue()时调用的是这个方法。而 SuperType 的实例仍然会调用最初的方法。重点在于上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的。 另一个要理解的重点是，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。下面是一个例子： 1234567891011121314151617181920212223242526function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();// 通过对象字面量添加新方法，这会导致上一行无效SubType.prototype = &#123; getSubValue() &#123; return this.subproperty; &#125;, someOtherMethod() &#123; return false; &#125;&#125;;let instance = new SubType();console.log(instance.getSuperValue()); // 出错！ 在这段代码中，子类的原型在被赋值为 SuperType 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 Object 的实例，而不再是 SuperType 的实例。因此之前的原型链就断了。SubType和 SuperType 之间也没有关系了。 原型链的问题 原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。下面的例子揭示了这个问题： 123456789101112131415function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();let instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;let instance2 = new SubType();console.log(instance2.colors); // &quot;red,blue,green,black&quot; 在这个例子中，SuperType 构造函数定义了一个 colors 属性，其中包含一个数组（引用值）。每个 SuperType 的实例都会有自己的 colors 属性，包含自己的数组。但是，当 SubType 通过原型继承SuperType 后，SubType.prototype 变成了 SuperType 的一个实例，因而也获得了自己的 colors属性。这类似于创建了 SubType.prototype.colors 属性。最终结果是，SubType 的所有实例都会共享这个 colors 属性。这一点通过 instance1.colors 上的修改也能反映到 instance2.colors上就可以看出来。 原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。 盗用构造函数为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数。来看下面的例子： 123456789101112131415function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123; // 继承 SuperType SuperType.call(this);&#125;let instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;let instance2 = new SubType();console.log(instance2.colors); // &quot;red,blue,green&quot; 示例中的代码展示了盗用构造函数的调用。通过使用 call()（或 apply()）方法，SuperType构造函数在为 SubType 的实例创建的新对象的上下文中执行了。这相当于新的 SubType 对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的 colors 属性。 传递参数 相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。来看下面的例子： 1234567891011121314function SuperType(name)&#123; this.name = name;&#125;function SubType() &#123; // 继承 SuperType 并传参 SuperType.call(this, &quot;Nicholas&quot;); // 实例属性 this.age = 29;&#125;let instance = new SubType();console.log(instance.name); // &quot;Nicholas&quot;;console.log(instance.age); // 29 在这个例子中，SuperType 构造函数接收一个参数 name，然后将它赋值给一个属性。在 SubType构造函数中调用 SuperType 构造函数时传入这个参数，实际上会在 SubType 的实例上定义 name 属性。为确保 SuperType 构造函数不会覆盖 SubType 定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。 盗用构造函数的问题 盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。 此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。 组合继承组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子： 1234567891011121314151617181920212223242526272829303132function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;;function SubType(name, age)&#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;;let instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;instance1.sayName(); // &quot;Nicholas&quot;;instance1.sayAge(); // 29let instance2 = new SubType(&quot;Greg&quot;, 27);console.log(instance2.colors); // &quot;red,blue,green&quot;instance2.sayName(); // &quot;Greg&quot;;instance2.sayAge(); // 27 在这个例子中，SuperType 构造函数定义了两个属性，name 和 colors，而它的原型上也定义了一个方法sayName()。SubType构造函数调用了 SuperType 构造函数，传入了 name 参数，然后又定义了自己的属性 age。此外，SubType.prototype 也被赋值为 SuperType 的实例。原型赋值之后，又在这个原型上添加了新方法 sayAge()。这样，就可以创建两个 SubType 实例，让这两个实例都有自己的属性，包括 colors，同时还共享相同的方法。 组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。 原型式继承2006 年，Douglas Crockford 写了一篇文章：《JavaScript 中的原型式继承》（“Prototypal Inheritance in JavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数： 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。来看下面的例子： 1234567891011121314let person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;let anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);let yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); // &quot;Shelby,Court,Van,Rob,Barbie&quot; Crockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。在这个例子中，person 对象定义了另一个对象也应该共享的信息，把它传给 object()之后会返回一个新对象。这个新对象的原型是 person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着 person.friends 不仅是person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆了两个 person。 ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的 object()方法效果相同： 1234567891011121314let person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;let anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);let yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); // &quot;Shelby,Court,Van,Rob,Barbie&quot; Object.create()的第二个参数与 Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如： 1234567891011let person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;let anotherPerson = Object.create(person, &#123; name: &#123; value: &quot;Greg&quot; &#125;&#125;);console.log(anotherPerson.name); // &quot;Greg&quot; 原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。 寄生式继承与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下： 1234567function createAnother(original)&#123; let clone = object(original); // 通过调用函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式增强这个对象 console.log(&quot;hi&quot;); &#125;; return clone; // 返回这个对象&#125; 在这段代码中，createAnother()函数接收一个参数，就是新对象的基准对象。这个对象 original会被传给 object()函数，然后将返回的新对象赋值给 clone。接着给 clone 对象添加一个新方法sayHi()。最后返回这个对象。可以像下面这样使用 createAnother()函数： 123456let person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;let anotherPerson = createAnother(person);anotherPerson.sayHi(); // &quot;hi&quot; 这个例子基于 person 对象返回了一个新对象。新返回的 anotherPerson 对象具有 person 的所有属性和方法，还有一个新方法叫 sayHi()。 寄生式组合继承组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。再来看一看这个组合继承的例子： 1234567891011121314151617181920function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); // 第二次调用 SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); // 第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;; 在上面的代码执行后，SubType.prototype上会有两个属性：name 和 colors。它们都是 SuperType 的实例属性，但现在成为了 SubType 的原型属性。在调用 SubType 构造函数时，也会调用 SuperType 构造函数，这一次会在新对象上创建实例属性 name 和 colors。这两个实例属性会遮蔽原型上同名的属性。 上面的代码执行完之后，有两组 name 和 colors 属性：一组在实例上，另一组在 SubType 的原型上。这是调用两次 SuperType 构造函数的结果。好在有办法解决这个问题。 寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示： 12345function inheritPrototype(subType, superType) &#123; let prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 赋值对象&#125; 这个 inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用 inheritPrototype()就可以实现前面例子中的子类型原型赋值： 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; let prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 赋值对象&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;; 这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。 类前几节深入讲解了如何只使用 ECMAScript 5 的特性来模拟类似于类（class-like）的行为。不难看出，各种策略都有自己的问题，也有相应的妥协。正因为如此，实现继承的代码也显得非常冗长和混乱。 为解决这些问题，ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类（class）是ECMAScript 中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然 ECMAScript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。 类定义与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号： 12345// 类声明class Person &#123;&#125;// 类表达式const Animal = class &#123;&#125;; 与函数表达式类似，类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能： 123456789101112131415console.log(FunctionExpression); // undefinedvar FunctionExpression = function() &#123;&#125;;console.log(FunctionExpression); // function() &#123;&#125;console.log(FunctionDeclaration); // FunctionDeclaration() &#123;&#125;function FunctionDeclaration() &#123;&#125;console.log(FunctionDeclaration); // FunctionDeclaration() &#123;&#125;console.log(ClassExpression); // undefinedvar ClassExpression = class &#123;&#125;;console.log(ClassExpression); // class &#123;&#125;console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not definedclass ClassDeclaration &#123;&#125;console.log(ClassDeclaration); // class ClassDeclaration &#123;&#125; 另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制: 123456&#123; function FunctionDeclaration() &#123;&#125; class ClassDeclaration &#123;&#125; &#125;console.log(FunctionDeclaration); // FunctionDeclaration() &#123;&#125;console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined 类的构成： 类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。 与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例（比如，通过 class Foo &#123;&#125;创建实例 foo）： 1234567891011121314151617// 空类定义，有效class Foo &#123;&#125;// 有构造函数的类，有效class Bar &#123; constructor() &#123;&#125;&#125;// 有获取函数的类，有效class Baz &#123; get myBaz() &#123;&#125;&#125;// 有静态方法的类，有效class Qux &#123; static myQux() &#123;&#125;&#125; 类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。 12345678910let Person = class PersonName &#123; identify() &#123; console.log(Person.name, PersonName.name); &#125;&#125;let p = new Person();p.identify(); // PersonName PersonNameconsole.log(Person.name); // PersonNameconsole.log(PersonName); // ReferenceError: PersonName is not defined 类构造函数constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。 实例化 使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。唯一可感知的不同之处就是，JavaScript 解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。 使用 new 调用类的构造函数会执行如下操作。 在内存中创建一个新对象 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性。 构造函数内部的this被赋值为这个新对象（即this指向新对象）。 执行构造函数内部的代码（给新对象添加属性）。 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。 来看下面的例子： 123456789101112131415161718class Animal &#123;&#125;class Person &#123; constructor() &#123; console.log(&#x27;person ctor&#x27;); &#125;&#125;class Vegetable &#123; constructor() &#123; this.color = &#x27;orange&#x27;; &#125;&#125;let a = new Animal();let p = new Person(); // person ctorlet v = new Vegetable();console.log(v.color); // orange 类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的： 123456789101112131415class Person &#123; constructor(name) &#123; console.log(arguments.length); this.name = name || null; &#125;&#125;let p1 = new Person; // 0console.log(p1.name); // nulllet p2 = new Person(); // 0console.log(p2.name); // nulllet p3 = new Person(&#x27;Jake&#x27;); // 1console.log(p3.name); // Jake 默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。 12345678910111213141516171819class Person &#123; constructor(override) &#123; this.foo = &#x27;foo&#x27;; if (override) &#123; return &#123; bar: &#x27;bar&#x27; &#125;; &#125; &#125;&#125;let p1 = new Person(), p2 = new Person(true);console.log(p1); // Person&#123; foo: &#x27;foo&#x27; &#125;console.log(p1 instanceof Person); // trueconsole.log(p2); // &#123; bar: &#x27;bar&#x27; &#125;console.log(p2 instanceof Person); // false 类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。调用类构造函数时如果忘了使用 new 则会抛出错误： 123456789function Person() &#123;&#125;class Animal &#123;&#125;// 把 window 作为 this 来构建实例let p = Person();let a = Animal();// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27; 类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法（但作为类构造函数，仍然要使用 new 调用）。因此，实例化之后可以在实例上引用它： 1234567class Person &#123;&#125;// 使用类创建一个新实例let p1 = new Person();p1.constructor();// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;// 使用对类构造函数的引用创建一个新实例let p2 = new p1.constructor(); 把类当成特殊函数 ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript 类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数： 1234class Person &#123;&#125;console.log(Person); // class Person &#123;&#125;console.log(typeof Person); // function 类标识符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身： 1234class Person&#123;&#125;console.log(Person.prototype); // &#123; constructor: f() &#125;console.log(Person === Person.prototype.constructor); // true 与普通构造函数一样，可以使用instanceof 操作符检查构造函数原型是否存在于实例的原型链中: 12345class Person &#123;&#125;let p = new Person();console.log(p instanceof Person); // true 由此可知，可以使用 instanceof 操作符检查一个对象与类构造函数，以确定这个对象是不是类的实例。只不过此时的类构造函数要使用类标识符，比如，在前面的例子中要检查 p 和 Person。 如前所述，类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用 new 调用时就会被当成构造函数。重点在于，类中定义的 constructor 方法不会被当成构造函数，在对它使用instanceof 操作符时会返回 false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转： 12345678910111213class Person &#123;&#125;let p1 = new Person();console.log(p1.constructor === Person); // trueconsole.log(p1 instanceof Person); // trueconsole.log(p1 instanceof Person.constructor); // falselet p2 = new Person.constructor();console.log(p2.constructor === Person); // falseconsole.log(p2 instanceof Person); // falseconsole.log(p2 instanceof Person.constructor); // true 类是 JavaScript 的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递： 123456789101112131415// 类可以像函数一样在任何地方定义，比如在数组中let classList = [ class &#123; constructor(id) &#123; this.id_ = id; console.log(`instance $&#123;this.id_&#125;`); &#125; &#125;];function createInstance(classDefinition, id) &#123; return new classDefinition(id);&#125;let foo = createInstance(classList[0], 3141); // instance 3141 与立即调用函数表达式相似，类也可以立即实例化： 12345678// 因为是一个类表达式，所以类名是可选的let p = new class Foo &#123; constructor(x) &#123; console.log(x); &#125;&#125;(&#x27;bar&#x27;); // barconsole.log(p); // Foo &#123;&#125; 实例、原型和类成员类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。 实例成员 每次通过new 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。 每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享： 12345678910111213141516171819202122232425class Person &#123; constructor() &#123; // 这个例子先使用对象包装类型定义一个字符串 // 为的是在下面测试两个对象的相等性 this.name = new String(&#x27;Jack&#x27;); this.sayName = () =&gt; console.log(this.name); this.nicknames = [&#x27;Jake&#x27;, &#x27;J-Dog&#x27;] &#125;&#125;let p1 = new Person(), p2 = new Person();p1.sayName(); // Jackp2.sayName(); // Jackconsole.log(p1.name === p2.name); // falseconsole.log(p1.sayName === p2.sayName); // falseconsole.log(p1.nicknames === p2.nicknames); // falsep1.name = p1.nicknames[0];p2.name = p2.nicknames[1];p1.sayName(); // Jakep2.sayName(); // J-Dog 原型方法与访问器 为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。 1234567891011121314class Person &#123; constructor() &#123; // 添加到 this 的所有内容都会存在于不同的实例上 this.locate = () =&gt; console.log(&#x27;instance&#x27;); &#125; // 在类块中定义的所有内容都会定义在类的原型上 locate() &#123; console.log(&#x27;prototype&#x27;); &#125;&#125;let p = new Person();p.locate(); // instancePerson.prototype.locate(); // prototype 可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据： 1234class Person &#123; name: &#x27;Jake&#x27;&#125;// Uncaught SyntaxError: Unexpected token 类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键： 1234567891011121314151617181920const symbolKey = Symbol(&#x27;symbolKey&#x27;);class Person &#123; stringKey() &#123; console.log(&#x27;invoked stringKey&#x27;); &#125; [symbolKey]() &#123; console.log(&#x27;invoked symbolKey&#x27;); &#125; [&#x27;computed&#x27; + &#x27;Key&#x27;]() &#123; console.log(&#x27;invoked computedKey&#x27;); &#125;&#125;let p = new Person();p.stringKey(); // invoked stringKeyp[symbolKey](); // invoked symbolKeyp.computedKey(); // invoked computedKey 类定义也支持获取和设置访问器。语法与行为跟普通对象一样： 123456789101112class Person &#123; set name(newName) &#123; this.name_ = newName; &#125; get name() &#123; return this.name_; &#125;&#125;let p = new Person();p.name = &#x27;Jake&#x27;;console.log(p.name); // Jake 静态类方法 可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。 静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样： 1234567891011121314151617181920class Person &#123; constructor() &#123; // 添加到 this 的所有内容都会存在于不同的实例上 this.locate = () =&gt; console.log(&#x27;instance&#x27;, this); &#125; // 定义在类的原型对象上 locate() &#123; console.log(&#x27;prototype&#x27;, this); &#125; // 定义在类本身上 static locate() &#123; console.log(&#x27;class&#x27;, this); &#125;&#125;let p = new Person();p.locate(); // instance, Person &#123;&#125;Person.prototype.locate(); // prototype, &#123;constructor: ... &#125;Person.locate(); // class, class Person &#123;&#125; 静态类方法非常适合作为实例工厂： 123456789101112131415class Person &#123; constructor(age) &#123; this.age_ = age; &#125; sayAge() &#123; console.log(this.age_); &#125; static create() &#123; // 使用随机年龄创建并返回一个 Person 实例 return new Person(Math.floor(Math.random()*100)); &#125;&#125;console.log(Person.create()); // Person &#123; age_: ... &#125; 非函数原型和类成员 虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加： 123456789101112class Person &#123; sayName() &#123; console.log(`$&#123;Person.greeting&#125; $&#123;this.name&#125;`); &#125;&#125;// 在类上定义数据成员Person.greeting = &#x27;My name is&#x27;;// 在原型上定义数据成员Person.prototype.name = &#x27;Jake&#x27;;let p = new Person();p.sayName(); // My name is Jake 类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 this引用的数据。 迭代器与生成器方法 1234567891011121314151617181920212223242526class Person &#123; // 在原型上定义生成器方法 *createNicknameIterator() &#123; yield &#x27;Jack&#x27;; yield &#x27;Jake&#x27;; yield &#x27;J-Dog&#x27;; &#125; // 在类上定义生成器方法 static *createJobIterator() &#123; yield &#x27;Butcher&#x27;; yield &#x27;Baker&#x27;; yield &#x27;Candlestick maker&#x27;; &#125;&#125;let jobIter = Person.createJobIterator();console.log(jobIter.next().value); // Butcherconsole.log(jobIter.next().value); // Bakerconsole.log(jobIter.next().value); // Candlestick makerlet p = new Person();let nicknameIter = p.createNicknameIterator();console.log(nicknameIter.next().value); // Jackconsole.log(nicknameIter.next().value); // Jakeconsole.log(nicknameIter.next().value); // J-Dog 因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象： 1234567891011121314151617class Person &#123; constructor() &#123; this.nicknames = [&#x27;Jack&#x27;, &#x27;Jake&#x27;, &#x27;J-Dog&#x27;]; &#125; *[Symbol.iterator]() &#123; yield *this.nicknames.entries(); &#125;&#125;let p = new Person();for (let [idx, nickname] of p) &#123; console.log(nickname);&#125;// Jack// Jake// J-Dog 也可以只返回迭代器实例： 1234567891011121314151617class Person &#123; constructor() &#123; this.nicknames = [&#x27;Jack&#x27;, &#x27;Jake&#x27;, &#x27;J-Dog&#x27;]; &#125; [Symbol.iterator]() &#123; return this.nicknames.entries(); &#125;&#125;let p = new Person();for (let [idx, nickname] of p) &#123; console.log(nickname);&#125;// Jack// Jake// J-Dog 继承本章前面花了大量篇幅讨论如何使用 ES5 的机制实现继承。ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。 继承基础 ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）： 1234567891011121314151617class Vehicle &#123;&#125;// 继承类class Bus extends Vehicle &#123;&#125;let b = new Bus();console.log(b instanceof Bus); // trueconsole.log(b instanceof Vehicle); // truefunction Person() &#123;&#125;// 继承普通构造函数class Engineer extends Person &#123;&#125;let e = new Engineer();console.log(e instanceof Engineer); // trueconsole.log(e instanceof Person); // true 派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类： 1234567891011121314151617181920class Vehicle &#123; identifyPrototype(id) &#123; console.log(id, this); &#125; static identifyClass(id) &#123; console.log(id, this); &#125;&#125;class Bus extends Vehicle &#123;&#125;let v = new Vehicle();let b = new Bus();b.identifyPrototype(&#x27;bus&#x27;); // bus, Bus &#123;&#125;v.identifyPrototype(&#x27;vehicle&#x27;); // vehicle, Vehicle &#123;&#125;Bus.identifyClass(&#x27;bus&#x27;); // bus, class Bus &#123;&#125;Vehicle.identifyClass(&#x27;vehicle&#x27;); // vehicle, class Vehicle &#123;&#125; extends 关键字也可以在类表达式中使用，因此 let Bar = class extends Foo &#123;&#125;是有效的语法。 构造函数、HomeObject和super() 派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数。 123456789101112131415class Vehicle &#123; constructor() &#123; this.hasEngine = true; &#125;&#125;class Bus extends Vehicle &#123; constructor() &#123; // 不要在调用 super()之前引用 this，否则会抛出 ReferenceError super(); // 相当于 super.constructor() console.log(this instanceof Vehicle); // true console.log(this); // Bus &#123; hasEngine: true &#125; &#125;&#125;new Bus(); 在静态方法中可以通过 super 调用继承的类上定义的静态方法： 123456789101112class Vehicle &#123; static identify() &#123; console.log(&#x27;vehicle&#x27;); &#125;&#125;class Bus extends Vehicle &#123; static identify() &#123; super.identify(); &#125;&#125;Bus.identify(); // vehicle 在使用 super 时要注意几个问题。 super 只能在派生类构造函数和静态方法中使用。 123456class Vehicle &#123; constructor() &#123; super(); // SyntaxError: &#x27;super&#x27; keyword unexpected &#125;&#125; 不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。 12345678class Vehicle &#123;&#125;class Bus extends Vehicle &#123; constructor() &#123; console.log(super); // SyntaxError: &#x27;super&#x27; keyword unexpected here &#125;&#125; 调用 super()会调用父类构造函数，并将返回的实例赋值给 this。 123456789class Vehicle &#123;&#125;class Bus extends Vehicle &#123; constructor() &#123; super(); console.log(this instanceof Vehicle); &#125;&#125;new Bus(); // true super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。 1234567891011class Vehicle &#123; constructor(licensePlate) &#123; this.licensePlate = licensePlate; &#125;&#125;class Bus extends Vehicle &#123; constructor(licensePlate) &#123; super(licensePlate); &#125;&#125;console.log(new Bus(&#x27;1337H4X&#x27;)); // Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125; 如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数 1234567class Vehicle &#123; constructor(licensePlate) &#123; this.licensePlate = licensePlate; &#125;&#125;class Bus extends Vehicle &#123;&#125;console.log(new Bus(&#x27;1337H4X&#x27;)); // Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125; 在类构造函数中，不能在调用 super()之前引用 this。 12345678910class Vehicle &#123;&#125;class Bus extends Vehicle &#123; constructor() &#123; console.log(this); &#125;&#125;new Bus();// ReferenceError: Must call super constructor in derived class// before accessing &#x27;this&#x27; or returning from derived constructor 如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。 12345678910111213141516171819class Vehicle &#123;&#125;class Car extends Vehicle &#123;&#125;class Bus extends Vehicle &#123; constructor() &#123; super(); &#125;&#125;class Van extends Vehicle &#123; constructor() &#123; return &#123;&#125;; &#125;&#125;console.log(new Car()); // Car &#123;&#125;console.log(new Bus()); // Bus &#123;&#125;console.log(new Van()); // &#123;&#125; 抽象基类 有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法 ，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化： 1234567891011121314// 抽象基类class Vehicle &#123; constructor() &#123; console.log(new.target); if (new.target === Vehicle) &#123; throw new Error(&#x27;Vehicle cannot be directly instantiated&#x27;); &#125; &#125;&#125;// 派生类class Bus extends Vehicle &#123;&#125;new Bus(); // class Bus &#123;&#125;new Vehicle(); // class Vehicle &#123;&#125;// Error: Vehicle cannot be directly instantiated 另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法： 1234567891011121314151617181920212223// 抽象基类class Vehicle &#123; constructor() &#123; if (new.target === Vehicle) &#123; throw new Error(&#x27;Vehicle cannot be directly instantiated&#x27;); &#125; if (!this.foo) &#123; throw new Error(&#x27;Inheriting class must define foo()&#x27;); &#125; console.log(&#x27;success!&#x27;); &#125;&#125;// 派生类class Bus extends Vehicle &#123; foo() &#123;&#125;&#125;// 派生类class Van extends Vehicle &#123;&#125;new Bus(); // success!new Van(); // Error: Inheriting class must define foo() 继承内置类型 ES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型： 12345678910111213141516class SuperArray extends Array &#123; shuffle() &#123; // 洗牌算法 for (let i = this.length - 1; i &gt; 0; i--) &#123; const j = Math.floor(Math.random() * (i + 1)); [this[i], this[j]] = [this[j], this[i]]; &#125; &#125;&#125;let a = new SuperArray(1, 2, 3, 4, 5);console.log(a instanceof Array); // trueconsole.log(a instanceof SuperArray); // trueconsole.log(a); // [1, 2, 3, 4, 5]a.shuffle();console.log(a); // [3, 1, 4, 5, 2] 有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的： 123456789class SuperArray extends Array &#123;&#125;let a1 = new SuperArray(1, 2, 3, 4, 5);let a2 = a1.filter(x =&gt; !!(x%2))console.log(a1); // [1, 2, 3, 4, 5]console.log(a2); // [1, 3, 5]console.log(a1 instanceof SuperArray); // trueconsole.log(a2 instanceof SuperArray); // true 如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类： 12345678910111213class SuperArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;let a1 = new SuperArray(1, 2, 3, 4, 5);let a2 = a1.filter(x =&gt; !!(x%2))console.log(a1); // [1, 2, 3, 4, 5]console.log(a2); // [1, 3, 5]console.log(a1 instanceof SuperArray); // trueconsole.log(a2 instanceof SuperArray); // false 类混入 把不同类的行为集中到一个类是一种常见的 JavaScript 模式。虽然 ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。 注意：Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。 在下面的代码片段中，extends 关键字后面是一个 JavaScript 表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。这个表达式会在求值类定义时被求值： 123456789class Vehicle &#123;&#125;function getParentClass() &#123; console.log(&#x27;evaluated expression&#x27;); return Vehicle;&#125;class Bus extends getParentClass() &#123;&#125;// 可求值的表达式 混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。如果 Person 类需要组合 A、B、C，则需要某种机制实现 B 继承 A，C 继承 B，而 Person再继承 C，从而把 A、B、C 组合到这个超类中。实现这种模式有不同的策略。 一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式： 1234567891011121314151617181920212223242526class Vehicle &#123;&#125;let FooMixin = (Superclass) =&gt; class extends Superclass &#123; foo() &#123; console.log(&#x27;foo&#x27;); &#125;&#125;;let BarMixin = (Superclass) =&gt; class extends Superclass &#123; bar() &#123; console.log(&#x27;bar&#x27;); &#125;&#125;;let BazMixin = (Superclass) =&gt; class extends Superclass &#123; baz() &#123; console.log(&#x27;baz&#x27;); &#125;&#125;;class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) &#123;&#125;let b = new Bus();b.foo(); // foob.bar(); // barb.baz(); // baz 通过写一个辅助函数，可以把嵌套调用展开： 123456789101112131415161718192021222324252627282930class Vehicle &#123;&#125;let FooMixin = (Superclass) =&gt; class extends Superclass &#123; foo() &#123; console.log(&#x27;foo&#x27;); &#125;&#125;;let BarMixin = (Superclass) =&gt; class extends Superclass &#123; bar() &#123; console.log(&#x27;bar&#x27;); &#125;&#125;;let BazMixin = (Superclass) =&gt; class extends Superclass &#123; baz() &#123; console.log(&#x27;baz&#x27;); &#125;&#125;;function mix(BaseClass, ...Mixins) &#123; return Mixins.reduce((accumulator, current) =&gt; current(accumulator), BaseClass);&#125;class Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) &#123;&#125;let b = new Bus();b.foo(); // foob.bar(); // barb.baz(); // baz 注意：很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(5)——迭代器与生成器","slug":"JS高级程序设计读书笔记(5)——迭代器与生成器","date":"2023-02-07T07:11:39.000Z","updated":"2023-11-27T15:34:23.881Z","comments":true,"path":"2023/02/07/JS高级程序设计读书笔记(5)——迭代器与生成器/","link":"","permalink":"http://pvnk1u.github.io/2023/02/07/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"在软件开发领域，“迭代” 的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。 理解迭代在JavaScript 中，计数循环就是一种最简单的迭代： 123for (let i = 1; i &lt;= 10; ++i) &#123; console.log(i); &#125; 循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循 环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。 迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是JavaScript中有序集合的最典型例子。 1234let collection = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]; for (let index = 0; index &lt; collection.length; ++index) &#123; console.log(collection[index]); &#125; 因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。 由于如下原因，通过这种循环来执行例程并不理想。 迭代之前需要事先知道如何使用数据结构 数组中的每一项都只能先通过引用取得数组对象， 然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。 遍历顺序并不是数据结构固有的 通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。 ES5 新增了 Array.prototype.forEach()方法，向通用迭代需求迈进了一步（但仍然不够理想）： 12345let collection = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]; collection.forEach((item) =&gt; console.log(item));// foo // bar // baz 这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。 因此这个方法只适用于数组，而且回调结构也比较笨拙。 在 ECMAScript 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其他很多语言都对这个模式提供了完备的支持。JavaScript 在 ECMAScript 6 以后也支持了迭代器模式。 迭代器模式迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。 可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序： 123456// 数组的元素是有限的// 递增索引可以按序访问每个元素let arr = [3, 1, 4]; // 集合的元素是有限的// 可以按插入顺序访问每个元素let set = new Set().add(3).add(1).add(4); 不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如开头提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。 任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。迭代器（iterator）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是 Iterable 和 Iterator 的强大之处。 可迭代协议实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力。在 ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而 且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。 很多内置类型都实现了 Iterable 接口： 字符串 数组 映射 集合 arguments对象 NodeList等DOM集合模型 检查是否存在默认迭代器属性可以暴露这个工厂函数： 12345678910111213141516171819202122let num = 1; let obj = &#123;&#125;; // 这两种类型没有实现迭代器工厂函数console.log(num[Symbol.iterator]); // undefined console.log(obj[Symbol.iterator]); // undefined let str = &#x27;abc&#x27;; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let map = new Map().set(&#x27;a&#x27;, 1).set(&#x27;b&#x27;, 2).set(&#x27;c&#x27;, 3); let set = new Set().add(&#x27;a&#x27;).add(&#x27;b&#x27;).add(&#x27;c&#x27;); let els = document.querySelectorAll(&#x27;div&#x27;); // 这些类型都实现了迭代器工厂函数console.log(str[Symbol.iterator]); // f values() &#123; [native code] &#125; console.log(arr[Symbol.iterator]); // f values() &#123; [native code] &#125; console.log(map[Symbol.iterator]); // f values() &#123; [native code] &#125; console.log(set[Symbol.iterator]); // f values() &#123; [native code] &#125; console.log(els[Symbol.iterator]); // f values() &#123; [native code] &#125; // 调用这个工厂函数会生成一个迭代器console.log(str[Symbol.iterator]()); // StringIterator &#123;&#125; console.log(arr[Symbol.iterator]()); // ArrayIterator &#123;&#125; console.log(map[Symbol.iterator]()); // MapIterator &#123;&#125; console.log(set[Symbol.iterator]()); // SetIterator &#123;&#125; console.log(els[Symbol.iterator]()); // ArrayIterator &#123;&#125; 实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括： for-of 循环 数组解构 扩展操作符 Array.from() 创建集合 创建映射 Promise.all()接收由期约组成的可迭代对象 Promise.race()接收由期约组成的可迭代对象 yield*操作符，在生成器中使用 这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器： 1234567891011121314151617181920212223242526let arr = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]; // for-of 循环for (let el of arr) &#123; console.log(el); &#125;// foo // bar // baz // 数组解构let [a, b, c] = arr; console.log(a, b, c); // foo, bar, baz // 扩展操作符let arr2 = [...arr]; console.log(arr2); // [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] // Array.from() let arr3 = Array.from(arr); console.log(arr3); // [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] // Set 构造函数let set = new Set(arr); console.log(set); // Set(3) &#123;&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;&#125;// Map 构造函数let pairs = arr.map((x, i) =&gt; [x, i]); console.log(pairs); // [[&#x27;foo&#x27;, 0], [&#x27;bar&#x27;, 1], [&#x27;baz&#x27;, 2]] let map = new Map(pairs); console.log(map); // Map(3) &#123; &#x27;foo&#x27;=&gt;0, &#x27;bar&#x27;=&gt;1, &#x27;baz&#x27;=&gt;2 &#125; 如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口： 12345678class FooArray extends Array &#123;&#125; let fooArr = new FooArray(&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;); for (let el of fooArr) &#123; console.log(el); &#125; // foo // bar // baz 迭代器协议迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 API 使用 next()方法 在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。 next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。done 是一个布尔值，表示是否还可以再次调用 next()取得下一个值；value 包含可迭代对象的下一个值（done 为 false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”。可以通过以下简单的数组来演示： 1234567891011// 可迭代对象let arr = [&#x27;foo&#x27;, &#x27;bar&#x27;]; // 迭代器工厂函数console.log(arr[Symbol.iterator]); // f values() &#123; [native code] &#125; // 迭代器let iter = arr[Symbol.iterator](); console.log(iter); // ArrayIterator &#123;&#125; // 执行迭代console.log(iter.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(iter.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125; 这里通过创建迭代器并调用next()方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态， 后续调用 next()就一直返回同样的值了： 123456let arr = [&#x27;foo&#x27;]; let iter = arr[Symbol.iterator](); console.log(iter.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125; 每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象： 1234567let arr = [&#x27;foo&#x27;, &#x27;bar&#x27;]; let iter1 = arr[Symbol.iterator](); let iter2 = arr[Symbol.iterator](); console.log(iter1.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(iter2.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(iter2.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(iter1.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; 迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化： 12345678let arr = [&#x27;foo&#x27;, &#x27;baz&#x27;]; let iter = arr[Symbol.iterator](); console.log(iter.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; // 在数组中间插入值arr.splice(1, 0, &#x27;bar&#x27;); console.log(iter.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(iter.next()); // &#123; done: false, value: &#x27;baz&#x27; &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125; 需要注意的是，迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。 “迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型。下面的例子比较了一个显式的迭代器实现和一个原生的迭代器实现。 123456789101112131415161718192021// 这个类实现了可迭代接口（Iterable） // 调用默认的迭代器工厂函数会返回// 一个实现迭代器接口（Iterator）的迭代器对象class Foo &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false, value: &#x27;foo&#x27; &#125;; &#125; &#125; &#125; &#125; let f = new Foo(); // 打印出实现了迭代器接口的对象console.log(f[Symbol.iterator]()); // &#123; next: f() &#123;&#125; &#125; // Array 类型实现了可迭代接口（Iterable）// 调用 Array 类型的默认迭代器工厂函数// 会创建一个 ArrayIterator 的实例let a = new Array(); // 打印出 ArrayIterator 的实例console.log(a[Symbol.iterator]()); // Array Iterator &#123;&#125; 自定义迭代器与 Iterable 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。下面这个例子中 的 Counter 类只能被迭代一定的次数： 123456789101112131415161718192021222324class Counter &#123; // Counter 的实例应该迭代 limit 次 constructor(limit) &#123; this.count = 1; this.limit = limit; &#125; next() &#123; if (this.count &lt;= this.limit) &#123; return &#123; done: false, value: this.count++ &#125;; &#125; else &#123; return &#123; done: true, value: undefined &#125;; &#125; &#125; [Symbol.iterator]() &#123; return this; &#125; &#125; let counter = new Counter(3); for (let i of counter) &#123; console.log(i); &#125; // 1 // 2 // 3 这个类实现了 Iterator 接口，但不理想。因为它的每个实例只能被迭代一次： 123456for (let i of counter) &#123; console.log(i); &#125; // 1 // 2 // 3 for (let i of counter) &#123; console.log(i); &#125; // (nothing logged) 为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此， 可以把计数器变量放到闭包里，然后通过闭包返回迭代器： 12345678910111213141516171819202122232425262728class Counter &#123; constructor(limit) &#123; this.limit = limit; &#125; [Symbol.iterator]() &#123; let count = 1, limit = this.limit; return &#123; next() &#123; if (count &lt;= limit) &#123; return &#123; done: false, value: count++ &#125;; &#125; else &#123; return &#123; done: true, value: undefined &#125;; &#125; &#125; &#125;; &#125; &#125; let counter = new Counter(3); for (let i of counter) &#123; console.log(i); &#125; // 1 // 2 // 3 for (let i of counter) &#123; console.log(i); &#125; // 1 // 2 // 3 每个以这种方式创建的迭代器也实现了 Iterable 接口。Symbol.iterator 属性引用的工厂函数会返回相同的迭代器： 12345let arr = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]; let iter1 = arr[Symbol.iterator](); console.log(iter1[Symbol.iterator]); // f values() &#123; [native code] &#125; let iter2 = iter1[Symbol.iterator](); console.log(iter1 === iter2); // true 因为每个迭代器也实现了 Iterable 接口，所以它们可以用在任何期待可迭代对象的地方，比如 for-of 循环： 12345678910let arr = [3, 1, 4]; let iter = arr[Symbol.iterator](); for (let item of arr ) &#123; console.log(item); &#125; // 3 // 1 // 4 for (let item of iter ) &#123; console.log(item); &#125; // 3 // 1 // 4 提前终止迭代器可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知 道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括： for-of 循环通过 break、continue、return 或 throw 提前退出； 解构操作并未消费所有值。 return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回&#123; done: true &#125;。 因为这个返回值只会用在生成器的上下文中，所以本章后面再讨论这种情况。 如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用 return()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Counter &#123; constructor(limit) &#123; this.limit = limit; &#125; [Symbol.iterator]() &#123; let count = 1, limit = this.limit; return &#123; next() &#123; if (count &lt;= limit) &#123; return &#123; done: false, value: count++ &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, return() &#123; console.log(&#x27;Exiting early&#x27;); return &#123; done: true &#125;; &#125; &#125;; &#125; &#125; let counter1 = new Counter(5); for (let i of counter1) &#123; if (i &gt; 2) &#123; break; &#125; console.log(i); &#125; // 1 // 2 // Exiting early let counter2 = new Counter(5); try &#123; for (let i of counter2) &#123; if (i &gt; 2) &#123; throw &#x27;err&#x27;; &#125; console.log(i); &#125; &#125; catch(e) &#123;&#125; // 1 // 2 // Exiting early let counter3 = new Counter(5); let [a, b] = counter3; // Exiting early 如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的： 1234567891011121314151617let a = [1, 2, 3, 4, 5]; let iter = a[Symbol.iterator](); for (let i of iter) &#123; console.log(i); if (i &gt; 2) &#123; break &#125; &#125; // 1 // 2 // 3 for (let i of iter) &#123; console.log(i); &#125; // 4 // 5 因为 return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭， 可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return()不会强制迭代器进入关闭状态。即便如此， return()方法还是会被调用。 123456789101112131415161718192021let a = [1, 2, 3, 4, 5]; let iter = a[Symbol.iterator](); iter.return = function() &#123; console.log(&#x27;Exiting early&#x27;); return &#123; done: true &#125;;&#125;; for (let i of iter) &#123; console.log(i); if (i &gt; 2) &#123; break &#125; &#125; // 1 // 2 // 3 // Exiting earlyfor (let i of iter) &#123; console.log(i); &#125; // 4 // 5 生成器生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。 生成器基础生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。 1234567891011121314151617181920// 生成器函数声明function* generatorFn() &#123;&#125; // 生成器函数表达式let generatorFn = function* () &#123;&#125; // 作为对象字面量方法的生成器函数let foo = &#123; * generatorFn() &#123;&#125; &#125; // 作为类实例方法的生成器函数class Foo &#123; * generatorFn() &#123;&#125; &#125; // 作为类静态方法的生成器函数class Bar &#123; static * generatorFn() &#123;&#125; &#125; 标识生成器函数的星号不受两侧空格的影响： 123456789// 等价的生成器函数： function* generatorFnA() &#123;&#125; function *generatorFnB() &#123;&#125; function * generatorFnC() &#123;&#125; // 等价的生成器方法：class Foo &#123; *generatorFnD() &#123;&#125; * generatorFnE() &#123;&#125; &#125; 调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。 1234function* generatorFn() &#123;&#125; const g = generatorFn(); console.log(g); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(g.next); // f next() &#123; [native code] &#125; next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。 1234function* generatorFn() &#123;&#125; let generatorObject = generatorFn(); console.log(generatorObject); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(generatorObject.next()); // &#123; done: true, value: undefined &#125; value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定： 123456function* generatorFn() &#123; return &#x27;foo&#x27;; &#125; let generatorObject = generatorFn(); console.log(generatorObject); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(generatorObject.next()); // &#123; done: true, value: &#x27;foo&#x27; &#125; 生成器函数只会在初次调用 next()方法后开始执行，如下所示： 123456function* generatorFn() &#123; console.log(&#x27;foobar&#x27;); &#125; // 初次调用生成器函数并不会打印日志let generatorObject = generatorFn(); generatorObject.next(); // foobar 生成器对象实现了Iterable 接口，它们默认的迭代器是自引用的： 123456789101112function* generatorFn() &#123;&#125; console.log(generatorFn); // f* generatorFn() &#123;&#125; console.log(generatorFn()[Symbol.iterator]);// f [Symbol.iterator]() &#123;native code&#125; console.log(generatorFn()); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(generatorFn()[Symbol.iterator]()); // generatorFn &#123;&lt;suspended&gt;&#125; const g = generatorFn(); console.log(g === g[Symbol.iterator]()); // true 通过yield中断执行yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行： 123456function* generatorFn() &#123; yield; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next()); // &#123; done: false, value: undefined &#125; console.log(generatorObject.next()); // &#123; done: true, value: undefined &#125; 此时的yield 关键字有点像函数的中间返回语句，它生成的值会出现在 next()方法返回的对象里。 通过 yield 关键字退出的生成器函数会处在 done: false 状态；通过 return 关键字退出的生成器函 数会处于 done: true 状态。 123456789function* generatorFn() &#123; yield &#x27;foo&#x27;; yield &#x27;bar&#x27;; return &#x27;baz&#x27;; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(generatorObject.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(generatorObject.next()); // &#123; done: true, value: &#x27;baz&#x27; &#125; 生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 next() 不会影响其他生成器： 1234567891011function* generatorFn() &#123; yield &#x27;foo&#x27;; yield &#x27;bar&#x27;; return &#x27;baz&#x27;; &#125; let generatorObject1 = generatorFn(); let generatorObject2 = generatorFn(); console.log(generatorObject1.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(generatorObject2.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125;console.log(generatorObject2.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(generatorObject1.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的 return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误： 12345678910111213141516171819202122// 有效function* validGeneratorFn() &#123; yield; &#125; // 无效function* invalidGeneratorFnA() &#123; function a() &#123; yield; &#125; &#125; // 无效function* invalidGeneratorFnB() &#123; const b = () =&gt; &#123; yield; &#125; &#125; // 无效function* invalidGeneratorFnC() &#123; (() =&gt; &#123; yield; &#125;)(); &#125; 生成器对象作为可迭代对象 在生成器对象上显式调用 next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象， 那么使用起来会更方便： 1234567891011function* generatorFn() &#123; yield 1; yield 2; yield 3; &#125; for (const x of generatorFn()) &#123; console.log(x); &#125; // 1 // 2 // 3 在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，需要定义一个可迭代对象， 而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现： 1234567891011function* nTimes(n) &#123; while(n--) &#123; yield; &#125; &#125; for (let _ of nTimes(3)) &#123; console.log(&#x27;foo&#x27;); &#125; // foo // foo // foo 传给生成器的函数可以控制迭代循环的次数。在 n 为 0 时，while 条件为假，循环退出，生成器函数返回。 使用yield实现输入和输出 除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解—— 第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数： 123456789function* generatorFn(initial) &#123; console.log(initial); console.log(yield); console.log(yield); &#125; let generatorObject = generatorFn(&#x27;foo&#x27;); generatorObject.next(&#x27;bar&#x27;); // foo generatorObject.next(&#x27;baz&#x27;); // baz generatorObject.next(&#x27;qux&#x27;); // qux yield 关键字可以同时用于输入和输出，如下例所示： 123456function* generatorFn() &#123; return yield &#x27;foo&#x27;; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(generatorObject.next(&#x27;bar&#x27;)); // &#123; done: true, value: &#x27;bar&#x27; &#125; 因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到 yield关键字时暂停执行并计算出要产生的值：”foo”。下一次调用 next()传入了”bar”，作为交给同一个 yield 的值。然后这个值被确定为本次生成器函数要返回的值。 yield 关键字并非只能使用一次。比如，以下代码就定义了一个无穷计数生成器函数： 12345678910111213function* generatorFn() &#123; for (let i = 0;;++i) &#123; yield i; &#125; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next().value); // 0 console.log(generatorObject.next().value); // 1 console.log(generatorObject.next().value); // 2 console.log(generatorObject.next().value); // 3 console.log(generatorObject.next().value); // 4 console.log(generatorObject.next().value); // 5 ... 假设想定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个 新数组可以实现这个需求，但不用数组也可以实现同样的行为： 1234567891011function* nTimes(n) &#123; for (let i = 0; i &lt; n; ++i) &#123; yield i; &#125; &#125; for (let x of nTimes(3)) &#123; console.log(x); &#125; // 0 // 1 // 2 另外，使用 while 循环也可以，而且代码稍微简洁一点： 123456789101112function* nTimes(n) &#123; let i = 0; while(n--) &#123; yield i++; &#125; &#125; for (let x of nTimes(3)) &#123; console.log(x); &#125; // 0 // 1 // 2 这样使用生成器也可以实现范围和填充数组： 1234567891011121314151617function* range(start, end) &#123; while(end &gt; start) &#123; yield start++; &#125; &#125; for (const x of range(4, 7)) &#123; console.log(x); &#125; // 4 // 5 // 6 function* zeroes(n) &#123; while(n--) &#123; yield 0; &#125; &#125; console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0] 产生可迭代对象 可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值： 12345678910111213141516// 等价的 generatorFn： // function* generatorFn() &#123; // for (const x of [1, 2, 3]) &#123; // yield x; // &#125; // &#125; function* generatorFn() &#123; yield* [1, 2, 3]; &#125; let generatorObject = generatorFn(); for (const x of generatorFn()) &#123; console.log(x); &#125; // 1 // 2 // 3 与生成器函数的星号类似，yield 星号两侧的空格不影响其行为： 1234567891011121314function* generatorFn() &#123; yield* [1, 2]; yield *[3, 4]; yield * [5, 6]; &#125; for (const x of generatorFn()) &#123; console.log(x); &#125; // 1 // 2 // 3 // 4 // 5 // 6 因为 yield*实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把 yield 放到一个循环里没什么不同。下面两个生成器函数的行为是等价的： 1234567891011121314151617181920function* generatorFnA() &#123; for (const x of [1, 2, 3]) &#123; yield x; &#125; &#125; for (const x of generatorFnA()) &#123; console.log(x); &#125; // 1 // 2 // 3 function* generatorFnB() &#123; yield* [1, 2, 3]; &#125; for (const x of generatorFnB()) &#123; console.log(x); &#125; // 1 // 2 // 3 yield*的值是关联迭代器返回 done: true 时的 value 属性。对于普通迭代器来说，这个值是 undefined： 12345678910function* generatorFn() &#123; console.log(&#x27;iter value:&#x27;, yield* [1, 2, 3]); &#125; for (const x of generatorFn()) &#123; console.log(&#x27;value:&#x27;, x); &#125; // value: 1 // value: 2 // value: 3 // iter value: undefined 对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值： 123456789101112function* innerGeneratorFn() &#123; yield &#x27;foo&#x27;; return &#x27;bar&#x27;; &#125; function* outerGeneratorFn(genObj) &#123; console.log(&#x27;iter value:&#x27;, yield* innerGeneratorFn()); &#125; for (const x of outerGeneratorFn()) &#123; console.log(&#x27;value:&#x27;, x); &#125; // value: foo // iter value: bar 使用yield*实现递归算法 yield*最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子： 123456789101112function* nTimes(n) &#123; if (n &gt; 0) &#123; yield* nTimes(n - 1); yield n - 1; &#125; &#125; for (const x of nTimes(3)) &#123; console.log(x); &#125; // 0 // 1 // 2 在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。 生成器作为默认迭代器因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器， 所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容： 12345678910111213141516class Foo &#123; constructor() &#123; this.values = [1, 2, 3]; &#125; * [Symbol.iterator]() &#123; yield* this.values; &#125; &#125; const f = new Foo(); for (const x of f) &#123; console.log(x); &#125; // 1 // 2 // 3 这里，for-of 循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。 这个生成器对象是可迭代的，所以完全可以在迭代中使用。 提前终止生成器与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next() 方法，还有一个可选的 return()方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：throw()。 123456function* generatorFn() &#123;&#125; const g = generatorFn(); console.log(g); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(g.next); // f next() &#123; [native code] &#125; console.log(g.return); // f return() &#123; [native code] &#125; console.log(g.throw); // f throw() &#123; [native code] &#125; return()和 throw()方法都可以用于强制生成器进入关闭状态。 return() return()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值： 123456789function* generatorFn() &#123; for (const x of [1, 2, 3]) &#123; yield x; &#125; &#125; const g = generatorFn(); console.log(g); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(g.return(4)); // &#123; done: true, value: 4 &#125; console.log(g); // generatorFn &#123;&lt;closed&gt;&#125; 与迭代器不同，所有生成器对象都有 return()方法，只要通过它进入关闭状态，就无法恢复了。 后续调用 next()会显示 done: true 状态，而提供的任何返回值都不会被存储或传播： 1234567891011function* generatorFn() &#123; for (const x of [1, 2, 3]) &#123; yield x; &#125; &#125; const g = generatorFn(); console.log(g.next()); // &#123; done: false, value: 1 &#125; console.log(g.return(4)); // &#123; done: true, value: 4 &#125; console.log(g.next()); // &#123; done: true, value: undefined &#125; console.log(g.next()); // &#123; done: true, value: undefined &#125; console.log(g.next()); // &#123; done: true, value: undefined &#125; for-of 循环等内置语言结构会忽略状态为 done: true 的 IteratorObject 内部返回的值。 1234567891011121314function* generatorFn() &#123; for (const x of [1, 2, 3]) &#123; yield x; &#125; &#125; const g = generatorFn(); for (const x of g) &#123; if (x &gt; 1) &#123; g.return(4); &#125; console.log(x); &#125; // 1 // 2 throw() throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭： 12345678910111213function* generatorFn() &#123; for (const x of [1, 2, 3]) &#123; yield x; &#125; &#125; const g = generatorFn(); console.log(g); // generatorFn &#123;&lt;suspended&gt;&#125; try &#123; g.throw(&#x27;foo&#x27;); &#125; catch (e) &#123; console.log(e); // foo &#125; console.log(g); // generatorFn &#123;&lt;closed&gt;&#125; 不过，假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，因此在这个例子中会跳过一个值。比如： 12345678910111213function* generatorFn() &#123; for (const x of [1, 2, 3]) &#123; try &#123; yield x; &#125; catch(e) &#123; &#125; &#125; &#125; const g = generatorFn(); console.log(g.next()); // &#123; done: false, value: 1&#125; g.throw(&#x27;foo&#x27;); console.log(g.next()); // &#123; done: false, value: 3&#125; 如果生成器对象还没有开始执行，那么调用 throw()抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。 小结迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现 Iterable 接口的对象都有一个 Symbol.iterator 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现 Iterator 接口的对象。 迭代器必须通过连续调用 next()方法才能连续取得值，这个方法返回一个 IteratorObject。这 个对象包含一个 done 属性和一个 value 属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用 next()方法来消费，也可以通过原生消费者，比如 for-of 循环来自动消费。 生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了 Iterable 接口， 因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 yield 关键字，这个关键字能够暂停执行生成器函数。使用 yield 关键字还可以通过 next()方法接收输入和产生输出。在加上星号之 后，&#96;yield 关键字可以将跟在它后面的可迭代对象序列化为一连串值。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(4)——集合引用类型","slug":"JS高级程序设计读书笔记(4)——集合引用类型","date":"2022-09-06T20:32:39.000Z","updated":"2023-11-27T15:34:23.881Z","comments":true,"path":"2022/09/07/JS高级程序设计读书笔记(4)——集合引用类型/","link":"","permalink":"http://pvnk1u.github.io/2022/09/07/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Object到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。 显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示： 123let person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29; 另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是 为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 person 对象，但使 用的是对象字面量表示法: 1234let person = &#123; name: &quot;Nicholas&quot;, age: 29 &#125;; 当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了： 123let person = &#123;&#125;; // 与 new Object()相同person.name = &quot;Nicholas&quot;; person.age = 29; 虽然使用哪种方式创建 Object 实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这 是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给 函数传递大量可选参数的主要方式，比如： 1234567891011121314151617function displayInfo(args) &#123; let output = &quot;&quot;; if (typeof args.name == &quot;string&quot;)&#123; output += &quot;Name: &quot; + args.name + &quot;\\n&quot;; &#125; if (typeof args.age == &quot;number&quot;) &#123; output += &quot;Age: &quot; + args.age + &quot;\\n&quot;; &#125; alert(output); &#125; displayInfo(&#123; name: &quot;Nicholas&quot;, age: 29 &#125;); displayInfo(&#123; name: &quot;Greg&quot; &#125;); 虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如： 12console.log(person[&quot;name&quot;]); // &quot;Nicholas&quot; console.log(person.name); // &quot;Nicholas&quot; 从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性， 就像下面这个例子中一样： 12let propertyName = &quot;name&quot;; console.log(person[propertyName]); // &quot;Nicholas&quot; 另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字&#x2F;保留字时，也可以使用中 括号语法。比如： 1person[&quot;first name&quot;] = &quot;Nicholas&quot;; 因为”first name”中包含一个空格，所以不能使用点语法来访问。不过，属性名中是可以包含非 字母数字字符的，这时候只要用中括号语法存取它们就行了。 Array除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。ECMAScript 数组跟其他编程语言 的数组有很大区别。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言 不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素 是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。 创建数组有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如： 1let colors = new Array(); 如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创 建并设置为这个值。比如，下面的代码会创建一个初始 length 为 20 的数组： 1let colors = new Array(20); 也可以给 Array 构造函数传入要保存的元素。比如，下面的代码会创建一个包含 3 个字符串值的 数组： 1let colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); 在使用 Array 构造函数时，也可以省略 new 操作符。结果是一样的。 另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以 逗号分隔的元素列表，如下面的例子所示： 123let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个元素的数组let names = []; // 创建一个空数组let values = [1,2,]; // 创建一个包含 2 个元素的数组 Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：from()和 of()。from()用于将 类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。 Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性 和可索引元素的结构。这种方式可用于很多场合： 12345678910111213141516171819202122232425262728293031323334353637383940// 字符串会被拆分为单字符数组console.log(Array.from(&quot;Matt&quot;)); // [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] // 可以使用 from()将集合和映射转换为一个新数组const m = new Map().set(1, 2) .set(3, 4); const s = new Set().add(1) .add(2) .add(3) .add(4); console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] // Array.from()对现有数组执行浅复制const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1); console.log(a1); // [1, 2, 3, 4] alert(a1 === a2); // false// 可以使用任何可迭代对象const iter = &#123; *[Symbol.iterator]() &#123; yield 1; yield 2; yield 3; yield 4; &#125; &#125;; console.log(Array.from(iter)); // [1, 2, 3, 4]// arguments 对象可以被轻松地转换为数组function getArgsArray() &#123; return Array.from(arguments); &#125; console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4] // from()也能转换带有必要属性的自定义对象const arrayLikeObject = &#123; 0: 1, 1: 2, 2: 3, 3: 4, length: 4 &#125;; console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4] Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像 调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函 数中 this 的值。但这个重写的 this 值在箭头函数中不适用。 12345const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1, x =&gt; x**2); const a3 = Array.from(a1, function(x) &#123;return x**this.exponent&#125;, &#123;exponent: 2&#125;); console.log(a2); // [1, 4, 9, 16] console.log(a3); // [1, 4, 9, 16] Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法： 12console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] console.log(Array.of(undefined)); // [undefined] 检测数组一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣： 123if (value instanceof Array)&#123; // 操作数组&#125; 使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两 个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。 为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是 否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子： 123if (Array.isArray(value))&#123; // 操作数组&#125; 迭代器方法在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和 entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回 索引&#x2F;值对的迭代器： 123456789const a = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]; // 因为这些方法都返回迭代器，所以可以将它们的内容// 通过 Array.from()直接转换为数组实例const aKeys = Array.from(a.keys()); const aValues = Array.from(a.values()); const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] console.log(aEntries); // [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]] 使用 ES6 的解构可以非常容易地在循环中拆分键&#x2F;值对： 12345678910111213const a = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]; for (const [idx, element] of a.entries()) &#123; alert(idx); alert(element); &#125; // 0 // foo // 1 // bar // 2 // baz // 3 // qux 复制和填充方法ES6 新增了两个方法：批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。 使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充 的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。 也可以将负索引想象成数组长度加上它得到的一个正索引： 1234567891011121314151617181920212223242526272829303132const zeroes = [0, 0, 0, 0, 0]; // 用 5 填充整个数组zeroes.fill(5); console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置// 用 6 填充索引大于等于 3 的元素zeroes.fill(6, 3); console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置// 用 7 填充索引大于等于 1 且小于 3 的元素zeroes.fill(7, 1, 3); console.log(zeroes); // [0, 7, 7, 0, 0]; zeroes.fill(0); // 重置// 用 8 填充索引大于等于 1 且小于 4 的元素// (-4 + zeroes.length = 1) // (-1 + zeroes.length = 4) zeroes.fill(8, -4, -1); console.log(zeroes); // [0, 8, 8, 8, 0]; fill()静默忽略超出数组边界、零长度及方向相反的索引范围：const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略zeroes.fill(1, -10, -6); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引过高，忽略zeroes.fill(1, 10, 15); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引反向，忽略zeroes.fill(2, 4, 2); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引部分可用，填充可用部分zeroes.fill(4, 3, 10) console.log(zeroes); // [0, 0, 0, 4, 4] 与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指 定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344let ints, reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置// 在源索引或目标索引到达数组边界时停止ints.copyWithin(5); console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] reset(); // 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置ints.copyWithin(0, 5); console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] reset(); // 从 ints 中复制索引 0 开始到索引 3 结束的内容// 插入到索引 4 开始的位置ints.copyWithin(4, 0, 3); alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] reset(); // JavaScript 引擎在插值前会完整复制范围内的值// 因此复制期间不存在重写的风险ints.copyWithin(2, 0, 6); alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] reset(); // 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的ints.copyWithin(-4, -7, -3); alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：let ints, reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引过低，忽略ints.copyWithin(1, -15, -12); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset() // 索引过高，忽略ints.copyWithin(1, 12, 15); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引反向，忽略ints.copyWithin(2, 4, 2); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引部分可用，复制、填充可用部分ints.copyWithin(4, 7, 10) alert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]; 转换方法前面提到过，所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf() 返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的 字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。来看下面的例子： 1234let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,green alert(colors.valueOf()); // red,blue,green alert(colors); // red,blue,green 首先是被显式调用的 toString()和 valueOf()方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。最后一行代码直接用 alert()显示数组，因为 alert()期待字符串，所以会在后台调用数组的 toString()方法，从而得到跟前面一样的结果。 toLocaleString()方法也可能返回跟toString()和 valueOf()相同的结果，但也不一定。在 调用数组的 toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法 唯一的区别是，为了得到最终的字符串，会调用数组每个值的 toLocaleString()方法，而不是 toString()方法。看下面的例子： 1234567891011121314151617181920let person1 = &#123; toLocaleString() &#123; return &quot;Nikolaos&quot;; &#125;, toString() &#123; return &quot;Nicholas&quot;; &#125; &#125;; let person2 = &#123; toLocaleString() &#123; return &quot;Grigorios&quot;; &#125;, toString() &#123; return &quot;Greg&quot;; &#125; &#125;; let people = [person1, person2]; alert(people); // Nicholas,Greg alert(people.toString()); // Nicholas,Greg alert(people.toLocaleString()); // Nikolaos,Grigorios 这里定义了两个对象 person1 和 person2，它们都定义了 toString()和 toLocaleString()方 法，而且返回不同的值。然后又创建了一个包含这两个对象的数组 people。在将数组传给 alert()时， 输出的是”Nicholas,Greg”，这是因为会在数组每一项上调用 toString()方法（与下一行显式调用 toString()方法结果一样）。而在调用数组的 toLocaleString()方法时，结果变成了”Nikolaos, Grigorios”，这是因为调用了数组每一项的 toLocaleString()方法。 继承的方法 toLocaleString()以及 toString()都返回数组值的逗号分隔的字符串。如果想使 用不同的分隔符，则可以使用 join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所 有项的字符串。来看下面的例子： 123let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; alert(colors.join(&quot;,&quot;)); // red,green,blue alert(colors.join(&quot;||&quot;)); // red||green||blue 这里在 colors 数组上调用了 join()方法，得到了与调用 toString()方法相同的结果。传入逗 号，结果就是逗号分隔的字符串。最后一行给 join() 传入了双竖线，得到了字符串 “red||green||blue”。如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符。 如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、 toString()和 valueOf()返回的结果中会以空字符串表示。 栈方法ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样， 也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就 是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个 地方发生，即栈顶。ECMAScript 数组提供了 push()和 pop()方法，以实现类似栈的行为。 push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则 用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子： 12345678let colors = new Array(); // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); // 2 count = colors.push(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.pop(); // 取得最后一项alert(item); // black alert(colors.length); // 2 队列方法就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式 限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push() 方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift()，它会删除数 组的第一项并返回它，然后数组长度减 1。使用 shift()和 push()，可以把数组当成队列来使用： 12345678let colors = new Array(); // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); // 2 count = colors.push(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.shift(); // 取得第一项alert(item); // red alert(colors.length); // 2 ECMAScript 也为数组提供了 unshift()方法。顾名思义，unshift()就是执行跟 shift()相反的 操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 unshift()和 pop()，可以在 相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示： 12345678let colors = new Array(); // 创建一个数组let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项alert(count); // 2 count = colors.unshift(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.pop(); // 取得最后一项alert(item); // green alert(colors.length); // 2 排序方法数组有两个方法可以用来对元素重新排序：reverse()和 sort()。顾名思义，reverse()方法就 是将数组元素反向排列。比如： 123let values = [1, 2, 3, 4, 5]; values.reverse(); alert(values); // 5,4,3,2,1 这里，数组 values 的初始状态为[1,2,3,4,5]。通过调用 reverse()反向排序，得到了 [5,4,3,2,1]。这个方法很直观，但不够灵活，所以才有了 sort()方法。 默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此， sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值， 也会先把数组转换为字符串再比较、排序。比如： 123let values = [0, 1, 5, 10, 15]; values.sort(); alert(values); // 0,1,10,15,5 一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此， 即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情 况下都不是最合适的。为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。 比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相 等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一 个例子： 123456789function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; 这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 sort()方法，如下所示: 123let values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); // 0,1,5,10,15 在给 sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也可以产生降序效果，只要把返回值交换一下即可： 123456789101112function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; let values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); // 15,10,5,1,0 此外，这个比较函数还可简写为一个箭头函数： 123let values = [0, 1, 5, 10, 15]; values.sort((a, b) =&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0); alert(values); // 15,10,5,1,0 reverse()和 sort()都返回调用它们的数组的引用。 如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函 数还可以写得更简单，因为这时可以直接用第二个值减去第一个值： 123function compare(value1, value2)&#123; return value2 - value1; &#125; 比较函数就是要返回小于 0、0 和大于 0 的数值，因此减法操作完全可以满足要求。 操作方法对于数组中的元素，有很多操作方法。比如，concat()方法可以在现有数组全部元素基础上 创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这 个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。 如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子： 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]); console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] 这里先创建一个包含 3个值的数组 colors。然后 colors 调用 concat()方法，传入字符串”yellow” 和一个包含”black”和”brown”的数组。保存在 colors2 中的结果就是[“red”, “green”, “blue”, “yellow”, “black”, “brown”]。原始数组 colors 保持不变。 打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平 类数组对象： 12345678910111213141516let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let newColors = [&quot;black&quot;, &quot;brown&quot;]; let moreNewColors = &#123; [Symbol.isConcatSpreadable]: true, length: 2, 0: &quot;pink&quot;, 1: &quot;cyan&quot; &#125;; newColors[Symbol.isConcatSpreadable] = false; // 强制不打平数组let colors2 = colors.concat(&quot;yellow&quot;, newColors); // 强制打平类数组对象let colors3 = colors.concat(moreNewColors); console.log(colors); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] console.log(colors3); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;] 接下来，方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以 接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 slice()会返回该索引 到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子： 12345let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]; let colors2 = colors.slice(1); let colors3 = colors.slice(1, 4); alert(colors2); // green,blue,yellow,purple alert(colors3); // green,blue,yellow 这里，colors 数组一开始有 5 个元素。调用 slice()传入 1 会得到包含 4 个元素的新数组。其中不包括”red”，这是因为拆分操作要从位置 1 开始，即从”green”开始。得到的 colors2 数组包含 “green”、”blue”、”yellow”和”purple”。colors3 数组是通过调用 slice()并传入 1 和 4 得到的， 即从位置 1 开始复制到位置 3。因此 colors3 包含”green”、”blue”和”yellow”。 如果 slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比 如，在包含 5 个元素的数组上调用 slice(-2,-1)，就相当于调用 slice(3,4)。如果结 束位置小于开始位置，则返回空数组。 或许最强大的数组方法就属 splice()了，使用它的方式可以有很多种。splice()的主要目的是 在数组中间插入元素，但有 3 种不同的方式使用这个方法。 删除 需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从 数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。 插入 需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多 个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串 “red”和”green”。 替换 splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位 置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量 一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始 向数组中插入”red”和”green”。 splice()方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返 回空数组）。以下示例展示了上述 3 种使用方式。 12345678910let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let removed = colors.splice(0,1); // 删除第一项alert(colors); // green,blue alert(removed); // red，只有一个元素的数组removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 在位置 1 插入两个元素alert(colors); // green,yellow,orange,blue alert(removed); // 空数组removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素alert(colors); // green,red,purple,orange,blue alert(removed); // yellow，只有一个元素的数组 搜索和位置方法ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。 严格相等 ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参 数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项） 开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。 indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。 includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一 项时，会使用全等（&#x3D;&#x3D;&#x3D;）比较，也就是说两项必须严格相等。下面来看一些例子： 1234567891011121314let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; alert(numbers.indexOf(4)); // 3 alert(numbers.lastIndexOf(4)); // 5 alert(numbers.includes(4)); // true alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.includes(4, 7)); // false let person = &#123; name: &quot;Nicholas&quot; &#125;; let people = [&#123; name: &quot;Nicholas&quot; &#125;]; let morePeople = [person]; alert(people.indexOf(person)); // -1 alert(morePeople.indexOf(person)); // 0 alert(people.includes(person)); // false alert(morePeople.includes(person)); // true 断言函数 ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回 值决定了相应索引的元素是否被认为匹配。 断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前 元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。 find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回 第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数， 用于指定断言函数内部 this 的值。 1234567891011121314const people = [ &#123; name: &quot;Matt&quot;, age: 27 &#125;, &#123; name: &quot;Nicholas&quot;, age: 29 &#125; ]; alert(people.find((element, index, array) =&gt; element.age &lt; 28)); // &#123;name: &quot;Matt&quot;, age: 27&#125; alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28)); // 0 找到匹配项后，这两个方法都不再继续搜索。 1234567891011121314const evens = [2, 4, 6]; // 找到匹配后，永远不会检查数组的最后一个元素evens.find((element, index, array) =&gt; &#123; console.log(element); console.log(index); console.log(array); return element === 4; &#125;); // 2 // 0 // [2, 4, 6] // 4 // 1 // [2, 4, 6] 迭代方法ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数， 以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影 响方法的返回值。数组的 5 个迭代方法如下。 every() 对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。 filter() 对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。 forEach() 对数组每一项都运行传入的函数，没有返回值。 map() 对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。 some() 对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。 这些方法都不改变调用它们的数组。 在这些方法中，every()和 some()是最相似的，都是从数组中搜索符合某个条件的元素。对 every() 来说，传入的函数必须对每一项都返回 true，它才会返回 true；否则，它就返回 false。而对 some() 来说，只要有一项让传入的函数返回 true，它就会返回 true。下面是一个例子： 12345let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2); alert(everyResult); // false let someResult = numbers.some((item, index, array) =&gt; item &gt; 2); alert(someResult); // true 下面再看一看 filter()方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码： 123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2); alert(filterResult); // 3,4,5,4,3 这里，调用 filter()返回的数组包含 3、4、5、4、3，因为只有对这些项传入的函数才返回 true。 这个方法非常适合从数组中筛选满足给定条件的元素。 接下来 map()方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传 入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示： 123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let mapResult = numbers.map((item, index, array) =&gt; item * 2); alert(mapResult); // 2,4,6,8,10,8,6,4,2 以上代码返回了一个数组，包含原始数组中每个值乘以 2 的结果。这个方法非常适合创建一个与原 始数组元素一一对应的新数组。 最后，再来看一看 forEach()方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，forEach()方法相当于使用 for 循环遍历数组。比如： 1234let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach((item, index, array) =&gt; &#123; // 执行某些操作 &#125;); 数组的这些迭代方法通过执行不同操作方便了对数组的处理。 归并方法ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。 而 reduceRight()从最后一项开始遍历至第一项。 这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。 传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数 组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法 传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数 的第一个参数是数组的第一项，第二个参数是数组的第二项。 可以使用 reduce()函数执行累加数组中所有数值的操作，比如： 123let values = [1, 2, 3, 4, 5]; let sum = values.reduce((prev, cur, index, array) =&gt; prev + cur); alert(sum); // 15 第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数 组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。 reduceRight()方法与之类似，只是方向相反。来看下面的例子： 12345let values = [1, 2, 3, 4, 5]; let sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); // 15 在这里，第一次调用归并函数时 prev 是 5，而 cur 是 4。当然，最终结果相同，因为归并操作都是简单的加法。 定型数组定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。为理解如何使 用定型数组，有必要先了解一下它的用途。 由来随着浏览器的流行，不难想象人们会满怀期待地通过它来运行复杂的 3D 应用程序。早在 2006 年， Mozilla、Opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台， 无须安装任何插件。其目标是开发一套 JavaScript API，从而充分利用 3D 图形 API 和 GPU 加速，以便 在元素上渲染复杂的图形。 WebGL 最后的 JavaScript API 是基于 OpenGL ES（OpenGL for Embedded Systems）2.0 规范的。OpenGL ES 是 OpenGL 专注于 2D 和 3D 计算机图形的子集。这个新 API 被命名为 WebGL（Web Graphics Library）， 于 2011 年发布 1.0 版。有了它，开发者就能够编写涉及复杂图形的应用程序，它会被兼容 WebGL 的浏 览器原生解释执行。 在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形 驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript 数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 绑定都需要在 目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费 很多时间。 定型数组 这当然是难以接受的，Mozilla 为解决这个问题而实现了 CanvasFloatArray。这是一个提供 JavaScript 接口的、C 语言风格的浮点值数组。JavaScript 运行时使用这个类型可以分配、读取和写入数组。 这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。最终，CanvasFloatArray 变成了 Float32Array，也就是今天定型数组中可用的第一个“类型”。 ArrayBufferFloat32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的 预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。 ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。 12const buf = new ArrayBuffer(16); // 在内存中分配 16 字节alert(buf.byteLength); // 16 ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新实例中： 123const buf1 = new ArrayBuffer(16); const buf2 = buf1.slice(4, 12); alert(buf2.byteLength); // 8 ArrayBuffer 某种程度上类似于 C++的 malloc()，但也有几个明显的区别。 malloc()在分配失败时会返回一个 null 指针。ArrayBuffer 在分配失败时会抛出错误。 malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer 分配的内存不能超过 Number.MAX_SAFE_INTEGER（253  1）字节。 malloc()调用成功不会初始化实际的地址。声明 ArrayBuffer 则会将所有二进制位初始化 为 0 通过 malloc()分配的堆内存除非调用 free()或程序退出，否则系统不能再使用。而通过声明 ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。 不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须 通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。 DataView第一种允许读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I&#x2F;O 和网络 I&#x2F;O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。 必须在对已有的ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或 部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。 1234567891011121314151617181920const buf = new ArrayBuffer(16); // DataView 默认使用整个 ArrayBuffer const fullDataView = new DataView(buf); alert(fullDataView.byteOffset); // 0 alert(fullDataView.byteLength); // 16 alert(fullDataView.buffer === buf); // true // 构造函数接收一个可选的字节偏移量和字节长度// byteOffset=0 表示视图从缓冲起点开始// byteLength=8 限制视图为前 8 个字节const firstHalfDataView = new DataView(buf, 0, 8); alert(firstHalfDataView.byteOffset); // 0 alert(firstHalfDataView.byteLength); // 8 alert(firstHalfDataView.buffer === buf); // true // 如果不指定，则 DataView 会使用剩余的缓冲// byteOffset=8 表示视图从缓冲的第 9 个字节开始// byteLength 未指定，默认为剩余缓冲const secondHalfDataView = new DataView(buf, 8); alert(secondHalfDataView.byteOffset); // 8 alert(secondHalfDataView.byteLength); // 8 alert(secondHalfDataView.buffer === buf); // true 要通过 DataView 读取缓冲，还需要几个组件。 首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。 DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。 最后是内存中值的字节序。默认为大端字节序。 ElementType DataView 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个 ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换。 ECMAScript 6 支持 8 种不同的 ElementType（见下表）。 ElementType 字节 说明 等价的C类型 值的范围 Int8 1 8位有符号整数 signed char -128-127 Uint8 1 8位无符号整数 unsigned char 0-255 Int16 2 16位有符号整数 short -32768-32767 Uint16 2 16位无符号整数 unsigned short 0-65535 Int32 4 32位有符号整数 int -2147483648-147483647 Uint32 4 32位无符号整数 unsigned int 0-4294967295 Float32 4 32位IEEE-754浮点数 float -3.4e+38-+3.4e+38 Float64 8 64位IEEE-754浮点数 double -1.7e+308-+1.7e+308 DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移 量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示： 123456789101112131415161718// 在内存中分配两个字节并声明一个 DataView const buf = new ArrayBuffer(2); const view = new DataView(buf); // 说明整个缓冲确实所有二进制位都是 0 // 检查第一个和第二个字符alert(view.getInt8(0)); // 0 alert(view.getInt8(1)); // 0 // 检查整个缓冲alert(view.getInt16(0)); // 0 // 将整个缓冲都设置为 1 // 255 的二进制表示是 11111111（2^8 - 1）view.setUint8(0, 255); // DataView 会自动将数据转换为特定的 ElementType // 255 的十六进制表示是 0xFF view.setUint8(1, 0xFF); // 现在，缓冲里都是 1 了// 如果把它当成二补数的有符号整数，则应该是-1 alert(view.getInt16(0)); // -1 字节序 前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约 定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。 JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这 个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所 有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。 12345678910111213141516171819202122232425262728293031// 在内存中分配两个字节并声明一个 DataView const buf = new ArrayBuffer(2); const view = new DataView(buf); // 填充缓冲，让第一位和最后一位都是 1 view.setUint8(0, 0x80); // 设置最左边的位等于 1 view.setUint8(1, 0x01); // 设置最右边的位等于 1 // 缓冲内容（为方便阅读，人为加了空格）// 0x8 0x0 0x0 0x1 // 1000 0000 0000 0001 // 按大端字节序读取 Uint16 // 0x80 是高字节，0x01 是低字节// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769 alert(view.getUint16(0)); // 32769 // 按小端字节序读取 Uint16 // 0x01 是高字节，0x80 是低字节// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384 alert(view.getUint16(0, true)); // 384 // 按大端字节序写入 Uint16 view.setUint16(0, 0x0004); // 缓冲内容（为方便阅读，人为加了空格）// 0x0 0x0 0x0 0x4 // 0000 0000 0000 0100 alert(view.getUint8(0)); // 0 alert(view.getUint8(1)); // 4 // 按小端字节序写入 Uint16 view.setUint16(0, 0x0002, true); // 缓冲内容（为方便阅读，人为加了空格）// 0x0 0x2 0x0 0x0 // 0000 0010 0000 0000 alert(view.getUint8(0)); // 2 alert(view.getUint8(1)); // 0 边界情形 DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError： 1234567891011121314const buf = new ArrayBuffer(6); const view = new DataView(buf); // 尝试读取部分超出缓冲范围的值view.getInt32(4); // RangeError // 尝试读取超出缓冲范围的值view.getInt32(8); // RangeError // 尝试读取超出缓冲范围的值view.getInt32(-1); // RangeError // 尝试写入超出缓冲范围的值view.setInt32(4, 123); // RangeError DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则 抛出错误： 12345678910const buf = new ArrayBuffer(1); const view = new DataView(buf); view.setInt8(0, 1.5); alert(view.getInt8(0)); // 1 view.setInt8(0, [4]); alert(view.getInt8(0)); // 4 view.setInt8(0, &#x27;f&#x27;); alert(view.getInt8(0)); // 0 view.setInt8(0, Symbol()); // TypeError 定型数组 定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别 在于，它特定于一种 ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的 API 和更高的性能。设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定 型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、 按位运算和其他对定型数组的常见操作，因此使用它们速度极快。 创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类 型的定型数组。另外，通过.from()和.of()也可以创建定型数组： 1234567891011121314151617181920212223242526272829303132333435// 创建一个 12 字节的缓冲const buf = new ArrayBuffer(12); // 创建一个引用该缓冲的 Int32Array const ints = new Int32Array(buf); // 这个定型数组知道自己的每个元素需要 4 字节// 因此长度为 3 alert(ints.length); // 3 // 创建一个长度为 6 的 Int32Array const ints2 = new Int32Array(6); // 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节alert(ints2.length); // 6 // 类似 DataView，定型数组也有一个指向关联缓冲的引用alert(ints2.buffer.byteLength); // 24 // 创建一个包含[2, 4, 6, 8]的 Int32Array const ints3 = new Int32Array([2, 4, 6, 8]); alert(ints3.length); // 4 alert(ints3.buffer.byteLength); // 16 alert(ints3[2]); // 6 // 通过复制 ints3 的值创建一个 Int16Array const ints4 = new Int16Array(ints3); // 这个新类型数组会分配自己的缓冲// 对应索引的每个值会相应地转换为新格式alert(ints4.length); // 4 alert(ints4.buffer.byteLength); // 8 alert(ints4[2]); // 6 // 基于普通数组来创建一个 Int16Array const ints5 = Int16Array.from([3, 5, 7, 9]); alert(ints5.length); // 4 alert(ints5.buffer.byteLength); // 8 alert(ints5[2]); // 7 // 基于传入的参数创建一个 Float32Array const floats = Float32Array.of(3.14, 2.718, 1.618); alert(floats.length); // 3 alert(floats.buffer.byteLength); // 12 alert(floats[2]); // 1.6180000305175781 定型数组的构造函数和实例都有一个 BYTES_PER_ELEMENT 属性，返回该类型数组中每个元素的大小： 123456alert(Int16Array.BYTES_PER_ELEMENT); // 2 alert(Int32Array.BYTES_PER_ELEMENT); // 4 const ints = new Int32Array(1), floats = new Float64Array(1); alert(ints.BYTES_PER_ELEMENT); // 4 alert(floats.BYTES_PER_ELEMENT); // 8 如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充： 12345const ints = new Int32Array(4); alert(ints[0]); // 0 alert(ints[1]); // 0 alert(ints[2]); // 0 alert(ints[3]); // 0 定型数组行为 从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性： [] copyWithin() entries() every() fill() filter() find() findIndex() forEach() indexOf() join() keys() lastIndexOf() length map() reduce() reduceRight() reverse() slice() some() sort() toLocaleString() toString() values() 其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组： 123const ints = new Int16Array([1, 2, 3]); const doubleints = ints.map(x =&gt; 2*x); alert(doubleints instanceof Int16Array); // true 定型数组有一个 Symbol.iterator 符号属性，因此可以通过 for..of 循环和扩展操作符来操作： 12345678const ints = new Int16Array([1, 2, 3]); for (const int of ints) &#123; alert(int); &#125; // 1 // 2 // 3 alert(Math.max(...ints)); // 3 定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组： concat() pop() push() shift() splice() unshift() 不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：set()和 subarray()。 set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置： 12345678910111213// 创建长度为 8 的 int16 数组const container = new Int16Array(8); // 把定型数组复制为前 4 个值// 偏移量默认为索引 0 container.set(Int8Array.of(1, 2, 3, 4)); console.log(container); // [1,2,3,4,0,0,0,0] // 把普通数组复制为后 4 个值// 偏移量 4 表示从索引 4 开始插入container.set([5,6,7,8], 4); console.log(container); // [1,2,3,4,5,6,7,8] // 溢出会抛出错误container.set([5,6,7,8], 7); // RangeError subarray()执行与 set()相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。 复制值时的开始索引和结束索引是可选的： 12345678910const source = Int16Array.of(2, 4, 6, 8); // 把整个数组复制为一个同类型的新数组const fullCopy = source.subarray(); console.log(fullCopy); // [2, 4, 6, 8] // 从索引 2 开始复制数组const halfCopy = source.subarray(2); console.log(halfCopy); // [6, 8] // 从索引 1 开始复制到索引 3 const partialCopy = source.subarray(1, 3); console.log(partialCopy); // [4, 6] 下溢与上溢 定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了 如何处理下溢和上溢： 123456789101112131415161718192021222324252627// 长度为 2 的有符号整数数组// 每个索引保存一个二补数形式的有符号整数// 范围是-128（-1 * 2^7）~127（2^7 - 1）const ints = new Int8Array(2); // 长度为 2 的无符号整数数组// 每个索引保存一个无符号整数// 范围是 0~255（2^7 - 1）const unsignedInts = new Uint8Array(2); // 上溢的位不会影响相邻索引// 索引只取最低有效位上的 8 位unsignedInts[1] = 256; // 0x100 console.log(unsignedInts); // [0, 0] unsignedInts[1] = 511; // 0x1FF console.log(unsignedInts); // [0, 255] // 下溢的位会被转换为其无符号的等价值// 0xFF 是以二补数形式表示的-1（截取到 8 位）, // 但 255 是一个无符号整数unsignedInts[1] = -1 // 0xFF (truncated to 8 bits) console.log(unsignedInts); // [0, 255] // 上溢自动变成二补数形式// 0x80 是无符号整数的 128，是二补数形式的-128 ints[1] = 128; // 0x80 console.log(ints); // [0, -128] // 下溢自动变成二补数形式// 0xFF 是无符号整数的 255，是二补数形式的-1 ints[1] = 255; // 0xFF console.log(ints); // [0, -1] 除了 8 种元素类型，还有一种“夹板”数组类型：Uint8ClampedArray，不允许任何方向溢出。 超出最大值 255 的值会被向下舍入为 255，而小于最小值 0 的值会被向上舍入为 0。 MapECMAScript 6 以前，在 JavaScript 中实现“键&#x2F;值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此 TC39 委员会专门为 “键&#x2F;值”存储定义了一个规范。 作为 ECMAScript 6 的新增特性，Map 是一种新的集合类型，为这门语言带来了真正的键&#x2F;值存储机 制。Map 的大多数特性都可以通过 Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。 基本API使用 new 关键字和 Map 构造函数可以创建一个空映射： 1const m = new Map(); 如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键&#x2F;值对数 组。可迭代对象中的每个键&#x2F;值对都会按照迭代顺序插入到新映射实例中： 1234567891011121314151617181920// 使用嵌套数组初始化映射const m1 = new Map([ [&quot;key1&quot;, &quot;val1&quot;], [&quot;key2&quot;, &quot;val2&quot;], [&quot;key3&quot;, &quot;val3&quot;] ]); alert(m1.size); // 3 // 使用自定义迭代器初始化映射const m2 = new Map(&#123; [Symbol.iterator]: function*() &#123; yield [&quot;key1&quot;, &quot;val1&quot;]; yield [&quot;key2&quot;, &quot;val2&quot;]; yield [&quot;key3&quot;, &quot;val3&quot;]; &#125; &#125;); alert(m2.size); // 3 // 映射期待的键/值对，无论是否提供const m3 = new Map([[]]); alert(m3.has(undefined)); // true alert(m3.get(undefined)); // undefined 初始化之后，可以使用 set()方法再添加键&#x2F;值对。另外，可以使用 get()和 has()进行查询，可 以通过size 属性获取映射中的键&#x2F;值对的数量，还可以使用 delete()和 clear()删除值。 1234567891011121314151617const m = new Map(); alert(m.has(&quot;firstName&quot;)); // false alert(m.get(&quot;firstName&quot;)); // undefined alert(m.size); // 0 m.set(&quot;firstName&quot;, &quot;Matt&quot;) .set(&quot;lastName&quot;, &quot;Frisbie&quot;); alert(m.has(&quot;firstName&quot;)); // true alert(m.get(&quot;firstName&quot;)); // Matt alert(m.size); // 2 m.delete(&quot;firstName&quot;); // 只删除这一个键/值对alert(m.has(&quot;firstName&quot;)); // false alert(m.has(&quot;lastName&quot;)); // true alert(m.size); // 1 m.clear(); // 清除这个映射实例中的所有键/值对alert(m.has(&quot;firstName&quot;)); // false alert(m.has(&quot;lastName&quot;)); // false alert(m.size); // 0 set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明： 1234const m = new Map().set(&quot;key1&quot;, &quot;val1&quot;); m.set(&quot;key2&quot;, &quot;val2&quot;) .set(&quot;key3&quot;, &quot;val3&quot;); alert(m.size); // 3 与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为 键。Map 内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与 Object 类似，映射的值是没有限制的。 123456789101112const m = new Map(); const functionKey = function() &#123;&#125;; const symbolKey = Symbol(); const objectKey = new Object(); m.set(functionKey, &quot;functionValue&quot;); m.set(symbolKey, &quot;symbolValue&quot;); m.set(objectKey, &quot;objectValue&quot;); alert(m.get(functionKey)); // functionValue alert(m.get(symbolKey)); // symbolValue alert(m.get(objectKey)); // objectValue // SameValueZero 比较意味着独立实例不冲突alert(m.get(function() &#123;&#125;)); // undefined 与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变： 12345678910111213const m = new Map(); const objKey = &#123;&#125;, objVal = &#123;&#125;, arrKey = [], arrVal = []; m.set(objKey, objVal); m.set(arrKey, arrVal); objKey.foo = &quot;foo&quot;; objVal.bar = &quot;bar&quot;; arrKey.push(&quot;foo&quot;); arrVal.push(&quot;bar&quot;); console.log(m.get(objKey)); // &#123;bar: &quot;bar&quot;&#125; console.log(m.get(arrKey)); // [&quot;bar&quot;] SameValueZero比较也可能导致意想不到的冲突： 1234567891011const m = new Map(); const a = 0/&quot;&quot;, // NaN b = 0/&quot;&quot;, // NaN pz = +0, nz = -0; alert(a === b); // false alert(pz === nz); // true m.set(a, &quot;foo&quot;); m.set(pz, &quot;bar&quot;); alert(m.get(b)); // foo alert(m.get(nz)); // bar 顺序与迭代与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。 映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以 通过 entries()方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器： 123456789101112131415161718const m = new Map([ [&quot;key1&quot;, &quot;val1&quot;], [&quot;key2&quot;, &quot;val2&quot;], [&quot;key3&quot;, &quot;val3&quot;] ]); alert(m.entries === m[Symbol.iterator]); // true for (let pair of m.entries()) &#123; alert(pair); &#125; // [key1,val1] // [key2,val2] // [key3,val3] for (let pair of m[Symbol.iterator]()) &#123; alert(pair); &#125; // [key1,val1] // [key2,val2] // [key3,val3] 因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组： 123456const m = new Map([ [&quot;key1&quot;, &quot;val1&quot;], [&quot;key2&quot;, &quot;val2&quot;], [&quot;key3&quot;, &quot;val3&quot;] ]); console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]] 如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg) 方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调 内部this 的值： 123456789const m = new Map([ [&quot;key1&quot;, &quot;val1&quot;], [&quot;key2&quot;, &quot;val2&quot;], [&quot;key3&quot;, &quot;val3&quot;] ]); m.forEach((val, key) =&gt; alert(`$&#123;key&#125; -&gt; $&#123;val&#125;`)); // key1 -&gt; val1 // key2 -&gt; val2 // key3 -&gt; val3 keys()和 values()分别返回以插入顺序生成键和值的迭代器： 1234567891011121314151617const m = new Map([ [&quot;key1&quot;, &quot;val1&quot;], [&quot;key2&quot;, &quot;val2&quot;], [&quot;key3&quot;, &quot;val3&quot;] ]); for (let key of m.keys()) &#123; alert(key); &#125; // key1 // key2 // key3 for (let key of m.values()) &#123; alert(key); &#125; // value1 // value2 // value3 键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份： 1234567891011121314151617181920const m1 = new Map([ [&quot;key1&quot;, &quot;val1&quot;] ]); // 作为键的字符串原始值是不能修改的for (let key of m1.keys()) &#123; key = &quot;newKey&quot;; alert(key); // newKey alert(m1.get(&quot;key1&quot;)); // val1 &#125; const keyObj = &#123;id: 1&#125;; const m = new Map([ [keyObj, &quot;val1&quot;] ]); // 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值for (let key of m.keys()) &#123; key.id = &quot;newKey&quot;; alert(key); // &#123;id: &quot;newKey&quot;&#125; alert(m.get(keyObj)); // val1 &#125; alert(keyObj); // &#123;id: &quot;newKey&quot;&#125; 选择 Object 还是 Map对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。 内存占用 Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键&#x2F;值对所占用的内存数量 都会随键的数量线性增加。批量添加或删除键&#x2F;值对则取决于各浏览器对该类型内存分配的工程实现。 不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键&#x2F;值对。 插入性能 向 Object 和 Map 中插入新键&#x2F;值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快 一点儿。对这两个类型来说，插入速度并不会随着键&#x2F;值对数量而线性增加。如果代码涉及大量插入操 作，那么显然 Map 的性能更佳。 查找速度 与插入不同，从大型 Object 和 Map 中查找键&#x2F;值对的性能差异极小，但如果只包含少量键&#x2F;值对， 则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言， 查找速度不会随着键&#x2F;值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选 择 Object 更好一些。 删除性能 使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此， 出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一 种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。 如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。 WeakMapECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键&#x2F; 值对存储机制。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱）， 描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。 基本API可以使用 new 关键字实例化一个空的 WeakMap： 1const wm = new WeakMap(); 弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出 TypeError。值的类型没有限制。 如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键&#x2F;值对数组。 可迭代对象中的每个键&#x2F;值都会按照迭代顺序插入新实例中： 12345678910111213141516171819202122232425262728const key1 = &#123;id: 1&#125;, key2 = &#123;id: 2&#125;, key3 = &#123;id: 3&#125;; // 使用嵌套数组初始化弱映射const wm1 = new WeakMap([ [key1, &quot;val1&quot;], [key2, &quot;val2&quot;], [key3, &quot;val3&quot;] ]); alert(wm1.get(key1)); // val1 alert(wm1.get(key2)); // val2 alert(wm1.get(key3)); // val3 // 初始化是全有或全无的操作// 只要有一个键无效就会抛出错误，导致整个初始化失败const wm2 = new WeakMap([ [key1, &quot;val1&quot;], [&quot;BADKEY&quot;, &quot;val2&quot;], [key3, &quot;val3&quot;] ]); // TypeError: Invalid value used as WeakMap key typeof wm2; // ReferenceError: wm2 is not defined // 原始值可以先包装成对象再用作键const stringKey = new String(&quot;key1&quot;); const wm3 = new WeakMap([ stringKey, &quot;val1&quot; ]); alert(wm3.get(stringKey)); // &quot;val1&quot; 初始化之后可以使用 set()再添加键&#x2F;值对，可以使用 get()和 has()查询，还可以使用 delete() 删除： 123456789101112const wm = new WeakMap(); const key1 = &#123;id: 1&#125;, key2 = &#123;id: 2&#125;; alert(wm.has(key1)); // false alert(wm.get(key1)); // undefined wm.set(key1, &quot;Matt&quot;) .set(key2, &quot;Frisbie&quot;); alert(wm.has(key1)); // true alert(wm.get(key1)); // Matt wm.delete(key1); // 只删除这一个键/值对alert(wm.has(key1)); // false alert(wm.has(key2)); // true set()方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明： 123456789const key1 = &#123;id: 1&#125;, key2 = &#123;id: 2&#125;, key3 = &#123;id: 3&#125;; const wm = new WeakMap().set(key1, &quot;val1&quot;); wm.set(key2, &quot;val2&quot;) .set(key3, &quot;val3&quot;); alert(wm.get(key1)); // val1 alert(wm.get(key2)); // val2 alert(wm.get(key3)); // val3 弱键WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用， 不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键&#x2F;值 对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。 来看下面的例子： 12const wm = new WeakMap(); wm.set(&#123;&#125;, &quot;val&quot;); set()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用， 所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键&#x2F;值对就从弱映射中消失 了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键&#x2F;值被破坏以后，值本身 也会成为垃圾回收的目标。 再看一个稍微不同的例子： 12345678const wm = new WeakMap(); const container = &#123; key: &#123;&#125; &#125;; wm.set(container.key, &quot;val&quot;); function removeReference() &#123; container.key = null; &#125; 这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目 标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以 把这个键&#x2F;值对清理掉。 不可迭代键因为 WeakMap 中的键&#x2F;值对任何时候都可能被销毁，所以没必要提供迭代其键&#x2F;值对的能力。当然， 也用不着像 clear()这样一次性销毁所有键&#x2F;值的方法。WeakMap 确实没有这个方法。因为不可能迭代， 所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问 WeakMap 实例，也没办法看到其中的内容。 WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。 使用弱映射WeakMap 实例与现有 JavaScript 对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相关策略。 私有变量 弱映射造就了在JavaScript中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。 下面是一个示例实现： 123456789101112131415161718192021222324252627const wm = new WeakMap(); class User &#123; constructor(id) &#123; this.idProperty = Symbol(&#x27;id&#x27;); this.setId(id); &#125; setPrivate(property, value) &#123; const privateMembers = wm.get(this) || &#123;&#125;; privateMembers[property] = value; wm.set(this, privateMembers); &#125; getPrivate(property) &#123; return wm.get(this)[property]; &#125; setId(id) &#123; this.setPrivate(this.idProperty, id); &#125; getId() &#123; return this.getPrivate(this.idProperty); &#125; &#125; const user = new User(123); alert(user.getId()); // 123 user.setId(456); alert(user.getId()); // 456// 并不是真正私有的alert(wm.get(user)[user.idProperty]); // 456 慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以 取得“私有”变量了。为了避免这种访问，可以用一个闭包把 WeakMap 包装起来，这样就可以把弱映射与外界完全隔离开了： 12345678910111213141516171819202122232425262728const User = (() =&gt; &#123; const wm = new WeakMap(); class User &#123; constructor(id) &#123; this.idProperty = Symbol(&#x27;id&#x27;); this.setId(id); &#125; setPrivate(property, value) &#123; const privateMembers = wm.get(this) || &#123;&#125;; privateMembers[property] = value; wm.set(this, privateMembers); &#125; getPrivate(property) &#123; return wm.get(this)[property]; &#125; setId(id) &#123; this.setPrivate(this.idProperty, id); &#125; getId(id) &#123; return this.getPrivate(this.idProperty); &#125; &#125; return User; &#125;)(); const user = new User(123); alert(user.getId()); // 123 user.setId(456); alert(user.getId()); // 456 这样，拿不到弱映射中的键，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但 整个代码也完全陷入了 ES6 之前的闭包私有变量模式。 因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中 使用了常规的 Map： 1234const m = new Map(); const loginButton = document.querySelector(&#x27;#login&#x27;); // 给这个节点关联一些元数据m.set(loginButton, &#123;disabled: true&#125;); 假设在上面的代码执行后，页面被 JavaScript 改变了，原来的登录按钮从 DOM 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍然会逗留在内存中，除非明确将其从映射中 删除或者等到映射本身被销毁。 如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）： 1234const wm = new WeakMap(); const loginButton = document.querySelector(&#x27;#login&#x27;); // 给这个节点关联一些元数据wm.set(loginButton, &#123;disabled: true&#125;); SetECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构。Set 在很多方面都像是加强的 Map，这是因为它们的大多数 API 和行为都是共有的。 基本API使用 new 关键字和 Set 构造函数可以创建一个空集合： 1const m = new Set(); 如果想在创建的同时初始化实例，则可以给 Set 构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素： 123456789101112// 使用数组初始化集合 const s1 = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); alert(s1.size); // 3 // 使用自定义迭代器初始化集合const s2 = new Set(&#123; [Symbol.iterator]: function*() &#123; yield &quot;val1&quot;; yield &quot;val2&quot;; yield &quot;val3&quot;; &#125; &#125;); alert(s2.size); // 3 初始化之后，可以使用 add()增加值，使用 has()查询，通过 size 取得元素数量，以及使用 delete() 和 clear()删除元素： 123456789101112131415const s = new Set(); alert(s.has(&quot;Matt&quot;)); // false alert(s.size); // 0 s.add(&quot;Matt&quot;) .add(&quot;Frisbie&quot;); alert(s.has(&quot;Matt&quot;)); // true alert(s.size); // 2 s.delete(&quot;Matt&quot;); alert(s.has(&quot;Matt&quot;)); // false alert(s.has(&quot;Frisbie&quot;)); // true alert(s.size); // 1 s.clear(); // 销毁集合实例中的所有值alert(s.has(&quot;Matt&quot;)); // false alert(s.has(&quot;Frisbie&quot;)); // false alert(s.size); // 0 add()返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化： 1234const s = new Set().add(&quot;val1&quot;); s.add(&quot;val2&quot;) .add(&quot;val3&quot;); alert(s.size); // 3 与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作 （ECMAScript 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。 123456789101112const s = new Set(); const functionVal = function() &#123;&#125;; const symbolVal = Symbol(); const objectVal = new Object(); s.add(functionVal); s.add(symbolVal); s.add(objectVal); alert(s.has(functionVal)); // true alert(s.has(symbolVal)); // true alert(s.has(objectVal)); // true // SameValueZero 检查意味着独立的实例不会冲突alert(s.has(function() &#123;&#125;)); // false 与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变： 123456789const s = new Set(); const objVal = &#123;&#125;, arrVal = []; s.add(objVal); s.add(arrVal); objVal.bar = &quot;bar&quot;; arrVal.push(&quot;bar&quot;); alert(s.has(objVal)); // true alert(s.has(arrVal)); // true add()和 delete()操作是幂等的。delete()返回一个布尔值，表示集合中是否存在要删除的值： 123456789const s = new Set(); s.add(&#x27;foo&#x27;); alert(s.size); // 1 s.add(&#x27;foo&#x27;); alert(s.size); // 1 // 集合里有这个值alert(s.delete(&#x27;foo&#x27;)); // true // 集合里没有这个值alert(s.delete(&#x27;foo&#x27;)); // false 顺序与迭代Set 会维护值插入时的顺序，因此支持按顺序迭代。 集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器： 123456789101112131415const s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); alert(s.values === s[Symbol.iterator]); // true alert(s.keys === s[Symbol.iterator]); // true for (let value of s.values()) &#123; alert(value); &#125; // val1 // val2 // val3 for (let value of s[Symbol.iterator]()) &#123; alert(value); &#125; // val1 // val2 // val3 因为 values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组： 12const s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); console.log([...s]); // [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;] 集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现： 1234567const s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); for (let pair of s.entries()) &#123; console.log(pair); &#125; // [&quot;val1&quot;, &quot;val1&quot;] // [&quot;val2&quot;, &quot;val2&quot;] // [&quot;val3&quot;, &quot;val3&quot;] 如果不使用迭代器，而是使用回调方式，则可以调用集合的 forEach()方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this的值： 12345const s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); s.forEach((val, dupVal) =&gt; alert(`$&#123;val&#125; -&gt; $&#123;dupVal&#125;`)); // val1 -&gt; val1 // val2 -&gt; val2 // val3 -&gt; val3 修改集合中值的属性不会影响其作为集合值的身份： 12345678910111213141516const s1 = new Set([&quot;val1&quot;]); // 字符串原始值作为值不会被修改for (let value of s1.values()) &#123; value = &quot;newVal&quot;; alert(value); // newVal alert(s1.has(&quot;val1&quot;)); // true &#125; const valObj = &#123;id: 1&#125;; const s2 = new Set([valObj]); // 修改值对象的属性，但对象仍然存在于集合中for (let value of s2.values()) &#123; value.id = &quot;newVal&quot;; alert(value); // &#123;id: &quot;newVal&quot;&#125; alert(s2.has(valObj)); // true &#125; alert(valObj); // &#123;id: &quot;newVal&quot;&#125; 定义正式集合操作从各方面来看，Set 跟 Map 都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API对自 身的简单操作。很多开发者都喜欢使用 Set 操作，但需要手动实现：或者是子类化 Set，或者是定义一 个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态 方法。在实现这些操作时，需要考虑几个地方。 某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。 Set 保留插入顺序，所有方法返回的集合必须保证顺序。 尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能 够节省对象初始化成本。 不要修改已有的集合实例。union(a, b)或 a.union(b)应该返回包含结果的新集合实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class XSet extends Set &#123; union(...sets) &#123; return XSet.union(this, ...sets) &#125; intersection(...sets) &#123; return XSet.intersection(this, ...sets); &#125; difference(set) &#123; return XSet.difference(this, set); &#125; symmetricDifference(set) &#123; return XSet.symmetricDifference(this, set); &#125; cartesianProduct(set) &#123; return XSet.cartesianProduct(this, set); &#125; powerSet() &#123; return XSet.powerSet(this); &#125; // 返回两个或更多集合的并集 static union(a, ...bSets) &#123; const unionSet = new XSet(a); for (const b of bSets) &#123; for (const bValue of b) &#123; unionSet.add(bValue); &#125; &#125; return unionSet; &#125; // 返回两个或更多集合的交集 static intersection(a, ...bSets) &#123; const intersectionSet = new XSet(a); for (const aValue of intersectionSet) &#123; for (const b of bSets) &#123; if (!b.has(aValue)) &#123; intersectionSet.delete(aValue); &#125; &#125; &#125; return intersectionSet; &#125; // 返回两个集合的差集 static difference(a, b) &#123; const differenceSet = new XSet(a); for (const bValue of b) &#123; if (a.has(bValue)) &#123; differenceSet.delete(bValue); &#125; &#125; return differenceSet; &#125; // 返回两个集合的对称差集 static symmetricDifference(a, b) &#123; // 按照定义，对称差集可以表达为 return a.union(b).difference(a.intersection(b)); &#125; // 返回两个集合（数组对形式）的笛卡儿积 // 必须返回数组集合，因为笛卡儿积可能包含相同值的对 static cartesianProduct(a, b) &#123; const cartesianProductSet = new XSet(); for (const aValue of a) &#123; for (const bValue of b) &#123; cartesianProductSet.add([aValue, bValue]); &#125; &#125; return cartesianProductSet; &#125; // 返回一个集合的幂集 static powerSet(a) &#123; const powerSet = new XSet().add(new XSet()); for (const aValue of a) &#123; for (const set of new XSet(powerSet)) &#123; powerSet.add(new XSet(set).add(aValue)); &#125; &#125; return powerSet; &#125; &#125; WeakSetES6新增的“弱集合”（WeakSet）是一种新的集合类型，为这门语言带来了集合数据结构。WeakSet是Set的“兄弟”类型，其API也是Set的子集。WeakSet中的“weak”，描述的是JavaScript垃圾回收程序对待“弱集合”中值的方式。 基本API可以使用new关键字实例化一个空的WeakSet： 1const ws = new WeakSet(); 弱集合中的值只能是Object或者继承自Object的类型，尝试使用非对象设置值会抛出TypeError。 如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中： 123456789101112131415161718const val1 = &#123;id: 1&#125;, val2 = &#123;id: 2&#125;, val3 = &#123;id: 3&#125;; // 使用数组初始化弱集合const ws1 = new WeakSet([val1, val2, val3]); alert(ws1.has(val1)); // true alert(ws1.has(val2)); // true alert(ws1.has(val3)); // true // 初始化是全有或全无的操作// 只要有一个值无效就会抛出错误，导致整个初始化失败const ws2 = new WeakSet([val1, &quot;BADVAL&quot;, val3]); // TypeError: Invalid value used in WeakSet typeof ws2; // ReferenceError: ws2 is not defined // 原始值可以先包装成对象再用作值const stringVal = new String(&quot;val1&quot;); const ws3 = new WeakSet([stringVal]); alert(ws3.has(stringVal)); // true 初始化之后可以使用add()再添加新值，可以使用 has()查询，还可以使用 delete()删除： 1234567891011const ws = new WeakSet(); const val1 = &#123;id: 1&#125;, val2 = &#123;id: 2&#125;; alert(ws.has(val1)); // false ws.add(val1) .add(val2); alert(ws.has(val1)); // true alert(ws.has(val2)); // true ws.delete(val1); // 只删除这一个值alert(ws.has(val1)); // false alert(ws.has(val2)); // true add()方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明： 123456789const val1 = &#123;id: 1&#125;, val2 = &#123;id: 2&#125;, val3 = &#123;id: 3&#125;; const ws = new WeakSet().add(val1); ws.add(val2) .add(val3); alert(ws.has(val1)); // true alert(ws.has(val2)); // true alert(ws.has(val3)); // true 弱值WeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用， 不会阻止垃圾回收。 12const ws = new WeakSet(); ws.add(&#123;&#125;); add()方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当 这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为 一个空集合。 再看一个稍微不同的例子： 12345678const ws = new WeakSet(); const container = &#123; val: &#123;&#125; &#125;; ws.add(container.val); function removeReference() &#123; container.val = null; &#125; 这一次，container 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁值对象的最后一个引用，垃圾回收程序就可以把这个值清理掉。 不可迭代值因为 WeakSet 中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着 像 clear()这样一次性销毁所有值的方法。WeakSet 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱集合中取得值。即便代码可以访问 WeakSet 实例，也没办法看到其中的内容。 WeakSet 之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。 使用弱集合相比于 WeakMap 实例，WeakSet 实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。 来看下面的例子，这里使用了一个普通 Set： 1234const disabledElements = new Set(); const loginButton = document.querySelector(&#x27;#login&#x27;); // 通过加入对应集合，给这个节点打上“禁用”标签disabledElements.add(loginButton); 这样，通过查询元素在不在 disabledElements 中，就可以知道它是不是被禁用了。不过，假如 元素从 DOM 树中被删除了，它的引用却仍然保存在 Set 中，因此垃圾回收程序也不能回收它。 为了让垃圾回收程序回收元素的内存，可以在这里使用 WeakSet： 1234const disabledElements = new WeakSet(); const loginButton = document.querySelector(&#x27;#login&#x27;);// 通过加入对应集合，给这个节点打上“禁用”标签disabledElements.add(loginButton); 这样，只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。 迭代与扩展操作ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。 有 4 种原生集合类型定义了默认迭代器： Array 所有定型数组 Map Set 很简单，这意味着上述所有类型都支持顺序迭代，都可以传入 for-of 循环： 12345678910111213141516171819let iterableThings = [ Array.of(1, 2), typedArr = Int16Array.of(3, 4), new Map([[5, 6], [7, 8]]), new Set([9, 10]) ]; for (const iterableThing of iterableThings) &#123; for (const x of iterableThing) &#123; console.log(x); &#125; &#125; // 1 // 2 // 3 // 4 // [5, 6] // [7, 8] // 9 // 10 这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用， 只需简单的语法就可以复制整个对象： 12345let arr1 = [1, 2, 3]; let arr2 = [...arr1]; console.log(arr1); // [1, 2, 3] console.log(arr2); // [1, 2, 3] console.log(arr1 === arr2); // false 对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制： 1234let map1 = new Map([[1, 2], [3, 4]]); let map2 = new Map(map1); console.log(map1); // Map &#123;1 =&gt; 2, 3 =&gt; 4&#125; console.log(map2); // Map &#123;1 =&gt; 2, 3 =&gt; 4&#125; 当然，也可以构建数组的部分元素： 123let arr1 = [1, 2, 3]; let arr2 = [0, ...arr1, 4, 5]; console.log(arr2); // [0, 1, 2, 3, 4, 5] 浅复制意味着只会复制对象引用： 1234let arr1 = [&#123;&#125;]; let arr2 = [...arr1]; arr1[0].foo = &#x27;bar&#x27;; console.log(arr2[0]); // &#123; foo: &#x27;bar&#x27; &#125; 上面的这些类型都支持多种构建方法，比如 Array.of()和 Array.from()静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作： 123456789101112131415let arr1 = [1, 2, 3]; // 把数组复制到定型数组let typedArr1 = Int16Array.of(...arr1); let typedArr2 = Int16Array.from(arr1); console.log(typedArr1); // Int16Array [1, 2, 3] console.log(typedArr2); // Int16Array [1, 2, 3] // 把数组复制到映射let map = new Map(arr1.map((x) =&gt; [x, &#x27;val&#x27; + x])); console.log(map); // Map &#123;1 =&gt; &#x27;val 1&#x27;, 2 =&gt; &#x27;val 2&#x27;, 3 =&gt; &#x27;val 3&#x27;&#125; // 把数组复制到集合let set = new Set(typedArr2); console.log(set); // Set &#123;1, 2, 3&#125; // 把集合复制回数组let arr2 = [...set]; console.log(arr2); // [1, 2, 3]","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(3)——基本引用类型","slug":"JS高级程序设计读书笔记(3)——基本引用类型","date":"2022-08-17T20:32:39.000Z","updated":"2023-11-27T15:34:23.880Z","comments":true,"path":"2022/08/18/JS高级程序设计读书笔记(3)——基本引用类型/","link":"","permalink":"http://pvnk1u.github.io/2022/08/18/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。 引用类型虽然有点像类，但跟类并不是一个概念。 对象被认为是某个特定引用类型的实例。新对象通过使用new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码： 1let now = new Date(); 这行代码创建了引用类型 Date 的一个新实例，并将它保存在变量 now 中。Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像 Date 这样的原生引用类型，帮助开发者实现常见的任务。 函数也是一种引用类型。 DateECMAScript 的Date 类型参考了Java 早期版本中的java.util.Date。为此，Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970 年1 月1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示1970 年1 月1 日之前及之后285 616 年的日期。 要创建日期对象，就使用new 操作符来调用Date 构造函数： 在不给Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元1970 年1 月1 日午夜之后的毫秒数）。ECMAScript为此提供了两个辅助方法：Date.parse()和Date.UTC()。 Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第5 版定义了Date.parse()应该支持的日期格式，填充了第3 版遗留的空白。所有实现都必须支持下列日期格式： “月&#x2F;日&#x2F;年”，如”5&#x2F;23&#x2F;2019”； “月名 日, 年”，如”May 23, 2019”； “周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”； ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容ES5 的实现）。 比如，要创建一个表示“2019 年5 月23 日”的日期对象，可以使用以下代码： 1let someDate = new Date(Date.parse(&quot;May 23, 2019&quot;)); 如果传给Date.parse()的字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date 构造函数，那么Date 会在后台调用Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的： 1let someDate = new Date(&quot;May 23, 2019&quot;); 这两行代码得到的日期对象相同。 Date.UTC()方法也返回日期的毫秒表示，但使用的是跟Date.parse()不同的信息来生成这个值。传给Date.UTC()的参数是年、零起点月数（1 月是0，2 月是1，以此类推）、日（131）、时（023）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1 日。其他参数的默认值都是0。下面是使用Date.UTC()的两个例子： 12345// GMT 时间2000 年1 月1 日零点 let y2k = new Date(Date.UTC(2000, 0)); // GMT 时间2005 年5 月5 日下午5 点55 分55 秒 let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 这个例子创建了两个日期 。第一个日期是2000 年1 月1 日零点（GMT），2000 代表年，0 代表月（1 月）。因为没有其他参数（日取1，其他取 0），所以结果就是该月第1 天零点。第二个日期表示2005年5 月5 日下午5 点55 分55 秒（GMT）。虽然日期里面涉及的都是5，但月数必须用4，因为月数是零起点的。小时也必须是17，因为这里采用的是24 小时制，即取值范围是0~23。其他参数就都很直观了。 与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。不过 Date 构造函数跟 Date.UTC()接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写： 123456// 本地时间2000 年1 月1 日零点 let y2k = new Date(2000, 0); // 本地时间2005 年5 月5 日下午5 点55 分55 秒 let allFives = new Date(2005, 4, 5, 17, 55, 55); 以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。 ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中： 123456789// 起始时间 let start = Date.now(); // 调用函数 doSomething(); // 结束时间 let stop = Date.now(), result = stop - start; 继承的方法与其他类型一样，Date 类型重写了toLocaleString()、toString()和valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以24 小时制（0~23）表示的。下面给出了toLocaleString()和toString()返回的2019 年2 月1 日零点的示例（地区为”en-US”的PST，即Pacific Standard Time，太平洋标准时间）： 123toLocaleString() - 2/1/2019 12:00:00 AM toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time) Date 类型的valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子： 123456let date1 = new Date(2019, 0, 1); // 2019 年1 月1 日 let date2 = new Date(2019, 1, 1); // 2019 年2 月1 日 console.log(date1 &lt; date2); // true console.log(date1 &gt; date2); // false 日期2019 年1 月1 日在2019 年2 月1 日之前，所以说前者小于后者没问题。因为2019 年1 月1 日的毫秒表示小于2019 年2 月1 日的毫秒表示，所以用小于号比较这两个日期时会返回true。这也是确保日期先后的一个简单方式。 日期格式化方法Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串： toDateString()显示日期中的周几、月、日、年（格式特定于实现）； toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）； toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）； toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）； toUTCString()显示完整的UTC 日期（格式特定于实现）。 1234567891011121314151617var a = new Date();undefineda.toDateString()&#x27;Mon Aug 22 2022&#x27;a.toTimeString()&#x27;12:37:11 GMT+0800 (中国标准时间)&#x27;a.toLocaleDateString()&#x27;2022/8/22&#x27;a.toLocaleTimeString()&#x27;12:37:11&#x27;a.toUTCString()&#x27;Mon, 22 Aug 2022 04:37:11 GMT&#x27; 这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。 日期&#x2F;时间组件方法Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。 方法 说明 getTime() 返回日期的毫秒表示；与valueOf()相同 setTime(milliseconds) 设置日期的毫秒表示，从而修改整个日期 getFullYear() 返回4 位数年（即2019 而不是19） getUTCFullYear() 返回UTC 日期的4 位数年 setFullYear(year) 设置日期的年（year 必须是4 位数） setUTCFullYear(year) 设置UTC 日期的年（year 必须是4 位数） getMonth() 返回日期的月（0 表示1 月，11 表示12 月） getUTCMonth() 返回UTC 日期的月（0 表示1 月，11 表示12 月） setMonth(month) 设置日期的月（month 为大于0 的数值，大于11 加年） setUTCMonth(month) 设置UTC 日期的月（month 为大于0 的数值，大于11 加年） getDate() 返回日期中的日（1~31） getUTCDate() 返回UTC 日期中的日（1~31） setDate(date) 设置日期中的日（如果date 大于该月天数，则加月） setUTCDate(date) 设置UTC 日期中的日（如果date 大于该月天数，则加月） getDay() 返回日期中表示周几的数值（0 表示周日，6 表示周六） getUTCDay() 返回UTC 日期中表示周几的数值（0 表示周日，6 表示周六） getHours() 返回日期中的时（0~23） getUTCHours() 返回UTC 日期中的时（0~23） setHours(hours) 设置日期中的时（如果hours 大于23，则加日） setUTCHours(hours) 设置UTC 日期中的时（如果hours 大于23，则加日） getMinutes() 返回日期中的分（0~59） getUTCMinutes() 返回UTC 日期中的分（0~59） setMinutes(minutes) 设置日期中的分（如果minutes 大于59，则加时） setUTCMinutes(minutes) 设置UTC 日期中的分（如果minutes 大于59，则加时） getSeconds() 返回日期中的秒（0~59） getUTCSeconds() 返回UTC 日期中的秒（0~59） setSeconds(seconds) 设置日期中的秒（如果seconds 大于59，则加分） setUTCSeconds(seconds) 设置UTC 日期中的秒（如果seconds 大于59，则加分） getMilliseconds() 返回日期中的毫秒 getUTCMilliseconds() 返回UTC 日期中的毫秒 setMilliseconds(milliseconds) 设置日期中的毫秒 setUTCMilliseconds(milliseconds) 设置UTC 日期中的毫秒 getTimezoneOffset() 返回以分钟计的UTC 与本地时区的偏移量（如美国EST 即“东部标准时间”返回300，进入夏令时的地区可能有所差异） RegExpECMAScript 通过RegExp 类型支持正则表达式。正则表达式使用类似Perl 的简洁语法来创建： 1let expression = /pattern/flags; 原始值包装类型为了方便操作原始值，ECMAScript 提供了3 种特殊的引用类型：Boolean、Number 和String。 这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子： 12let s1 = &quot;some text&quot;; let s2 = s1.substring(2); 在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在s1 上调用了substring()方法，并把结果保存在s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3 步： 创建一个String 类型的实例； 调用实例上的特定方法； 销毁实例。 可以把这3 步想象成执行了如下3 行ECMAScript 代码： 1234let s1 = new String(&quot;some text&quot;); let s2 = s1.substring(2); s1 = null; 这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3 步也会在后台发生，只不过使用的是Boolean 和Number 包装类型而已。 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过new 实例化引用类型后，得到的实例会在离开作用域时被销毁。 Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如： 12let obj = new Object(&quot;some text&quot;); console.log(obj instanceof String); // true 如果传给Object 的是字符串，则会创建一个String 的实例。如果是数值，则会创建Number 的实例。布尔值则会得到Boolean 的实例。 注意，使用new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如： 12345let value = &quot;25&quot;; let number = Number(value); // 转型函数 console.log(typeof number); // &quot;number&quot; let obj = new Number(value); // 构造函数 console.log(typeof obj); // &quot;object&quot; 在这个例子中，变量 number 中保存的是一个值为 25 的原始数值，而变量 obj 中保存的是一个Number 的实例。 BooleanBoolean 是对应布尔值的引用类型。要创建一个Boolean 对象，就使用Boolean 构造函数并传入true 或false，如下例所示： 1let booleanObject = new Boolean(true); Boolean 的实例会重写valueOf()方法，返回一个原始值true 或false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean 对象时，比如： 12345678let falseObject = new Boolean(false); let result = falseObject &amp;&amp; true; console.log(result); // true let falseValue = false; result = falseValue &amp;&amp; true; console.log(result); // false 在这段代码中，我们创建一个值为false 的Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值true 组合起来。在布尔算术中，false &amp;&amp; true 等于false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为true，因此 falseObject在这个表达式里实际上表示一个true 值。那么true &amp;&amp; true 当然是true。 除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回true，但对原始值则返回false，如下所示： 1234console.log(typeof falseObject); // object console.log(typeof falseValue); // boolean console.log(falseObject instanceof Boolean); // true console.log(falseValue instanceof Boolean); // false 理解原始布尔值和Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。 NumberNumber 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个 数值，如下例所示： 1let numberObject = new Number(10); 与 Boolean 类型一样，Number 类型重写了 valueOf()、toLocaleString()和 toString()方 法。valueOf()方法返回Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数并返回相应基数形式的数值字符串，如下所示： 123456let num = 10; console.log(num.toString()); // &quot;10&quot; console.log(num.toString(2)); // &quot;1010&quot; console.log(num.toString(8)); // &quot;12&quot; console.log(num.toString(10)); // &quot;10&quot; console.log(num.toString(16)); // &quot;a&quot; 除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法。 toFixed()方法返回包含指定小数点位数的数值字符串，如： 12let num = 10; console.log(num.toFixed(2)); // &quot;10.00&quot; 这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为 “10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位： 12let num = 10.005; console.log(num.toFixed(2)); // &quot;10.01&quot; toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定 得到精确的结果。比如，0.1 + 0.2 &#x3D; 0.30000000000000004。 另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表 示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。 来看下面的例子: 12let num = 10; console.log(num.toExponential(1)); // &quot;1.0e+1&quot; 与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。在处理原始数值和引用数值时，typeof 和 instacnceof 操作符会返回不同的结果，如下所示： 123456let numberObject = new Number(10); let numberValue = 10; console.log(typeof numberObject); // &quot;object&quot; console.log(typeof numberValue); // &quot;number&quot; console.log(numberObject instanceof Number); // true console.log(numberValue instanceof Number); // false 原始数值在调用 typeof 时始终返回”number”，而 Number 对象则返回”object”。类似地，Number 对象是 Number 类型的实例，而原始数值不是。 isInteger()方法与安全整数 ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0 可能会让人误以为数值是一个浮点值： 123console.log(Number.isInteger(1)); // true console.log(Number.isInteger(1.00)); // true console.log(Number.isInteger(1.01)); // false IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值 范围从 Number.MIN_SAFE_INTEGER（-253+ 1）到 Number.MAX_SAFE_INTEGER（253 - 1）。对超出这 个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的 数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法： 1234console.log(Number.isSafeInteger(-1 * (2 ** 53))); // false console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); // true console.log(Number.isSafeInteger(2 ** 53)); // false console.log(Number.isSafeInteger((2 ** 53) - 1)); // true StringString 是对应字符串的引用类型。要创建一个 String 对象，使用 String构造函数并传入一个 数值，如下例所示： 1let stringObject = new String(&quot;hello world&quot;); String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleString() 和 toString()都返回对象的原始字符串值。 每个 String 对象都有一个 length 属性，表示字符串中字符的数量。来看下面的例子： 12let stringValue = &quot;hello world&quot;; console.log(stringValue.length); // &quot;11&quot; 注意，即使字符串中包含双字节 字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数。 JavaScript字符 JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元。 此外，charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符： 12let message = &quot;abcde&quot;; console.log(message.charAt(2)); // &quot;c&quot; JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码 的字符（U+0000~U+FFFF），这两种编码实际上是一样的。 使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索 引以整数指定。比如： 12345let message = &quot;abcde&quot;; // Unicode &quot;Latin small letter C&quot;的编码是 U+0063 console.log(message.charCodeAt(2)); // 99 // 十进制 99 等于十六进制 63 console.log(99 === 0x63); // true 字符串操作方法 首先是 concat()，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子： 1234let stringValue = &quot;hello &quot;; let result = stringValue.concat(&quot;world&quot;); console.log(result); // &quot;hello world&quot; console.log(stringValue); // &quot;hello&quot; 对 stringValue 调 用 concat()方法的结果是得到”hello world”， 但 stringValue 的值保持不变。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串， 如下所示： 1234let stringValue = &quot;hello &quot;; let result = stringValue.concat(&quot;world&quot;, &quot;!&quot;); console.log(result); // &quot;hello world!&quot; console.log(stringValue); // &quot;hello&quot; 虽然 concat()方法可以拼接 字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。 ECMAScript 提供了 3 个从字符串中提取子字符串的方法：slice()、substr()和 substring()。3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对 substr()而言，第二个参数表示返回的子字符串数量。 任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat()方法一样，slice()、substr() 和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来看下面的例子： 1234567let stringValue = &quot;hello world&quot;; console.log(stringValue.slice(3)); // &quot;lo world&quot; console.log(stringValue.substring(3)); // &quot;lo world&quot; console.log(stringValue.substr(3)); // &quot;lo world&quot; console.log(stringValue.slice(3, 7)); // &quot;lo w&quot; console.log(stringValue.substring(3,7)); // &quot;lo w&quot; console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot; 当某个参数是负值时，这 3 个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字符串长度加上负参数值。而 substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。 substring()方法会将所有负参数值都转换为 0。看下面的例子： 1234567let stringValue = &quot;hello world&quot;; console.log(stringValue.slice(-3)); // &quot;rld&quot; console.log(stringValue.substring(-3)); // &quot;hello world&quot; console.log(stringValue.substr(-3)); // &quot;rld&quot; console.log(stringValue.slice(3, -4)); // &quot;lo w&quot; console.log(stringValue.substring(3, -4)); // &quot;hel&quot; console.log(stringValue.substr(3, -4)); // &quot;&quot; (empty string) 字符串位置方法 有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()。这两个方法从字符 串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。来看下面的例子： 123let stringValue = &quot;hello world&quot;; console.log(stringValue.indexOf(&quot;o&quot;)); // 4 console.log(stringValue.lastIndexOf(&quot;o&quot;)); // 7 这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个 参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。下面看一个例子： 123let stringValue = &quot;hello world&quot;; console.log(stringValue.indexOf(&quot;o&quot;, 6)); // 7 console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4 像这样使用第二个参数并循环调用 indexOf()或 lastIndexOf()，就可以在字符串中找到所有的目标子字符串，如下所示： 12345678let stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;; let positions = new Array(); let pos = stringValue.indexOf(&quot;e&quot;); while(pos &gt; -1) &#123; positions.push(pos); pos = stringValue.indexOf(&quot;e&quot;, pos + 1); &#125; console.log(positions); // [3,24,32,35,52] 字符串包含方法 ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、 endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含 的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索 引(string.length - substring.length)的匹配项，而 includes()检查整个字符串： 1234567let message = &quot;foobarbaz&quot;; console.log(message.startsWith(&quot;foo&quot;)); // true console.log(message.startsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;baz&quot;)); // true console.log(message.endsWith(&quot;bar&quot;)); // false console.log(message.includes(&quot;bar&quot;)); // true console.log(message.includes(&quot;qux&quot;)); // false startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。 endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样： 1234let message = &quot;foobarbaz&quot;; console.log(message.endsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;bar&quot;, 6)); // true trim()方法 ECMAScript 在所有字符串上都提供了trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如： 12345let stringValue = &quot; hello world &quot;; let trimmedStringValue = stringValue.trim(); console.log(stringValue); // &quot; hello world &quot; console.log(trimmedStringValue); // &quot;hello world&quot; 由于trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。 另外，trimLeft()和trimRight()方法分别用于从字符串开始和末尾清理空格符。 repeat()方法 ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。 123let stringValue = &quot;na &quot;; console.log(stringValue.repeat(16) + &quot;batman&quot;); // na na na na na na na na na na na na na na na na batman padStart()和padEnd()方法 padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。 1234567let stringValue = &quot;foo&quot;; console.log(stringValue.padStart(6)); // &quot; foo&quot; console.log(stringValue.padStart(9, &quot;.&quot;)); // &quot;......foo&quot; console.log(stringValue.padEnd(6)); // &quot;foo &quot; console.log(stringValue.padEnd(9, &quot;.&quot;)); // &quot;foo......&quot; 可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。 12345678let stringValue = &quot;foo&quot;; console.log(stringValue.padStart(8, &quot;bar&quot;)); // &quot;barbafoo&quot; console.log(stringValue.padStart(2)); // &quot;foo&quot; console.log(stringValue.padEnd(8, &quot;bar&quot;)); // &quot;foobarba&quot; console.log(stringValue.padEnd(2)); // &quot;foo&quot; 字符串迭代与解构 字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器： 1234567let message = &quot;abc&quot;; let stringIterator = message[Symbol.iterator](); console.log(stringIterator.next()); // &#123;value: &quot;a&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: &quot;b&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: &quot;c&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: undefined, done: true&#125; 在for-of 循环中可以通过这个迭代器按序访问每个字符： 123for (const c of &quot;abcde&quot;) &#123; console.log(c); &#125; 12345// a // b // c // d // e 有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组： 12let message = &quot;abcde&quot;; console.log([...message]); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] 字符串大小写转换 下一组方法涉及大小写转换，包括 4 个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的方法，与java.lang.String 中的方法同名。toLocaleLowerCase()和toLocaleUpperCase()方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。下面是几个例子： 12345let stringValue = &quot;hello world&quot;; console.log(stringValue.toLocaleUpperCase()); // &quot;HELLO WORLD&quot; console.log(stringValue.toUpperCase()); // &quot;HELLO WORLD&quot; console.log(stringValue.toLocaleLowerCase()); // &quot;hello world&quot; console.log(stringValue.toLowerCase()); // &quot;hello world&quot; 字符串模式匹配方法 String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是match()方法，这个方法本质上跟RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp 对象。来看下面的例子： 12345678let text = &quot;cat, bat, sat, fat&quot;; let pattern = /.at/; // 等价于pattern.exec(text) let matches = text.match(pattern); console.log(matches.index); // 0 console.log(matches[0]); // &quot;cat&quot; console.log(pattern.lastIndex); // 0 另一个查找模式的字符串方法是search()。这个方法唯一的参数与match()方法一样：正则表达式字符串或RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。search()始终从字符串开头向后匹配模式。看下面的例子： 123let text = &quot;cat, bat, sat, fat&quot;; let pos = text.search(/at/); console.log(pos); // 1 这里，search(/at/)返回1，即”at”的第一个字符在字符串中的位置。 为简化子字符串替换操作，ECMAScript 提供了replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示： 1234567let text = &quot;cat, bat, sat, fat&quot;; let result = text.replace(&quot;at&quot;, &quot;ond&quot;); console.log(result); // &quot;cond, bat, sat, fat&quot; result = text.replace(/at/g, &quot;ond&quot;); console.log(result); // &quot;cond, bond, sond, fond&quot; localeCompare()方法 最后一个方法是localeCompare()，这个方法比较两个字符串，返回如下3 个值中的一个。 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。） 如果字符串与字符串参数相等，则返回0。 如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。） 1234let stringValue = &quot;yellow&quot;; console.log(stringValue.localeCompare(&quot;brick&quot;)); // 1 console.log(stringValue.localeCompare(&quot;yellow&quot;)); // 0 console.log(stringValue.localeCompare(&quot;zoo&quot;)); // -1 localeCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是ECMAScript 实现的标准语言，localeCompare()区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。 单例内置对象ECMA-262 对内置对象的定义是“任何由ECMAScript 实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括Object、Array 和String。本节介绍ECMA-262定义的另外两个单例内置对象：Global 和Math。 GlobalGlobal 对象是ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成Global 对象的属性 。前面介绍的函数，包括isNaN()、isFinite()、parseInt()和parseFloat()，实际上都是Global 对象的方法。除了这些，Global 对象上还有另外一些方法。 URL编码方法 encodeURI()和encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI 不能包含某些字符，比如空格。使用URI 编码方法来编码URI 可以让浏览器能够理解它们，同时又以特殊的UTF-8 编码替换掉所有无效字符。 ecnodeURI()方法用于对整个 URI 进行编码，比如”www.wrox.com/illegal value.js”。而encodeURIComponent()方法用于编码URI 中单独的组件，比如前面URL 中的”illegal value.js”。 这两个方法的主要区别是，encodeURI()不会编码属于URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而encodeURIComponent()会编码它发现的所有非标准字符。来看下面的例子： 1234567let uri = &quot;http://www.wrox.com/illegal value.js#start&quot;; // &quot;http://www.wrox.com/illegal%20value.js#start&quot; console.log(encodeURI(uri)); // &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; console.log(encodeURIComponent(uri)); 与encodeURI()和encodeURIComponent()相对的是decodeURI()和decodeURIComponent()。decodeURI()只对使用encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由encodeURI()替换的。类似地，decodeURIComponent()解码所有被encodeURIComponent()编码的字符，基本上就是解码所有特殊值。 eval()方法 最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是 eval()。这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。来看一个例子： 1eval(&quot;console.log(&#x27;hi&#x27;)&quot;); 上面这行代码的功能与下一行等价： 1console.log(&quot;hi&quot;); 当解释器发现eval()调用时，会将参数解释为实际的ECMAScript 语句，然后将其插入到该位置。通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在eval()调用内部被引用，比如下面这个例子： 12let msg = &quot;hello world&quot;; eval(&quot;console.log(msg)&quot;); // &quot;hello world&quot; 类似地，可以在eval()内部定义一个函数或变量，然后在外部代码中引用，如下所示： 12eval(&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;); sayHi(); 通过 eval()定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在eval()执行的时候才会被创建。 在严格模式下，在 eval()内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报错。同样，在严格模式下，赋值给eval 也会导致错误： 12&quot;use strict&quot;; eval = &quot;hi&quot;; // 导致错误 windows对象 虽然ECMA-262没有规定直接访问Global 对象的方式，但浏览器将window 对象实现为Global对象的代理。因此，所有全局作用域中声明的变量和函数都变成了window 的属性。来看下面的例子： 1234567var color = &quot;red&quot;; function sayColor() &#123; console.log(window.color); &#125; window.sayColor(); // &quot;red&quot; 这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，通过window.color 访问了color 变量，说明全局变量变成了window 的属性。接着，又通过window对象直接调用了window.sayColor()函数，从而输出字符串。 另一种获取Global 对象的方式是使用如下的代码： 123let global = function() &#123; return this; &#125;(); 这段代码创建一个立即调用的函数表达式，返回了this 的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过call()/apply()）指定this 值的情况下执行时，this 值等于Global 对象。因此，调用一个简单返回this 的函数是在任何执行上下文中获取Global 对象的通用方式。 MathECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。 min()和 max()方法 Math 对象提供了很多辅助执行简单或复杂数学计算的方法。 min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示： 1234let max = Math.max(3, 54, 32, 16); console.log(max); // 54 let min = Math.min(3, 54, 32, 16); console.log(min); // 3 要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符： 12let values = [1, 2, 3, 4, 5, 6, 7, 8]; let max = Math.max(...val); 舍入方法 接下来是用于把小数值舍入为整数的 4 个方法：Math.ceil()、Math.floor()、Math.round() 和 Math.fround()。这几个方法处理舍入的方式如下所述。 Math.ceil()方法始终向上舍入为最接近的整数。 Math.floor()方法始终向下舍入为最接近的整数。 Math.round()方法执行四舍五入。 Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示。 random()方法 Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用 Math.random()从一组整数中随机选择一个数： 1number = Math.floor(Math.random() * total_number_of_choices + first_possible_value) 这里使用了 Math.floor()方法，因为 Math.random()始终返回小数，即便乘以一个数再加上一 个数也是小数。因此，如果想从 1~10 范围内随机选择一个数，代码就是这样的： 1let num = Math.floor(Math.random() * 10 + 1); 这样就有 10 个可能的值（110），其中最小的值是 1。如果想选择一个 210 范围内的值，则代码就要写成这样： 1let num = Math.floor(Math.random() * 9 + 2); 2~10 只有 9 个数，所以可选总数（total_number_of_choices）是 9，而最小可能的值 （first_possible_value）是 2。很多时候，通过函数来算出可选总数和最小可能的值可能更方便， 比如： 123456function selectFrom(lowerValue, upperValue) &#123; let choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue); &#125; let num = selectFrom(2,10); console.log(num); // 2~10 范围内的值，其中包含 2 和 10 这里的函数 selectFrom()接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加 1 得到可选总数，然后再套用上面的公式。于是，调用 selectFrom(2,10)就可以从 2~10（包含） 范围内选择一个值了。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(2)——变量、作用域与内存","slug":"JS高级程序设计读书笔记(2)——变量、作用域与内存","date":"2022-08-15T20:32:39.000Z","updated":"2023-11-27T15:34:23.880Z","comments":true,"path":"2022/08/16/JS高级程序设计读书笔记(2)——变量、作用域与内存/","link":"","permalink":"http://pvnk1u.github.io/2022/08/16/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/","excerpt":"","text":"相比于其他语言，JavaScript中的变量可谓独树一帜。由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。这样的变量很有意思，很强大，当然也有不少问题。 原始值与引用值ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。 在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和Symbol。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。 动态属性原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子： 123let person = new Object(); person.name = &quot;Nicholas&quot;; console.log(person.name); // &quot;Nicholas&quot; 这里，首先创建了一个对象，并把它保存在变量 person 中。然后，给这个对象添加了一个名为name 的属性，并给这个属性赋值了一个字符串”Nicholas”。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。 原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如： 123let name = &quot;Nicholas&quot;; name.age = 27; console.log(name.age); // undefined 只有引用值可以动态添加后面可以使用的属性。 原始类型的初始化可以只使用原始字面量形式。如果使用的是new 关键字，则JavaScript 会创建一个Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异： 12345678910let name1 = &quot;Nicholas&quot;; let name2 = new String(&quot;Matt&quot;); name1.age = 27; name2.age = 26; console.log(name1.age); // undefined console.log(name2.age); // 26 console.log(typeof name1); // string console.log(typeof name2); // object 复制值除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置： 12let num1 = 5; let num2 = num1; 这里，num1 包含数值5。当把num2 初始化为num1 时，num2 也会得到数值5。这个值跟存储在num1 中的5 是完全独立的，因为它是那个值的副本。 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示： 1234let obj1 = new Object(); let obj2 = obj1; obj1.name = &quot;Nicholas&quot;; console.log(obj2.name); // &quot;Nicholas&quot; 传递参数ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。 在按值传递参数时，值会被复制到一个局部变量。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在ECMAScript 中是不可能的。）来看下面这个例子： 1234567891011function addTen(num) &#123; num += 10; return num; &#125; let count = 20;let result = addTen(count); console.log(count); // 20，没有变化 console.log(result); // 30 这里，函数addTen()有一个参数num，它其实是一个局部变量。在调用时，变量count 作为参数传入。count 的值是20，这个值被复制到参数num 以便在addTen()内部使用。在函数内部，参数num的值被加上了10，但这不会影响函数外部的原始变量count。参数 num 和变量count 互不干扰，它们只不过碰巧保存了一样的值。如果num 是按引用传递的，那么count 的值也会被修改为30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子： 12345678function setName(obj) &#123; obj.name = &quot;Nicholas&quot;; &#125; let person = new Object(); setName(person); console.log(person.name); // &quot;Nicholas&quot; 这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数obj 中。在函数内部，obj 和person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给obj 设置了name属性时，函数外部的对象也会反映这个变化，因为obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子： 1234567891011function setName(obj) &#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;; &#125; let person = new Object(); setName(person); console.log(person.name); // &quot;Nicholas&quot; 这个例子前后唯一的变化就是setName()中多了两行代码，将obj 重新定义为一个有着不同name的新对象。当person 传入setName()时，其name 属性被设置为”Nicholas”。然后变量obj 被设置为一个新对象且name 属性被设置为”Greg”。如果 person 是按引用传递的，那么person 应该自动将指针改为指向name 为”Greg”的对象。可是，当我们再次访问person.name 时，它的值是”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。 确定类型typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined 的最好方式。如果值是对象或null，那么typeof返回”object”: 123456789101112131415let s = &quot;Nicholas&quot;; let b = true; let i = 22; let u; let n = null; let o = new Object(); console.log(typeof s); // string console.log(typeof i); // number console.log(typeof b); // boolean console.log(typeof u); // undefined console.log(typeof n); // object console.log(typeof o); // object typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了instanceof 操作符，语法如下： 1result = variable instanceof constructor 如果变量是给定引用类型（由其原型链决定）的实例，则instanceof 操作符返回true。来看下面的例子： 123console.log(person instanceof Object); // 变量person 是Object 吗？ console.log(colors instanceof Array); // 变量colors 是Array 吗？ console.log(pattern instanceof RegExp); // 变量pattern 是RegExp 吗？ 按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回true。类似地，如果用instanceof 检测原始值，则始终会返回false，因为原始值不是对象。 执行上下文与作用域执行上下文（以下简称“上下文”）的概念在JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。 全局上下文是最外层的上下文。根据ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是常说的window 对象，因此所有通过var 定义的全局变量和函数都会成为window 对象的属性和方法。使用let 和const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。） 看一看下面这个例子： 123456789101112131415var color = &quot;blue&quot;; function changeColor() &#123; if (color === &quot;blue&quot;) &#123; color = &quot;red&quot;; &#125; else &#123; color = &quot;blue&quot;; &#125; &#125; changeColor(); 对这个例子而言，函数 changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments 对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。 此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。看一看下面这个例子： 12345678910111213141516171819202122var color = &quot;blue&quot;; function changeColor() &#123; let anotherColor = &quot;red&quot;; function swapColors() &#123; let tempColor = anotherColor; anotherColor = color; color = tempColor; // 这里可以访问color、anotherColor 和tempColor &#125; // 这里可以访问color 和anotherColor，但访问不到tempColor swapColors(); &#125; // 这里只能访问color changeColor(); 作用域链增强虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时： try&#x2F;catch 语句的catch 块 with 语句 这两种情况下，都会在作用域链前端添加一个变量对象。对with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子： 12345678910function buildUrl() &#123; let qs = &quot;?debug=true&quot;; with(location)&#123; let url = href + qs; &#125; return url; &#125; 这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性。在引用qs 时，引用的则是定义在buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用let 声明的变量url，因为被限制在块级作用域（稍后介绍），所以在with 块之外没有定义。 变量声明ES6 之后，JavaScript 的变量声明经历了翻天覆地的变化。直到ECMAScript 5.1，var 都是声明变量的唯一关键字。ES6 不仅增加了 let 和 const 两个关键字，而且还让这两个关键字压倒性地超越 var成为首选。 使用var 的函数作用域声明 在使用var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示： 1234567function add(num1, num2) &#123; var sum = num1 + num2; return sum; &#125; let result = add(10, 20); // 30 console.log(sum); // 报错：sum 在这里不是有效变量 这里，函数add()定义了一个局部变量sum，保存加法操作的结果。这个值作为函数的值被返回，但变量sum 在函数外部是访问不到的。如果省略上面例子中的关键字var，那么sum 在add()被调用之后就变成可以访问的了，如下所示： 12345678function add(num1, num2) &#123; sum = num1 + num2; return sum; &#125; let result = add(10, 20); // 30 console.log(sum); // 30 这一次，变量 sum 被用加法操作的结果初始化时并没有使用 var 声明。在调用 add()之后，sum被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。 未经声明而初始化变量是JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。 使用let 的块级作用域声明 ES6 新增的let 关键字跟var 很相似，但它的作用域是块级的，这也是JavaScript 中的新概念。块级作用域由最近的一对包含花括号&#123;&#125;界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是let 声明变量的作用域。 1234567891011121314151617181920212223242526if (true) &#123; let a; &#125; console.log(a); // ReferenceError: a 没有定义 while (true) &#123; let b; &#125;console.log(b); // ReferenceError: b 没有定义 function foo() &#123; let c; &#125; console.log(c); // ReferenceError: c 没有定义 // 这没什么可奇怪的 // var 声明也会导致报错 // 这不是对象字面量，而是一个独立的块 // JavaScript 解释器会根据其中内容识别出它来 &#123; let d; &#125; console.log(d); // ReferenceError: d 没有定义 let 与 var的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的let 声明会抛出SyntaxError。 123456789101112var a; var a; // 不会报错 &#123; let b; let b; &#125; // SyntaxError: 标识符b 已经声明过了 let 的行为非常适合在循环中声明迭代变量。使用var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子： 1234567for (var i = 0; i &lt; 10; ++i) &#123;&#125; console.log(i); // 10 for (let j = 0; j &lt; 10; ++j) &#123;&#125; console.log(j); // ReferenceError: j 没有定义 使用const 的常量声明 除了let，ES6 同时还增加了const 关键字。使用const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。 12345const a; // SyntaxError: 常量声明时没有初始化 const b = 3; console.log(b); // 3 b = 4; // TypeError: 给常量赋值 const 除了要遵循以上规则，其他方面与let 声明是一样的。 const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。 123456const o1 = &#123;&#125;; o1 = &#123;&#125;; // TypeError: 给常量赋值 const o2 = &#123;&#125;; o2.name = &#x27;Jake&#x27;; console.log(o2.name); // &#x27;Jake&#x27; 如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败： 1234const o3 = Object.freeze(&#123;&#125;); o3.name = &#x27;Jake&#x27;; console.log(o3.name); // undefined 标识符查找 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。 一个例子： 1234567var color = &#x27;blue&#x27;; function getColor() &#123; return color; &#125; console.log(getColor()); // &#x27;blue&#x27; 在这个例子中，调用函数getColor()时会引用变量color。为确定color 的值会进行两步搜索。第一步，搜索 getColor()的变量对象，查找名为 color 的标识符。结果没找到，于是继续搜索下一个变量对象（来自全局上下文），然后就找到了名为 color 的标识符。因为全局变量对象上有 color的定义，所以搜索结束。 对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符，如下面的例子所示： 123456789var color = &#x27;blue&#x27;; function getColor() &#123; let color = &#x27;red&#x27;; return color; &#125; console.log(getColor()); // &#x27;red&#x27; 使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次： 12345678910111213var color = &#x27;blue&#x27;; function getColor() &#123; let color = &#x27;red&#x27;; &#123; let color = &#x27;green&#x27;; return color; &#125; &#125; console.log(getColor()); // &#x27;green&#x27; 在这个修改后的例子中，getColor()内部声明了一个名为color 的局部变量。在调用这个函数时，变量会被声明。在执行到函数返回语句时，代码引用了变量color。于是开始在局部上下文中搜索这个标识符，结果找到了值为’green’的变量color。因为变量已找到，搜索随即停止，所以就使用这个局部变量。这意味着函数会返回’green’。在局部变量 color 声明之后的任何代码都无法访问全局变量color，除非使用完全限定的写法window.color。 垃圾回收JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C 和 C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。 以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。 标记清理JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。 引用计数另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0 的值的内存。 引用计数最早由Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象A 有一个指针指向对象B，而对象B 也引用了对象A。比如： 12345678function problem() &#123; let objectA = new Object(); let objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA; &#125; 在这个例子中，objectA 和objectB 通过各自的属性相互引用，意味着它们的引用数都是2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和objectB 在函数结束后还会存在，因为它们的引用数永远不会变成0。如果函数被多次调用，则会导致大量内存永远不会被释放。 性能垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。 现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。” 内存管理将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，如下面的例子所示： 12345678910111213function createPerson(name)&#123; let localPerson = new Object(); localPerson.name = name; return localPerson; &#125; let globalPerson = createPerson(&quot;Nicholas&quot;); // 解除globalPerson 对值的引用 globalPerson = null; 在上面的代码中，变量globalPerson 保存着createPerson()函数调用返回的值。在createPerson()内部，localPerson 创建了一个对象并给它添加了一个name 属性。然后，localPerson 作为函数值被返回，并被赋值给globalPerson。localPerson 在createPerson()执行完成超出上下文后会自动被解除引用，不需要显式处理。但 globalPerson 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的。 不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。 通过const 和let 声明提升性能 ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为const和let 都以块（而非函数）为作用域，所以相比于使用var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。 隐藏类和删除操作 根据JavaScript 所在的运行环境，有时候需要根据浏览器使用的JavaScript 引擎来采取不同的性能优化策略。截至2017 年，Chrome 是最流行的浏览器，使用V8 JavaScript 引擎。V8在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。 根据JavaScript 所在的运行环境，有时候需要根据浏览器使用的JavaScript 引擎来采取不同的性能优化策略。截至2017 年，Chrome 是最流行的浏览器，使用V8 JavaScript 引擎。V8 在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。 运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。比如下面的代码： 123456function Article() &#123; this.title = &#x27;Inauguration Ceremony Features Kazoo Band&#x27;; &#125; let a1 = new Article(); let a2 = new Article(); V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码： 1a2.author = &#x27;Jake&#x27;; 此时两个 Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。 当然，解决方案就是避免JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示： 12345678function Article(opt_author) &#123; this.title = &#x27;Inauguration Ceremony Features Kazoo Band&#x27;; this.author = opt_author; &#125; let a1 = new Article(); let a2 = new Article(&#x27;Jake&#x27;); 这样，两个实例基本上就一样了（不考虑hasOwnProperty 的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用delete 关键字会导致生成相同的隐藏类片段。看一下这个例子： 123456789function Article() &#123; this.title = &#x27;Inauguration Ceremony Features Kazoo Band&#x27;; this.author = &#x27;Jake&#x27;; &#125; let a1 = new Article(); let a2 = new Article(); delete a1.author; 在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如： 12345678910function Article() &#123; this.title = &#x27;Inauguration Ceremony Features Kazoo Band&#x27;; this.author = &#x27;Jake&#x27;; &#125; let a1 = new Article(); let a2 = new Article(); a1.author = null; 内存泄漏 写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。 意外声明全局变量是最常见但也最容易修复的内存泄漏问题。下面的代码没有使用任何关键字声明变量： 123function setName() &#123; name = &#x27;Jake&#x27;; &#125; 此时，解释器会把变量 name 当作 window 的属性来创建（相当于 window.name = &#39;Jake&#39;）。可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上var、let 或const 关键字即可，这样变量就会在函数执行完毕后离开作用域。 定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量： 12345let name = &#x27;Jake&#x27;; setInterval(() =&gt; &#123; console.log(name); &#125;, 100); 只要定时器一直运行，回调函数中引用的name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。 使用JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子： 1234567let outer = function() &#123; let name = &#x27;Jake&#x27;; return function() &#123; return name; &#125;; &#125;; 调用outer()会导致分配给name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字串），那可能就是个大问题了。 静态分配与对象池 为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。 浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。看一看下面的例子，这是一个计算二维矢量加法的函数： 12345678function addVector(a, b) &#123; let resultant = new Vector(); resultant.x = a.x + b.x; resultant.y = a.y + b.y; return resultant; &#125; 调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。 该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象： 12345function addVector(a, b, resultant) &#123; resultant.x = a.x + b.x; resultant.y = a.y + b.y; return resultant; &#125; 当然，这需要在其他地方实例化矢量参数 resultant，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？ 一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现： 123456789101112131415161718192021222324252627282930// vectorPool 是已有的对象池 let v1 = vectorPool.allocate(); let v2 = vectorPool.allocate(); let v3 = vectorPool.allocate(); v1.x = 10; v1.y = 5; v2.x = -3; v2.y = -6; addVector(v1, v2, v3); console.log([v3.x, v3.y]); // [7, -1] vectorPool.free(v1); vectorPool.free(v2); vectorPool.free(v3); // 如果对象有属性引用了其他对象 // 则这里也需要把这些属性设置为null v1 = null; v2 = null; v3 = null; 如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。比如下面这个例子： 1234let vectorList = new Array(100); let vector = new Vector(); vectorList.push(vector); 由于 JavaScript 数组的大小是动态可变的，引擎会删除大小为 100 的数组，再创建一个新的大小为200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。 静态分配是优化的一种极端形式。如果应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"JS高级程序设计读书笔记(1)——语言基础","slug":"JS高级程序设计读书笔记(1)——语言基础","date":"2022-07-17T20:32:39.000Z","updated":"2023-11-27T15:34:23.877Z","comments":true,"path":"2022/07/18/JS高级程序设计读书笔记(1)——语言基础/","link":"","permalink":"http://pvnk1u.github.io/2022/07/18/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"","text":"语法 区分大小写 ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。 标识符 所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成： 第一个字符必须是一个字母、下划线（_）或美元符号（$）； 剩下的其他字符可以是字母、下划线、美元符号或数字 严格模式 ECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执 行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行： 1&quot;use strict&quot;; 虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的 JavaScript 引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAScript 3 语法。 也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可： 1234function doSomething() &#123; &quot;use strict&quot;; // 函数体 &#125; 语句 ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。 即使语句末尾的分号不是必需的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以 避免输入内容不完整。此外，加分号也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只 删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的 位置补上分号以纠正语法错误。 变量ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一 个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在 ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。 var关键字1var message; 这行代码定义了一个名为 message 的变量，可以用它保存任何类型的值。（不初始化的情况下，变 量会保存一个特殊值 undefined）ECMAScript 实现变量初始化，因 此可以同时定义变量并设置它的值： 1var message = &quot;hi&quot;; 这里，message 被定义为一个保存字符串值 hi 的变量。像这样初始化变量不会将它标识为字符串 类型，只是一个简单的赋值而已。随后，不仅可以改变保存的值，也可以改变值的类型： 12var message = &quot;hi&quot;; message = 100; // 合法，但不推荐 var声明作用域 关键的问题在于，使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁： 12345function test() &#123; var message = &quot;hi&quot;; // 局部变量&#125; test(); console.log(message); // 出错！ 这里，message 变量是在函数内部使用 var 定义的。函数叫 test()，调用它会创建这个变量并给 它赋值。调用之后变量随即被销毁，因此示例中的最后一行会导致错误。不过，在函数内定义变量时省略 var 操作符，可以创建一个全局变量： 12345function test() &#123; message = &quot;hi&quot;; // 全局变量，不推荐&#125; test(); console.log(message); // &quot;hi&quot; 去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test()，就会定义这个变量，并且可以在函数外部访问到。 在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError。 如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）： 123var message = &quot;hi&quot;, found = false, age = 29; var声明提升 使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域 顶部： 12345function foo() &#123; console.log(age); var age = 26; &#125; foo(); // undefined 之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码： 123456function foo() &#123; var age; console.log(age); age = 26; &#125; foo(); // undefined 这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次 使用 var 声明同一个变量也没有问题： 1234567function foo() &#123; var age = 16; var age = 26; var age = 36; console.log(age); &#125; foo(); // 36 let声明let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域， 而 var 声明的范围是函数作用域。 12345678910if (true) &#123; var name = &#x27;Matt&#x27;; console.log(name); // Matt &#125; console.log(name); // Mattif (true) &#123; let age = 26; console.log(age); // 26 &#125; console.log(age); // ReferenceError: age 没有定义 在这里，age 变量之所以不能在 if 块外部被引用，是因为它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let。 let 也不允许同一个块作用域中出现冗余声明。这样会导致报错： 12345678if(true)&#123; var name = &#x27;Matt&#x27;; var name = &#x27;Nick&#x27;; &#125; if(true)&#123; let age = 1; let age = 2; // SyntaxError；标识符 age 已经声明过了&#125; const声明const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且 尝试修改 const 声明的变量会导致运行时错误。 123456789101112131415if(true)&#123; const age = 26; age = 36; // TypeError: 给常量赋值&#125;if(true)&#123; // const 也不允许重复声明 const name = &#x27;Matt&#x27;; const name = &#x27;Nicholas&#x27;; // SyntaxError&#125;// const 声明的作用域也是块const name = &#x27;Matt&#x27;;if (true) &#123; const name = &#x27;Nicholas&#x27;;&#125;console.log(name); // Matt const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象， 那么修改这个对象内部的属性并不违反 const 的限制。 12const person = &#123;&#125;; person.name = &#x27;Matt&#x27;; // ok JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变 量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）： 1for (const i = 0; i &lt; 10; ++i) &#123;&#125; // TypeError：给常量赋值 不过，如果只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义: 12345678910111213let i = 0; for (const j = 7; i &lt; 5; ++i) &#123; console.log(j); &#125; // 7, 7, 7, 7, 7 for (const key in &#123;a: 1, b: 2&#125;) &#123; console.log(key); &#125; // a, b for (const value of [1,2,3,4,5]) &#123; console.log(value); &#125; // 1, 2, 3, 4, 5 风格最佳实践ECMAScript 6 增加 let 和 const 从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的 var 所造成的各种问题，已经让 JavaScript社区为之苦恼了很多年。随着这两个新关键 字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。 不使用var 有了 let 和 const，大多数开发者会发现自己不再需要 var 了。限制自己只使用 let 和 const 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。 const优先，let次之 使用 const声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。 数据类型ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、 String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对 象）。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。 typeof操作符因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof操作符会返回下列字符串之一： “undefined”表示值未定义； “boolean”表示值为布尔值； “string”表示值为字符串； “number”表示值为数值； “object”表示值为对象（而不是函数）或 null； “function”表示值为函数； “symbol”表示值为符号。 下面是使用 typeof 操作符的例子： 1234let message = &quot;some string&quot;; console.log(typeof message); // &quot;string&quot; console.log(typeof(message)); // &quot;string&quot; console.log(typeof 95); // &quot;number&quot; 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null 返回的是”object”。这是因为特殊值 null 被认为是一个对空对象的引用。 Undefined类型Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值： 12let message; console.log(message == undefined); // true 包含 undefined 值的变量跟未定义变量是有区别的。对未声明的变量，只能执行一个 有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用， 实际上在严格模式下会抛出错误。） 在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时， 返回的结果还是”undefined”，无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然 严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。 即使未初始化的变量会被自动赋予 undefined 值，但仍然建议在声明变量的同时进行初始化。这样，当 typeof 返回”undefined”时，就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。 undefined 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是 undefined 这个字面值，而不仅仅是 假值。 1234567891011let message; // 这个变量被声明了，只是值为 undefined // age 没有声明 if (message) &#123; // 这个块不会执行&#125; if (!message) &#123; // 这个块会执行&#125; if (age) &#123; // 这里会报错&#125; Null类型Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回”object”的原因： 12let car = null; console.log(typeof car); // &quot;object&quot; 在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如： 123if (car != null) &#123; // car 是一个对象的引用&#125; undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例 子所示： 1console.log(null == undefined); // true 即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将 变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。 null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可 能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。 1234567891011121314let message = null; let age; if (message) &#123; // 这个块不会执行&#125; if (!message) &#123; // 这个块会执行&#125;if (age) &#123; // 这个块不会执行&#125; if (!age) &#123; // 这个块会执行&#125; Boolean类型Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。 这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。 布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False（及其他大小混写形式） 是有效的标识符，但不是布尔值。 虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其 他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数： 12let message = &quot;Hello world!&quot;; let messageAsBoolean = Boolean(message); Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true 或 false的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。 数据类型 转化为true值 转化为false的值 Boolean true false String 非空字符串 “”(空字符串) Number 非零数值（包括无穷值） 0、NaN Object 任意对象 null Undefined N&#x2F;A(不存在) undefined if 等流控制语句会自动执行其他类型值到布尔值的转换: 1234let message = &quot;Hello world!&quot;; if (message) &#123; console.log(&quot;Value is true&quot;); &#125; console.log 会输出字符串”Value is true”，因为字符串 message 会被自动 转换为等价的布尔值 true。 Number类型Number 类型使用 IEEE 754 格式表示整 数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。 最基本的数值字面量格式是十进制整数，直接写出来即可： 1let intNum = 55; // 整数 整数也可以用八进制（以8 为基数）或十六进制（以16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示： 123let octalNum1 = 070; // 八进制的56 let octalNum2 = 079; // 无效的八进制值，当成79 处理 let octalNum3 = 08; // 无效的八进制值，当成8处理 八进制字面量在严格模式下是无效的，会导致JavaScript 引擎抛出语法错误。 要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（09 以及AF）。十六进制数字中的字母大小写均可。下面是几个例子： 12let hexNum1 = 0xA; // 十六进制10 let hexNum2 = 0x1f; // 十六进制31 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。 由于JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。 浮点值 要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子： 123let floatNum1 = 1.1; let floatNum2 = 0.1; let floatNum3 = .1; // 有效，但不推荐 因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0（如1.0），那它也会被转换为整数，如下例所示： 12let floatNum1 = 1.; // 小数点后面没有数字，当成整数1 处理 let floatNum2 = 10.0; // 小数点后面是零，当成整数10 处理 对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10 的多少次幂。比如： 1let floatNum = 3.125e7; // 等于31250000 在这个例子中，floatNum 等于31250000，只不过科学记数法显得更简洁。这种表示法实际上相当于说：“以3.125 作为系数，乘以10 的7 次幂。” 科学记数法也可以用于表示非常小的数值，例如0.000 000 000 000 000 03。这个数值用科学记数法可以表示为3e-17。默认情况下，ECMAScript 会将小数点后至少包含6 个零的浮点值转换为科学记数法。 浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下面的例子： 123if (a + b == 0.3) &#123; // 别这么干！ console.log(&quot;You got 0.3.&quot;); &#125; 这里检测两个数值之和是否等于0.3。如果两个数值分别是0.05 和0.25，或者 0.15 和0.15，那没问题。但如果是0.1 和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。 之所以存在这种舍入错误，是因为使用了IEEE 754 数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。 值的范围 由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以Infinity（正无穷大）表示。 如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。这是因为Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用isFinite()函数，如下所示： 12let result = Number.MAX_VALUE + Number.MAX_VALUE; console.log(isFinite(result)); // false 使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取正、负Infinity。没错，这两个属性包含的值分别就是-Infinity 和Infinity。 NaN 有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript 中，0、+0 或-0 相除会返回NaN： 12console.log(0/0); // NaN console.log(-0/+0); // NaN 如果分子是非0 值，分母是有符号0 或无符号0，则会返回Infinity 或-Infinity： 12console.log(5/0); // Infinity console.log(5/-0); // -Infinity NaN 有几个独特的属性。首先，任何涉及NaN 的操作始终返回NaN（如NaN/10），在连续多步计算时这可能是个问题。其次，NaN 不等于包括NaN 在内的任何值。例如，下面的比较操作会返回false： 1console.log(NaN == NaN); // false 为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下： 12345console.log(isNaN(NaN)); // true console.log(isNaN(10)); // false，10 是数值 console.log(isNaN(&quot;10&quot;)); // false，可以转换为数值10 console.log(isNaN(&quot;blue&quot;)); // true，不可以转换为数值 console.log(isNaN(true)); // false，可以转换为数值1 虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString()方法，并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式。 数值转换 有3 个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3 个函数执行的操作也不同。 Number()函数基于如下规则进行转换： 布尔值，true转换为1，false转换为0 数值，直接返回 null，返回0 undefined，返回NaN 字符串，应用以下规则 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回1，Number(“123”)返回123，Number(“011”)返回11（忽略前面的0）。 如果字符串包含有效的浮点值格式如”1.1“，则会转换为相应的浮点值（同样，忽略前面的零）。 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。 如果是空字符串（不包含字符），则返回0。 如果字符串包含除上述情况之外的其他字符，则返回NaN。 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用toString()方法，再按照转换字符串的规则转换。 1234let num1 = Number(&quot;Hello world!&quot;); // NaN let num2 = Number(&quot;&quot;); // 0 let num3 = Number(&quot;000011&quot;); // 11 let num4 = Number(true); // 1 考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。这意味着空字符串也会返回NaN（这一点跟Number()不一样，它返回0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点不是有效的整数字符。 假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。 1234567let num1 = parseInt(&quot;1234blue&quot;); // 1234 let num2 = parseInt(&quot;&quot;); // NaN let num3 = parseInt(&quot;0xA&quot;); // 10，解释为十六进制整数 let num4 = parseInt(22.5); // 22 let num5 = parseInt(&quot;70&quot;); // 70，解释为十进制值 let num6 = parseInt(&quot;0xf&quot;); // 15，解释为十六进制整数 不同的数值格式很容易混淆，因此 parseInt()也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入16 作为第二个参数，以便正确解析： 1let num = parseInt(&quot;0xAF&quot;, 16); // 175 parseFloat()函数的工作方式跟parseInt()函数类似，都是从位置0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成22.34。 parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回整数。下面是几个示例： 1234567let num1 = parseFloat(&quot;1234blue&quot;); // 1234，按整数解析 let num2 = parseFloat(&quot;0xA&quot;); // 0 let num3 = parseFloat(&quot;22.5&quot;); // 22.5 let num4 = parseFloat(&quot;22.34.5&quot;); // 22.34 let num5 = parseFloat(&quot;0908.5&quot;); // 908.5 let num6 = parseFloat(&quot;3.125e7&quot;); // 31250000 String类型String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示。 字符串的特点 ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示： 12let lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; 这里，变量lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”，因为这两个字符串都没有用了。 转换为字符串 有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如： 12345let age = 11; let ageAsString = age.toString(); // 字符串&quot;11&quot; let found = true; let foundAsString = found.toString(); // 字符串&quot;true&quot; toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有toString()方法，该方法只是简单地返回自身的一个副本。）null 和undefined 值没有toString()方法。 多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如： 12345678let num = 10; console.log(num.toString()); // &quot;10&quot; console.log(num.toString(2)); // &quot;1010&quot; console.log(num.toString(8)); // &quot;12&quot; console.log(num.toString(10)); // &quot;10&quot; console.log(num.toString(16)); // &quot;a&quot; 如果不确定一个值是不是null 或undefined，可以使用 String()转型函数，它始终会返回表示相应类型值的字符串。String()函数遵循如下规则。 如果值有toString()方法，则调用该方法（不传参数）并返回结果 如果值是null，返回”null” 如果值是undefined，返回”undefined” 用加号操作符给一个值加上一个空字符串””也可以将其转换为字符串。 模板字面量 ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串： 12345678910111213141516let myMultiLineString = &#x27;first line\\nsecond line&#x27;; let myMultiLineTemplateLiteral = `first line second line`; console.log(myMultiLineString); // first line // second line&quot; console.log(myMultiLineTemplateLiteral); // first line // second line console.log(myMultiLineString === myMultiLinetemplateLiteral); // true 顾名思义，模板字面量在定义模板时特别有用，比如下面这个HTML 模板： 123456789let pageHTML = ` &lt;div&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;Jake&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;`; 字符串插值 模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。 字符串插值通过在$&#123;&#125;中使用一个JavaScript 表达式实现： 1234567891011121314let value = 5; let exponent = &#x27;second&#x27;; // 以前，字符串插值是这样实现的： let interpolatedString = value + &#x27; to the &#x27; + exponent + &#x27; power is &#x27; + (value * value); // 现在，可以用模板字面量这样实现： let interpolatedTemplateLiteral = `$&#123; value &#125; to the $&#123; exponent &#125; power is $&#123; value * value &#125;`; console.log(interpolatedString); // 5 to the second power is 25 console.log(interpolatedTemplateLiteral); // 5 to the second power is 25 所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义： 1console.log(`Hello, $&#123; `World` &#125;!`); // Hello, World! 将表达式转换为字符串时会调用toString()： 12let foo = &#123; toString: () =&gt; &#x27;World&#x27; &#125;; console.log(`Hello, $&#123; foo &#125;!`); // Hello, World! 在插值表达式中可以调用函数和方法： 12345function capitalize(word) &#123; return `$&#123; word[0].toUpperCase() &#125;$&#123; word.slice(1) &#125;`; &#125; console.log(`$&#123; capitalize(&#x27;hello&#x27;) &#125;, $&#123; capitalize(&#x27;world&#x27;) &#125;!`); // Hello, World! 此外，模板也可以插入自己之前的值： 1234567891011let value = &#x27;&#x27;; function append() &#123; value = `$&#123;value&#125;abc` console.log(value); &#125; append(); // abc append(); // abcabc append(); // abcabcabc Symbol类型Symbol（符号）是ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。 尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为Object API 提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。 符号的基本用法 符号需要使用Symbol()函数初始化。因为符号本身是原始类型，所以typeof 操作符对符号返回symbol。 123let sym = Symbol(); console.log(typeof sym); // symbol 调用Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关。 最重要的是，Symbol()函数不能与new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用Boolean、String 或Number那样，它们都支持构造函数且可用于初始化包含原始值的包装对象： 12345678910let myBoolean = new Boolean(); console.log(typeof myBoolean); // &quot;object&quot; let myString = new String(); console.log(typeof myString); // &quot;object&quot; let myNumber = new Number(); console.log(typeof myNumber); // &quot;object&quot;let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor 如果确实想使用符号包装对象，可以借用Object()函数： 12345let mySymbol = Symbol(); let myWrappedSymbol = Object(mySymbol); console.log(typeof myWrappedSymbol); // &quot;object&quot; 使用全局符号注册表 如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。 为此，需要使用Symbol.for()方法： 123let fooGlobalSymbol = Symbol.for(&#x27;foo&#x27;); console.log(typeof fooGlobalSymbol); // symbol Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。 1234let fooGlobalSymbol = Symbol.for(&#x27;foo&#x27;); // 创建新符号 let otherFooGlobalSymbol = Symbol.for(&#x27;foo&#x27;); // 重用已有符号console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true 即使采用相同的符号描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不等同： 1234let localSymbol = Symbol(&#x27;foo&#x27;); let globalSymbol = Symbol.for(&#x27;foo&#x27;);console.log(localSymbol === globalSymbol); // false 全局注册表中的符号必须使用字符串键来创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。 12let emptyGlobalSymbol = Symbol.for(); console.log(emptyGlobalSymbol); // Symbol(undefined) 还可以使用Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回undefined。 12345678// 创建全局符号 let s = Symbol.for(&#x27;foo&#x27;); console.log(Symbol.keyFor(s)); // foo // 创建普通符号 let s2 = Symbol(&#x27;bar&#x27;); console.log(Symbol.keyFor(s2)); // undefined 如果传给Symbol.keyFor()的不是符号，则该方法抛出TypeError： 1Symbol.keyFor(123); // TypeError: 123 is not a symbol 使用符号作为属性 凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。 12345678910111213141516171819202122232425262728293031323334let s1 = Symbol(&#x27;foo&#x27;), s2 = Symbol(&#x27;bar&#x27;), s3 = Symbol(&#x27;baz&#x27;), s4 = Symbol(&#x27;qux&#x27;); let o = &#123; [s1]: &#x27;foo val&#x27; &#125;; // 这样也可以：o[s1] = &#x27;foo val&#x27;; console.log(o); // &#123;Symbol(foo): foo val&#125; Object.defineProperty(o, s2, &#123;value: &#x27;bar val&#x27;&#125;); console.log(o); // &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125; Object.defineProperties(o, &#123; [s3]: &#123;value: &#x27;baz val&#x27;&#125;, [s4]: &#123;value: &#x27;qux val&#x27;&#125; &#125;); console.log(o); // &#123;Symbol(foo): foo val, Symbol(bar): bar val, // Symbol(baz): baz val, Symbol(qux): qux val&#125; 类似于Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键： 1234567891011121314151617181920212223242526272829let s1 = Symbol(&#x27;foo&#x27;), s2 = Symbol(&#x27;bar&#x27;); let o = &#123; [s1]: &#x27;foo val&#x27;, [s2]: &#x27;bar val&#x27;, baz: &#x27;baz val&#x27;, qux: &#x27;qux val&#x27; &#125;; console.log(Object.getOwnPropertySymbols(o)); // [Symbol(foo), Symbol(bar)] console.log(Object.getOwnPropertyNames(o)); // [&quot;baz&quot;, &quot;qux&quot;] console.log(Object.getOwnPropertyDescriptors(o)); // &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125; console.log(Reflect.ownKeys(o)); // [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)] 因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键： 1234567891011121314151617let o = &#123; [Symbol(&#x27;foo&#x27;)]: &#x27;foo val&#x27;, [Symbol(&#x27;bar&#x27;)]: &#x27;bar val&#x27; &#125;; console.log(o); // &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125; let barSymbol = Object.getOwnPropertySymbols(o) .find((symbol) =&gt; symbol.toString().match(/bar/)); console.log(barSymbol); // Symbol(bar) 常用内置符号 ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以Symbol 工厂函数字符串属性的形式存在。 这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，for-of 循环会在相关对象上使用Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变for-of 在迭代该对象时的行为。 这些内置符号也没有什么特别之处，它们就是全局函数Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。 Symbol.asyncIterator 根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的AsyncIterator。由for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器API 的函数。 for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器API 的对象。 技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用next()方法返回，也可以隐式地通过异步生成器函数返回： 12345678910111213141516171819202122232425262728293031323334class Emitter &#123; constructor(max) &#123; this.max = max; this.asyncIdx = 0; &#125; async *[Symbol.asyncIterator]() &#123; while(this.asyncIdx &lt; this.max) &#123; yield new Promise((resolve) =&gt; resolve(this.asyncIdx++)); &#125; &#125; &#125; async function asyncCount() &#123; let emitter = new Emitter(5); for await(const x of emitter) &#123; console.log(x); &#125; &#125; asyncCount(); // 0 // 1 // 2 // 3 // 4 也可通过以下方式使用： 1234567891011121314151617const myAsyncIterable = new Object();myAsyncIterable[Symbol.asyncIterator] = async function*() &#123; yield &quot;hello&quot;; yield &quot;async&quot;; yield &quot;iteration!&quot;;&#125;;(async () =&gt; &#123; for await (const x of myAsyncIterable) &#123; console.log(x); // expected output: // &quot;hello&quot; // &quot;async&quot; // &quot;iteration!&quot; &#125;&#125;)(); Symbol.hasInstance 根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由instanceof 操作符使用”。instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。instanceof 的典型使用场景如下： 123456789function Foo() &#123;&#125; let f = new Foo(); console.log(f instanceof Foo); // true class Bar &#123;&#125; let b = new Bar(); console.log(b instanceof Bar); // true 在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol.hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下： 12345678function Foo() &#123;&#125; let f = new Foo(); console.log(Foo[Symbol.hasInstance](f)); // true class Bar &#123;&#125; let b = new Bar(); console.log(Bar[Symbol.hasInstance](b)); // true 这个属性定义在Function 的原型上，因此默认在所有函数和类上都可以调用。由于instanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数： 123456789101112131415class Bar &#123;&#125; class Baz extends Bar &#123; static [Symbol.hasInstance]() &#123; return false; &#125; &#125; let b = new Baz(); console.log(Bar[Symbol.hasInstance](b)); // true console.log(b instanceof Bar); // true console.log(Baz[Symbol.hasInstance](b)); // false console.log(b instanceof Baz); // false Symbol.isConcatSpreadable 根据ECMAScript 规范，这个符号作为一个属性表示“一个布尔值，如果是true，则意味着对象应该用Array.prototype.concat()打平其数组元素”。ES6 中的Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖 Symbol.isConcatSpreadable 的值可以修改这个行为。 当变量为数组的时候，默认值为undefined，此时是可以展开的，且true值也可以展开，如需不要展开，将数组的Symbol.isConcatSpreadable值定义为false即可。 当变量为对象的时候，默认值为undefined，此时是不可以展开的，且false也不展开，如需展开，将对象的Symbol.isConcatSpreadable值定义为true即可。 123456789101112131415161718192021222324let initial = [&#x27;foo&#x27;]; let array = [&#x27;bar&#x27;]; console.log(array[Symbol.isConcatSpreadable]); // undefined console.log(initial.concat(array)); // [&#x27;foo&#x27;, &#x27;bar&#x27;] array[Symbol.isConcatSpreadable] = false; console.log(initial.concat(array)); // [&#x27;foo&#x27;, Array(1)] let arrayLikeObject = &#123; length: 1, 0: &#x27;baz&#x27; &#125;; console.log(arrayLikeObject[Symbol.isConcatSpreadable]); // undefined console.log(initial.concat(arrayLikeObject)); // [&#x27;foo&#x27;, &#123;...&#125;] arrayLikeObject[Symbol.isConcatSpreadable] = true; console.log(initial.concat(arrayLikeObject)); // [&#x27;foo&#x27;, &#x27;baz&#x27;] let otherObject = new Set().add(&#x27;qux&#x27;); console.log(otherObject[Symbol.isConcatSpreadable]); // undefined console.log(initial.concat(otherObject)); // [&#x27;foo&#x27;, Set(1)] otherObject[Symbol.isConcatSpreadable] = true; console.log(initial.concat(otherObject)); // [&#x27;foo&#x27;] Symbol.iterator 根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由for-of 语句使用”。换句话说，这个符号表示实现迭代器API 的函数。 技术上，这个由Symbol.iterator 函数生成的对象应该通过其next()方法陆续返回值。可以通过显式地调用next()方法返回，也可以隐式地通过生成器函数返回： 12345678910111213141516171819202122232425262728293031323334class Emitter &#123; constructor(max) &#123; this.max = max; this.idx = 0; &#125; *[Symbol.iterator]() &#123; while(this.idx &lt; this.max) &#123; yield this.idx++; &#125; &#125; &#125; function count() &#123; let emitter = new Emitter(5); for (const x of emitter) &#123; console.log(x); &#125; &#125; count(); // 0// 1 // 2 // 3 // 4 Symbol.match 根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由String.prototype.match()方法使用”。String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数： 123456console.log(RegExp.prototype[Symbol.match]); // ƒ [Symbol.match]() &#123; [native code] &#125; console.log(&#x27;foobar&#x27;.match(/bar/)); // [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined] 给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 Symbol.match 函数以取代默认对正则表达式求值的行为，从而让match()方法使用非正则表达式实例。Symbol.match 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制： 12345678910111213141516171819202122232425class FooMatcher &#123; static [Symbol.match](target) &#123; return target.includes(&#x27;foo&#x27;); &#125; &#125; console.log(&#x27;foobar&#x27;.match(FooMatcher)); // true console.log(&#x27;barbaz&#x27;.match(FooMatcher)); // false class StringMatcher &#123; constructor(str) &#123; this.str = str; &#125; [Symbol.match](target) &#123; return target.includes(this.str); &#125; &#125; console.log(&#x27;foobar&#x27;.match(new StringMatcher(&#x27;foo&#x27;))); // true console.log(&#x27;barbaz&#x27;.match(new StringMatcher(&#x27;qux&#x27;))); // false Symbol.replace 根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”。String.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数： 12345console.log(RegExp.prototype[Symbol.replace]); // ƒ [Symbol.replace]() &#123; [native code] &#125; console.log(&#x27;foobarbaz&#x27;.replace(/bar/, &#x27;qux&#x27;)); // &#x27;fooquxbaz&#x27; 给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.replace 函数以取代默认对正则表达式求值的行为，从而让replace()方法使用非正则表达式实例。Symbol.replace 函数接收两个参数，即调用replace()方法的字符串实例和替换字符串。返回的值没有限制： 123456789101112131415161718192021222324252627class FooReplacer &#123; static [Symbol.replace](target, replacement) &#123; return target.split(&#x27;foo&#x27;).join(replacement); &#125; &#125; console.log(&#x27;barfoobaz&#x27;.replace(FooReplacer, &#x27;qux&#x27;)); // &quot;barquxbaz&quot; class StringReplacer &#123; constructor(str) &#123; this.str = str; &#125; [Symbol.replace](target, replacement) &#123; return target.split(this.str).join(replacement); &#125; &#125; console.log(&#x27;barfoobaz&#x27;.replace(new StringReplacer(&#x27;foo&#x27;), &#x27;qux&#x27;)); // &quot;barquxbaz&quot; Symbol.search 根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由String.prototype.search()方法使用”。String.prototype.search()方法会使用以Symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数： 123456console.log(RegExp.prototype[Symbol.search]); // ƒ [Symbol.search]() &#123; [native code] &#125; console.log(&#x27;foobar&#x27;.search(/bar/)); // 3 给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为，从而让search()方法使用非正则表达式实例。Symbol.search 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制： 12345678910111213141516171819202122232425class FooSearcher &#123; static [Symbol.search](target) &#123; return target.indexOf(&#x27;foo&#x27;); &#125; &#125;console.log(&#x27;foobar&#x27;.search(FooSearcher)); // 0 console.log(&#x27;barfoo&#x27;.search(FooSearcher)); // 3 console.log(&#x27;barbaz&#x27;.search(FooSearcher)); // -1 class StringSearcher &#123; constructor(str) &#123; this.str = str; &#125; [Symbol.search](target) &#123; return target.indexOf(this.str); &#125; &#125; console.log(&#x27;foobar&#x27;.search(new StringSearcher(&#x27;foo&#x27;))); // 0 console.log(&#x27;barfoo&#x27;.search(new StringSearcher(&#x27;foo&#x27;))); // 3 console.log(&#x27;barbaz&#x27;.search(new StringSearcher(&#x27;qux&#x27;))); // -1 Symbol.species 根据ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义： 123456789101112class Array1 extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;const a = new Array1(1, 2, 3);const mapped = a.map(x =&gt; x * x);console.log(mapped instanceof Array1);// expected output: falseconsole.log(mapped instanceof Array);// expected output: true Symbol.split 根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用”。String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数： 123456console.log(RegExp.prototype[Symbol.split]); // ƒ [Symbol.split]() &#123; [native code] &#125; console.log(&#x27;foobarbaz&#x27;.split(/bar/)); // [&#x27;foo&#x27;, &#x27;baz&#x27;] 给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义Symbol.split 函数以取代默认对正则表达式求值的行为，从而让split()方法使用非正则表达式实例。Symbol.split 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制： 123456789101112131415161718192021222324class FooSplitter &#123; static [Symbol.split](target) &#123; return target.split(&#x27;foo&#x27;); &#125; &#125; console.log(&#x27;barfoobaz&#x27;.split(FooSplitter)); // [&quot;bar&quot;, &quot;baz&quot;] class StringSplitter &#123; constructor(str) &#123; this.str = str; &#125; [Symbol.split](target) &#123; return target.split(this.str); &#125; &#125; console.log(&#x27;barfoobaz&#x27;.split(new StringSplitter(&#x27;foo&#x27;))); // [&quot;bar&quot;, &quot;baz&quot;] Symbol.toPrimitive 根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由ToPrimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的Symbol.toPrimitive 属性上定义一个函数可以改变默认行为。 根据提供给这个函数的参数（string、number 或default），可以控制返回的原始值： 123456789101112131415161718192021222324252627282930class Foo &#123;&#125; let foo = new Foo(); console.log(3 + foo); // &quot;3[object Object]&quot; console.log(3 - foo); // NaN console.log(String(foo)); // &quot;[object Object]&quot; class Bar &#123; constructor() &#123; this[Symbol.toPrimitive] = function(hint) &#123; switch (hint) &#123; case &#x27;number&#x27;: return 3; case &#x27;string&#x27;: return &#x27;string bar&#x27;; case &#x27;default&#x27;: default: return &#x27;default bar&#x27;; &#125; &#125; &#125; &#125; let bar = new Bar();console.log(3 + bar); // &quot;3default bar&quot; console.log(3 - bar); // 0console.log(String(bar)); // string bar Symbol.toStringTag 根据ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Object.prototype.toString()使用”。 通过toString()方法获取对象标识时，会检索由Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义: 1234567891011121314151617181920212223242526let s = new Set(); console.log(s); // Set(0) &#123;&#125; console.log(s.toString()); // [object Set] console.log(s[Symbol.toStringTag]); // Set class Foo &#123;&#125; let foo = new Foo(); console.log(foo); // Foo &#123;&#125; console.log(foo.toString()); // [object Object] console.log(foo[Symbol.toStringTag]); // undefined class Bar &#123; constructor() &#123; this[Symbol.toStringTag] = &#x27;Bar&#x27;; &#125; &#125; let bar = new Bar(); console.log(bar); // Bar &#123;&#125; console.log(bar.toString()); // [object Bar] console.log(bar[Symbol.toStringTag]); // Bar Symbol.unscopables 根据ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的with 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为true，就可以阻止该属性出现在with 环境绑定中，如下例所示: 12345678910111213let o = &#123; foo: &#x27;bar&#x27; &#125;; with (o) &#123; console.log(foo); // bar &#125; o[Symbol.unscopables] = &#123; foo: true &#125;; with (o) &#123; console.log(foo); //ReferenceError &#125; 不推荐使用with，因此也不推荐使用Symbol.unscopables。 Object类型ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过new 操作符后跟对象类型的名称来创建。开发者可以通过创建Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法： 1let o = new Object(); Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java 中的java.lang.Object，ECMAScript 中的Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。 每个Object 实例都有如下属性和方法。 constructor 用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数。 hasOwnProperty(propertyName) 用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如o.hasOwnProperty(&quot;name&quot;)）或符号。 isPrototypeOf(object) 用于判断当前对象是否为另一个对象的原型。 propertyIsEnumerable(propertyName) 用于判断给定的属性是否可以使用for-in 语句枚举。与hasOwnProperty()一样，属性名必须是字符串。 toLocaleString() 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。 toString() 返回对象的字符串表示 valueOf() 返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同 因为在ECMAScript 中Object 是所有对象的基类，所以任何对象都有这些属性和方法。 操作符ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和&#x2F;或 toString()方法来取得可以计算的值。 一元操作符 只操作一个值的操作符叫一元操作符（unary operator）。 递增&#x2F;递减操作符 123456let age = 29; let anotherAge = --age + 2; console.log(age); // 28 console.log(anotherAge); // 30 在这个例子中，变量 anotherAge 以 age 减 1 后的值再加2 进行初始化。因为递减操作先发生，所以age 的值先变成28，然后再加2，结果是30。 前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如： 12345678let num1 = 2; let num2 = 20; let num3 = --num1 + num2; let num4 = num1 + num2; console.log(num3); // 21 console.log(num4); // 21 这里，num3 等于21 是因为num1 先减1 之后才加num2。变量num4 也是21，那是因为加法使用的也是递减后的值。 递增和递减的后缀版语法一样（分别是++和–），只不过要放在变量后面。后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。在某些情况下，这种差异没什么影响，可是，在跟其他操作混合时，差异就会变明显，比如： 123456let num1 = 2; let num2 = 20; let num3 = num1-- + num2; let num4 = num1 + num2;console.log(num3); // 22 console.log(num4); // 21 一元加和减 一元加和减操作符对大多数开发者来说并不陌生，它们在ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响： 123let num = 25; num = +num; console.log(num); // 25 如果将一元加应用到非数值，则会执行与使用Number()转型函数一样的类型转换：布尔值false和true 转换为0 和1，字符串根据特殊规则进行解析，对象会调用它们的valueOf()和&#x2F;或toString()方法以得到可以转换的值。 布尔操作符 对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像if-else 和循环这样的语句也没什么用了。布尔操作符一共有3 个：逻辑非、逻辑与和逻辑或。 逻辑非 逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。 如果操作数是对象，则返回false。 如果操作数是空字符串，则返回true。 如果操作数是非空字符串，则返回false。 如果操作数是数值0，则返回true。 如果操作数是非0 数值（包括Infinity），则返回false。 如果操作数是null，则返回true。 如果操作数是NaN，则返回true。 如果操作数是undefined，则返回true。 以下示例验证了上述行为： 123456console.log(!false); // true console.log(!&quot;blue&quot;); // false console.log(!0); // true console.log(!NaN); // true console.log(!&quot;&quot;); // true console.log(!12345); // false 逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用Boolean()函数是一样的。 逻辑与 逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值，如下所示： 1let result = true &amp;&amp; false; 逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是false，那么无论第二个操作数是什么值，结果也不可能等于true。 逻辑或 逻辑或操作符由两个管道符（||）表示，比如： 1let result = true || false; 与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。 乘性操作符 ECMAScript 定义了3 个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C 语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用Number()转型函数转换为数值。这意味着空字符串会被当成0，而布尔值true 会被当成1。 指数操作符 ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的： 1234567console.log(Math.pow(3, 2); // 9 console.log(3 ** 2); // 9 console.log(Math.pow(16, 0.5); // 4 console.log(16** 0.5); // 4 加性操作符 加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。不过，在 ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。 关系操作符 关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;&#x3D;）和大于等于（&gt;&#x3D;），用法跟数学课上学的一样。这几个操作符都返回布尔值。 与ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。 如果操作数都是数值，则执行数值比较。 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。 因为比较的是字符对应的编码的大小，所以会发生： 1let result = &quot;Brick&quot; &lt; &quot;alphabet&quot;; // true 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。 如果有任一操作数是对象，则调用其valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有valueOf()操作符，则调用toString()方法，取得结果后再根据前面的规则执行比较。 如果有任一操作数是布尔值，则将其转换为数值再执行比较。 相等操作符 判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript 中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。 等于和不等于 ECMAScript 中的等于操作符用两个等于号（&#x3D;&#x3D;）表示，如果操作数相等，则会返回true。不等于操作符用叹号和等于号（!&#x3D;）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。 在转换操作数的类型时，相等和不相等操作符遵循如下规则。 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为0，true 转换为1。 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。 在进行比较时，这两个操作符会遵循如下规则。 null 和undefined 相等。 null 和undefined 不能转换为其他类型的值再进行比较。 如果有任一操作数是NaN，则相等操作符返回false，不相等操作符返回true。记住：即使两个操作数都是NaN，相等操作符也返回false，因为按照规则，NaN 不等于NaN。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true。否则，两者不相等。 下表总结了一些特殊情况及比较的结果。 表达式 结果 null &#x3D;&#x3D; undefined true “NaN” &#x3D;&#x3D; NaN false 5 &#x3D;&#x3D; NaN false NaN &#x3D;&#x3D; NaN false NaN !&#x3D; NaN true false &#x3D;&#x3D; 0 true true &#x3D;&#x3D; 1 true true &#x3D;&#x3D; 2 false undefined &#x3D;&#x3D; 0 false null &#x3D;&#x3D; 0 false “5” &#x3D;&#x3D; 5 true 全等和不全等 全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3 个等于号（&#x3D;&#x3D;&#x3D;）表示，只有两个操作数在不转换的前提下相等才返回true，比如： 12let result1 = (&quot;55&quot; == 55); // true，转换后相等 let result2 = (&quot;55&quot; === 55); // false，不相等，因为数据类型不同 不全等操作符用一个叹号和两个等于号（!&#x3D;&#x3D;）表示，只有两个操作数在不转换的前提下不相等才返回true。比如： 12let result1 = (&quot;55&quot; != 55); // false，转换后相等 let result2 = (&quot;55&quot; !== 55); // true，不相等，因为数据类型不同 另外，虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是false，因为它们不是相同的数据类型。 条件操作符 条件操作符是ECMAScript 中用途最为广泛的操作符之一，语法跟Java 中一样： 1variable = boolean_expression ? true_value : false_value; 赋值操作符 简单赋值用等于号（&#x3D;）表示，将右手边的值赋给左手边的变量，如下所示： 1let num = 10; 复合赋值使用乘性、加性或位操作符后跟等于号（&#x3D;）表示。这些赋值操作符是类似如下常见赋值操作的简写形式： 12let num = 10; num = num + 10; 以上代码的第二行可以通过复合赋值来完成： 12let num = 10; num += 10; 每个数学操作符以及其他一些操作符都有对应的复合赋值操作符： 乘后赋值（*&#x3D;） 除后赋值（&#x2F;&#x3D;） 取模后赋值（%&#x3D;） 加后赋值（+&#x3D;） 减后赋值（-&#x3D;） 左移后赋值（&lt;&lt;&#x3D;） 右移后赋值（&gt;&gt;&#x3D;） 无符号右移后赋值（&gt;&gt;&gt;&#x3D;） 这些操作符仅仅是简写语法，使用它们不会提升性能。 逗号操作符 逗号操作符可以用来在一条语句中执行多个操作，如下所示： 1let num1 = 1, num2 = 2, num3 = 3; 语句ECMA-262 描述了一些语句（也称为流控制语句），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。 if语句 if 语句是使用最频繁的语句之一，语法如下： 1if (condition) statement1 else statement2 这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。 do-while语句 do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。do-while 的语法如下： 123do &#123; statement &#125; while (expression); 后测试循环经常用于这种情形：循环体内代码在退出前至少要执行一次。 while语句 while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行。下面是while 循环的语法： 1while(expression) statement for 语句 for 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下： 1for (initialization; expression; post-loop-expression) statement 在for 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用let 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。 初始化、条件表达式和循环后表达式都不是必需的。因此，下面这种写法可以创建一个无穷循环： 123for (;;) &#123; // 无穷循环 doSomething(); &#125; 如果只包含条件表达式，那么for 循环实际上就变成了while 循环： 123456let count = 10; let i = 0; for (; i &lt; count; ) &#123; console.log(i); i++; &#125; for-in 语句 for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下： 1for (property in expression) statement 下面是一个例子： 123for (const propName in window) &#123; document.write(propName); &#125; 这个例子使用 for-in 循环显示了 BOM 对象 window 的所有属性。每次执行循环，都会给变量propName 赋予一个window 对象的属性作为值，直到window 的所有属性都被枚举一遍。与for 循环一样，这里控制语句中的const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。 ECMAScript 中对象的属性是无序的，因此for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。 如果for-in 循环要迭代的变量是null 或undefined，则不执行循环体。 for-of 语句 for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下： 1for (property of expression) statement 下面是示例： 123for (const el of [2,4,6,8]) &#123; document.write(el); &#125; 在这个例子中，使用for-of 语句显示了一个包含4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与for 循环一样，这里控制语句中的const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。 for-of 循环会按照可迭代对象的next()方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则for-of 语句会抛出错误。 标签语句 标签语句用于给语句加标签，语法如下： 1label: statement 下面是一个例子： 123start: for (let i = 0; i &lt; count; i++) &#123; console.log(i); &#125; 在这个例子中，start 是一个标签，可以在后面通过break 或continue 语句引用。标签语句的典型应用场景是嵌套循环。 break 和continue 语句 break 和continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。下面看一个例子： 1234567891011let num = 0; for (let i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++; &#125; console.log(num); // 4 如果将break 换成continue，则会出现不同的效果： 12345678910111213let num = 0; for (let i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; continue; &#125; num++; &#125; console.log(num); // 8 break 和continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中，如下面的例子所示： 1234567891011121314151617let num = 0; outermost: for (let i = 0; i &lt; 10; i++) &#123; for (let j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125; &#125; console.log(num); // 55 在这个例子中，outermost 标签标识的是第一个for 语句。正常情况下，每个循环执行10 次，意味着num++语句会执行100 次，而循环结束时console.log 的结果应该是100。但是，break语句带来了一个变数，即要退出到的标签。添加标签不仅让break 退出（使用变量j 的）内部循环，也会退出（使用变量i 的）外部循环。当执行到i 和j 都等于5 时，循环停止执行，此时num 的值是55。 continue语句也可以使用标签，如下面的例子所示： 1234567891011121314let num = 0; outermost: for (let i = 0; i &lt; 10; i++) &#123; for (let j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125; &#125; console.log(num); // 95 这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当i 和j 都等于5 时，会执行continue，跳到外部循环继续执行，从而导致内部循环少执行5 次，结果num 等于95。 组合使用标签语句和break、continue 能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。 with语句 with 语句的用途是将代码作用域设置为特定的对象，其语法是： 1with (expression) statement; 使用with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示： 123let qs = location.search.substring(1); let hostName = location.hostname; let url = location.href; 上面代码中的每一行都用到了location 对象。如果使用with 语句，就可以少写一些代码： 1234567with(location) &#123; let qs = search.substring(1); let hostName = hostname; let url = href; &#125; 这里，with 语句用于连接location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location对象，看它是否有一个同名的属性。如果有，则该变量会被求值为location 对象的属性。 严格模式不允许使用with 语句，否则会抛出错误。由于with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。 switch 语句 switch 语句是与if 语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript 中switch语句跟C 语言中switch 语句的语法非常相似，如下所示： 12345678910111213141516171819switch (expression) &#123; case value1: statement break; case value2: statement break; case value3: statement break; case value4: statement break; default: statement &#125; break关键字会导致代码执行跳出switch 语句。如果没有break，则代码会继续匹配下一个条件。default关键字用于在任何条件都没有满足时指定默认执行的语句（相当于else 语句）。 虽然switch 语句是从其他语言借鉴过来的，但ECMAScript 为它赋予了一些独有的特性。首先，switch 语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至对象。其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子： 123456789101112switch (&quot;hello world&quot;) &#123; case &quot;hello&quot; + &quot; world&quot;: console.log(&quot;Greeting was found.&quot;); break; case &quot;goodbye&quot;: console.log(&quot;Closing was found.&quot;); break; default: console.log(&quot;Unexpected message was found.&quot;); &#125; switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值10）。 函数函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript 中的函数使用function 关键字声明，后跟一组参数，然后是函数体。 函数的基本语法： 123function functionName(arg0, arg1,...,argN) &#123; statements &#125; ECMAScript中的函数不需要指定是否返回值。要注意的是，只要碰到return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。return 语句也可以不带返回值。这时候，函数会立即停止执行并返回undefined。这种用法最常用于提前终止函数执行，并不是为了返回值。 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。","categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]},{"title":"Hello World","slug":"Hello World","date":"2022-07-16T20:32:39.000Z","updated":"2023-11-27T15:34:23.876Z","comments":true,"path":"2022/07/17/Hello World/","link":"","permalink":"http://pvnk1u.github.io/2022/07/17/Hello%20World/","excerpt":"","text":"Hello World;","categories":[],"tags":[]}],"categories":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/categories/web/"},{"name":"html","slug":"web/html","permalink":"http://pvnk1u.github.io/categories/web/html/"},{"name":"css","slug":"web/html/css","permalink":"http://pvnk1u.github.io/categories/web/html/css/"},{"name":"css","slug":"web/css","permalink":"http://pvnk1u.github.io/categories/web/css/"},{"name":"javascript","slug":"web/javascript","permalink":"http://pvnk1u.github.io/categories/web/javascript/"}],"tags":[{"name":"web","slug":"web","permalink":"http://pvnk1u.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"http://pvnk1u.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"http://pvnk1u.github.io/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://pvnk1u.github.io/tags/javascript/"}]}